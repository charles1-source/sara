"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@google";
exports.ids = ["vendor-chunks/@google"];
exports.modules = {

/***/ "(rsc)/./node_modules/@google/genai/dist/node/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@google/genai/dist/node/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActivityHandling: () => (/* binding */ ActivityHandling),\n/* harmony export */   AdapterSize: () => (/* binding */ AdapterSize),\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   ApiSpec: () => (/* binding */ ApiSpec),\n/* harmony export */   AuthType: () => (/* binding */ AuthType),\n/* harmony export */   Batches: () => (/* binding */ Batches),\n/* harmony export */   Behavior: () => (/* binding */ Behavior),\n/* harmony export */   BlockedReason: () => (/* binding */ BlockedReason),\n/* harmony export */   Caches: () => (/* binding */ Caches),\n/* harmony export */   Chat: () => (/* binding */ Chat),\n/* harmony export */   Chats: () => (/* binding */ Chats),\n/* harmony export */   ComputeTokensResponse: () => (/* binding */ ComputeTokensResponse),\n/* harmony export */   ControlReferenceImage: () => (/* binding */ ControlReferenceImage),\n/* harmony export */   ControlReferenceType: () => (/* binding */ ControlReferenceType),\n/* harmony export */   CountTokensResponse: () => (/* binding */ CountTokensResponse),\n/* harmony export */   CreateFileResponse: () => (/* binding */ CreateFileResponse),\n/* harmony export */   DeleteCachedContentResponse: () => (/* binding */ DeleteCachedContentResponse),\n/* harmony export */   DeleteFileResponse: () => (/* binding */ DeleteFileResponse),\n/* harmony export */   DeleteModelResponse: () => (/* binding */ DeleteModelResponse),\n/* harmony export */   DynamicRetrievalConfigMode: () => (/* binding */ DynamicRetrievalConfigMode),\n/* harmony export */   EditImageResponse: () => (/* binding */ EditImageResponse),\n/* harmony export */   EditMode: () => (/* binding */ EditMode),\n/* harmony export */   EmbedContentResponse: () => (/* binding */ EmbedContentResponse),\n/* harmony export */   EndSensitivity: () => (/* binding */ EndSensitivity),\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   FeatureSelectionPreference: () => (/* binding */ FeatureSelectionPreference),\n/* harmony export */   FileSource: () => (/* binding */ FileSource),\n/* harmony export */   FileState: () => (/* binding */ FileState),\n/* harmony export */   Files: () => (/* binding */ Files),\n/* harmony export */   FinishReason: () => (/* binding */ FinishReason),\n/* harmony export */   FunctionCallingConfigMode: () => (/* binding */ FunctionCallingConfigMode),\n/* harmony export */   FunctionResponse: () => (/* binding */ FunctionResponse),\n/* harmony export */   FunctionResponseScheduling: () => (/* binding */ FunctionResponseScheduling),\n/* harmony export */   GenerateContentResponse: () => (/* binding */ GenerateContentResponse),\n/* harmony export */   GenerateContentResponsePromptFeedback: () => (/* binding */ GenerateContentResponsePromptFeedback),\n/* harmony export */   GenerateContentResponseUsageMetadata: () => (/* binding */ GenerateContentResponseUsageMetadata),\n/* harmony export */   GenerateImagesResponse: () => (/* binding */ GenerateImagesResponse),\n/* harmony export */   GenerateVideosOperation: () => (/* binding */ GenerateVideosOperation),\n/* harmony export */   GenerateVideosResponse: () => (/* binding */ GenerateVideosResponse),\n/* harmony export */   GoogleGenAI: () => (/* binding */ GoogleGenAI),\n/* harmony export */   HarmBlockMethod: () => (/* binding */ HarmBlockMethod),\n/* harmony export */   HarmBlockThreshold: () => (/* binding */ HarmBlockThreshold),\n/* harmony export */   HarmCategory: () => (/* binding */ HarmCategory),\n/* harmony export */   HarmProbability: () => (/* binding */ HarmProbability),\n/* harmony export */   HarmSeverity: () => (/* binding */ HarmSeverity),\n/* harmony export */   HttpResponse: () => (/* binding */ HttpResponse),\n/* harmony export */   ImagePromptLanguage: () => (/* binding */ ImagePromptLanguage),\n/* harmony export */   InlinedResponse: () => (/* binding */ InlinedResponse),\n/* harmony export */   JobState: () => (/* binding */ JobState),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   ListBatchJobsResponse: () => (/* binding */ ListBatchJobsResponse),\n/* harmony export */   ListCachedContentsResponse: () => (/* binding */ ListCachedContentsResponse),\n/* harmony export */   ListFilesResponse: () => (/* binding */ ListFilesResponse),\n/* harmony export */   ListModelsResponse: () => (/* binding */ ListModelsResponse),\n/* harmony export */   ListTuningJobsResponse: () => (/* binding */ ListTuningJobsResponse),\n/* harmony export */   Live: () => (/* binding */ Live),\n/* harmony export */   LiveClientToolResponse: () => (/* binding */ LiveClientToolResponse),\n/* harmony export */   LiveMusicPlaybackControl: () => (/* binding */ LiveMusicPlaybackControl),\n/* harmony export */   LiveMusicServerMessage: () => (/* binding */ LiveMusicServerMessage),\n/* harmony export */   LiveSendToolResponseParameters: () => (/* binding */ LiveSendToolResponseParameters),\n/* harmony export */   LiveServerMessage: () => (/* binding */ LiveServerMessage),\n/* harmony export */   MaskReferenceImage: () => (/* binding */ MaskReferenceImage),\n/* harmony export */   MaskReferenceMode: () => (/* binding */ MaskReferenceMode),\n/* harmony export */   MediaModality: () => (/* binding */ MediaModality),\n/* harmony export */   MediaResolution: () => (/* binding */ MediaResolution),\n/* harmony export */   Modality: () => (/* binding */ Modality),\n/* harmony export */   Mode: () => (/* binding */ Mode),\n/* harmony export */   Models: () => (/* binding */ Models),\n/* harmony export */   MusicGenerationMode: () => (/* binding */ MusicGenerationMode),\n/* harmony export */   Operations: () => (/* binding */ Operations),\n/* harmony export */   Outcome: () => (/* binding */ Outcome),\n/* harmony export */   PagedItem: () => (/* binding */ PagedItem),\n/* harmony export */   Pager: () => (/* binding */ Pager),\n/* harmony export */   PersonGeneration: () => (/* binding */ PersonGeneration),\n/* harmony export */   RawReferenceImage: () => (/* binding */ RawReferenceImage),\n/* harmony export */   RecontextImageResponse: () => (/* binding */ RecontextImageResponse),\n/* harmony export */   ReplayResponse: () => (/* binding */ ReplayResponse),\n/* harmony export */   SafetyFilterLevel: () => (/* binding */ SafetyFilterLevel),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   SegmentImageResponse: () => (/* binding */ SegmentImageResponse),\n/* harmony export */   SegmentMode: () => (/* binding */ SegmentMode),\n/* harmony export */   Session: () => (/* binding */ Session),\n/* harmony export */   StartSensitivity: () => (/* binding */ StartSensitivity),\n/* harmony export */   StyleReferenceImage: () => (/* binding */ StyleReferenceImage),\n/* harmony export */   SubjectReferenceImage: () => (/* binding */ SubjectReferenceImage),\n/* harmony export */   SubjectReferenceType: () => (/* binding */ SubjectReferenceType),\n/* harmony export */   Tokens: () => (/* binding */ Tokens),\n/* harmony export */   TrafficType: () => (/* binding */ TrafficType),\n/* harmony export */   TuningMode: () => (/* binding */ TuningMode),\n/* harmony export */   TurnCoverage: () => (/* binding */ TurnCoverage),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   UpscaleImageResponse: () => (/* binding */ UpscaleImageResponse),\n/* harmony export */   UrlRetrievalStatus: () => (/* binding */ UrlRetrievalStatus),\n/* harmony export */   VideoCompressionQuality: () => (/* binding */ VideoCompressionQuality),\n/* harmony export */   createModelContent: () => (/* binding */ createModelContent),\n/* harmony export */   createPartFromBase64: () => (/* binding */ createPartFromBase64),\n/* harmony export */   createPartFromCodeExecutionResult: () => (/* binding */ createPartFromCodeExecutionResult),\n/* harmony export */   createPartFromExecutableCode: () => (/* binding */ createPartFromExecutableCode),\n/* harmony export */   createPartFromFunctionCall: () => (/* binding */ createPartFromFunctionCall),\n/* harmony export */   createPartFromFunctionResponse: () => (/* binding */ createPartFromFunctionResponse),\n/* harmony export */   createPartFromText: () => (/* binding */ createPartFromText),\n/* harmony export */   createPartFromUri: () => (/* binding */ createPartFromUri),\n/* harmony export */   createUserContent: () => (/* binding */ createUserContent),\n/* harmony export */   mcpToTool: () => (/* binding */ mcpToTool),\n/* harmony export */   setDefaultBaseUrls: () => (/* binding */ setDefaultBaseUrls)\n/* harmony export */ });\n/* harmony import */ var google_auth_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n\n\n\n\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ let _defaultBaseGeminiUrl = undefined;\nlet _defaultBaseVertexUrl = undefined;\n/**\n * Overrides the base URLs for the Gemini API and Vertex AI API.\n *\n * @remarks This function should be called before initializing the SDK. If the\n * base URLs are set after initializing the SDK, the base URLs will not be\n * updated. Base URLs provided in the HttpOptions will also take precedence over\n * URLs set here.\n *\n * @example\n * ```ts\n * import {GoogleGenAI, setDefaultBaseUrls} from '@google/genai';\n * // Override the base URL for the Gemini API.\n * setDefaultBaseUrls({geminiUrl:'https://gemini.google.com'});\n *\n * // Override the base URL for the Vertex AI API.\n * setDefaultBaseUrls({vertexUrl: 'https://vertexai.googleapis.com'});\n *\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n */ function setDefaultBaseUrls(baseUrlParams) {\n    _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;\n    _defaultBaseVertexUrl = baseUrlParams.vertexUrl;\n}\n/**\n * Returns the default base URLs for the Gemini API and Vertex AI API.\n */ function getDefaultBaseUrls() {\n    return {\n        geminiUrl: _defaultBaseGeminiUrl,\n        vertexUrl: _defaultBaseVertexUrl\n    };\n}\n/**\n * Returns the default base URL based on the following priority:\n *   1. Base URLs set via HttpOptions.\n *   2. Base URLs set via the latest call to setDefaultBaseUrls.\n *   3. Base URLs set via environment variables.\n */ function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {\n    var _a, _b;\n    if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {\n        const defaultBaseUrls = getDefaultBaseUrls();\n        if (vertexai) {\n            return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;\n        } else {\n            return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;\n        }\n    }\n    return httpOptions.baseUrl;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class BaseModule {\n}\nfunction formatMap(templateString, valueMap) {\n    // Use a regular expression to find all placeholders in the template string\n    const regex = /\\{([^}]+)\\}/g;\n    // Replace each placeholder with its corresponding value from the valueMap\n    return templateString.replace(regex, (match, key)=>{\n        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {\n            const value = valueMap[key];\n            // Convert the value to a string if it's not a string already\n            return value !== undefined && value !== null ? String(value) : \"\";\n        } else {\n            // Handle missing keys\n            throw new Error(`Key '${key}' not found in valueMap.`);\n        }\n    });\n}\nfunction setValueByPath(data, keys, value) {\n    for(let i = 0; i < keys.length - 1; i++){\n        const key = keys[i];\n        if (key.endsWith(\"[]\")) {\n            const keyName = key.slice(0, -2);\n            if (!(keyName in data)) {\n                if (Array.isArray(value)) {\n                    data[keyName] = Array.from({\n                        length: value.length\n                    }, ()=>({}));\n                } else {\n                    throw new Error(`Value must be a list given an array path ${key}`);\n                }\n            }\n            if (Array.isArray(data[keyName])) {\n                const arrayData = data[keyName];\n                if (Array.isArray(value)) {\n                    for(let j = 0; j < arrayData.length; j++){\n                        const entry = arrayData[j];\n                        setValueByPath(entry, keys.slice(i + 1), value[j]);\n                    }\n                } else {\n                    for (const d of arrayData){\n                        setValueByPath(d, keys.slice(i + 1), value);\n                    }\n                }\n            }\n            return;\n        } else if (key.endsWith(\"[0]\")) {\n            const keyName = key.slice(0, -3);\n            if (!(keyName in data)) {\n                data[keyName] = [\n                    {}\n                ];\n            }\n            const arrayData = data[keyName];\n            setValueByPath(arrayData[0], keys.slice(i + 1), value);\n            return;\n        }\n        if (!data[key] || typeof data[key] !== \"object\") {\n            data[key] = {};\n        }\n        data = data[key];\n    }\n    const keyToSet = keys[keys.length - 1];\n    const existingData = data[keyToSet];\n    if (existingData !== undefined) {\n        if (!value || typeof value === \"object\" && Object.keys(value).length === 0) {\n            return;\n        }\n        if (value === existingData) {\n            return;\n        }\n        if (typeof existingData === \"object\" && typeof value === \"object\" && existingData !== null && value !== null) {\n            Object.assign(existingData, value);\n        } else {\n            throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);\n        }\n    } else {\n        data[keyToSet] = value;\n    }\n}\nfunction getValueByPath(data, keys) {\n    try {\n        if (keys.length === 1 && keys[0] === \"_self\") {\n            return data;\n        }\n        for(let i = 0; i < keys.length; i++){\n            if (typeof data !== \"object\" || data === null) {\n                return undefined;\n            }\n            const key = keys[i];\n            if (key.endsWith(\"[]\")) {\n                const keyName = key.slice(0, -2);\n                if (keyName in data) {\n                    const arrayData = data[keyName];\n                    if (!Array.isArray(arrayData)) {\n                        return undefined;\n                    }\n                    return arrayData.map((d)=>getValueByPath(d, keys.slice(i + 1)));\n                } else {\n                    return undefined;\n                }\n            } else {\n                data = data[key];\n            }\n        }\n        return data;\n    } catch (error) {\n        if (error instanceof TypeError) {\n            return undefined;\n        }\n        throw error;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function tBytes$1(fromBytes) {\n    if (typeof fromBytes !== \"string\") {\n        throw new Error(\"fromImageBytes must be a string\");\n    }\n    // TODO(b/389133914): Remove dummy bytes converter.\n    return fromBytes;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\n/** Required. Outcome of the code execution. */ var Outcome;\n(function(Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */ Outcome[\"OUTCOME_UNSPECIFIED\"] = \"OUTCOME_UNSPECIFIED\";\n    /**\n     * Code execution completed successfully.\n     */ Outcome[\"OUTCOME_OK\"] = \"OUTCOME_OK\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the reason.\n     */ Outcome[\"OUTCOME_FAILED\"] = \"OUTCOME_FAILED\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not be a partial output present.\n     */ Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"OUTCOME_DEADLINE_EXCEEDED\";\n})(Outcome || (Outcome = {}));\n/** Required. Programming language of the `code`. */ var Language;\n(function(Language) {\n    /**\n     * Unspecified language. This value should not be used.\n     */ Language[\"LANGUAGE_UNSPECIFIED\"] = \"LANGUAGE_UNSPECIFIED\";\n    /**\n     * Python >= 3.10, with numpy and simpy available.\n     */ Language[\"PYTHON\"] = \"PYTHON\";\n})(Language || (Language = {}));\n/** Optional. The type of the data. */ var Type;\n(function(Type) {\n    /**\n     * Not specified, should not be used.\n     */ Type[\"TYPE_UNSPECIFIED\"] = \"TYPE_UNSPECIFIED\";\n    /**\n     * OpenAPI string type\n     */ Type[\"STRING\"] = \"STRING\";\n    /**\n     * OpenAPI number type\n     */ Type[\"NUMBER\"] = \"NUMBER\";\n    /**\n     * OpenAPI integer type\n     */ Type[\"INTEGER\"] = \"INTEGER\";\n    /**\n     * OpenAPI boolean type\n     */ Type[\"BOOLEAN\"] = \"BOOLEAN\";\n    /**\n     * OpenAPI array type\n     */ Type[\"ARRAY\"] = \"ARRAY\";\n    /**\n     * OpenAPI object type\n     */ Type[\"OBJECT\"] = \"OBJECT\";\n    /**\n     * Null type\n     */ Type[\"NULL\"] = \"NULL\";\n})(Type || (Type = {}));\n/** Required. Harm category. */ var HarmCategory;\n(function(HarmCategory) {\n    /**\n     * The harm category is unspecified.\n     */ HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    /**\n     * The harm category is hate speech.\n     */ HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    /**\n     * The harm category is dangerous content.\n     */ HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is harassment.\n     */ HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    /**\n     * The harm category is sexually explicit content.\n     */ HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    /**\n     * Deprecated: Election filter is not longer supported. The harm category is civic integrity.\n     */ HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n    /**\n     * The harm category is image hate.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_HATE\"] = \"HARM_CATEGORY_IMAGE_HATE\";\n    /**\n     * The harm category is image dangerous content.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is image harassment.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_HARASSMENT\"] = \"HARM_CATEGORY_IMAGE_HARASSMENT\";\n    /**\n     * The harm category is image sexually explicit content.\n     */ HarmCategory[\"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\";\n})(HarmCategory || (HarmCategory = {}));\n/** Optional. Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. */ var HarmBlockMethod;\n(function(HarmBlockMethod) {\n    /**\n     * The harm block method is unspecified.\n     */ HarmBlockMethod[\"HARM_BLOCK_METHOD_UNSPECIFIED\"] = \"HARM_BLOCK_METHOD_UNSPECIFIED\";\n    /**\n     * The harm block method uses both probability and severity scores.\n     */ HarmBlockMethod[\"SEVERITY\"] = \"SEVERITY\";\n    /**\n     * The harm block method uses the probability score.\n     */ HarmBlockMethod[\"PROBABILITY\"] = \"PROBABILITY\";\n})(HarmBlockMethod || (HarmBlockMethod = {}));\n/** Required. The harm block threshold. */ var HarmBlockThreshold;\n(function(HarmBlockThreshold) {\n    /**\n     * Unspecified harm block threshold.\n     */ HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Block low threshold and above (i.e. block more).\n     */ HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Block medium threshold and above.\n     */ HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Block only high threshold (i.e. block less).\n     */ HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    /**\n     * Block none.\n     */ HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n    /**\n     * Turn off the safety filter.\n     */ HarmBlockThreshold[\"OFF\"] = \"OFF\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/** The mode of the predictor to be used in dynamic retrieval. */ var Mode;\n(function(Mode) {\n    /**\n     * Always trigger retrieval.\n     */ Mode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */ Mode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(Mode || (Mode = {}));\n/** Type of auth scheme. */ var AuthType;\n(function(AuthType) {\n    AuthType[\"AUTH_TYPE_UNSPECIFIED\"] = \"AUTH_TYPE_UNSPECIFIED\";\n    /**\n     * No Auth.\n     */ AuthType[\"NO_AUTH\"] = \"NO_AUTH\";\n    /**\n     * API Key Auth.\n     */ AuthType[\"API_KEY_AUTH\"] = \"API_KEY_AUTH\";\n    /**\n     * HTTP Basic Auth.\n     */ AuthType[\"HTTP_BASIC_AUTH\"] = \"HTTP_BASIC_AUTH\";\n    /**\n     * Google Service Account Auth.\n     */ AuthType[\"GOOGLE_SERVICE_ACCOUNT_AUTH\"] = \"GOOGLE_SERVICE_ACCOUNT_AUTH\";\n    /**\n     * OAuth auth.\n     */ AuthType[\"OAUTH\"] = \"OAUTH\";\n    /**\n     * OpenID Connect (OIDC) Auth.\n     */ AuthType[\"OIDC_AUTH\"] = \"OIDC_AUTH\";\n})(AuthType || (AuthType = {}));\n/** The API spec that the external API implements. */ var ApiSpec;\n(function(ApiSpec) {\n    /**\n     * Unspecified API spec. This value should not be used.\n     */ ApiSpec[\"API_SPEC_UNSPECIFIED\"] = \"API_SPEC_UNSPECIFIED\";\n    /**\n     * Simple search API spec.\n     */ ApiSpec[\"SIMPLE_SEARCH\"] = \"SIMPLE_SEARCH\";\n    /**\n     * Elastic search API spec.\n     */ ApiSpec[\"ELASTIC_SEARCH\"] = \"ELASTIC_SEARCH\";\n})(ApiSpec || (ApiSpec = {}));\n/** Status of the url retrieval. */ var UrlRetrievalStatus;\n(function(UrlRetrievalStatus) {\n    /**\n     * Default value. This value is unused\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSPECIFIED\"] = \"URL_RETRIEVAL_STATUS_UNSPECIFIED\";\n    /**\n     * Url retrieval is successful.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_SUCCESS\"] = \"URL_RETRIEVAL_STATUS_SUCCESS\";\n    /**\n     * Url retrieval is failed due to error.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_ERROR\"] = \"URL_RETRIEVAL_STATUS_ERROR\";\n    /**\n     * Url retrieval is failed because the content is behind paywall.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_PAYWALL\"] = \"URL_RETRIEVAL_STATUS_PAYWALL\";\n    /**\n     * Url retrieval is failed because the content is unsafe.\n     */ UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSAFE\"] = \"URL_RETRIEVAL_STATUS_UNSAFE\";\n})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));\n/** Output only. The reason why the model stopped generating tokens.\n\n  If empty, the model has not stopped generating the tokens.\n   */ var FinishReason;\n(function(FinishReason) {\n    /**\n     * The finish reason is unspecified.\n     */ FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    /**\n     * Token generation reached a natural stopping point or a configured stop sequence.\n     */ FinishReason[\"STOP\"] = \"STOP\";\n    /**\n     * Token generation reached the configured maximum output tokens.\n     */ FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    /**\n     * Token generation stopped because the content potentially contains safety violations. NOTE: When streaming, [content][] is empty if content filters blocks the output.\n     */ FinishReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The token generation stopped because of potential recitation.\n     */ FinishReason[\"RECITATION\"] = \"RECITATION\";\n    /**\n     * The token generation stopped because of using an unsupported language.\n     */ FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    /**\n     * All other reasons that stopped the token generation.\n     */ FinishReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Token generation stopped because the content contains forbidden terms.\n     */ FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Token generation stopped for potentially containing prohibited content.\n     */ FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n     */ FinishReason[\"SPII\"] = \"SPII\";\n    /**\n     * The function call generated by the model is invalid.\n     */ FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * Token generation stopped because generated images have safety violations.\n     */ FinishReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The tool call generated by the model is invalid.\n     */ FinishReason[\"UNEXPECTED_TOOL_CALL\"] = \"UNEXPECTED_TOOL_CALL\";\n})(FinishReason || (FinishReason = {}));\n/** Output only. Harm probability levels in the content. */ var HarmProbability;\n(function(HarmProbability) {\n    /**\n     * Harm probability unspecified.\n     */ HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm.\n     */ HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    /**\n     * Low level of harm.\n     */ HarmProbability[\"LOW\"] = \"LOW\";\n    /**\n     * Medium level of harm.\n     */ HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    /**\n     * High level of harm.\n     */ HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/** Output only. Harm severity levels in the content. */ var HarmSeverity;\n(function(HarmSeverity) {\n    /**\n     * Harm severity unspecified.\n     */ HarmSeverity[\"HARM_SEVERITY_UNSPECIFIED\"] = \"HARM_SEVERITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_NEGLIGIBLE\"] = \"HARM_SEVERITY_NEGLIGIBLE\";\n    /**\n     * Low level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_LOW\"] = \"HARM_SEVERITY_LOW\";\n    /**\n     * Medium level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_MEDIUM\"] = \"HARM_SEVERITY_MEDIUM\";\n    /**\n     * High level of harm severity.\n     */ HarmSeverity[\"HARM_SEVERITY_HIGH\"] = \"HARM_SEVERITY_HIGH\";\n})(HarmSeverity || (HarmSeverity = {}));\n/** Output only. Blocked reason. */ var BlockedReason;\n(function(BlockedReason) {\n    /**\n     * Unspecified blocked reason.\n     */ BlockedReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    /**\n     * Candidates blocked due to safety.\n     */ BlockedReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * Candidates blocked due to other reason.\n     */ BlockedReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Candidates blocked due to the terms which are included from the terminology blocklist.\n     */ BlockedReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Candidates blocked due to prohibited content.\n     */ BlockedReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Candidates blocked due to unsafe image generation content.\n     */ BlockedReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n})(BlockedReason || (BlockedReason = {}));\n/** Output only. Traffic type. This shows whether a request consumes Pay-As-You-Go or Provisioned Throughput quota. */ var TrafficType;\n(function(TrafficType) {\n    /**\n     * Unspecified request traffic type.\n     */ TrafficType[\"TRAFFIC_TYPE_UNSPECIFIED\"] = \"TRAFFIC_TYPE_UNSPECIFIED\";\n    /**\n     * Type for Pay-As-You-Go traffic.\n     */ TrafficType[\"ON_DEMAND\"] = \"ON_DEMAND\";\n    /**\n     * Type for Provisioned Throughput traffic.\n     */ TrafficType[\"PROVISIONED_THROUGHPUT\"] = \"PROVISIONED_THROUGHPUT\";\n})(TrafficType || (TrafficType = {}));\n/** Server content modalities. */ var Modality;\n(function(Modality) {\n    /**\n     * The modality is unspecified.\n     */ Modality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Indicates the model should return text\n     */ Modality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Indicates the model should return images.\n     */ Modality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Indicates the model should return audio.\n     */ Modality[\"AUDIO\"] = \"AUDIO\";\n})(Modality || (Modality = {}));\n/** The media resolution to use. */ var MediaResolution;\n(function(MediaResolution) {\n    /**\n     * Media resolution has not been set\n     */ MediaResolution[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low (64 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium (256 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high (zoomed reframing with 256 tokens).\n     */ MediaResolution[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(MediaResolution || (MediaResolution = {}));\n/** Job state. */ var JobState;\n(function(JobState) {\n    /**\n     * The job state is unspecified.\n     */ JobState[\"JOB_STATE_UNSPECIFIED\"] = \"JOB_STATE_UNSPECIFIED\";\n    /**\n     * The job has been just created or resumed and processing has not yet begun.\n     */ JobState[\"JOB_STATE_QUEUED\"] = \"JOB_STATE_QUEUED\";\n    /**\n     * The service is preparing to run the job.\n     */ JobState[\"JOB_STATE_PENDING\"] = \"JOB_STATE_PENDING\";\n    /**\n     * The job is in progress.\n     */ JobState[\"JOB_STATE_RUNNING\"] = \"JOB_STATE_RUNNING\";\n    /**\n     * The job completed successfully.\n     */ JobState[\"JOB_STATE_SUCCEEDED\"] = \"JOB_STATE_SUCCEEDED\";\n    /**\n     * The job failed.\n     */ JobState[\"JOB_STATE_FAILED\"] = \"JOB_STATE_FAILED\";\n    /**\n     * The job is being cancelled. From this state the job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.\n     */ JobState[\"JOB_STATE_CANCELLING\"] = \"JOB_STATE_CANCELLING\";\n    /**\n     * The job has been cancelled.\n     */ JobState[\"JOB_STATE_CANCELLED\"] = \"JOB_STATE_CANCELLED\";\n    /**\n     * The job has been stopped, and can be resumed.\n     */ JobState[\"JOB_STATE_PAUSED\"] = \"JOB_STATE_PAUSED\";\n    /**\n     * The job has expired.\n     */ JobState[\"JOB_STATE_EXPIRED\"] = \"JOB_STATE_EXPIRED\";\n    /**\n     * The job is being updated. Only jobs in the `JOB_STATE_RUNNING` state can be updated. After updating, the job goes back to the `JOB_STATE_RUNNING` state.\n     */ JobState[\"JOB_STATE_UPDATING\"] = \"JOB_STATE_UPDATING\";\n    /**\n     * The job is partially succeeded, some results may be missing due to errors.\n     */ JobState[\"JOB_STATE_PARTIALLY_SUCCEEDED\"] = \"JOB_STATE_PARTIALLY_SUCCEEDED\";\n})(JobState || (JobState = {}));\n/** Tuning mode. */ var TuningMode;\n(function(TuningMode) {\n    /**\n     * Tuning mode is unspecified.\n     */ TuningMode[\"TUNING_MODE_UNSPECIFIED\"] = \"TUNING_MODE_UNSPECIFIED\";\n    /**\n     * Full fine-tuning mode.\n     */ TuningMode[\"TUNING_MODE_FULL\"] = \"TUNING_MODE_FULL\";\n    /**\n     * PEFT adapter tuning mode.\n     */ TuningMode[\"TUNING_MODE_PEFT_ADAPTER\"] = \"TUNING_MODE_PEFT_ADAPTER\";\n})(TuningMode || (TuningMode = {}));\n/** Optional. Adapter size for tuning. */ var AdapterSize;\n(function(AdapterSize) {\n    /**\n     * Adapter size is unspecified.\n     */ AdapterSize[\"ADAPTER_SIZE_UNSPECIFIED\"] = \"ADAPTER_SIZE_UNSPECIFIED\";\n    /**\n     * Adapter size 1.\n     */ AdapterSize[\"ADAPTER_SIZE_ONE\"] = \"ADAPTER_SIZE_ONE\";\n    /**\n     * Adapter size 2.\n     */ AdapterSize[\"ADAPTER_SIZE_TWO\"] = \"ADAPTER_SIZE_TWO\";\n    /**\n     * Adapter size 4.\n     */ AdapterSize[\"ADAPTER_SIZE_FOUR\"] = \"ADAPTER_SIZE_FOUR\";\n    /**\n     * Adapter size 8.\n     */ AdapterSize[\"ADAPTER_SIZE_EIGHT\"] = \"ADAPTER_SIZE_EIGHT\";\n    /**\n     * Adapter size 16.\n     */ AdapterSize[\"ADAPTER_SIZE_SIXTEEN\"] = \"ADAPTER_SIZE_SIXTEEN\";\n    /**\n     * Adapter size 32.\n     */ AdapterSize[\"ADAPTER_SIZE_THIRTY_TWO\"] = \"ADAPTER_SIZE_THIRTY_TWO\";\n})(AdapterSize || (AdapterSize = {}));\n/** Options for feature selection preference. */ var FeatureSelectionPreference;\n(function(FeatureSelectionPreference) {\n    FeatureSelectionPreference[\"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\"] = \"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\";\n    FeatureSelectionPreference[\"PRIORITIZE_QUALITY\"] = \"PRIORITIZE_QUALITY\";\n    FeatureSelectionPreference[\"BALANCED\"] = \"BALANCED\";\n    FeatureSelectionPreference[\"PRIORITIZE_COST\"] = \"PRIORITIZE_COST\";\n})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));\n/** Defines the function behavior. Defaults to `BLOCKING`. */ var Behavior;\n(function(Behavior) {\n    /**\n     * This value is unused.\n     */ Behavior[\"UNSPECIFIED\"] = \"UNSPECIFIED\";\n    /**\n     * If set, the system will wait to receive the function response before continuing the conversation.\n     */ Behavior[\"BLOCKING\"] = \"BLOCKING\";\n    /**\n     * If set, the system will not wait to receive the function response. Instead, it will attempt to handle function responses as they become available while maintaining the conversation between the user and the model.\n     */ Behavior[\"NON_BLOCKING\"] = \"NON_BLOCKING\";\n})(Behavior || (Behavior = {}));\n/** Config for the dynamic retrieval config mode. */ var DynamicRetrievalConfigMode;\n(function(DynamicRetrievalConfigMode) {\n    /**\n     * Always trigger retrieval.\n     */ DynamicRetrievalConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */ DynamicRetrievalConfigMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));\n/** The environment being operated. */ var Environment;\n(function(Environment) {\n    /**\n     * Defaults to browser.\n     */ Environment[\"ENVIRONMENT_UNSPECIFIED\"] = \"ENVIRONMENT_UNSPECIFIED\";\n    /**\n     * Operates in a web browser.\n     */ Environment[\"ENVIRONMENT_BROWSER\"] = \"ENVIRONMENT_BROWSER\";\n})(Environment || (Environment = {}));\n/** Config for the function calling config mode. */ var FunctionCallingConfigMode;\n(function(FunctionCallingConfigMode) {\n    /**\n     * The function calling config mode is unspecified. Should not be used.\n     */ FunctionCallingConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Default model behavior, model decides to predict either function calls or natural language response.\n     */ FunctionCallingConfigMode[\"AUTO\"] = \"AUTO\";\n    /**\n     * Model is constrained to always predicting function calls only. If \"allowed_function_names\" are set, the predicted function calls will be limited to any one of \"allowed_function_names\", else the predicted function calls will be any one of the provided \"function_declarations\".\n     */ FunctionCallingConfigMode[\"ANY\"] = \"ANY\";\n    /**\n     * Model will not predict any function calls. Model behavior is same as when not passing any function declarations.\n     */ FunctionCallingConfigMode[\"NONE\"] = \"NONE\";\n})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));\n/** Enum that controls the safety filter level for objectionable content. */ var SafetyFilterLevel;\n(function(SafetyFilterLevel) {\n    SafetyFilterLevel[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    SafetyFilterLevel[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(SafetyFilterLevel || (SafetyFilterLevel = {}));\n/** Enum that controls the generation of people. */ var PersonGeneration;\n(function(PersonGeneration) {\n    /**\n     * Block generation of images of people.\n     */ PersonGeneration[\"DONT_ALLOW\"] = \"DONT_ALLOW\";\n    /**\n     * Generate images of adults, but not children.\n     */ PersonGeneration[\"ALLOW_ADULT\"] = \"ALLOW_ADULT\";\n    /**\n     * Generate images that include adults and children.\n     */ PersonGeneration[\"ALLOW_ALL\"] = \"ALLOW_ALL\";\n})(PersonGeneration || (PersonGeneration = {}));\n/** Enum that specifies the language of the text in the prompt. */ var ImagePromptLanguage;\n(function(ImagePromptLanguage) {\n    /**\n     * Auto-detect the language.\n     */ ImagePromptLanguage[\"auto\"] = \"auto\";\n    /**\n     * English\n     */ ImagePromptLanguage[\"en\"] = \"en\";\n    /**\n     * Japanese\n     */ ImagePromptLanguage[\"ja\"] = \"ja\";\n    /**\n     * Korean\n     */ ImagePromptLanguage[\"ko\"] = \"ko\";\n    /**\n     * Hindi\n     */ ImagePromptLanguage[\"hi\"] = \"hi\";\n    /**\n     * Chinese\n     */ ImagePromptLanguage[\"zh\"] = \"zh\";\n    /**\n     * Portuguese\n     */ ImagePromptLanguage[\"pt\"] = \"pt\";\n    /**\n     * Spanish\n     */ ImagePromptLanguage[\"es\"] = \"es\";\n})(ImagePromptLanguage || (ImagePromptLanguage = {}));\n/** Enum representing the mask mode of a mask reference image. */ var MaskReferenceMode;\n(function(MaskReferenceMode) {\n    MaskReferenceMode[\"MASK_MODE_DEFAULT\"] = \"MASK_MODE_DEFAULT\";\n    MaskReferenceMode[\"MASK_MODE_USER_PROVIDED\"] = \"MASK_MODE_USER_PROVIDED\";\n    MaskReferenceMode[\"MASK_MODE_BACKGROUND\"] = \"MASK_MODE_BACKGROUND\";\n    MaskReferenceMode[\"MASK_MODE_FOREGROUND\"] = \"MASK_MODE_FOREGROUND\";\n    MaskReferenceMode[\"MASK_MODE_SEMANTIC\"] = \"MASK_MODE_SEMANTIC\";\n})(MaskReferenceMode || (MaskReferenceMode = {}));\n/** Enum representing the control type of a control reference image. */ var ControlReferenceType;\n(function(ControlReferenceType) {\n    ControlReferenceType[\"CONTROL_TYPE_DEFAULT\"] = \"CONTROL_TYPE_DEFAULT\";\n    ControlReferenceType[\"CONTROL_TYPE_CANNY\"] = \"CONTROL_TYPE_CANNY\";\n    ControlReferenceType[\"CONTROL_TYPE_SCRIBBLE\"] = \"CONTROL_TYPE_SCRIBBLE\";\n    ControlReferenceType[\"CONTROL_TYPE_FACE_MESH\"] = \"CONTROL_TYPE_FACE_MESH\";\n})(ControlReferenceType || (ControlReferenceType = {}));\n/** Enum representing the subject type of a subject reference image. */ var SubjectReferenceType;\n(function(SubjectReferenceType) {\n    SubjectReferenceType[\"SUBJECT_TYPE_DEFAULT\"] = \"SUBJECT_TYPE_DEFAULT\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PERSON\"] = \"SUBJECT_TYPE_PERSON\";\n    SubjectReferenceType[\"SUBJECT_TYPE_ANIMAL\"] = \"SUBJECT_TYPE_ANIMAL\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PRODUCT\"] = \"SUBJECT_TYPE_PRODUCT\";\n})(SubjectReferenceType || (SubjectReferenceType = {}));\n/** Enum representing the Imagen 3 Edit mode. */ var EditMode;\n(function(EditMode) {\n    EditMode[\"EDIT_MODE_DEFAULT\"] = \"EDIT_MODE_DEFAULT\";\n    EditMode[\"EDIT_MODE_INPAINT_REMOVAL\"] = \"EDIT_MODE_INPAINT_REMOVAL\";\n    EditMode[\"EDIT_MODE_INPAINT_INSERTION\"] = \"EDIT_MODE_INPAINT_INSERTION\";\n    EditMode[\"EDIT_MODE_OUTPAINT\"] = \"EDIT_MODE_OUTPAINT\";\n    EditMode[\"EDIT_MODE_CONTROLLED_EDITING\"] = \"EDIT_MODE_CONTROLLED_EDITING\";\n    EditMode[\"EDIT_MODE_STYLE\"] = \"EDIT_MODE_STYLE\";\n    EditMode[\"EDIT_MODE_BGSWAP\"] = \"EDIT_MODE_BGSWAP\";\n    EditMode[\"EDIT_MODE_PRODUCT_IMAGE\"] = \"EDIT_MODE_PRODUCT_IMAGE\";\n})(EditMode || (EditMode = {}));\n/** Enum that represents the segmentation mode. */ var SegmentMode;\n(function(SegmentMode) {\n    SegmentMode[\"FOREGROUND\"] = \"FOREGROUND\";\n    SegmentMode[\"BACKGROUND\"] = \"BACKGROUND\";\n    SegmentMode[\"PROMPT\"] = \"PROMPT\";\n    SegmentMode[\"SEMANTIC\"] = \"SEMANTIC\";\n    SegmentMode[\"INTERACTIVE\"] = \"INTERACTIVE\";\n})(SegmentMode || (SegmentMode = {}));\n/** Enum that controls the compression quality of the generated videos. */ var VideoCompressionQuality;\n(function(VideoCompressionQuality) {\n    /**\n     * Optimized video compression quality. This will produce videos\n        with a compressed, smaller file size.\n     */ VideoCompressionQuality[\"OPTIMIZED\"] = \"OPTIMIZED\";\n    /**\n     * Lossless video compression quality. This will produce videos\n        with a larger file size.\n     */ VideoCompressionQuality[\"LOSSLESS\"] = \"LOSSLESS\";\n})(VideoCompressionQuality || (VideoCompressionQuality = {}));\n/** State for the lifecycle of a File. */ var FileState;\n(function(FileState) {\n    FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    FileState[\"PROCESSING\"] = \"PROCESSING\";\n    FileState[\"ACTIVE\"] = \"ACTIVE\";\n    FileState[\"FAILED\"] = \"FAILED\";\n})(FileState || (FileState = {}));\n/** Source of the File. */ var FileSource;\n(function(FileSource) {\n    FileSource[\"SOURCE_UNSPECIFIED\"] = \"SOURCE_UNSPECIFIED\";\n    FileSource[\"UPLOADED\"] = \"UPLOADED\";\n    FileSource[\"GENERATED\"] = \"GENERATED\";\n})(FileSource || (FileSource = {}));\n/** Server content modalities. */ var MediaModality;\n(function(MediaModality) {\n    /**\n     * The modality is unspecified.\n     */ MediaModality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Plain text.\n     */ MediaModality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Images.\n     */ MediaModality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Video.\n     */ MediaModality[\"VIDEO\"] = \"VIDEO\";\n    /**\n     * Audio.\n     */ MediaModality[\"AUDIO\"] = \"AUDIO\";\n    /**\n     * Document, e.g. PDF.\n     */ MediaModality[\"DOCUMENT\"] = \"DOCUMENT\";\n})(MediaModality || (MediaModality = {}));\n/** Start of speech sensitivity. */ var StartSensitivity;\n(function(StartSensitivity) {\n    /**\n     * The default is START_SENSITIVITY_LOW.\n     */ StartSensitivity[\"START_SENSITIVITY_UNSPECIFIED\"] = \"START_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection will detect the start of speech more often.\n     */ StartSensitivity[\"START_SENSITIVITY_HIGH\"] = \"START_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection will detect the start of speech less often.\n     */ StartSensitivity[\"START_SENSITIVITY_LOW\"] = \"START_SENSITIVITY_LOW\";\n})(StartSensitivity || (StartSensitivity = {}));\n/** End of speech sensitivity. */ var EndSensitivity;\n(function(EndSensitivity) {\n    /**\n     * The default is END_SENSITIVITY_LOW.\n     */ EndSensitivity[\"END_SENSITIVITY_UNSPECIFIED\"] = \"END_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection ends speech more often.\n     */ EndSensitivity[\"END_SENSITIVITY_HIGH\"] = \"END_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection ends speech less often.\n     */ EndSensitivity[\"END_SENSITIVITY_LOW\"] = \"END_SENSITIVITY_LOW\";\n})(EndSensitivity || (EndSensitivity = {}));\n/** The different ways of handling user activity. */ var ActivityHandling;\n(function(ActivityHandling) {\n    /**\n     * If unspecified, the default behavior is `START_OF_ACTIVITY_INTERRUPTS`.\n     */ ActivityHandling[\"ACTIVITY_HANDLING_UNSPECIFIED\"] = \"ACTIVITY_HANDLING_UNSPECIFIED\";\n    /**\n     * If true, start of activity will interrupt the model's response (also called \"barge in\"). The model's current response will be cut-off in the moment of the interruption. This is the default behavior.\n     */ ActivityHandling[\"START_OF_ACTIVITY_INTERRUPTS\"] = \"START_OF_ACTIVITY_INTERRUPTS\";\n    /**\n     * The model's response will not be interrupted.\n     */ ActivityHandling[\"NO_INTERRUPTION\"] = \"NO_INTERRUPTION\";\n})(ActivityHandling || (ActivityHandling = {}));\n/** Options about which input is included in the user's turn. */ var TurnCoverage;\n(function(TurnCoverage) {\n    /**\n     * If unspecified, the default behavior is `TURN_INCLUDES_ONLY_ACTIVITY`.\n     */ TurnCoverage[\"TURN_COVERAGE_UNSPECIFIED\"] = \"TURN_COVERAGE_UNSPECIFIED\";\n    /**\n     * The users turn only includes activity since the last turn, excluding inactivity (e.g. silence on the audio stream). This is the default behavior.\n     */ TurnCoverage[\"TURN_INCLUDES_ONLY_ACTIVITY\"] = \"TURN_INCLUDES_ONLY_ACTIVITY\";\n    /**\n     * The users turn includes all realtime input since the last turn, including inactivity (e.g. silence on the audio stream).\n     */ TurnCoverage[\"TURN_INCLUDES_ALL_INPUT\"] = \"TURN_INCLUDES_ALL_INPUT\";\n})(TurnCoverage || (TurnCoverage = {}));\n/** Specifies how the response should be scheduled in the conversation. */ var FunctionResponseScheduling;\n(function(FunctionResponseScheduling) {\n    /**\n     * This value is unused.\n     */ FunctionResponseScheduling[\"SCHEDULING_UNSPECIFIED\"] = \"SCHEDULING_UNSPECIFIED\";\n    /**\n     * Only add the result to the conversation context, do not interrupt or trigger generation.\n     */ FunctionResponseScheduling[\"SILENT\"] = \"SILENT\";\n    /**\n     * Add the result to the conversation context, and prompt to generate output without interrupting ongoing generation.\n     */ FunctionResponseScheduling[\"WHEN_IDLE\"] = \"WHEN_IDLE\";\n    /**\n     * Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.\n     */ FunctionResponseScheduling[\"INTERRUPT\"] = \"INTERRUPT\";\n})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));\n/** Scale of the generated music. */ var Scale;\n(function(Scale) {\n    /**\n     * Default value. This value is unused.\n     */ Scale[\"SCALE_UNSPECIFIED\"] = \"SCALE_UNSPECIFIED\";\n    /**\n     * C major or A minor.\n     */ Scale[\"C_MAJOR_A_MINOR\"] = \"C_MAJOR_A_MINOR\";\n    /**\n     * Db major or Bb minor.\n     */ Scale[\"D_FLAT_MAJOR_B_FLAT_MINOR\"] = \"D_FLAT_MAJOR_B_FLAT_MINOR\";\n    /**\n     * D major or B minor.\n     */ Scale[\"D_MAJOR_B_MINOR\"] = \"D_MAJOR_B_MINOR\";\n    /**\n     * Eb major or C minor\n     */ Scale[\"E_FLAT_MAJOR_C_MINOR\"] = \"E_FLAT_MAJOR_C_MINOR\";\n    /**\n     * E major or Db minor.\n     */ Scale[\"E_MAJOR_D_FLAT_MINOR\"] = \"E_MAJOR_D_FLAT_MINOR\";\n    /**\n     * F major or D minor.\n     */ Scale[\"F_MAJOR_D_MINOR\"] = \"F_MAJOR_D_MINOR\";\n    /**\n     * Gb major or Eb minor.\n     */ Scale[\"G_FLAT_MAJOR_E_FLAT_MINOR\"] = \"G_FLAT_MAJOR_E_FLAT_MINOR\";\n    /**\n     * G major or E minor.\n     */ Scale[\"G_MAJOR_E_MINOR\"] = \"G_MAJOR_E_MINOR\";\n    /**\n     * Ab major or F minor.\n     */ Scale[\"A_FLAT_MAJOR_F_MINOR\"] = \"A_FLAT_MAJOR_F_MINOR\";\n    /**\n     * A major or Gb minor.\n     */ Scale[\"A_MAJOR_G_FLAT_MINOR\"] = \"A_MAJOR_G_FLAT_MINOR\";\n    /**\n     * Bb major or G minor.\n     */ Scale[\"B_FLAT_MAJOR_G_MINOR\"] = \"B_FLAT_MAJOR_G_MINOR\";\n    /**\n     * B major or Ab minor.\n     */ Scale[\"B_MAJOR_A_FLAT_MINOR\"] = \"B_MAJOR_A_FLAT_MINOR\";\n})(Scale || (Scale = {}));\n/** The mode of music generation. */ var MusicGenerationMode;\n(function(MusicGenerationMode) {\n    /**\n     * Rely on the server default generation mode.\n     */ MusicGenerationMode[\"MUSIC_GENERATION_MODE_UNSPECIFIED\"] = \"MUSIC_GENERATION_MODE_UNSPECIFIED\";\n    /**\n     * Steer text prompts to regions of latent space with higher quality\n        music.\n     */ MusicGenerationMode[\"QUALITY\"] = \"QUALITY\";\n    /**\n     * Steer text prompts to regions of latent space with a larger\n        diversity of music.\n     */ MusicGenerationMode[\"DIVERSITY\"] = \"DIVERSITY\";\n    /**\n     * Steer text prompts to regions of latent space more likely to\n        generate music with vocals.\n     */ MusicGenerationMode[\"VOCALIZATION\"] = \"VOCALIZATION\";\n})(MusicGenerationMode || (MusicGenerationMode = {}));\n/** The playback control signal to apply to the music generation. */ var LiveMusicPlaybackControl;\n(function(LiveMusicPlaybackControl) {\n    /**\n     * This value is unused.\n     */ LiveMusicPlaybackControl[\"PLAYBACK_CONTROL_UNSPECIFIED\"] = \"PLAYBACK_CONTROL_UNSPECIFIED\";\n    /**\n     * Start generating the music.\n     */ LiveMusicPlaybackControl[\"PLAY\"] = \"PLAY\";\n    /**\n     * Hold the music generation. Use PLAY to resume from the current position.\n     */ LiveMusicPlaybackControl[\"PAUSE\"] = \"PAUSE\";\n    /**\n     * Stop the music generation and reset the context (prompts retained).\n        Use PLAY to restart the music generation.\n     */ LiveMusicPlaybackControl[\"STOP\"] = \"STOP\";\n    /**\n     * Reset the context of the music generation without stopping it.\n        Retains the current prompts and config.\n     */ LiveMusicPlaybackControl[\"RESET_CONTEXT\"] = \"RESET_CONTEXT\";\n})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));\n/** A function response. */ class FunctionResponse {\n}\n/**\n * Creates a `Part` object from a `URI` string.\n */ function createPartFromUri(uri, mimeType) {\n    return {\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `text` string.\n */ function createPartFromText(text) {\n    return {\n        text: text\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionCall` object.\n */ function createPartFromFunctionCall(name, args) {\n    return {\n        functionCall: {\n            name: name,\n            args: args\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionResponse` object.\n */ function createPartFromFunctionResponse(id, name, response) {\n    return {\n        functionResponse: {\n            id: id,\n            name: name,\n            response: response\n        }\n    };\n}\n/**\n * Creates a `Part` object from a `base64` encoded `string`.\n */ function createPartFromBase64(data, mimeType) {\n    return {\n        inlineData: {\n            data: data,\n            mimeType: mimeType\n        }\n    };\n}\n/**\n * Creates a `Part` object from the `outcome` and `output` of a `CodeExecutionResult` object.\n */ function createPartFromCodeExecutionResult(outcome, output) {\n    return {\n        codeExecutionResult: {\n            outcome: outcome,\n            output: output\n        }\n    };\n}\n/**\n * Creates a `Part` object from the `code` and `language` of an `ExecutableCode` object.\n */ function createPartFromExecutableCode(code, language) {\n    return {\n        executableCode: {\n            code: code,\n            language: language\n        }\n    };\n}\nfunction _isPart(obj) {\n    if (typeof obj === \"object\" && obj !== null) {\n        return \"fileData\" in obj || \"text\" in obj || \"functionCall\" in obj || \"functionResponse\" in obj || \"inlineData\" in obj || \"videoMetadata\" in obj || \"codeExecutionResult\" in obj || \"executableCode\" in obj;\n    }\n    return false;\n}\nfunction _toParts(partOrString) {\n    const parts = [];\n    if (typeof partOrString === \"string\") {\n        parts.push(createPartFromText(partOrString));\n    } else if (_isPart(partOrString)) {\n        parts.push(partOrString);\n    } else if (Array.isArray(partOrString)) {\n        if (partOrString.length === 0) {\n            throw new Error(\"partOrString cannot be an empty array\");\n        }\n        for (const part of partOrString){\n            if (typeof part === \"string\") {\n                parts.push(createPartFromText(part));\n            } else if (_isPart(part)) {\n                parts.push(part);\n            } else {\n                throw new Error(\"element in PartUnion must be a Part object or string\");\n            }\n        }\n    } else {\n        throw new Error(\"partOrString must be a Part object, string, or array\");\n    }\n    return parts;\n}\n/**\n * Creates a `Content` object with a user role from a `PartListUnion` object or `string`.\n */ function createUserContent(partOrString) {\n    return {\n        role: \"user\",\n        parts: _toParts(partOrString)\n    };\n}\n/**\n * Creates a `Content` object with a model role from a `PartListUnion` object or `string`.\n */ function createModelContent(partOrString) {\n    return {\n        role: \"model\",\n        parts: _toParts(partOrString)\n    };\n}\n/** A wrapper class for the http response. */ class HttpResponse {\n    constructor(response){\n        // Process the headers.\n        const headers = {};\n        for (const pair of response.headers.entries()){\n            headers[pair[0]] = pair[1];\n        }\n        this.headers = headers;\n        // Keep the original response.\n        this.responseInternal = response;\n    }\n    json() {\n        return this.responseInternal.json();\n    }\n}\n/** Content filter results for a prompt sent in the request. */ class GenerateContentResponsePromptFeedback {\n}\n/** Usage metadata about response(s). */ class GenerateContentResponseUsageMetadata {\n}\n/** Response message for PredictionService.GenerateContent. */ class GenerateContentResponse {\n    /**\n     * Returns the concatenation of all text parts from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the text from the first\n     * one will be returned.\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     * If there are thought parts in the response, the concatenation of all text\n     * parts excluding the thought parts will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'Why is the sky blue?',\n     * });\n     *\n     * console.debug(response.text);\n     * ```\n     */ get text() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning text from the first one.\");\n        }\n        let text = \"\";\n        let anyTextPartText = false;\n        const nonTextParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartText = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartText ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the first candidate\n     * in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the inline data from the\n     * first one will be returned. If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning data from the first one.\");\n        }\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && (fieldValue !== null || fieldValue !== undefined)) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n    /**\n     * Returns the function calls from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the function calls from\n     * the first one will be returned.\n     * If there are no function calls in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const controlLightFunctionDeclaration: FunctionDeclaration = {\n     *   name: 'controlLight',\n     *   parameters: {\n     *   type: Type.OBJECT,\n     *   description: 'Set the brightness and color temperature of a room light.',\n     *   properties: {\n     *     brightness: {\n     *       type: Type.NUMBER,\n     *       description:\n     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',\n     *     },\n     *     colorTemperature: {\n     *       type: Type.STRING,\n     *       description:\n     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',\n     *     },\n     *   },\n     *   required: ['brightness', 'colorTemperature'],\n     *  };\n     *  const response = await ai.models.generateContent({\n     *     model: 'gemini-2.0-flash',\n     *     contents: 'Dim the lights so the room feels cozy and warm.',\n     *     config: {\n     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],\n     *       toolConfig: {\n     *         functionCallingConfig: {\n     *           mode: FunctionCallingConfigMode.ANY,\n     *           allowedFunctionNames: ['controlLight'],\n     *         },\n     *       },\n     *     },\n     *   });\n     *  console.debug(JSON.stringify(response.functionCalls));\n     * ```\n     */ get functionCalls() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning function calls from the first one.\");\n        }\n        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.functionCall).map((part)=>part.functionCall).filter((functionCall)=>functionCall !== undefined);\n        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {\n            return undefined;\n        }\n        return functionCalls;\n    }\n    /**\n     * Returns the first executable code from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the executable code from\n     * the first one will be returned.\n     * If there are no executable code in the response, undefined will be\n     * returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.executableCode);\n     * ```\n     */ get executableCode() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning executable code from the first one.\");\n        }\n        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.executableCode).map((part)=>part.executableCode).filter((executableCode)=>executableCode !== undefined);\n        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {\n            return undefined;\n        }\n        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;\n    }\n    /**\n     * Returns the first code execution result from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the code execution result from\n     * the first one will be returned.\n     * If there are no code execution result in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.codeExecutionResult);\n     * ```\n     */ get codeExecutionResult() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn(\"there are multiple candidates in the response, returning code execution result from the first one.\");\n        }\n        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part)=>part.codeExecutionResult).map((part)=>part.codeExecutionResult).filter((codeExecutionResult)=>codeExecutionResult !== undefined);\n        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {\n            return undefined;\n        }\n        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;\n    }\n}\n/** Response for the embed_content method. */ class EmbedContentResponse {\n}\n/** The output images response. */ class GenerateImagesResponse {\n}\n/** Response for the request to edit an image. */ class EditImageResponse {\n}\nclass UpscaleImageResponse {\n}\n/** The output images response. */ class RecontextImageResponse {\n}\n/** The output images response. */ class SegmentImageResponse {\n}\nclass ListModelsResponse {\n}\nclass DeleteModelResponse {\n}\n/** Response for counting tokens. */ class CountTokensResponse {\n}\n/** Response for computing tokens. */ class ComputeTokensResponse {\n}\n/** Response with generated videos. */ class GenerateVideosResponse {\n}\n/** Response for the list tuning jobs method. */ class ListTuningJobsResponse {\n}\n/** Empty response for caches.delete method. */ class DeleteCachedContentResponse {\n}\nclass ListCachedContentsResponse {\n}\n/** Response for the list files method. */ class ListFilesResponse {\n}\n/** Response for the create file method. */ class CreateFileResponse {\n}\n/** Response for the delete file method. */ class DeleteFileResponse {\n}\n/** Config for `inlined_responses` parameter. */ class InlinedResponse {\n}\n/** Config for batches.list return value. */ class ListBatchJobsResponse {\n}\n/** Represents a single response in a replay. */ class ReplayResponse {\n}\n/** A raw reference image.\n\n  A raw reference image represents the base image to edit, provided by the user.\n  It can optionally be provided in addition to a mask reference image or\n  a style reference image.\n   */ class RawReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_RAW\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId\n        };\n        return referenceImageAPI;\n    }\n}\n/** A mask reference image.\n\n  This encapsulates either a mask image provided by the user and configs for\n  the user provided mask, or only config parameters for the model to generate\n  a mask.\n\n  A mask image is an image whose non-zero values indicate where to edit the base\n  image. If the user provides a mask image, the mask must be in the same\n  dimensions as the raw image.\n   */ class MaskReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_MASK\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            maskImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A control reference image.\n\n  The image of the control reference image is either a control image provided\n  by the user, or a regular image which the backend will use to generate a\n  control image of. In the case of the latter, the\n  enable_control_image_computation field in the config should be set to True.\n\n  A control image is an image that represents a sketch image of areas for the\n  model to fill in based on the prompt.\n   */ class ControlReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_CONTROL\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            controlImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A style reference image.\n\n  This encapsulates a style reference image provided by the user, and\n  additionally optional config parameters for the style reference image.\n\n  A raw reference image can also be provided as a destination for the style to\n  be applied to.\n   */ class StyleReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_STYLE\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            styleImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** A subject reference image.\n\n  This encapsulates a subject reference image provided by the user, and\n  additionally optional config parameters for the subject reference image.\n\n  A raw reference image can also be provided as a destination for the subject to\n  be applied to.\n   */ class SubjectReferenceImage {\n    /* Internal method to convert to ReferenceImageAPIInternal. */ toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: \"REFERENCE_TYPE_SUBJECT\",\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            subjectImageConfig: this.config\n        };\n        return referenceImageAPI;\n    }\n}\n/** Response message for API call. */ class LiveServerMessage {\n    /**\n     * Returns the concatenation of all text parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     */ get text() {\n        var _a, _b, _c;\n        let text = \"\";\n        let anyTextPartFound = false;\n        const nonTextParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"text\" && fieldName !== \"thought\" && fieldValue !== null) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === \"string\") {\n                if (typeof part.thought === \"boolean\" && part.thought) {\n                    continue;\n                }\n                anyTextPartFound = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartFound ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */ get data() {\n        var _a, _b, _c;\n        let data = \"\";\n        const nonDataParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []){\n            for (const [fieldName, fieldValue] of Object.entries(part)){\n                if (fieldName !== \"inlineData\" && fieldValue !== null) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === \"string\") {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n}\n/** A video generation long-running operation. */ class GenerateVideosOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */ _fromAPIResponse({ apiResponse, isVertexAI }) {\n        const operation = new GenerateVideosOperation();\n        operation.name = apiResponse[\"name\"];\n        operation.metadata = apiResponse[\"metadata\"];\n        operation.done = apiResponse[\"done\"];\n        operation.error = apiResponse[\"error\"];\n        if (isVertexAI) {\n            const response = apiResponse[\"response\"];\n            if (response) {\n                const operationResponse = new GenerateVideosResponse();\n                const responseVideos = response[\"videos\"];\n                operationResponse.generatedVideos = responseVideos === null || responseVideos === void 0 ? void 0 : responseVideos.map((generatedVideo)=>{\n                    return {\n                        video: {\n                            uri: generatedVideo[\"gcsUri\"],\n                            videoBytes: generatedVideo[\"bytesBase64Encoded\"] ? tBytes$1(generatedVideo[\"bytesBase64Encoded\"]) : undefined,\n                            mimeType: generatedVideo[\"mimeType\"]\n                        }\n                    };\n                });\n                operationResponse.raiMediaFilteredCount = response[\"raiMediaFilteredCount\"];\n                operationResponse.raiMediaFilteredReasons = response[\"raiMediaFilteredReasons\"];\n                operation.response = operationResponse;\n            }\n        } else {\n            const response = apiResponse[\"response\"];\n            if (response) {\n                const operationResponse = new GenerateVideosResponse();\n                const generatedVideoResponse = response[\"generateVideoResponse\"];\n                const responseVideos = generatedVideoResponse === null || generatedVideoResponse === void 0 ? void 0 : generatedVideoResponse[\"generatedSamples\"];\n                operationResponse.generatedVideos = responseVideos === null || responseVideos === void 0 ? void 0 : responseVideos.map((generatedVideo)=>{\n                    const video = generatedVideo[\"video\"];\n                    return {\n                        video: {\n                            uri: video === null || video === void 0 ? void 0 : video[\"uri\"],\n                            videoBytes: (video === null || video === void 0 ? void 0 : video[\"encodedVideo\"]) ? tBytes$1(video === null || video === void 0 ? void 0 : video[\"encodedVideo\"]) : undefined,\n                            mimeType: generatedVideo[\"encoding\"]\n                        }\n                    };\n                });\n                operationResponse.raiMediaFilteredCount = generatedVideoResponse === null || generatedVideoResponse === void 0 ? void 0 : generatedVideoResponse[\"raiMediaFilteredCount\"];\n                operationResponse.raiMediaFilteredReasons = generatedVideoResponse === null || generatedVideoResponse === void 0 ? void 0 : generatedVideoResponse[\"raiMediaFilteredReasons\"];\n                operation.response = operationResponse;\n            }\n        }\n        return operation;\n    }\n}\n/** Client generated response to a `ToolCall` received from the server.\n\n  Individual `FunctionResponse` objects are matched to the respective\n  `FunctionCall` objects by the `id` field.\n\n  Note that in the unary and server-streaming GenerateContent APIs function\n  calling happens by exchanging the `Content` parts, while in the bidi\n  GenerateContent APIs function calling happens over this dedicated set of\n  messages.\n   */ class LiveClientToolResponse {\n}\n/** Parameters for sending tool responses to the live API. */ class LiveSendToolResponseParameters {\n    constructor(){\n        /** Tool responses to send to the session. */ this.functionResponses = [];\n    }\n}\n/** Response message for the LiveMusicClientMessage call. */ class LiveMusicServerMessage {\n    /**\n     * Returns the first audio chunk from the server content, if present.\n     *\n     * @remarks\n     * If there are no audio chunks in the response, undefined will be returned.\n     */ get audioChunk() {\n        if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {\n            return this.serverContent.audioChunks[0];\n        }\n        return undefined;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function tModel(apiClient, model) {\n    if (!model || typeof model !== \"string\") {\n        throw new Error(\"model is required and must be a string\");\n    }\n    if (apiClient.isVertexAI()) {\n        if (model.startsWith(\"publishers/\") || model.startsWith(\"projects/\") || model.startsWith(\"models/\")) {\n            return model;\n        } else if (model.indexOf(\"/\") >= 0) {\n            const parts = model.split(\"/\", 2);\n            return `publishers/${parts[0]}/models/${parts[1]}`;\n        } else {\n            return `publishers/google/models/${model}`;\n        }\n    } else {\n        if (model.startsWith(\"models/\") || model.startsWith(\"tunedModels/\")) {\n            return model;\n        } else {\n            return `models/${model}`;\n        }\n    }\n}\nfunction tCachesModel(apiClient, model) {\n    const transformedModel = tModel(apiClient, model);\n    if (!transformedModel) {\n        return \"\";\n    }\n    if (transformedModel.startsWith(\"publishers/\") && apiClient.isVertexAI()) {\n        // vertex caches only support model name start with projects.\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;\n    } else if (transformedModel.startsWith(\"models/\") && apiClient.isVertexAI()) {\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;\n    } else {\n        return transformedModel;\n    }\n}\nfunction tBlobs(blobs) {\n    if (Array.isArray(blobs)) {\n        return blobs.map((blob)=>tBlob(blob));\n    } else {\n        return [\n            tBlob(blobs)\n        ];\n    }\n}\nfunction tBlob(blob) {\n    if (typeof blob === \"object\" && blob !== null) {\n        return blob;\n    }\n    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);\n}\nfunction tImageBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"image/\")) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tAudioBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith(\"audio/\")) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tPart(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"PartUnion is required\");\n    }\n    if (typeof origin === \"object\") {\n        return origin;\n    }\n    if (typeof origin === \"string\") {\n        return {\n            text: origin\n        };\n    }\n    throw new Error(`Unsupported part type: ${typeof origin}`);\n}\nfunction tParts(origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"PartListUnion is required\");\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tPart(item));\n    }\n    return [\n        tPart(origin)\n    ];\n}\nfunction _isContent(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"parts\" in origin && Array.isArray(origin.parts);\n}\nfunction _isFunctionCallPart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionCall\" in origin;\n}\nfunction _isFunctionResponsePart(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"functionResponse\" in origin;\n}\nfunction tContent(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error(\"ContentUnion is required\");\n    }\n    if (_isContent(origin)) {\n        // _isContent is a utility function that checks if the\n        // origin is a Content.\n        return origin;\n    }\n    return {\n        role: \"user\",\n        parts: tParts(origin)\n    };\n}\nfunction tContentsForEmbed(apiClient, origin) {\n    if (!origin) {\n        return [];\n    }\n    if (apiClient.isVertexAI() && Array.isArray(origin)) {\n        return origin.flatMap((item)=>{\n            const content = tContent(item);\n            if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n                return [\n                    content.parts[0].text\n                ];\n            }\n            return [];\n        });\n    } else if (apiClient.isVertexAI()) {\n        const content = tContent(origin);\n        if (content.parts && content.parts.length > 0 && content.parts[0].text !== undefined) {\n            return [\n                content.parts[0].text\n            ];\n        }\n        return [];\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item)=>tContent(item));\n    }\n    return [\n        tContent(origin)\n    ];\n}\nfunction tContents(origin) {\n    if (origin === null || origin === undefined || Array.isArray(origin) && origin.length === 0) {\n        throw new Error(\"contents are required\");\n    }\n    if (!Array.isArray(origin)) {\n        // If it's not an array, it's a single content or a single PartUnion.\n        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them\");\n        }\n        return [\n            tContent(origin)\n        ];\n    }\n    const result = [];\n    const accumulatedParts = [];\n    const isContentArray = _isContent(origin[0]);\n    for (const item of origin){\n        const isContent = _isContent(item);\n        if (isContent != isContentArray) {\n            throw new Error(\"Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them\");\n        }\n        if (isContent) {\n            // `isContent` contains the result of _isContent, which is a utility\n            // function that checks if the item is a Content.\n            result.push(item);\n        } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {\n            throw new Error(\"To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them\");\n        } else {\n            accumulatedParts.push(item);\n        }\n    }\n    if (!isContentArray) {\n        result.push({\n            role: \"user\",\n            parts: tParts(accumulatedParts)\n        });\n    }\n    return result;\n}\n/*\nTransform the type field from an array of types to an array of anyOf fields.\nExample:\n  {type: ['STRING', 'NUMBER']}\nwill be transformed to\n  {anyOf: [{type: 'STRING'}, {type: 'NUMBER'}]}\n*/ function flattenTypeArrayToAnyOf(typeList, resultingSchema) {\n    if (typeList.includes(\"null\")) {\n        resultingSchema[\"nullable\"] = true;\n    }\n    const listWithoutNull = typeList.filter((type)=>type !== \"null\");\n    if (listWithoutNull.length === 1) {\n        resultingSchema[\"type\"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;\n    } else {\n        resultingSchema[\"anyOf\"] = [];\n        for (const i of listWithoutNull){\n            resultingSchema[\"anyOf\"].push({\n                \"type\": Object.values(Type).includes(i.toUpperCase()) ? i.toUpperCase() : Type.TYPE_UNSPECIFIED\n            });\n        }\n    }\n}\nfunction processJsonSchema(_jsonSchema) {\n    const genAISchema = {};\n    const schemaFieldNames = [\n        \"items\"\n    ];\n    const listSchemaFieldNames = [\n        \"anyOf\"\n    ];\n    const dictSchemaFieldNames = [\n        \"properties\"\n    ];\n    if (_jsonSchema[\"type\"] && _jsonSchema[\"anyOf\"]) {\n        throw new Error(\"type and anyOf cannot be both populated.\");\n    }\n    /*\n    This is to handle the nullable array or object. The _jsonSchema will\n    be in the format of {anyOf: [{type: 'null'}, {type: 'object'}]}. The\n    logic is to check if anyOf has 2 elements and one of the element is null,\n    if so, the anyOf field is unnecessary, so we need to get rid of the anyOf\n    field and make the schema nullable. Then use the other element as the new\n    _jsonSchema for processing. This is because the backend doesn't have a null\n    type.\n    This has to be checked before we process any other fields.\n    For example:\n      const objectNullable = z.object({\n        nullableArray: z.array(z.string()).nullable(),\n      });\n    Will have the raw _jsonSchema as:\n    {\n      type: 'OBJECT',\n      properties: {\n          nullableArray: {\n             anyOf: [\n                {type: 'null'},\n                {\n                  type: 'array',\n                  items: {type: 'string'},\n                },\n              ],\n          }\n      },\n      required: [ 'nullableArray' ],\n    }\n    Will result in following schema compatible with Gemini API:\n      {\n        type: 'OBJECT',\n        properties: {\n           nullableArray: {\n              nullable: true,\n              type: 'ARRAY',\n              items: {type: 'string'},\n           }\n        },\n        required: [ 'nullableArray' ],\n      }\n    */ const incomingAnyOf = _jsonSchema[\"anyOf\"];\n    if (incomingAnyOf != null && incomingAnyOf.length == 2) {\n        if (incomingAnyOf[0][\"type\"] === \"null\") {\n            genAISchema[\"nullable\"] = true;\n            _jsonSchema = incomingAnyOf[1];\n        } else if (incomingAnyOf[1][\"type\"] === \"null\") {\n            genAISchema[\"nullable\"] = true;\n            _jsonSchema = incomingAnyOf[0];\n        }\n    }\n    if (_jsonSchema[\"type\"] instanceof Array) {\n        flattenTypeArrayToAnyOf(_jsonSchema[\"type\"], genAISchema);\n    }\n    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)){\n        // Skip if the fieldvalue is undefined or null.\n        if (fieldValue == null) {\n            continue;\n        }\n        if (fieldName == \"type\") {\n            if (fieldValue === \"null\") {\n                throw new Error(\"type: null can not be the only possible type for the field.\");\n            }\n            if (fieldValue instanceof Array) {\n                continue;\n            }\n            genAISchema[\"type\"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;\n        } else if (schemaFieldNames.includes(fieldName)) {\n            genAISchema[fieldName] = processJsonSchema(fieldValue);\n        } else if (listSchemaFieldNames.includes(fieldName)) {\n            const listSchemaFieldValue = [];\n            for (const item of fieldValue){\n                if (item[\"type\"] == \"null\") {\n                    genAISchema[\"nullable\"] = true;\n                    continue;\n                }\n                listSchemaFieldValue.push(processJsonSchema(item));\n            }\n            genAISchema[fieldName] = listSchemaFieldValue;\n        } else if (dictSchemaFieldNames.includes(fieldName)) {\n            const dictSchemaFieldValue = {};\n            for (const [key, value] of Object.entries(fieldValue)){\n                dictSchemaFieldValue[key] = processJsonSchema(value);\n            }\n            genAISchema[fieldName] = dictSchemaFieldValue;\n        } else {\n            // additionalProperties is not included in JSONSchema, skipping it.\n            if (fieldName === \"additionalProperties\") {\n                continue;\n            }\n            genAISchema[fieldName] = fieldValue;\n        }\n    }\n    return genAISchema;\n}\n// we take the unknown in the schema field because we want enable user to pass\n// the output of major schema declaration tools without casting. Tools such as\n// zodToJsonSchema, typebox, zodToJsonSchema function can return JsonSchema7Type\n// or object, see details in\n// https://github.com/StefanTerdell/zod-to-json-schema/blob/70525efe555cd226691e093d171370a3b10921d1/src/zodToJsonSchema.ts#L7\n// typebox can return unknown, see details in\n// https://github.com/sinclairzx81/typebox/blob/5a5431439f7d5ca6b494d0d18fbfd7b1a356d67c/src/type/create/type.ts#L35\n// Note: proper json schemas with the $schema field set never arrive to this\n// transformer. Schemas with $schema are routed to the equivalent API json\n// schema field.\nfunction tSchema(schema) {\n    return processJsonSchema(schema);\n}\nfunction tSpeechConfig(speechConfig) {\n    if (typeof speechConfig === \"object\") {\n        return speechConfig;\n    } else if (typeof speechConfig === \"string\") {\n        return {\n            voiceConfig: {\n                prebuiltVoiceConfig: {\n                    voiceName: speechConfig\n                }\n            }\n        };\n    } else {\n        throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);\n    }\n}\nfunction tLiveSpeechConfig(speechConfig) {\n    if (\"multiSpeakerVoiceConfig\" in speechConfig) {\n        throw new Error(\"multiSpeakerVoiceConfig is not supported in the live API.\");\n    }\n    return speechConfig;\n}\nfunction tTool(tool) {\n    if (tool.functionDeclarations) {\n        for (const functionDeclaration of tool.functionDeclarations){\n            if (functionDeclaration.parameters) {\n                if (!Object.keys(functionDeclaration.parameters).includes(\"$schema\")) {\n                    functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);\n                } else {\n                    if (!functionDeclaration.parametersJsonSchema) {\n                        functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;\n                        delete functionDeclaration.parameters;\n                    }\n                }\n            }\n            if (functionDeclaration.response) {\n                if (!Object.keys(functionDeclaration.response).includes(\"$schema\")) {\n                    functionDeclaration.response = processJsonSchema(functionDeclaration.response);\n                } else {\n                    if (!functionDeclaration.responseJsonSchema) {\n                        functionDeclaration.responseJsonSchema = functionDeclaration.response;\n                        delete functionDeclaration.response;\n                    }\n                }\n            }\n        }\n    }\n    return tool;\n}\nfunction tTools(tools) {\n    // Check if the incoming type is defined.\n    if (tools === undefined || tools === null) {\n        throw new Error(\"tools is required\");\n    }\n    if (!Array.isArray(tools)) {\n        throw new Error(\"tools is required and must be an array of Tools\");\n    }\n    const result = [];\n    for (const tool of tools){\n        result.push(tool);\n    }\n    return result;\n}\n/**\n * Prepends resource name with project, location, resource_prefix if needed.\n *\n * @param client The API client.\n * @param resourceName The resource name.\n * @param resourcePrefix The resource prefix.\n * @param splitsAfterPrefix The number of splits after the prefix.\n * @returns The completed resource name.\n *\n * Examples:\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/bar/locations/us-west1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'projects/foo/locations/us-central1/cachedContents/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/foo/locations/us-central1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns 'cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'some/wrong/cachedContents/resource/name/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * # client.vertexai = True\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * -> 'some/wrong/resource/name/123'\n * ```\n */ function resourceName(client, resourceName, resourcePrefix, splitsAfterPrefix = 1) {\n    const shouldAppendPrefix = !resourceName.startsWith(`${resourcePrefix}/`) && resourceName.split(\"/\").length === splitsAfterPrefix;\n    if (client.isVertexAI()) {\n        if (resourceName.startsWith(\"projects/\")) {\n            return resourceName;\n        } else if (resourceName.startsWith(\"locations/\")) {\n            return `projects/${client.getProject()}/${resourceName}`;\n        } else if (resourceName.startsWith(`${resourcePrefix}/`)) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName}`;\n        } else if (shouldAppendPrefix) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName}`;\n        } else {\n            return resourceName;\n        }\n    }\n    if (shouldAppendPrefix) {\n        return `${resourcePrefix}/${resourceName}`;\n    }\n    return resourceName;\n}\nfunction tCachedContentName(apiClient, name) {\n    if (typeof name !== \"string\") {\n        throw new Error(\"name must be a string\");\n    }\n    return resourceName(apiClient, name, \"cachedContents\");\n}\nfunction tTuningJobStatus(status) {\n    switch(status){\n        case \"STATE_UNSPECIFIED\":\n            return \"JOB_STATE_UNSPECIFIED\";\n        case \"CREATING\":\n            return \"JOB_STATE_RUNNING\";\n        case \"ACTIVE\":\n            return \"JOB_STATE_SUCCEEDED\";\n        case \"FAILED\":\n            return \"JOB_STATE_FAILED\";\n        default:\n            return status;\n    }\n}\nfunction tBytes(fromImageBytes) {\n    return tBytes$1(fromImageBytes);\n}\nfunction _isFile(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"name\" in origin;\n}\nfunction isGeneratedVideo(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"video\" in origin;\n}\nfunction isVideo(origin) {\n    return origin !== null && origin !== undefined && typeof origin === \"object\" && \"uri\" in origin;\n}\nfunction tFileName(fromName) {\n    var _a;\n    let name;\n    if (_isFile(fromName)) {\n        name = fromName.name;\n    }\n    if (isVideo(fromName)) {\n        name = fromName.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (isGeneratedVideo(fromName)) {\n        name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (typeof fromName === \"string\") {\n        name = fromName;\n    }\n    if (name === undefined) {\n        throw new Error(\"Could not extract file name from the provided input.\");\n    }\n    if (name.startsWith(\"https://\")) {\n        const suffix = name.split(\"files/\")[1];\n        const match = suffix.match(/[a-z0-9]+/);\n        if (match === null) {\n            throw new Error(`Could not extract file name from URI ${name}`);\n        }\n        name = match[0];\n    } else if (name.startsWith(\"files/\")) {\n        name = name.split(\"files/\")[1];\n    }\n    return name;\n}\nfunction tModelsUrl(apiClient, baseModels) {\n    let res;\n    if (apiClient.isVertexAI()) {\n        res = baseModels ? \"publishers/google/models\" : \"models\";\n    } else {\n        res = baseModels ? \"models\" : \"tunedModels\";\n    }\n    return res;\n}\nfunction tExtractModels(response) {\n    for (const key of [\n        \"models\",\n        \"tunedModels\",\n        \"publisherModels\"\n    ]){\n        if (hasField(response, key)) {\n            return response[key];\n        }\n    }\n    return [];\n}\nfunction hasField(data, fieldName) {\n    return data !== null && typeof data === \"object\" && fieldName in data;\n}\nfunction mcpToGeminiTool(mcpTool, config = {}) {\n    const mcpToolSchema = mcpTool;\n    const functionDeclaration = {\n        name: mcpToolSchema[\"name\"],\n        description: mcpToolSchema[\"description\"],\n        parametersJsonSchema: mcpToolSchema[\"inputSchema\"]\n    };\n    if (config.behavior) {\n        functionDeclaration[\"behavior\"] = config.behavior;\n    }\n    const geminiTool = {\n        functionDeclarations: [\n            functionDeclaration\n        ]\n    };\n    return geminiTool;\n}\n/**\n * Converts a list of MCP tools to a single Gemini tool with a list of function\n * declarations.\n */ function mcpToolsToGeminiTool(mcpTools, config = {}) {\n    const functionDeclarations = [];\n    const toolNames = new Set();\n    for (const mcpTool of mcpTools){\n        const mcpToolName = mcpTool.name;\n        if (toolNames.has(mcpToolName)) {\n            throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n        }\n        toolNames.add(mcpToolName);\n        const geminiTool = mcpToGeminiTool(mcpTool, config);\n        if (geminiTool.functionDeclarations) {\n            functionDeclarations.push(...geminiTool.functionDeclarations);\n        }\n    }\n    return {\n        functionDeclarations: functionDeclarations\n    };\n}\n// Transforms a source input into a BatchJobSource object with validation.\nfunction tBatchJobSource(apiClient, src) {\n    if (typeof src !== \"string\" && !Array.isArray(src)) {\n        if (apiClient && apiClient.isVertexAI()) {\n            if (src.gcsUri && src.bigqueryUri) {\n                throw new Error(\"Only one of `gcsUri` or `bigqueryUri` can be set.\");\n            } else if (!src.gcsUri && !src.bigqueryUri) {\n                throw new Error(\"One of `gcsUri` or `bigqueryUri` must be set.\");\n            }\n        } else {\n            // Logic for non-Vertex AI client (inlined_requests, file_name)\n            if (src.inlinedRequests && src.fileName) {\n                throw new Error(\"Only one of `inlinedRequests` or `fileName` can be set.\");\n            } else if (!src.inlinedRequests && !src.fileName) {\n                throw new Error(\"One of `inlinedRequests` or `fileName` must be set.\");\n            }\n        }\n        return src;\n    } else if (Array.isArray(src)) {\n        return {\n            inlinedRequests: src\n        };\n    } else if (typeof src === \"string\") {\n        if (src.startsWith(\"gs://\")) {\n            return {\n                format: \"jsonl\",\n                gcsUri: [\n                    src\n                ]\n            };\n        } else if (src.startsWith(\"bq://\")) {\n            return {\n                format: \"bigquery\",\n                bigqueryUri: src\n            };\n        } else if (src.startsWith(\"files/\")) {\n            return {\n                fileName: src\n            };\n        }\n    }\n    throw new Error(`Unsupported source: ${src}`);\n}\nfunction tBatchJobDestination(dest) {\n    if (typeof dest !== \"string\") {\n        return dest;\n    }\n    const destString = dest;\n    if (destString.startsWith(\"gs://\")) {\n        return {\n            format: \"jsonl\",\n            gcsUri: destString\n        };\n    } else if (destString.startsWith(\"bq://\")) {\n        return {\n            format: \"bigquery\",\n            bigqueryUri: destString\n        };\n    } else {\n        throw new Error(`Unsupported destination: ${destString}`);\n    }\n}\nfunction tBatchJobName(apiClient, name) {\n    const nameString = name;\n    if (!apiClient.isVertexAI()) {\n        const mldevPattern = /batches\\/[^/]+$/;\n        if (mldevPattern.test(nameString)) {\n            return nameString.split(\"/\").pop();\n        } else {\n            throw new Error(`Invalid batch job name: ${nameString}.`);\n        }\n    }\n    const vertexPattern = /^projects\\/[^/]+\\/locations\\/[^/]+\\/batchPredictionJobs\\/[^/]+$/;\n    if (vertexPattern.test(nameString)) {\n        return nameString.split(\"/\").pop();\n    } else if (/^\\d+$/.test(nameString)) {\n        return nameString;\n    } else {\n        throw new Error(`Invalid batch job name: ${nameString}.`);\n    }\n}\nfunction tJobState(state) {\n    const stateString = state;\n    if (stateString === \"BATCH_STATE_UNSPECIFIED\") {\n        return \"JOB_STATE_UNSPECIFIED\";\n    } else if (stateString === \"BATCH_STATE_PENDING\") {\n        return \"JOB_STATE_PENDING\";\n    } else if (stateString === \"BATCH_STATE_SUCCEEDED\") {\n        return \"JOB_STATE_SUCCEEDED\";\n    } else if (stateString === \"BATCH_STATE_FAILED\") {\n        return \"JOB_STATE_FAILED\";\n    } else if (stateString === \"BATCH_STATE_CANCELLED\") {\n        return \"JOB_STATE_CANCELLED\";\n    } else {\n        return stateString;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function videoMetadataToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToMldev$4(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev$4(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$4(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$4(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev$4(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction schemaToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDefault = getValueByPath(fromObject, [\n        \"default\"\n    ]);\n    if (fromDefault != null) {\n        setValueByPath(toObject, [\n            \"default\"\n        ], fromDefault);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromExample = getValueByPath(fromObject, [\n        \"example\"\n    ]);\n    if (fromExample != null) {\n        setValueByPath(toObject, [\n            \"example\"\n        ], fromExample);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaxLength = getValueByPath(fromObject, [\n        \"maxLength\"\n    ]);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, [\n            \"maxLength\"\n        ], fromMaxLength);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, [\n            \"maxProperties\"\n        ], fromMaxProperties);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinLength = getValueByPath(fromObject, [\n        \"minLength\"\n    ]);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, [\n            \"minLength\"\n        ], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        \"minProperties\"\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, [\n            \"minProperties\"\n        ], fromMinProperties);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromPattern = getValueByPath(fromObject, [\n        \"pattern\"\n    ]);\n    if (fromPattern != null) {\n        setValueByPath(toObject, [\n            \"pattern\"\n        ], fromPattern);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$4(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToMldev$4(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$4(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev$4(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$4(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$4(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$4(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction urlContextToMldev$4() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolComputerUseToMldev$4(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    return toObject;\n}\nfunction toolToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$4(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$4(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev$4());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], toolComputerUseToMldev$4(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction latLngToMldev$2(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction retrievalConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToMldev$2(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$2(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToMldev$2(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev$3(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, [\n        \"speaker\"\n    ]);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, [\n            \"speaker\"\n        ], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$3(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        \"speakerVoiceConfigs\"\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return speakerVoiceConfigToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"speakerVoiceConfigs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction speechConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$3(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"multiSpeakerVoiceConfig\"\n        ], multiSpeakerVoiceConfigToMldev$3(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$4(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], schemaToMldev$1(tSchema(fromResponseSchema)));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToMldev$1(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$4(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$2(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToMldev$3(tSpeechConfig(fromSpeechConfig)));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], thinkingConfigToMldev$1(fromThinkingConfig));\n    }\n    return toObject;\n}\nfunction inlinedRequestToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"request\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"request\",\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"request\",\n            \"generationConfig\"\n        ], generateContentConfigToMldev$1(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction batchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"format\"\n    ]) !== undefined) {\n        throw new Error(\"format parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]) !== undefined) {\n        throw new Error(\"bigqueryUri parameter is not supported in Gemini API.\");\n    }\n    const fromFileName = getValueByPath(fromObject, [\n        \"fileName\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]);\n    if (fromInlinedRequests != null) {\n        let transformedList = fromInlinedRequests;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedRequestToMldev(apiClient, item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"requests\",\n            \"requests\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"batch\",\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    if (getValueByPath(fromObject, [\n        \"dest\"\n    ]) !== undefined) {\n        throw new Error(\"dest parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"batch\",\n            \"inputConfig\"\n        ], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createBatchJobConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    if (getValueByPath(fromObject, [\n        \"filter\"\n    ]) !== undefined) {\n        throw new Error(\"filter parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listBatchJobsConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction batchJobSourceToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"instancesFormat\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsSource\",\n            \"uris\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigquerySource\",\n            \"inputUri\"\n        ], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileName\"\n    ]) !== undefined) {\n        throw new Error(\"fileName parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedRequests\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedRequests parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction batchJobDestinationToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"predictionsFormat\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsDestination\",\n            \"outputUriPrefix\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryDestination\",\n            \"outputUri\"\n        ], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, [\n        \"fileName\"\n    ]) !== undefined) {\n        throw new Error(\"fileName parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"inlinedResponses\"\n    ]) !== undefined) {\n        throw new Error(\"inlinedResponses parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"dest\"\n    ]);\n    if (parentObject !== undefined && fromDest != null) {\n        setValueByPath(parentObject, [\n            \"outputConfig\"\n        ], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"src\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"inputConfig\"\n        ], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createBatchJobConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listBatchJobsConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tBatchJobName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction videoMetadataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromMldev$2(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromMldev$2(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromMldev$2(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        setValueByPath(toObject, [\n            \"citations\"\n        ], fromCitations);\n    }\n    return toObject;\n}\nfunction urlMetadataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, [\n        \"retrievedUrl\"\n    ]);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, [\n            \"retrievedUrl\"\n        ], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        \"urlRetrievalStatus\"\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, [\n            \"urlRetrievalStatus\"\n        ], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, [\n        \"urlMetadata\"\n    ]);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return urlMetadataFromMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"urlMetadata\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction candidateFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], contentFromMldev$2(fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev$1(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], urlContextMetadataFromMldev$2(fromUrlContextMetadata));\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction jobErrorFromMldev(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    return toObject;\n}\nfunction inlinedResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateContentResponseFromMldev$1(fromResponse));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], jobErrorFromMldev(fromError));\n    }\n    return toObject;\n}\nfunction batchJobDestinationFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, [\n        \"responsesFile\"\n    ]);\n    if (fromFileName != null) {\n        setValueByPath(toObject, [\n            \"fileName\"\n        ], fromFileName);\n    }\n    const fromInlinedResponses = getValueByPath(fromObject, [\n        \"inlinedResponses\",\n        \"inlinedResponses\"\n    ]);\n    if (fromInlinedResponses != null) {\n        let transformedList = fromInlinedResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return inlinedResponseFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"inlinedResponses\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"metadata\",\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"metadata\",\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tJobState(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"metadata\",\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"metadata\",\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"metadata\",\n        \"output\"\n    ]);\n    if (fromDest != null) {\n        setValueByPath(toObject, [\n            \"dest\"\n        ], batchJobDestinationFromMldev(fromDest));\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        \"operations\"\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return batchJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"batchJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], jobErrorFromMldev(fromError));\n    }\n    return toObject;\n}\nfunction jobErrorFromVertex(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    return toObject;\n}\nfunction batchJobSourceFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"instancesFormat\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsSource\",\n        \"uris\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigquerySource\",\n        \"inputUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryUri\"\n        ], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobDestinationFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, [\n        \"predictionsFormat\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsDestination\",\n        \"outputUriPrefix\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        \"bigqueryDestination\",\n        \"outputUri\"\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, [\n            \"bigqueryUri\"\n        ], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tJobState(fromState));\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], jobErrorFromVertex(fromError));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromSrc = getValueByPath(fromObject, [\n        \"inputConfig\"\n    ]);\n    if (fromSrc != null) {\n        setValueByPath(toObject, [\n            \"src\"\n        ], batchJobSourceFromVertex(fromSrc));\n    }\n    const fromDest = getValueByPath(fromObject, [\n        \"outputConfig\"\n    ]);\n    if (fromDest != null) {\n        setValueByPath(toObject, [\n            \"dest\"\n        ], batchJobDestinationFromVertex(fromDest));\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        \"batchPredictionJobs\"\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return batchJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"batchJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], jobErrorFromVertex(fromError));\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ var PagedItem;\n(function(PagedItem) {\n    PagedItem[\"PAGED_ITEM_BATCH_JOBS\"] = \"batchJobs\";\n    PagedItem[\"PAGED_ITEM_MODELS\"] = \"models\";\n    PagedItem[\"PAGED_ITEM_TUNING_JOBS\"] = \"tuningJobs\";\n    PagedItem[\"PAGED_ITEM_FILES\"] = \"files\";\n    PagedItem[\"PAGED_ITEM_CACHED_CONTENTS\"] = \"cachedContents\";\n})(PagedItem || (PagedItem = {}));\n/**\n * Pager class for iterating through paginated results.\n */ class Pager {\n    constructor(name, request, response, params){\n        this.pageInternal = [];\n        this.paramsInternal = {};\n        this.requestInternal = request;\n        this.init(name, response, params);\n    }\n    init(name, response, params) {\n        var _a, _b;\n        this.nameInternal = name;\n        this.pageInternal = response[this.nameInternal] || [];\n        this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;\n        this.idxInternal = 0;\n        let requestParams = {\n            config: {}\n        };\n        if (!params || Object.keys(params).length === 0) {\n            requestParams = {\n                config: {}\n            };\n        } else if (typeof params === \"object\") {\n            requestParams = Object.assign({}, params);\n        } else {\n            requestParams = params;\n        }\n        if (requestParams[\"config\"]) {\n            requestParams[\"config\"][\"pageToken\"] = response[\"nextPageToken\"];\n        }\n        this.paramsInternal = requestParams;\n        this.pageInternalSize = (_b = (_a = requestParams[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageSize\"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;\n    }\n    initNextPage(response) {\n        this.init(this.nameInternal, response, this.paramsInternal);\n    }\n    /**\n     * Returns the current page, which is a list of items.\n     *\n     * @remarks\n     * The first page is retrieved when the pager is created. The returned list of\n     * items could be a subset of the entire list.\n     */ get page() {\n        return this.pageInternal;\n    }\n    /**\n     * Returns the type of paged item (for example, ``batch_jobs``).\n     */ get name() {\n        return this.nameInternal;\n    }\n    /**\n     * Returns the length of the page fetched each time by this pager.\n     *\n     * @remarks\n     * The number of items in the page is less than or equal to the page length.\n     */ get pageSize() {\n        return this.pageInternalSize;\n    }\n    /**\n     * Returns the headers of the API response.\n     */ get sdkHttpResponse() {\n        return this.sdkHttpResponseInternal;\n    }\n    /**\n     * Returns the parameters when making the API request for the next page.\n     *\n     * @remarks\n     * Parameters contain a set of optional configs that can be\n     * used to customize the API request. For example, the `pageToken` parameter\n     * contains the token to request the next page.\n     */ get params() {\n        return this.paramsInternal;\n    }\n    /**\n     * Returns the total number of items in the current page.\n     */ get pageLength() {\n        return this.pageInternal.length;\n    }\n    /**\n     * Returns the item at the given index.\n     */ getItem(index) {\n        return this.pageInternal[index];\n    }\n    /**\n     * Returns an async iterator that support iterating through all items\n     * retrieved from the API.\n     *\n     * @remarks\n     * The iterator will automatically fetch the next page if there are more items\n     * to fetch from the API.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * for await (const file of pager) {\n     *   console.log(file.name);\n     * }\n     * ```\n     */ [Symbol.asyncIterator]() {\n        return {\n            next: async ()=>{\n                if (this.idxInternal >= this.pageLength) {\n                    if (this.hasNextPage()) {\n                        await this.nextPage();\n                    } else {\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                }\n                const item = this.getItem(this.idxInternal);\n                this.idxInternal += 1;\n                return {\n                    value: item,\n                    done: false\n                };\n            },\n            return: async ()=>{\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n        };\n    }\n    /**\n     * Fetches the next page of items. This makes a new API request.\n     *\n     * @throws {Error} If there are no more pages to fetch.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * let page = pager.page;\n     * while (true) {\n     *   for (const file of page) {\n     *     console.log(file.name);\n     *   }\n     *   if (!pager.hasNextPage()) {\n     *     break;\n     *   }\n     *   page = await pager.nextPage();\n     * }\n     * ```\n     */ async nextPage() {\n        if (!this.hasNextPage()) {\n            throw new Error(\"No more pages to fetch.\");\n        }\n        const response = await this.requestInternal(this.params);\n        this.initNextPage(response);\n        return this.page;\n    }\n    /**\n     * Returns true if there are more pages to fetch from the API.\n     */ hasNextPage() {\n        var _a;\n        if (((_a = this.params[\"config\"]) === null || _a === void 0 ? void 0 : _a[\"pageToken\"]) !== undefined) {\n            return true;\n        }\n        return false;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Batches extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Create batch job.\n         *\n         * @param params - The parameters for create batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.create({\n         *   model: 'gemini-2.0-flash',\n         *   src: {gcsUri: 'gs://bucket/path/to/file.jsonl', format: 'jsonl'},\n         *   config: {\n         *     dest: {gcsUri: 'gs://bucket/path/output/directory', format: 'jsonl'},\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.create = async (params)=>{\n            var _a, _b;\n            if (this.apiClient.isVertexAI()) {\n                const timestamp = Date.now();\n                const timestampStr = timestamp.toString();\n                if (Array.isArray(params.src)) {\n                    throw new Error(\"InlinedRequest[] is not supported in Vertex AI. Please use \" + \"Google Cloud Storage URI or BigQuery URI instead.\");\n                }\n                params.config = params.config || {};\n                if (params.config.displayName === undefined) {\n                    params.config.displayName = \"genaiBatchJob_${timestampStr}\";\n                }\n                if (params.config.dest === undefined && typeof params.src === \"string\") {\n                    if (params.src.startsWith(\"gs://\") && params.src.endsWith(\".jsonl\")) {\n                        params.config.dest = `${params.src.slice(0, -6)}/dest`;\n                    } else if (params.src.startsWith(\"bq://\")) {\n                        params.config.dest = `${params.src}_dest_${timestampStr}`;\n                    } else {\n                        throw new Error(\"Unsupported source:\" + params.src);\n                    }\n                }\n            } else {\n                if (Array.isArray(params.src) || typeof params.src !== \"string\" && params.src.inlinedRequests) {\n                    // Move system instruction to httpOptions extraBody.\n                    let path = \"\";\n                    let queryParams = {};\n                    const body = createBatchJobParametersToMldev(this.apiClient, params);\n                    path = formatMap(\"{model}:batchGenerateContent\", body[\"_url\"]);\n                    queryParams = body[\"_query\"];\n                    // Move system instruction to 'request':\n                    // {'systemInstruction': system_instruction}\n                    const batch = body[\"batch\"];\n                    const inputConfig = batch[\"inputConfig\"];\n                    const requestsWrapper = inputConfig[\"requests\"];\n                    const requests = requestsWrapper[\"requests\"];\n                    const newRequests = [];\n                    for (const request of requests){\n                        const requestDict = request;\n                        if (requestDict[\"systemInstruction\"]) {\n                            const systemInstructionValue = requestDict[\"systemInstruction\"];\n                            delete requestDict[\"systemInstruction\"];\n                            const requestContent = requestDict[\"request\"];\n                            requestContent[\"systemInstruction\"] = systemInstructionValue;\n                            requestDict[\"request\"] = requestContent;\n                        }\n                        newRequests.push(requestDict);\n                    }\n                    requestsWrapper[\"requests\"] = newRequests;\n                    delete body[\"config\"];\n                    delete body[\"_url\"];\n                    delete body[\"_query\"];\n                    const response = this.apiClient.request({\n                        path: path,\n                        queryParams: queryParams,\n                        body: JSON.stringify(body),\n                        httpMethod: \"POST\",\n                        httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n                    }).then((httpResponse)=>{\n                        return httpResponse.json();\n                    });\n                    return response.then((apiResponse)=>{\n                        const resp = batchJobFromMldev(apiResponse);\n                        return resp;\n                    });\n                }\n            }\n            return await this.createInternal(params);\n        };\n        /**\n         * Lists batch job configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of batch jobs.\n         *\n         * @example\n         * ```ts\n         * const batchJobs = await ai.batches.list({config: {'pageSize': 2}});\n         * for await (const batchJob of batchJobs) {\n         *   console.log(batchJob);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */ async createInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = createBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchGenerateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets batch job configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The batch job.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Cancels a batch job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n        } else {\n            const body = cancelBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}:cancel\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listBatchJobsParametersToVertex(params);\n            path = formatMap(\"batchPredictionJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listBatchJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listBatchJobsParametersToMldev(params);\n            path = formatMap(\"batches\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listBatchJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Deletes a batch job.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap(\"batchPredictionJobs/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteResourceJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = deleteBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap(\"batches/{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = deleteResourceJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function videoMetadataToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToMldev$3(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev$3(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$3(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$3(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev$3(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$3(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToMldev$3(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$3(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev$3(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$3(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$3(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction urlContextToMldev$3() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolComputerUseToMldev$3(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    return toObject;\n}\nfunction toolToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$3(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$3(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev$3());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], toolComputerUseToMldev$3(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction latLngToMldev$1(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction retrievalConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToMldev$1(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev$1(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToMldev$1(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$3(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev$1(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"kmsKeyName\"\n    ]) !== undefined) {\n        throw new Error(\"kmsKeyName parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createCachedContentConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], updateCachedContentConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listCachedContentsConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction videoMetadataToVertex$2(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToVertex$2(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToVertex$2(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToVertex$2(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToVertex$2(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToVertex$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToVertex$2(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToVertex$2(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToVertex$2(fromTimeRangeFilter));\n    }\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, [\n            \"excludeDomains\"\n        ], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToVertex$2(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction enterpriseWebSearchToVertex$2(fromObject) {\n    const toObject = {};\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, [\n            \"excludeDomains\"\n        ], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction apiKeyConfigToVertex$2(fromObject) {\n    const toObject = {};\n    const fromApiKeyString = getValueByPath(fromObject, [\n        \"apiKeyString\"\n    ]);\n    if (fromApiKeyString != null) {\n        setValueByPath(toObject, [\n            \"apiKeyString\"\n        ], fromApiKeyString);\n    }\n    return toObject;\n}\nfunction authConfigToVertex$2(fromObject) {\n    const toObject = {};\n    const fromApiKeyConfig = getValueByPath(fromObject, [\n        \"apiKeyConfig\"\n    ]);\n    if (fromApiKeyConfig != null) {\n        setValueByPath(toObject, [\n            \"apiKeyConfig\"\n        ], apiKeyConfigToVertex$2(fromApiKeyConfig));\n    }\n    const fromAuthType = getValueByPath(fromObject, [\n        \"authType\"\n    ]);\n    if (fromAuthType != null) {\n        setValueByPath(toObject, [\n            \"authType\"\n        ], fromAuthType);\n    }\n    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [\n        \"googleServiceAccountConfig\"\n    ]);\n    if (fromGoogleServiceAccountConfig != null) {\n        setValueByPath(toObject, [\n            \"googleServiceAccountConfig\"\n        ], fromGoogleServiceAccountConfig);\n    }\n    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [\n        \"httpBasicAuthConfig\"\n    ]);\n    if (fromHttpBasicAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"httpBasicAuthConfig\"\n        ], fromHttpBasicAuthConfig);\n    }\n    const fromOauthConfig = getValueByPath(fromObject, [\n        \"oauthConfig\"\n    ]);\n    if (fromOauthConfig != null) {\n        setValueByPath(toObject, [\n            \"oauthConfig\"\n        ], fromOauthConfig);\n    }\n    const fromOidcConfig = getValueByPath(fromObject, [\n        \"oidcConfig\"\n    ]);\n    if (fromOidcConfig != null) {\n        setValueByPath(toObject, [\n            \"oidcConfig\"\n        ], fromOidcConfig);\n    }\n    return toObject;\n}\nfunction googleMapsToVertex$2(fromObject) {\n    const toObject = {};\n    const fromAuthConfig = getValueByPath(fromObject, [\n        \"authConfig\"\n    ]);\n    if (fromAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"authConfig\"\n        ], authConfigToVertex$2(fromAuthConfig));\n    }\n    return toObject;\n}\nfunction urlContextToVertex$2() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolComputerUseToVertex$2(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    return toObject;\n}\nfunction toolToVertex$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToVertex$2(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToVertex$2(fromGoogleSearchRetrieval));\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], enterpriseWebSearchToVertex$2(fromEnterpriseWebSearch));\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToVertex$2(fromGoogleMaps));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToVertex$2());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], toolComputerUseToVertex$2(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction latLngToVertex$1(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction retrievalConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToVertex$1(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction toolConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToVertex$1(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToVertex$1(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToVertex$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToVertex$1(fromToolConfig));\n    }\n    const fromKmsKeyName = getValueByPath(fromObject, [\n        \"kmsKeyName\"\n    ]);\n    if (parentObject !== undefined && fromKmsKeyName != null) {\n        setValueByPath(parentObject, [\n            \"encryption_spec\",\n            \"kmsKeyName\"\n        ], fromKmsKeyName);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createCachedContentConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, [\n        \"ttl\"\n    ]);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, [\n            \"ttl\"\n        ], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], updateCachedContentConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listCachedContentsConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction cachedContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (fromExpireTime != null) {\n        setValueByPath(toObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction listCachedContentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return cachedContentFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"cachedContents\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction cachedContentFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (fromExpireTime != null) {\n        setValueByPath(toObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction listCachedContentsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        \"cachedContents\"\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return cachedContentFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"cachedContents\"\n        ], transformedList);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Caches extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists cached content configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of cached contents.\n         *\n         * @example\n         * ```ts\n         * const cachedContents = await ai.caches.list({config: {'pageSize': 2}});\n         * for await (const cachedContent of cachedContents) {\n         *   console.log(cachedContent);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Creates a cached contents resource.\n     *\n     * @remarks\n     * Context caching is only supported for specific models. See [Gemini\n     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)\n     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)\n     * for more information.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created cached content.\n     *\n     * @example\n     * ```ts\n     * const contents = ...; // Initialize the content to cache.\n     * const response = await ai.caches.create({\n     *   model: 'gemini-2.0-flash-001',\n     *   config: {\n     *    'contents': contents,\n     *    'displayName': 'test cache',\n     *    'systemInstruction': 'What is the sum of the two pdfs?',\n     *    'ttl': '86400s',\n     *  }\n     * });\n     * ```\n     */ async create(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = createCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets cached content configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The cached content.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes cached content.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteCachedContentResponseFromVertex();\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteCachedContentResponseFromMldev();\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates cached content configurations.\n     *\n     * @param params - The parameters for the update request.\n     * @return The updated cached content.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.caches.update({\n     *   name: '...',  // The server-generated resource name.\n     *   config: {'ttl': '7600s'}\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = updateCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = cachedContentFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listCachedContentsParametersToVertex(params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromVertex(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listCachedContentsParametersToMldev(params);\n            path = formatMap(\"cachedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listCachedContentsResponseFromMldev(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns true if the response is valid, false otherwise.\n */ function isValidResponse(response) {\n    var _a;\n    if (response.candidates == undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    return isValidContent(content);\n}\nfunction isValidContent(content) {\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts){\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Validates the history contains the correct roles.\n *\n * @throws Error if the history does not start with a user turn.\n * @throws Error if the history contains an invalid role.\n */ function validateHistory(history) {\n    // Empty history is valid.\n    if (history.length === 0) {\n        return;\n    }\n    for (const content of history){\n        if (content.role !== \"user\" && content.role !== \"model\") {\n            throw new Error(`Role must be user or model, but got ${content.role}.`);\n        }\n    }\n}\n/**\n * Extracts the curated (valid) history from a comprehensive history.\n *\n * @remarks\n * The model may sometimes generate invalid or empty contents(e.g., due to safty\n * filters or recitation). Extracting valid turns from the history\n * ensures that subsequent requests could be accpeted by the model.\n */ function extractCuratedHistory(comprehensiveHistory) {\n    if (comprehensiveHistory === undefined || comprehensiveHistory.length === 0) {\n        return [];\n    }\n    const curatedHistory = [];\n    const length = comprehensiveHistory.length;\n    let i = 0;\n    while(i < length){\n        if (comprehensiveHistory[i].role === \"user\") {\n            curatedHistory.push(comprehensiveHistory[i]);\n            i++;\n        } else {\n            const modelOutput = [];\n            let isValid = true;\n            while(i < length && comprehensiveHistory[i].role === \"model\"){\n                modelOutput.push(comprehensiveHistory[i]);\n                if (isValid && !isValidContent(comprehensiveHistory[i])) {\n                    isValid = false;\n                }\n                i++;\n            }\n            if (isValid) {\n                curatedHistory.push(...modelOutput);\n            } else {\n                // Remove the last user input when model content is invalid.\n                curatedHistory.pop();\n            }\n        }\n    }\n    return curatedHistory;\n}\n/**\n * A utility class to create a chat session.\n */ class Chats {\n    constructor(modelsModule, apiClient){\n        this.modelsModule = modelsModule;\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates a new chat session.\n     *\n     * @remarks\n     * The config in the params will be used for all requests within the chat\n     * session unless overridden by a per-request `config` in\n     * @see {@link types.SendMessageParameters#config}.\n     *\n     * @param params - Parameters for creating a chat session.\n     * @returns A new chat session.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({\n     *   model: 'gemini-2.0-flash'\n     *   config: {\n     *     temperature: 0.5,\n     *     maxOutputTokens: 1024,\n     *   }\n     * });\n     * ```\n     */ create(params) {\n        return new Chat(this.apiClient, this.modelsModule, params.model, params.config, // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        structuredClone(params.history));\n    }\n}\n/**\n * Chat session that enables sending messages to the model with previous\n * conversation context.\n *\n * @remarks\n * The session maintains all the turns between user and model.\n */ class Chat {\n    constructor(apiClient, modelsModule, model, config = {}, history = []){\n        this.apiClient = apiClient;\n        this.modelsModule = modelsModule;\n        this.model = model;\n        this.config = config;\n        this.history = history;\n        // A promise to represent the current state of the message being sent to the\n        // model.\n        this.sendPromise = Promise.resolve();\n        validateHistory(history);\n    }\n    /**\n     * Sends a message to the model and returns the response.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessageStream} for streaming method.\n     * @param params - parameters for sending messages within a chat session.\n     * @returns The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessage({\n     *   message: 'Why is the sky blue?'\n     * });\n     * console.log(response.text);\n     * ```\n     */ async sendMessage(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const responsePromise = this.modelsModule.generateContent({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        this.sendPromise = (async ()=>{\n            var _a, _b, _c;\n            const response = await responsePromise;\n            const outputContent = (_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n            // Because the AFC input contains the entire curated chat history in\n            // addition to the new user input, we need to truncate the AFC history\n            // to deduplicate the existing chat history.\n            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;\n            const index = this.getHistory(true).length;\n            let automaticFunctionCallingHistory = [];\n            if (fullAutomaticFunctionCallingHistory != null) {\n                automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];\n            }\n            const modelOutput = outputContent ? [\n                outputContent\n            ] : [];\n            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);\n            return;\n        })();\n        await this.sendPromise.catch(()=>{\n            // Resets sendPromise to avoid subsequent calls failing\n            this.sendPromise = Promise.resolve();\n        });\n        return responsePromise;\n    }\n    /**\n     * Sends a message to the model and returns the response in chunks.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessage} for non-streaming method.\n     * @param params - parameters for sending the message.\n     * @return The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessageStream({\n     *   message: 'Why is the sky blue?'\n     * });\n     * for await (const chunk of response) {\n     *   console.log(chunk.text);\n     * }\n     * ```\n     */ async sendMessageStream(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const streamResponse = this.modelsModule.generateContentStream({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config\n        });\n        // Resolve the internal tracking of send completion promise - `sendPromise`\n        // for both success and failure response. The actual failure is still\n        // propagated by the `await streamResponse`.\n        this.sendPromise = streamResponse.then(()=>undefined).catch(()=>undefined);\n        const response = await streamResponse;\n        const result = this.processStreamResponse(response, inputContent);\n        return result;\n    }\n    /**\n     * Returns the chat history.\n     *\n     * @remarks\n     * The history is a list of contents alternating between user and model.\n     *\n     * There are two types of history:\n     * - The `curated history` contains only the valid turns between user and\n     * model, which will be included in the subsequent requests sent to the model.\n     * - The `comprehensive history` contains all turns, including invalid or\n     *   empty model outputs, providing a complete record of the history.\n     *\n     * The history is updated after receiving the response from the model,\n     * for streaming response, it means receiving the last chunk of the response.\n     *\n     * The `comprehensive history` is returned by default. To get the `curated\n     * history`, set the `curated` parameter to `true`.\n     *\n     * @param curated - whether to return the curated history or the comprehensive\n     *     history.\n     * @return History contents alternating between user and model for the entire\n     *     chat session.\n     */ getHistory(curated = false) {\n        const history = curated ? extractCuratedHistory(this.history) : this.history;\n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        return structuredClone(history);\n    }\n    processStreamResponse(streamResponse, inputContent) {\n        var _a, _b;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _c, e_1, _d, _e;\n            const outputContent = [];\n            try {\n                for(var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true){\n                    _e = streamResponse_1_1.value;\n                    _f = false;\n                    const chunk = _e;\n                    if (isValidResponse(chunk)) {\n                        const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n                        if (content !== undefined) {\n                            outputContent.push(content);\n                        }\n                    }\n                    yield yield __await(chunk);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n            this.recordHistory(inputContent, outputContent);\n        });\n    }\n    recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {\n        let outputContents = [];\n        if (modelOutput.length > 0 && modelOutput.every((content)=>content.role !== undefined)) {\n            outputContents = modelOutput;\n        } else {\n            // Appends an empty content when model returns empty response, so that the\n            // history is always alternating between user and model.\n            outputContents.push({\n                role: \"model\",\n                parts: []\n            });\n        }\n        if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {\n            this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));\n        } else {\n            this.history.push(userInput);\n        }\n        this.history.push(...outputContents);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * API errors raised by the GenAI API.\n */ class ApiError extends Error {\n    constructor(options){\n        super(options.message);\n        this.name = \"ApiError\";\n        this.status = options.status;\n        Object.setPrototypeOf(this, ApiError.prototype);\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction listFilesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFilesParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listFilesConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction fileStatusToMldev(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    return toObject;\n}\nfunction fileToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromSizeBytes = getValueByPath(fromObject, [\n        \"sizeBytes\"\n    ]);\n    if (fromSizeBytes != null) {\n        setValueByPath(toObject, [\n            \"sizeBytes\"\n        ], fromSizeBytes);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromExpirationTime = getValueByPath(fromObject, [\n        \"expirationTime\"\n    ]);\n    if (fromExpirationTime != null) {\n        setValueByPath(toObject, [\n            \"expirationTime\"\n        ], fromExpirationTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromSha256Hash = getValueByPath(fromObject, [\n        \"sha256Hash\"\n    ]);\n    if (fromSha256Hash != null) {\n        setValueByPath(toObject, [\n            \"sha256Hash\"\n        ], fromSha256Hash);\n    }\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromDownloadUri = getValueByPath(fromObject, [\n        \"downloadUri\"\n    ]);\n    if (fromDownloadUri != null) {\n        setValueByPath(toObject, [\n            \"downloadUri\"\n        ], fromDownloadUri);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], fromState);\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        setValueByPath(toObject, [\n            \"source\"\n        ], fromSource);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fileStatusToMldev(fromError));\n    }\n    return toObject;\n}\nfunction createFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFile = getValueByPath(fromObject, [\n        \"file\"\n    ]);\n    if (fromFile != null) {\n        setValueByPath(toObject, [\n            \"file\"\n        ], fileToMldev(fromFile));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction getFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction deleteFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"file\"\n        ], tFileName(fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction fileStatusFromMldev(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, [\n        \"details\"\n    ]);\n    if (fromDetails != null) {\n        setValueByPath(toObject, [\n            \"details\"\n        ], fromDetails);\n    }\n    const fromMessage = getValueByPath(fromObject, [\n        \"message\"\n    ]);\n    if (fromMessage != null) {\n        setValueByPath(toObject, [\n            \"message\"\n        ], fromMessage);\n    }\n    const fromCode = getValueByPath(fromObject, [\n        \"code\"\n    ]);\n    if (fromCode != null) {\n        setValueByPath(toObject, [\n            \"code\"\n        ], fromCode);\n    }\n    return toObject;\n}\nfunction fileFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromSizeBytes = getValueByPath(fromObject, [\n        \"sizeBytes\"\n    ]);\n    if (fromSizeBytes != null) {\n        setValueByPath(toObject, [\n            \"sizeBytes\"\n        ], fromSizeBytes);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromExpirationTime = getValueByPath(fromObject, [\n        \"expirationTime\"\n    ]);\n    if (fromExpirationTime != null) {\n        setValueByPath(toObject, [\n            \"expirationTime\"\n        ], fromExpirationTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromSha256Hash = getValueByPath(fromObject, [\n        \"sha256Hash\"\n    ]);\n    if (fromSha256Hash != null) {\n        setValueByPath(toObject, [\n            \"sha256Hash\"\n        ], fromSha256Hash);\n    }\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromDownloadUri = getValueByPath(fromObject, [\n        \"downloadUri\"\n    ]);\n    if (fromDownloadUri != null) {\n        setValueByPath(toObject, [\n            \"downloadUri\"\n        ], fromDownloadUri);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], fromState);\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        setValueByPath(toObject, [\n            \"source\"\n        ], fromSource);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], fromVideoMetadata);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fileStatusFromMldev(fromError));\n    }\n    return toObject;\n}\nfunction listFilesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromFiles = getValueByPath(fromObject, [\n        \"files\"\n    ]);\n    if (fromFiles != null) {\n        let transformedList = fromFiles;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return fileFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"files\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction createFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteFileResponseFromMldev() {\n    const toObject = {};\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Files extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists all current project files from the service.\n         *\n         * @param params - The parameters for the list request\n         * @return The paginated results of the list of files\n         *\n         * @example\n         * The following code prints the names of all files from the service, the\n         * size of each page is 10.\n         *\n         * ```ts\n         * const listResponse = await ai.files.list({config: {'pageSize': 10}});\n         * for await (const file of listResponse) {\n         *   console.log(file.name);\n         * }\n         * ```\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_FILES, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to the Gemini API.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     * Somex eamples for file extension to mimeType mapping:\n     * .txt -> text/plain\n     * .json -> application/json\n     * .jpg  -> image/jpeg\n     * .png -> image/png\n     * .mp3 -> audio/mpeg\n     * .mp4 -> video/mp4\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadFileParameters` interface.\n     *         @see {@link types.UploadFileParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a `types.File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to Gemini API.\n     *\n     * ```ts\n     * const file = await ai.files.upload({file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(file.name);\n     * ```\n     */ async upload(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Vertex AI does not support uploading files. You can share files through a GCS bucket.\");\n        }\n        return this.apiClient.uploadFile(params.file, params.config).then((response)=>{\n            const file = fileFromMldev(response);\n            return file;\n        });\n    }\n    /**\n     * Downloads a remotely stored file asynchronously to a location specified in\n     * the `params` object. This method only works on Node environment, to\n     * download files in the browser, use a browser compliant method like an <a>\n     * tag.\n     *\n     * @param params - The parameters for the download request.\n     *\n     * @example\n     * The following code downloads an example file named \"files/mehozpxf877d\" as\n     * \"file.txt\".\n     *\n     * ```ts\n     * await ai.files.download({file: file.name, downloadPath: 'file.txt'});\n     * ```\n     */ async download(params) {\n        await this.apiClient.downloadFile(params);\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = listFilesParametersToMldev(params);\n            path = formatMap(\"files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listFilesResponseFromMldev(apiResponse);\n                const typedResp = new ListFilesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async createInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createFileParametersToMldev(params);\n            path = formatMap(\"upload/v1beta/files\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = createFileResponseFromMldev(apiResponse);\n                const typedResp = new CreateFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Retrieves the file information from the service.\n     *\n     * @param params - The parameters for the get request\n     * @return The Promise that resolves to the types.File object requested.\n     *\n     * @example\n     * ```ts\n     * const config: GetFileParameters = {\n     *   name: fileName,\n     * };\n     * file = await ai.files.get(config);\n     * console.log(file.name);\n     * ```\n     */ async get(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = getFileParametersToMldev(params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = fileFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a remotely stored file.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The DeleteFileResponse, the response for the delete method.\n     *\n     * @example\n     * The following code deletes an example file named \"files/mehozpxf877d\".\n     *\n     * ```ts\n     * await ai.files.delete({name: file.name});\n     * ```\n     */ async delete(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = deleteFileParametersToMldev(params);\n            path = formatMap(\"files/{file}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteFileResponseFromMldev();\n                const typedResp = new DeleteFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function prebuiltVoiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev$2(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, [\n        \"speaker\"\n    ]);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, [\n            \"speaker\"\n        ], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$2(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        \"speakerVoiceConfigs\"\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return speakerVoiceConfigToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"speakerVoiceConfigs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction speechConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$2(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"multiSpeakerVoiceConfig\"\n        ], multiSpeakerVoiceConfigToMldev$2(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction videoMetadataToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToMldev$2(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev$2(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$2(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$2(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$2(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToMldev$2(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$2(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev$2(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$2(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$2(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction urlContextToMldev$2() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolComputerUseToMldev$2(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    return toObject;\n}\nfunction toolToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$2(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$2(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev$2());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], toolComputerUseToMldev$2(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction audioTranscriptionConfigToMldev$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction automaticActivityDetectionToMldev$1(fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, [\n        \"disabled\"\n    ]);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, [\n            \"disabled\"\n        ], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"startOfSpeechSensitivity\"\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"startOfSpeechSensitivity\"\n        ], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"endOfSpeechSensitivity\"\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"endOfSpeechSensitivity\"\n        ], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        \"prefixPaddingMs\"\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, [\n            \"prefixPaddingMs\"\n        ], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        \"silenceDurationMs\"\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, [\n            \"silenceDurationMs\"\n        ], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        \"automaticActivityDetection\"\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, [\n            \"automaticActivityDetection\"\n        ], automaticActivityDetectionToMldev$1(fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        \"activityHandling\"\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, [\n            \"activityHandling\"\n        ], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, [\n        \"turnCoverage\"\n    ]);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, [\n            \"turnCoverage\"\n        ], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction slidingWindowToMldev$1(fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, [\n        \"targetTokens\"\n    ]);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, [\n            \"targetTokens\"\n        ], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        \"triggerTokens\"\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, [\n            \"triggerTokens\"\n        ], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        \"slidingWindow\"\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, [\n            \"slidingWindow\"\n        ], slidingWindowToMldev$1(fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction proactivityConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromProactiveAudio = getValueByPath(fromObject, [\n        \"proactiveAudio\"\n    ]);\n    if (fromProactiveAudio != null) {\n        setValueByPath(toObject, [\n            \"proactiveAudio\"\n        ], fromProactiveAudio);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], speechConfigToMldev$2(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$2(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev$1(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev$1());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev$1());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], realtimeInputConfigToMldev$1(fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], contextWindowCompressionConfigToMldev$1(fromContextWindowCompression));\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], proactivityConfigToMldev$1(fromProactivity));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev$1(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction activityStartToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityEndToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], tBlobs(fromMedia));\n    }\n    const fromAudio = getValueByPath(fromObject, [\n        \"audio\"\n    ]);\n    if (fromAudio != null) {\n        setValueByPath(toObject, [\n            \"audio\"\n        ], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], activityStartToMldev());\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], activityEndToMldev());\n    }\n    return toObject;\n}\nfunction weightedPromptToMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromWeight = getValueByPath(fromObject, [\n        \"weight\"\n    ]);\n    if (fromWeight != null) {\n        setValueByPath(toObject, [\n            \"weight\"\n        ], fromWeight);\n    }\n    return toObject;\n}\nfunction liveMusicSetWeightedPromptsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        \"weightedPrompts\"\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return weightedPromptToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"weightedPrompts\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicGenerationConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromGuidance = getValueByPath(fromObject, [\n        \"guidance\"\n    ]);\n    if (fromGuidance != null) {\n        setValueByPath(toObject, [\n            \"guidance\"\n        ], fromGuidance);\n    }\n    const fromBpm = getValueByPath(fromObject, [\n        \"bpm\"\n    ]);\n    if (fromBpm != null) {\n        setValueByPath(toObject, [\n            \"bpm\"\n        ], fromBpm);\n    }\n    const fromDensity = getValueByPath(fromObject, [\n        \"density\"\n    ]);\n    if (fromDensity != null) {\n        setValueByPath(toObject, [\n            \"density\"\n        ], fromDensity);\n    }\n    const fromBrightness = getValueByPath(fromObject, [\n        \"brightness\"\n    ]);\n    if (fromBrightness != null) {\n        setValueByPath(toObject, [\n            \"brightness\"\n        ], fromBrightness);\n    }\n    const fromScale = getValueByPath(fromObject, [\n        \"scale\"\n    ]);\n    if (fromScale != null) {\n        setValueByPath(toObject, [\n            \"scale\"\n        ], fromScale);\n    }\n    const fromMuteBass = getValueByPath(fromObject, [\n        \"muteBass\"\n    ]);\n    if (fromMuteBass != null) {\n        setValueByPath(toObject, [\n            \"muteBass\"\n        ], fromMuteBass);\n    }\n    const fromMuteDrums = getValueByPath(fromObject, [\n        \"muteDrums\"\n    ]);\n    if (fromMuteDrums != null) {\n        setValueByPath(toObject, [\n            \"muteDrums\"\n        ], fromMuteDrums);\n    }\n    const fromOnlyBassAndDrums = getValueByPath(fromObject, [\n        \"onlyBassAndDrums\"\n    ]);\n    if (fromOnlyBassAndDrums != null) {\n        setValueByPath(toObject, [\n            \"onlyBassAndDrums\"\n        ], fromOnlyBassAndDrums);\n    }\n    const fromMusicGenerationMode = getValueByPath(fromObject, [\n        \"musicGenerationMode\"\n    ]);\n    if (fromMusicGenerationMode != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationMode\"\n        ], fromMusicGenerationMode);\n    }\n    return toObject;\n}\nfunction liveMusicSetConfigParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        \"musicGenerationConfig\"\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationConfig\"\n        ], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));\n    }\n    return toObject;\n}\nfunction liveMusicClientSetupToMldev(fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    return toObject;\n}\nfunction liveMusicClientContentToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        \"weightedPrompts\"\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return weightedPromptToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"weightedPrompts\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicClientMessageToMldev(fromObject) {\n    const toObject = {};\n    const fromSetup = getValueByPath(fromObject, [\n        \"setup\"\n    ]);\n    if (fromSetup != null) {\n        setValueByPath(toObject, [\n            \"setup\"\n        ], liveMusicClientSetupToMldev(fromSetup));\n    }\n    const fromClientContent = getValueByPath(fromObject, [\n        \"clientContent\"\n    ]);\n    if (fromClientContent != null) {\n        setValueByPath(toObject, [\n            \"clientContent\"\n        ], liveMusicClientContentToMldev(fromClientContent));\n    }\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        \"musicGenerationConfig\"\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationConfig\"\n        ], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));\n    }\n    const fromPlaybackControl = getValueByPath(fromObject, [\n        \"playbackControl\"\n    ]);\n    if (fromPlaybackControl != null) {\n        setValueByPath(toObject, [\n            \"playbackControl\"\n        ], fromPlaybackControl);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToVertex$1(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToVertex$1(fromVoiceConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]) !== undefined) {\n        throw new Error(\"multiSpeakerVoiceConfig parameter is not supported in Vertex AI.\");\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction videoMetadataToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToVertex$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToVertex$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToVertex$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToVertex$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToVertex$1(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToVertex$1(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToVertex$1(fromTimeRangeFilter));\n    }\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, [\n            \"excludeDomains\"\n        ], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToVertex$1(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction enterpriseWebSearchToVertex$1(fromObject) {\n    const toObject = {};\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, [\n            \"excludeDomains\"\n        ], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction apiKeyConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromApiKeyString = getValueByPath(fromObject, [\n        \"apiKeyString\"\n    ]);\n    if (fromApiKeyString != null) {\n        setValueByPath(toObject, [\n            \"apiKeyString\"\n        ], fromApiKeyString);\n    }\n    return toObject;\n}\nfunction authConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromApiKeyConfig = getValueByPath(fromObject, [\n        \"apiKeyConfig\"\n    ]);\n    if (fromApiKeyConfig != null) {\n        setValueByPath(toObject, [\n            \"apiKeyConfig\"\n        ], apiKeyConfigToVertex$1(fromApiKeyConfig));\n    }\n    const fromAuthType = getValueByPath(fromObject, [\n        \"authType\"\n    ]);\n    if (fromAuthType != null) {\n        setValueByPath(toObject, [\n            \"authType\"\n        ], fromAuthType);\n    }\n    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [\n        \"googleServiceAccountConfig\"\n    ]);\n    if (fromGoogleServiceAccountConfig != null) {\n        setValueByPath(toObject, [\n            \"googleServiceAccountConfig\"\n        ], fromGoogleServiceAccountConfig);\n    }\n    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [\n        \"httpBasicAuthConfig\"\n    ]);\n    if (fromHttpBasicAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"httpBasicAuthConfig\"\n        ], fromHttpBasicAuthConfig);\n    }\n    const fromOauthConfig = getValueByPath(fromObject, [\n        \"oauthConfig\"\n    ]);\n    if (fromOauthConfig != null) {\n        setValueByPath(toObject, [\n            \"oauthConfig\"\n        ], fromOauthConfig);\n    }\n    const fromOidcConfig = getValueByPath(fromObject, [\n        \"oidcConfig\"\n    ]);\n    if (fromOidcConfig != null) {\n        setValueByPath(toObject, [\n            \"oidcConfig\"\n        ], fromOidcConfig);\n    }\n    return toObject;\n}\nfunction googleMapsToVertex$1(fromObject) {\n    const toObject = {};\n    const fromAuthConfig = getValueByPath(fromObject, [\n        \"authConfig\"\n    ]);\n    if (fromAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"authConfig\"\n        ], authConfigToVertex$1(fromAuthConfig));\n    }\n    return toObject;\n}\nfunction urlContextToVertex$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolComputerUseToVertex$1(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    return toObject;\n}\nfunction toolToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToVertex$1(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToVertex$1(fromGoogleSearchRetrieval));\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], enterpriseWebSearchToVertex$1(fromEnterpriseWebSearch));\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToVertex$1(fromGoogleMaps));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToVertex$1());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], toolComputerUseToVertex$1(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    const fromTransparent = getValueByPath(fromObject, [\n        \"transparent\"\n    ]);\n    if (fromTransparent != null) {\n        setValueByPath(toObject, [\n            \"transparent\"\n        ], fromTransparent);\n    }\n    return toObject;\n}\nfunction audioTranscriptionConfigToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction automaticActivityDetectionToVertex(fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, [\n        \"disabled\"\n    ]);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, [\n            \"disabled\"\n        ], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"startOfSpeechSensitivity\"\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"startOfSpeechSensitivity\"\n        ], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"endOfSpeechSensitivity\"\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"endOfSpeechSensitivity\"\n        ], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        \"prefixPaddingMs\"\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, [\n            \"prefixPaddingMs\"\n        ], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        \"silenceDurationMs\"\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, [\n            \"silenceDurationMs\"\n        ], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        \"automaticActivityDetection\"\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, [\n            \"automaticActivityDetection\"\n        ], automaticActivityDetectionToVertex(fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        \"activityHandling\"\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, [\n            \"activityHandling\"\n        ], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, [\n        \"turnCoverage\"\n    ]);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, [\n            \"turnCoverage\"\n        ], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction slidingWindowToVertex(fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, [\n        \"targetTokens\"\n    ]);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, [\n            \"targetTokens\"\n        ], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        \"triggerTokens\"\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, [\n            \"triggerTokens\"\n        ], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        \"slidingWindow\"\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, [\n            \"slidingWindow\"\n        ], slidingWindowToVertex(fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction proactivityConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromProactiveAudio = getValueByPath(fromObject, [\n        \"proactiveAudio\"\n    ]);\n    if (fromProactiveAudio != null) {\n        setValueByPath(toObject, [\n            \"proactiveAudio\"\n        ], fromProactiveAudio);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToVertex$1(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToVertex(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], audioTranscriptionConfigToVertex());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], audioTranscriptionConfigToVertex());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], realtimeInputConfigToVertex(fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], contextWindowCompressionConfigToVertex(fromContextWindowCompression));\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], proactivityConfigToVertex(fromProactivity));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction activityStartToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityEndToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, [\n        \"media\"\n    ]);\n    if (fromMedia != null) {\n        setValueByPath(toObject, [\n            \"mediaChunks\"\n        ], tBlobs(fromMedia));\n    }\n    const fromAudio = getValueByPath(fromObject, [\n        \"audio\"\n    ]);\n    if (fromAudio != null) {\n        setValueByPath(toObject, [\n            \"audio\"\n        ], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        \"audioStreamEnd\"\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, [\n            \"audioStreamEnd\"\n        ], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        \"activityStart\"\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, [\n            \"activityStart\"\n        ], activityStartToVertex());\n    }\n    const fromActivityEnd = getValueByPath(fromObject, [\n        \"activityEnd\"\n    ]);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, [\n            \"activityEnd\"\n        ], activityEndToVertex());\n    }\n    return toObject;\n}\nfunction liveServerSetupCompleteFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction videoMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromMldev$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromMldev$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromMldev$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction transcriptionFromMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromFinished = getValueByPath(fromObject, [\n        \"finished\"\n    ]);\n    if (fromFinished != null) {\n        setValueByPath(toObject, [\n            \"finished\"\n        ], fromFinished);\n    }\n    return toObject;\n}\nfunction urlMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, [\n        \"retrievedUrl\"\n    ]);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, [\n            \"retrievedUrl\"\n        ], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        \"urlRetrievalStatus\"\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, [\n            \"urlRetrievalStatus\"\n        ], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, [\n        \"urlMetadata\"\n    ]);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return urlMetadataFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"urlMetadata\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveServerContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromModelTurn = getValueByPath(fromObject, [\n        \"modelTurn\"\n    ]);\n    if (fromModelTurn != null) {\n        setValueByPath(toObject, [\n            \"modelTurn\"\n        ], contentFromMldev$1(fromModelTurn));\n    }\n    const fromTurnComplete = getValueByPath(fromObject, [\n        \"turnComplete\"\n    ]);\n    if (fromTurnComplete != null) {\n        setValueByPath(toObject, [\n            \"turnComplete\"\n        ], fromTurnComplete);\n    }\n    const fromInterrupted = getValueByPath(fromObject, [\n        \"interrupted\"\n    ]);\n    if (fromInterrupted != null) {\n        setValueByPath(toObject, [\n            \"interrupted\"\n        ], fromInterrupted);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromGenerationComplete = getValueByPath(fromObject, [\n        \"generationComplete\"\n    ]);\n    if (fromGenerationComplete != null) {\n        setValueByPath(toObject, [\n            \"generationComplete\"\n        ], fromGenerationComplete);\n    }\n    const fromInputTranscription = getValueByPath(fromObject, [\n        \"inputTranscription\"\n    ]);\n    if (fromInputTranscription != null) {\n        setValueByPath(toObject, [\n            \"inputTranscription\"\n        ], transcriptionFromMldev(fromInputTranscription));\n    }\n    const fromOutputTranscription = getValueByPath(fromObject, [\n        \"outputTranscription\"\n    ]);\n    if (fromOutputTranscription != null) {\n        setValueByPath(toObject, [\n            \"outputTranscription\"\n        ], transcriptionFromMldev(fromOutputTranscription));\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], urlContextMetadataFromMldev$1(fromUrlContextMetadata));\n    }\n    return toObject;\n}\nfunction functionCallFromMldev(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, [\n        \"id\"\n    ]);\n    if (fromId != null) {\n        setValueByPath(toObject, [\n            \"id\"\n        ], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction liveServerToolCallFromMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionCalls = getValueByPath(fromObject, [\n        \"functionCalls\"\n    ]);\n    if (fromFunctionCalls != null) {\n        let transformedList = fromFunctionCalls;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionCallFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionCalls\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveServerToolCallCancellationFromMldev(fromObject) {\n    const toObject = {};\n    const fromIds = getValueByPath(fromObject, [\n        \"ids\"\n    ]);\n    if (fromIds != null) {\n        setValueByPath(toObject, [\n            \"ids\"\n        ], fromIds);\n    }\n    return toObject;\n}\nfunction modalityTokenCountFromMldev(fromObject) {\n    const toObject = {};\n    const fromModality = getValueByPath(fromObject, [\n        \"modality\"\n    ]);\n    if (fromModality != null) {\n        setValueByPath(toObject, [\n            \"modality\"\n        ], fromModality);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction usageMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        \"promptTokenCount\"\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"promptTokenCount\"\n        ], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        \"responseTokenCount\"\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, [\n            \"responseTokenCount\"\n        ], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        \"toolUsePromptTokenCount\"\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"toolUsePromptTokenCount\"\n        ], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        \"thoughtsTokenCount\"\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, [\n            \"thoughtsTokenCount\"\n        ], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        \"totalTokenCount\"\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, [\n            \"totalTokenCount\"\n        ], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        \"promptTokensDetails\"\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"promptTokensDetails\"\n        ], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        \"cacheTokensDetails\"\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"cacheTokensDetails\"\n        ], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        \"responseTokensDetails\"\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"responseTokensDetails\"\n        ], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        \"toolUsePromptTokensDetails\"\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"toolUsePromptTokensDetails\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveServerGoAwayFromMldev(fromObject) {\n    const toObject = {};\n    const fromTimeLeft = getValueByPath(fromObject, [\n        \"timeLeft\"\n    ]);\n    if (fromTimeLeft != null) {\n        setValueByPath(toObject, [\n            \"timeLeft\"\n        ], fromTimeLeft);\n    }\n    return toObject;\n}\nfunction liveServerSessionResumptionUpdateFromMldev(fromObject) {\n    const toObject = {};\n    const fromNewHandle = getValueByPath(fromObject, [\n        \"newHandle\"\n    ]);\n    if (fromNewHandle != null) {\n        setValueByPath(toObject, [\n            \"newHandle\"\n        ], fromNewHandle);\n    }\n    const fromResumable = getValueByPath(fromObject, [\n        \"resumable\"\n    ]);\n    if (fromResumable != null) {\n        setValueByPath(toObject, [\n            \"resumable\"\n        ], fromResumable);\n    }\n    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [\n        \"lastConsumedClientMessageIndex\"\n    ]);\n    if (fromLastConsumedClientMessageIndex != null) {\n        setValueByPath(toObject, [\n            \"lastConsumedClientMessageIndex\"\n        ], fromLastConsumedClientMessageIndex);\n    }\n    return toObject;\n}\nfunction liveServerMessageFromMldev(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], liveServerSetupCompleteFromMldev());\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], liveServerContentFromMldev(fromServerContent));\n    }\n    const fromToolCall = getValueByPath(fromObject, [\n        \"toolCall\"\n    ]);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, [\n            \"toolCall\"\n        ], liveServerToolCallFromMldev(fromToolCall));\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        \"toolCallCancellation\"\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, [\n            \"toolCallCancellation\"\n        ], liveServerToolCallCancellationFromMldev(fromToolCallCancellation));\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], usageMetadataFromMldev(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, [\n        \"goAway\"\n    ]);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, [\n            \"goAway\"\n        ], liveServerGoAwayFromMldev(fromGoAway));\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        \"sessionResumptionUpdate\"\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, [\n            \"sessionResumptionUpdate\"\n        ], liveServerSessionResumptionUpdateFromMldev(fromSessionResumptionUpdate));\n    }\n    return toObject;\n}\nfunction liveMusicServerSetupCompleteFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction weightedPromptFromMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromWeight = getValueByPath(fromObject, [\n        \"weight\"\n    ]);\n    if (fromWeight != null) {\n        setValueByPath(toObject, [\n            \"weight\"\n        ], fromWeight);\n    }\n    return toObject;\n}\nfunction liveMusicClientContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        \"weightedPrompts\"\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return weightedPromptFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"weightedPrompts\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicGenerationConfigFromMldev(fromObject) {\n    const toObject = {};\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromGuidance = getValueByPath(fromObject, [\n        \"guidance\"\n    ]);\n    if (fromGuidance != null) {\n        setValueByPath(toObject, [\n            \"guidance\"\n        ], fromGuidance);\n    }\n    const fromBpm = getValueByPath(fromObject, [\n        \"bpm\"\n    ]);\n    if (fromBpm != null) {\n        setValueByPath(toObject, [\n            \"bpm\"\n        ], fromBpm);\n    }\n    const fromDensity = getValueByPath(fromObject, [\n        \"density\"\n    ]);\n    if (fromDensity != null) {\n        setValueByPath(toObject, [\n            \"density\"\n        ], fromDensity);\n    }\n    const fromBrightness = getValueByPath(fromObject, [\n        \"brightness\"\n    ]);\n    if (fromBrightness != null) {\n        setValueByPath(toObject, [\n            \"brightness\"\n        ], fromBrightness);\n    }\n    const fromScale = getValueByPath(fromObject, [\n        \"scale\"\n    ]);\n    if (fromScale != null) {\n        setValueByPath(toObject, [\n            \"scale\"\n        ], fromScale);\n    }\n    const fromMuteBass = getValueByPath(fromObject, [\n        \"muteBass\"\n    ]);\n    if (fromMuteBass != null) {\n        setValueByPath(toObject, [\n            \"muteBass\"\n        ], fromMuteBass);\n    }\n    const fromMuteDrums = getValueByPath(fromObject, [\n        \"muteDrums\"\n    ]);\n    if (fromMuteDrums != null) {\n        setValueByPath(toObject, [\n            \"muteDrums\"\n        ], fromMuteDrums);\n    }\n    const fromOnlyBassAndDrums = getValueByPath(fromObject, [\n        \"onlyBassAndDrums\"\n    ]);\n    if (fromOnlyBassAndDrums != null) {\n        setValueByPath(toObject, [\n            \"onlyBassAndDrums\"\n        ], fromOnlyBassAndDrums);\n    }\n    const fromMusicGenerationMode = getValueByPath(fromObject, [\n        \"musicGenerationMode\"\n    ]);\n    if (fromMusicGenerationMode != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationMode\"\n        ], fromMusicGenerationMode);\n    }\n    return toObject;\n}\nfunction liveMusicSourceMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromClientContent = getValueByPath(fromObject, [\n        \"clientContent\"\n    ]);\n    if (fromClientContent != null) {\n        setValueByPath(toObject, [\n            \"clientContent\"\n        ], liveMusicClientContentFromMldev(fromClientContent));\n    }\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        \"musicGenerationConfig\"\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, [\n            \"musicGenerationConfig\"\n        ], liveMusicGenerationConfigFromMldev(fromMusicGenerationConfig));\n    }\n    return toObject;\n}\nfunction audioChunkFromMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromSourceMetadata = getValueByPath(fromObject, [\n        \"sourceMetadata\"\n    ]);\n    if (fromSourceMetadata != null) {\n        setValueByPath(toObject, [\n            \"sourceMetadata\"\n        ], liveMusicSourceMetadataFromMldev(fromSourceMetadata));\n    }\n    return toObject;\n}\nfunction liveMusicServerContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromAudioChunks = getValueByPath(fromObject, [\n        \"audioChunks\"\n    ]);\n    if (fromAudioChunks != null) {\n        let transformedList = fromAudioChunks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return audioChunkFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"audioChunks\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicFilteredPromptFromMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromFilteredReason = getValueByPath(fromObject, [\n        \"filteredReason\"\n    ]);\n    if (fromFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"filteredReason\"\n        ], fromFilteredReason);\n    }\n    return toObject;\n}\nfunction liveMusicServerMessageFromMldev(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], liveMusicServerSetupCompleteFromMldev());\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], liveMusicServerContentFromMldev(fromServerContent));\n    }\n    const fromFilteredPrompt = getValueByPath(fromObject, [\n        \"filteredPrompt\"\n    ]);\n    if (fromFilteredPrompt != null) {\n        setValueByPath(toObject, [\n            \"filteredPrompt\"\n        ], liveMusicFilteredPromptFromMldev(fromFilteredPrompt));\n    }\n    return toObject;\n}\nfunction liveServerSetupCompleteFromVertex(fromObject) {\n    const toObject = {};\n    const fromSessionId = getValueByPath(fromObject, [\n        \"sessionId\"\n    ]);\n    if (fromSessionId != null) {\n        setValueByPath(toObject, [\n            \"sessionId\"\n        ], fromSessionId);\n    }\n    return toObject;\n}\nfunction videoMetadataFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromVertex$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromVertex$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromVertex$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction transcriptionFromVertex(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    const fromFinished = getValueByPath(fromObject, [\n        \"finished\"\n    ]);\n    if (fromFinished != null) {\n        setValueByPath(toObject, [\n            \"finished\"\n        ], fromFinished);\n    }\n    return toObject;\n}\nfunction liveServerContentFromVertex(fromObject) {\n    const toObject = {};\n    const fromModelTurn = getValueByPath(fromObject, [\n        \"modelTurn\"\n    ]);\n    if (fromModelTurn != null) {\n        setValueByPath(toObject, [\n            \"modelTurn\"\n        ], contentFromVertex$1(fromModelTurn));\n    }\n    const fromTurnComplete = getValueByPath(fromObject, [\n        \"turnComplete\"\n    ]);\n    if (fromTurnComplete != null) {\n        setValueByPath(toObject, [\n            \"turnComplete\"\n        ], fromTurnComplete);\n    }\n    const fromInterrupted = getValueByPath(fromObject, [\n        \"interrupted\"\n    ]);\n    if (fromInterrupted != null) {\n        setValueByPath(toObject, [\n            \"interrupted\"\n        ], fromInterrupted);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromGenerationComplete = getValueByPath(fromObject, [\n        \"generationComplete\"\n    ]);\n    if (fromGenerationComplete != null) {\n        setValueByPath(toObject, [\n            \"generationComplete\"\n        ], fromGenerationComplete);\n    }\n    const fromInputTranscription = getValueByPath(fromObject, [\n        \"inputTranscription\"\n    ]);\n    if (fromInputTranscription != null) {\n        setValueByPath(toObject, [\n            \"inputTranscription\"\n        ], transcriptionFromVertex(fromInputTranscription));\n    }\n    const fromOutputTranscription = getValueByPath(fromObject, [\n        \"outputTranscription\"\n    ]);\n    if (fromOutputTranscription != null) {\n        setValueByPath(toObject, [\n            \"outputTranscription\"\n        ], transcriptionFromVertex(fromOutputTranscription));\n    }\n    return toObject;\n}\nfunction functionCallFromVertex(fromObject) {\n    const toObject = {};\n    const fromArgs = getValueByPath(fromObject, [\n        \"args\"\n    ]);\n    if (fromArgs != null) {\n        setValueByPath(toObject, [\n            \"args\"\n        ], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\nfunction liveServerToolCallFromVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionCalls = getValueByPath(fromObject, [\n        \"functionCalls\"\n    ]);\n    if (fromFunctionCalls != null) {\n        let transformedList = fromFunctionCalls;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionCallFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionCalls\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction liveServerToolCallCancellationFromVertex(fromObject) {\n    const toObject = {};\n    const fromIds = getValueByPath(fromObject, [\n        \"ids\"\n    ]);\n    if (fromIds != null) {\n        setValueByPath(toObject, [\n            \"ids\"\n        ], fromIds);\n    }\n    return toObject;\n}\nfunction modalityTokenCountFromVertex(fromObject) {\n    const toObject = {};\n    const fromModality = getValueByPath(fromObject, [\n        \"modality\"\n    ]);\n    if (fromModality != null) {\n        setValueByPath(toObject, [\n            \"modality\"\n        ], fromModality);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction usageMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        \"promptTokenCount\"\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"promptTokenCount\"\n        ], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        \"candidatesTokenCount\"\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, [\n            \"responseTokenCount\"\n        ], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        \"toolUsePromptTokenCount\"\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, [\n            \"toolUsePromptTokenCount\"\n        ], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        \"thoughtsTokenCount\"\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, [\n            \"thoughtsTokenCount\"\n        ], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        \"totalTokenCount\"\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, [\n            \"totalTokenCount\"\n        ], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        \"promptTokensDetails\"\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"promptTokensDetails\"\n        ], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        \"cacheTokensDetails\"\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"cacheTokensDetails\"\n        ], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        \"candidatesTokensDetails\"\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"responseTokensDetails\"\n        ], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        \"toolUsePromptTokensDetails\"\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"toolUsePromptTokensDetails\"\n        ], transformedList);\n    }\n    const fromTrafficType = getValueByPath(fromObject, [\n        \"trafficType\"\n    ]);\n    if (fromTrafficType != null) {\n        setValueByPath(toObject, [\n            \"trafficType\"\n        ], fromTrafficType);\n    }\n    return toObject;\n}\nfunction liveServerGoAwayFromVertex(fromObject) {\n    const toObject = {};\n    const fromTimeLeft = getValueByPath(fromObject, [\n        \"timeLeft\"\n    ]);\n    if (fromTimeLeft != null) {\n        setValueByPath(toObject, [\n            \"timeLeft\"\n        ], fromTimeLeft);\n    }\n    return toObject;\n}\nfunction liveServerSessionResumptionUpdateFromVertex(fromObject) {\n    const toObject = {};\n    const fromNewHandle = getValueByPath(fromObject, [\n        \"newHandle\"\n    ]);\n    if (fromNewHandle != null) {\n        setValueByPath(toObject, [\n            \"newHandle\"\n        ], fromNewHandle);\n    }\n    const fromResumable = getValueByPath(fromObject, [\n        \"resumable\"\n    ]);\n    if (fromResumable != null) {\n        setValueByPath(toObject, [\n            \"resumable\"\n        ], fromResumable);\n    }\n    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [\n        \"lastConsumedClientMessageIndex\"\n    ]);\n    if (fromLastConsumedClientMessageIndex != null) {\n        setValueByPath(toObject, [\n            \"lastConsumedClientMessageIndex\"\n        ], fromLastConsumedClientMessageIndex);\n    }\n    return toObject;\n}\nfunction liveServerMessageFromVertex(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        \"setupComplete\"\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, [\n            \"setupComplete\"\n        ], liveServerSetupCompleteFromVertex(fromSetupComplete));\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        \"serverContent\"\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, [\n            \"serverContent\"\n        ], liveServerContentFromVertex(fromServerContent));\n    }\n    const fromToolCall = getValueByPath(fromObject, [\n        \"toolCall\"\n    ]);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, [\n            \"toolCall\"\n        ], liveServerToolCallFromVertex(fromToolCall));\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        \"toolCallCancellation\"\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, [\n            \"toolCallCancellation\"\n        ], liveServerToolCallCancellationFromVertex(fromToolCallCancellation));\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], usageMetadataFromVertex(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, [\n        \"goAway\"\n    ]);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, [\n            \"goAway\"\n        ], liveServerGoAwayFromVertex(fromGoAway));\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        \"sessionResumptionUpdate\"\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, [\n            \"sessionResumptionUpdate\"\n        ], liveServerSessionResumptionUpdateFromVertex(fromSessionResumptionUpdate));\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function videoMetadataToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction schemaToMldev(fromObject) {\n    const toObject = {};\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDefault = getValueByPath(fromObject, [\n        \"default\"\n    ]);\n    if (fromDefault != null) {\n        setValueByPath(toObject, [\n            \"default\"\n        ], fromDefault);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromExample = getValueByPath(fromObject, [\n        \"example\"\n    ]);\n    if (fromExample != null) {\n        setValueByPath(toObject, [\n            \"example\"\n        ], fromExample);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaxLength = getValueByPath(fromObject, [\n        \"maxLength\"\n    ]);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, [\n            \"maxLength\"\n        ], fromMaxLength);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, [\n            \"maxProperties\"\n        ], fromMaxProperties);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinLength = getValueByPath(fromObject, [\n        \"minLength\"\n    ]);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, [\n            \"minLength\"\n        ], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        \"minProperties\"\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, [\n            \"minProperties\"\n        ], fromMinProperties);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromPattern = getValueByPath(fromObject, [\n        \"pattern\"\n    ]);\n    if (fromPattern != null) {\n        setValueByPath(toObject, [\n            \"pattern\"\n        ], fromPattern);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"method\"\n    ]) !== undefined) {\n        throw new Error(\"method parameter is not supported in Gemini API.\");\n    }\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$1(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToMldev$1(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$1(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev$1(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$1(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev$1(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction urlContextToMldev$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolComputerUseToMldev$1(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    return toObject;\n}\nfunction toolToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev$1(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev$1(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev$1());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], toolComputerUseToMldev$1(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction latLngToMldev(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction retrievalConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToMldev(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToMldev(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToMldev(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev$1(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, [\n        \"speaker\"\n    ]);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, [\n            \"speaker\"\n        ], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$1(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        \"speakerVoiceConfigs\"\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return speakerVoiceConfigToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"speakerVoiceConfigs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction speechConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev$1(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"multiSpeakerVoiceConfig\"\n        ], multiSpeakerVoiceConfigToMldev$1(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToMldev$1(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], schemaToMldev(tSchema(fromResponseSchema)));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]) !== undefined) {\n        throw new Error(\"routingConfig parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]) !== undefined) {\n        throw new Error(\"modelSelectionConfig parameter is not supported in Gemini API.\");\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToMldev(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"labels\"\n    ]) !== undefined) {\n        throw new Error(\"labels parameter is not supported in Gemini API.\");\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToMldev$1(tSpeechConfig(fromSpeechConfig)));\n    }\n    if (getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]) !== undefined) {\n        throw new Error(\"audioTimestamp parameter is not supported in Gemini API.\");\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], thinkingConfigToMldev(fromThinkingConfig));\n    }\n    return toObject;\n}\nfunction generateContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"taskType\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"requests[]\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, [\n        \"mimeType\"\n    ]) !== undefined) {\n        throw new Error(\"mimeType parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]) !== undefined) {\n        throw new Error(\"autoTruncate parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction embedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"content\"\n        ], tContentsForEmbed(apiClient, fromContents));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], embedContentConfigToMldev(fromConfig, toObject));\n    }\n    const fromModelForEmbedContent = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModelForEmbedContent !== undefined) {\n        setValueByPath(toObject, [\n            \"requests[]\",\n            \"model\"\n        ], tModel(apiClient, fromModelForEmbedContent));\n    }\n    return toObject;\n}\nfunction generateImagesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"negativePrompt parameter is not supported in Gemini API.\");\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    if (getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]) !== undefined) {\n        throw new Error(\"addWatermark parameter is not supported in Gemini API.\");\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleImageSize\"\n        ], fromImageSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]) !== undefined) {\n        throw new Error(\"enhancePrompt parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateImagesParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], generateImagesConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction listModelsConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, [\n        \"queryBase\"\n    ]);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, [\n            \"_url\",\n            \"models_url\"\n        ], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listModelsConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction updateModelConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], updateModelConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction deleteModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensConfigToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]) !== undefined) {\n        throw new Error(\"systemInstruction parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"tools\"\n    ]) !== undefined) {\n        throw new Error(\"tools parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]) !== undefined) {\n        throw new Error(\"generationConfig parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction countTokensParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], countTokensConfigToMldev(fromConfig));\n    }\n    return toObject;\n}\nfunction imageToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generateVideosConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    if (getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"outputGcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"fps\"\n    ]) !== undefined) {\n        throw new Error(\"fps parameter is not supported in Gemini API.\");\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    if (getValueByPath(fromObject, [\n        \"seed\"\n    ]) !== undefined) {\n        throw new Error(\"seed parameter is not supported in Gemini API.\");\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    if (getValueByPath(fromObject, [\n        \"resolution\"\n    ]) !== undefined) {\n        throw new Error(\"resolution parameter is not supported in Gemini API.\");\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    if (getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]) !== undefined) {\n        throw new Error(\"pubsubTopic parameter is not supported in Gemini API.\");\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    if (getValueByPath(fromObject, [\n        \"generateAudio\"\n    ]) !== undefined) {\n        throw new Error(\"generateAudio parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"lastFrame\"\n    ]) !== undefined) {\n        throw new Error(\"lastFrame parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]) !== undefined) {\n        throw new Error(\"referenceImages parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"compressionQuality\"\n    ]) !== undefined) {\n        throw new Error(\"compressionQuality parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction generateVideosParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToMldev(fromImage));\n    }\n    if (getValueByPath(fromObject, [\n        \"video\"\n    ]) !== undefined) {\n        throw new Error(\"video parameter is not supported in Gemini API.\");\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], generateVideosConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction videoMetadataToVertex(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToVertex(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToVertex(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToVertex(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToVertex(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToVertex(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction schemaToVertex(fromObject) {\n    const toObject = {};\n    const fromAnyOf = getValueByPath(fromObject, [\n        \"anyOf\"\n    ]);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, [\n            \"anyOf\"\n        ], fromAnyOf);\n    }\n    const fromDefault = getValueByPath(fromObject, [\n        \"default\"\n    ]);\n    if (fromDefault != null) {\n        setValueByPath(toObject, [\n            \"default\"\n        ], fromDefault);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, [\n        \"enum\"\n    ]);\n    if (fromEnum != null) {\n        setValueByPath(toObject, [\n            \"enum\"\n        ], fromEnum);\n    }\n    const fromExample = getValueByPath(fromObject, [\n        \"example\"\n    ]);\n    if (fromExample != null) {\n        setValueByPath(toObject, [\n            \"example\"\n        ], fromExample);\n    }\n    const fromFormat = getValueByPath(fromObject, [\n        \"format\"\n    ]);\n    if (fromFormat != null) {\n        setValueByPath(toObject, [\n            \"format\"\n        ], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, [\n        \"items\"\n    ]);\n    if (fromItems != null) {\n        setValueByPath(toObject, [\n            \"items\"\n        ], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, [\n        \"maxItems\"\n    ]);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, [\n            \"maxItems\"\n        ], fromMaxItems);\n    }\n    const fromMaxLength = getValueByPath(fromObject, [\n        \"maxLength\"\n    ]);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, [\n            \"maxLength\"\n        ], fromMaxLength);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        \"maxProperties\"\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, [\n            \"maxProperties\"\n        ], fromMaxProperties);\n    }\n    const fromMaximum = getValueByPath(fromObject, [\n        \"maximum\"\n    ]);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, [\n            \"maximum\"\n        ], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, [\n        \"minItems\"\n    ]);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, [\n            \"minItems\"\n        ], fromMinItems);\n    }\n    const fromMinLength = getValueByPath(fromObject, [\n        \"minLength\"\n    ]);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, [\n            \"minLength\"\n        ], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        \"minProperties\"\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, [\n            \"minProperties\"\n        ], fromMinProperties);\n    }\n    const fromMinimum = getValueByPath(fromObject, [\n        \"minimum\"\n    ]);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, [\n            \"minimum\"\n        ], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, [\n        \"nullable\"\n    ]);\n    if (fromNullable != null) {\n        setValueByPath(toObject, [\n            \"nullable\"\n        ], fromNullable);\n    }\n    const fromPattern = getValueByPath(fromObject, [\n        \"pattern\"\n    ]);\n    if (fromPattern != null) {\n        setValueByPath(toObject, [\n            \"pattern\"\n        ], fromPattern);\n    }\n    const fromProperties = getValueByPath(fromObject, [\n        \"properties\"\n    ]);\n    if (fromProperties != null) {\n        setValueByPath(toObject, [\n            \"properties\"\n        ], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        \"propertyOrdering\"\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, [\n            \"propertyOrdering\"\n        ], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, [\n        \"required\"\n    ]);\n    if (fromRequired != null) {\n        setValueByPath(toObject, [\n            \"required\"\n        ], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (fromTitle != null) {\n        setValueByPath(toObject, [\n            \"title\"\n        ], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, [\n        \"type\"\n    ]);\n    if (fromType != null) {\n        setValueByPath(toObject, [\n            \"type\"\n        ], fromType);\n    }\n    return toObject;\n}\nfunction modelSelectionConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromFeatureSelectionPreference = getValueByPath(fromObject, [\n        \"featureSelectionPreference\"\n    ]);\n    if (fromFeatureSelectionPreference != null) {\n        setValueByPath(toObject, [\n            \"featureSelectionPreference\"\n        ], fromFeatureSelectionPreference);\n    }\n    return toObject;\n}\nfunction safetySettingToVertex(fromObject) {\n    const toObject = {};\n    const fromMethod = getValueByPath(fromObject, [\n        \"method\"\n    ]);\n    if (fromMethod != null) {\n        setValueByPath(toObject, [\n            \"method\"\n        ], fromMethod);\n    }\n    const fromCategory = getValueByPath(fromObject, [\n        \"category\"\n    ]);\n    if (fromCategory != null) {\n        setValueByPath(toObject, [\n            \"category\"\n        ], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, [\n        \"threshold\"\n    ]);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, [\n            \"threshold\"\n        ], fromThreshold);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"behavior\"\n    ]) !== undefined) {\n        throw new Error(\"behavior parameter is not supported in Vertex AI.\");\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToVertex(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToVertex(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToVertex(fromTimeRangeFilter));\n    }\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, [\n            \"excludeDomains\"\n        ], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToVertex(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction enterpriseWebSearchToVertex(fromObject) {\n    const toObject = {};\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, [\n            \"excludeDomains\"\n        ], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction apiKeyConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromApiKeyString = getValueByPath(fromObject, [\n        \"apiKeyString\"\n    ]);\n    if (fromApiKeyString != null) {\n        setValueByPath(toObject, [\n            \"apiKeyString\"\n        ], fromApiKeyString);\n    }\n    return toObject;\n}\nfunction authConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromApiKeyConfig = getValueByPath(fromObject, [\n        \"apiKeyConfig\"\n    ]);\n    if (fromApiKeyConfig != null) {\n        setValueByPath(toObject, [\n            \"apiKeyConfig\"\n        ], apiKeyConfigToVertex(fromApiKeyConfig));\n    }\n    const fromAuthType = getValueByPath(fromObject, [\n        \"authType\"\n    ]);\n    if (fromAuthType != null) {\n        setValueByPath(toObject, [\n            \"authType\"\n        ], fromAuthType);\n    }\n    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [\n        \"googleServiceAccountConfig\"\n    ]);\n    if (fromGoogleServiceAccountConfig != null) {\n        setValueByPath(toObject, [\n            \"googleServiceAccountConfig\"\n        ], fromGoogleServiceAccountConfig);\n    }\n    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [\n        \"httpBasicAuthConfig\"\n    ]);\n    if (fromHttpBasicAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"httpBasicAuthConfig\"\n        ], fromHttpBasicAuthConfig);\n    }\n    const fromOauthConfig = getValueByPath(fromObject, [\n        \"oauthConfig\"\n    ]);\n    if (fromOauthConfig != null) {\n        setValueByPath(toObject, [\n            \"oauthConfig\"\n        ], fromOauthConfig);\n    }\n    const fromOidcConfig = getValueByPath(fromObject, [\n        \"oidcConfig\"\n    ]);\n    if (fromOidcConfig != null) {\n        setValueByPath(toObject, [\n            \"oidcConfig\"\n        ], fromOidcConfig);\n    }\n    return toObject;\n}\nfunction googleMapsToVertex(fromObject) {\n    const toObject = {};\n    const fromAuthConfig = getValueByPath(fromObject, [\n        \"authConfig\"\n    ]);\n    if (fromAuthConfig != null) {\n        setValueByPath(toObject, [\n            \"authConfig\"\n        ], authConfigToVertex(fromAuthConfig));\n    }\n    return toObject;\n}\nfunction urlContextToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolComputerUseToVertex(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    return toObject;\n}\nfunction toolToVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, [\n        \"retrieval\"\n    ]);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, [\n            \"retrieval\"\n        ], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToVertex(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToVertex(fromGoogleSearchRetrieval));\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, [\n            \"enterpriseWebSearch\"\n        ], enterpriseWebSearchToVertex(fromEnterpriseWebSearch));\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, [\n            \"googleMaps\"\n        ], googleMapsToVertex(fromGoogleMaps));\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToVertex());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], toolComputerUseToVertex(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        \"allowedFunctionNames\"\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, [\n            \"allowedFunctionNames\"\n        ], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction latLngToVertex(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, [\n        \"latitude\"\n    ]);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, [\n            \"latitude\"\n        ], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, [\n        \"longitude\"\n    ]);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, [\n            \"longitude\"\n        ], fromLongitude);\n    }\n    return toObject;\n}\nfunction retrievalConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, [\n        \"latLng\"\n    ]);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, [\n            \"latLng\"\n        ], latLngToVertex(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction toolConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        \"functionCallingConfig\"\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, [\n            \"functionCallingConfig\"\n        ], functionCallingConfigToVertex(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        \"retrievalConfig\"\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"retrievalConfig\"\n        ], retrievalConfigToVertex(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToVertex(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToVertex(fromVoiceConfig));\n    }\n    if (getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]) !== undefined) {\n        throw new Error(\"multiSpeakerVoiceConfig parameter is not supported in Vertex AI.\");\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        \"includeThoughts\"\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, [\n            \"includeThoughts\"\n        ], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        \"thinkingBudget\"\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, [\n            \"thinkingBudget\"\n        ], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction generateContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToVertex(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, [\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (fromTopP != null) {\n        setValueByPath(toObject, [\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (fromTopK != null) {\n        setValueByPath(toObject, [\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        \"candidateCount\"\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, [\n            \"candidateCount\"\n        ], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, [\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        \"stopSequences\"\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, [\n            \"stopSequences\"\n        ], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        \"responseLogprobs\"\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, [\n            \"responseLogprobs\"\n        ], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, [\n        \"logprobs\"\n    ]);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, [\n            \"logprobs\"\n        ], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        \"presencePenalty\"\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, [\n            \"presencePenalty\"\n        ], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        \"frequencyPenalty\"\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, [\n            \"frequencyPenalty\"\n        ], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (fromSeed != null) {\n        setValueByPath(toObject, [\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        \"responseMimeType\"\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, [\n            \"responseMimeType\"\n        ], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        \"responseSchema\"\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, [\n            \"responseSchema\"\n        ], schemaToVertex(tSchema(fromResponseSchema)));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        \"routingConfig\"\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, [\n            \"routingConfig\"\n        ], fromRoutingConfig);\n    }\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        \"modelSelectionConfig\"\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, [\n            \"modelConfig\"\n        ], modelSelectionConfigToVertex(fromModelSelectionConfig));\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        \"safetySettings\"\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return safetySettingToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"safetySettings\"\n        ], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, [\n        \"toolConfig\"\n    ]);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, [\n            \"toolConfig\"\n        ], toolConfigToVertex(fromToolConfig));\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        \"cachedContent\"\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, [\n            \"cachedContent\"\n        ], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, [\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, [\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, [\n            \"speechConfig\"\n        ], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        \"audioTimestamp\"\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, [\n            \"audioTimestamp\"\n        ], fromAudioTimestamp);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        \"thinkingConfig\"\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, [\n            \"thinkingConfig\"\n        ], thinkingConfigToVertex(fromThinkingConfig));\n    }\n    return toObject;\n}\nfunction generateContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"generationConfig\"\n        ], generateContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction embedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, [\n        \"taskType\"\n    ]);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"task_type\"\n        ], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, [\n        \"title\"\n    ]);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"title\"\n        ], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        \"outputDimensionality\"\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputDimensionality\"\n        ], fromOutputDimensionality);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, [\n            \"instances[]\",\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    const fromAutoTruncate = getValueByPath(fromObject, [\n        \"autoTruncate\"\n    ]);\n    if (parentObject !== undefined && fromAutoTruncate != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"autoTruncate\"\n        ], fromAutoTruncate);\n    }\n    return toObject;\n}\nfunction embedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        setValueByPath(toObject, [\n            \"instances[]\",\n            \"content\"\n        ], tContentsForEmbed(apiClient, fromContents));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], embedContentConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateImagesConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromImageSize = getValueByPath(fromObject, [\n        \"imageSize\"\n    ]);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleImageSize\"\n        ], fromImageSize);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], generateImagesConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction imageToVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"imageBytes\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction maskReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMaskMode = getValueByPath(fromObject, [\n        \"maskMode\"\n    ]);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, [\n            \"maskMode\"\n        ], fromMaskMode);\n    }\n    const fromSegmentationClasses = getValueByPath(fromObject, [\n        \"segmentationClasses\"\n    ]);\n    if (fromSegmentationClasses != null) {\n        setValueByPath(toObject, [\n            \"maskClasses\"\n        ], fromSegmentationClasses);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, [\n        \"maskDilation\"\n    ]);\n    if (fromMaskDilation != null) {\n        setValueByPath(toObject, [\n            \"dilation\"\n        ], fromMaskDilation);\n    }\n    return toObject;\n}\nfunction controlReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromControlType = getValueByPath(fromObject, [\n        \"controlType\"\n    ]);\n    if (fromControlType != null) {\n        setValueByPath(toObject, [\n            \"controlType\"\n        ], fromControlType);\n    }\n    const fromEnableControlImageComputation = getValueByPath(fromObject, [\n        \"enableControlImageComputation\"\n    ]);\n    if (fromEnableControlImageComputation != null) {\n        setValueByPath(toObject, [\n            \"computeControl\"\n        ], fromEnableControlImageComputation);\n    }\n    return toObject;\n}\nfunction styleReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromStyleDescription = getValueByPath(fromObject, [\n        \"styleDescription\"\n    ]);\n    if (fromStyleDescription != null) {\n        setValueByPath(toObject, [\n            \"styleDescription\"\n        ], fromStyleDescription);\n    }\n    return toObject;\n}\nfunction subjectReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromSubjectType = getValueByPath(fromObject, [\n        \"subjectType\"\n    ]);\n    if (fromSubjectType != null) {\n        setValueByPath(toObject, [\n            \"subjectType\"\n        ], fromSubjectType);\n    }\n    const fromSubjectDescription = getValueByPath(fromObject, [\n        \"subjectDescription\"\n    ]);\n    if (fromSubjectDescription != null) {\n        setValueByPath(toObject, [\n            \"subjectDescription\"\n        ], fromSubjectDescription);\n    }\n    return toObject;\n}\nfunction referenceImageAPIInternalToVertex(fromObject) {\n    const toObject = {};\n    const fromReferenceImage = getValueByPath(fromObject, [\n        \"referenceImage\"\n    ]);\n    if (fromReferenceImage != null) {\n        setValueByPath(toObject, [\n            \"referenceImage\"\n        ], imageToVertex(fromReferenceImage));\n    }\n    const fromReferenceId = getValueByPath(fromObject, [\n        \"referenceId\"\n    ]);\n    if (fromReferenceId != null) {\n        setValueByPath(toObject, [\n            \"referenceId\"\n        ], fromReferenceId);\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    const fromMaskImageConfig = getValueByPath(fromObject, [\n        \"maskImageConfig\"\n    ]);\n    if (fromMaskImageConfig != null) {\n        setValueByPath(toObject, [\n            \"maskImageConfig\"\n        ], maskReferenceConfigToVertex(fromMaskImageConfig));\n    }\n    const fromControlImageConfig = getValueByPath(fromObject, [\n        \"controlImageConfig\"\n    ]);\n    if (fromControlImageConfig != null) {\n        setValueByPath(toObject, [\n            \"controlImageConfig\"\n        ], controlReferenceConfigToVertex(fromControlImageConfig));\n    }\n    const fromStyleImageConfig = getValueByPath(fromObject, [\n        \"styleImageConfig\"\n    ]);\n    if (fromStyleImageConfig != null) {\n        setValueByPath(toObject, [\n            \"styleImageConfig\"\n        ], styleReferenceConfigToVertex(fromStyleImageConfig));\n    }\n    const fromSubjectImageConfig = getValueByPath(fromObject, [\n        \"subjectImageConfig\"\n    ]);\n    if (fromSubjectImageConfig != null) {\n        setValueByPath(toObject, [\n            \"subjectImageConfig\"\n        ], subjectReferenceConfigToVertex(fromSubjectImageConfig));\n    }\n    return toObject;\n}\nfunction editImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        \"guidanceScale\"\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"guidanceScale\"\n        ], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        \"includeSafetyAttributes\"\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeSafetyAttributes\"\n        ], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, [\n        \"language\"\n    ]);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"language\"\n        ], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, [\n        \"addWatermark\"\n    ]);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"addWatermark\"\n        ], fromAddWatermark);\n    }\n    const fromEditMode = getValueByPath(fromObject, [\n        \"editMode\"\n    ]);\n    if (parentObject !== undefined && fromEditMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editMode\"\n        ], fromEditMode);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, [\n        \"baseSteps\"\n    ]);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editConfig\",\n            \"baseSteps\"\n        ], fromBaseSteps);\n    }\n    return toObject;\n}\nfunction editImageParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return referenceImageAPIInternalToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], editImageConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        \"includeRaiReason\"\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"includeRaiReason\"\n        ], fromIncludeRaiReason);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromEnhanceInputImage = getValueByPath(fromObject, [\n        \"enhanceInputImage\"\n    ]);\n    if (parentObject !== undefined && fromEnhanceInputImage != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"enhanceInputImage\"\n        ], fromEnhanceInputImage);\n    }\n    const fromImagePreservationFactor = getValueByPath(fromObject, [\n        \"imagePreservationFactor\"\n    ]);\n    if (parentObject !== undefined && fromImagePreservationFactor != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"imagePreservationFactor\"\n        ], fromImagePreservationFactor);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"mode\"\n        ], fromMode);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromUpscaleFactor = getValueByPath(fromObject, [\n        \"upscaleFactor\"\n    ]);\n    if (fromUpscaleFactor != null) {\n        setValueByPath(toObject, [\n            \"parameters\",\n            \"upscaleConfig\",\n            \"upscaleFactor\"\n        ], fromUpscaleFactor);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], upscaleImageAPIConfigInternalToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction productImageToVertex(fromObject) {\n    const toObject = {};\n    const fromProductImage = getValueByPath(fromObject, [\n        \"productImage\"\n    ]);\n    if (fromProductImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromProductImage));\n    }\n    return toObject;\n}\nfunction recontextImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromPersonImage = getValueByPath(fromObject, [\n        \"personImage\"\n    ]);\n    if (parentObject !== undefined && fromPersonImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"personImage\",\n            \"image\"\n        ], imageToVertex(fromPersonImage));\n    }\n    const fromProductImages = getValueByPath(fromObject, [\n        \"productImages\"\n    ]);\n    if (parentObject !== undefined && fromProductImages != null) {\n        let transformedList = fromProductImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return productImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"productImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction recontextImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        \"numberOfImages\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfImages);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, [\n        \"baseSteps\"\n    ]);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"editConfig\",\n            \"baseSteps\"\n        ], fromBaseSteps);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        \"safetyFilterLevel\"\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"safetySetting\"\n        ], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        \"outputMimeType\"\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"mimeType\"\n        ], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        \"outputCompressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"outputOptions\",\n            \"compressionQuality\"\n        ], fromOutputCompressionQuality);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction recontextImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], recontextImageSourceToVertex(fromSource, toObject));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], recontextImageConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction scribbleImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    return toObject;\n}\nfunction segmentImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromScribbleImage = getValueByPath(fromObject, [\n        \"scribbleImage\"\n    ]);\n    if (parentObject !== undefined && fromScribbleImage != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"scribble\"\n        ], scribbleImageToVertex(fromScribbleImage));\n    }\n    return toObject;\n}\nfunction segmentImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"mode\"\n        ], fromMode);\n    }\n    const fromMaxPredictions = getValueByPath(fromObject, [\n        \"maxPredictions\"\n    ]);\n    if (parentObject !== undefined && fromMaxPredictions != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"maxPredictions\"\n        ], fromMaxPredictions);\n    }\n    const fromConfidenceThreshold = getValueByPath(fromObject, [\n        \"confidenceThreshold\"\n    ]);\n    if (parentObject !== undefined && fromConfidenceThreshold != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"confidenceThreshold\"\n        ], fromConfidenceThreshold);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, [\n        \"maskDilation\"\n    ]);\n    if (parentObject !== undefined && fromMaskDilation != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"maskDilation\"\n        ], fromMaskDilation);\n    }\n    const fromBinaryColorThreshold = getValueByPath(fromObject, [\n        \"binaryColorThreshold\"\n    ]);\n    if (parentObject !== undefined && fromBinaryColorThreshold != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"binaryColorThreshold\"\n        ], fromBinaryColorThreshold);\n    }\n    return toObject;\n}\nfunction segmentImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, [\n        \"source\"\n    ]);\n    if (fromSource != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], segmentImageSourceToVertex(fromSource, toObject));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], segmentImageConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction listModelsConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, [\n        \"queryBase\"\n    ]);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, [\n            \"_url\",\n            \"models_url\"\n        ], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listModelsConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction updateModelConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], updateModelConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction deleteModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"systemInstruction\"\n        ], contentToVertex(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"tools\"\n        ], transformedList);\n    }\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], countTokensConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction computeTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, [\n        \"contents\"\n    ]);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentToVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"contents\"\n        ], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction videoToVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"videoBytes\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"bytesBase64Encoded\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        \"referenceType\"\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, [\n            \"referenceType\"\n        ], fromReferenceType);\n    }\n    return toObject;\n}\nfunction generateVideosConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        \"numberOfVideos\"\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"sampleCount\"\n        ], fromNumberOfVideos);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, [\n        \"outputGcsUri\"\n    ]);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"storageUri\"\n        ], fromOutputGcsUri);\n    }\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (parentObject !== undefined && fromFps != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"fps\"\n        ], fromFps);\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        \"durationSeconds\"\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"durationSeconds\"\n        ], fromDurationSeconds);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, [\n        \"aspectRatio\"\n    ]);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"aspectRatio\"\n        ], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, [\n        \"resolution\"\n    ]);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"resolution\"\n        ], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        \"personGeneration\"\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"personGeneration\"\n        ], fromPersonGeneration);\n    }\n    const fromPubsubTopic = getValueByPath(fromObject, [\n        \"pubsubTopic\"\n    ]);\n    if (parentObject !== undefined && fromPubsubTopic != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"pubsubTopic\"\n        ], fromPubsubTopic);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        \"negativePrompt\"\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"negativePrompt\"\n        ], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        \"enhancePrompt\"\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"enhancePrompt\"\n        ], fromEnhancePrompt);\n    }\n    const fromGenerateAudio = getValueByPath(fromObject, [\n        \"generateAudio\"\n    ]);\n    if (parentObject !== undefined && fromGenerateAudio != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"generateAudio\"\n        ], fromGenerateAudio);\n    }\n    const fromLastFrame = getValueByPath(fromObject, [\n        \"lastFrame\"\n    ]);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"lastFrame\"\n        ], imageToVertex(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        \"referenceImages\"\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return videoGenerationReferenceImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, [\n            \"instances[0]\",\n            \"referenceImages\"\n        ], transformedList);\n    }\n    const fromCompressionQuality = getValueByPath(fromObject, [\n        \"compressionQuality\"\n    ]);\n    if (parentObject !== undefined && fromCompressionQuality != null) {\n        setValueByPath(parentObject, [\n            \"parameters\",\n            \"compressionQuality\"\n        ], fromCompressionQuality);\n    }\n    return toObject;\n}\nfunction generateVideosParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"prompt\"\n        ], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, [\n        \"image\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"image\"\n        ], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, [\n        \"video\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"instances[0]\",\n            \"video\"\n        ], videoToVertex(fromVideo));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], generateVideosConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction videoMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobFromMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromMldev(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromMldev(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromMldev(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentFromMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citationSources\"\n    ]);\n    if (fromCitations != null) {\n        setValueByPath(toObject, [\n            \"citations\"\n        ], fromCitations);\n    }\n    return toObject;\n}\nfunction urlMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, [\n        \"retrievedUrl\"\n    ]);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, [\n            \"retrievedUrl\"\n        ], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        \"urlRetrievalStatus\"\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, [\n            \"urlRetrievalStatus\"\n        ], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, [\n        \"urlMetadata\"\n    ]);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return urlMetadataFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"urlMetadata\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction candidateFromMldev(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], contentFromMldev(fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromMldev(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"tokenCount\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], urlContextMetadataFromMldev(fromUrlContextMetadata));\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromMldev(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, [\n        \"values\"\n    ]);\n    if (fromValues != null) {\n        setValueByPath(toObject, [\n            \"values\"\n        ], fromValues);\n    }\n    return toObject;\n}\nfunction embedContentMetadataFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction embedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentEmbeddingFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"embeddings\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], embedContentMetadataFromMldev());\n    }\n    return toObject;\n}\nfunction imageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromMldev(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction generatedImageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromMldev(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromMldev(fromSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction modelFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"version\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromMldev(fromTunedModelInfo));\n    }\n    const fromInputTokenLimit = getValueByPath(fromObject, [\n        \"inputTokenLimit\"\n    ]);\n    if (fromInputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"inputTokenLimit\"\n        ], fromInputTokenLimit);\n    }\n    const fromOutputTokenLimit = getValueByPath(fromObject, [\n        \"outputTokenLimit\"\n    ]);\n    if (fromOutputTokenLimit != null) {\n        setValueByPath(toObject, [\n            \"outputTokenLimit\"\n        ], fromOutputTokenLimit);\n    }\n    const fromSupportedActions = getValueByPath(fromObject, [\n        \"supportedGenerationMethods\"\n    ]);\n    if (fromSupportedActions != null) {\n        setValueByPath(toObject, [\n            \"supportedActions\"\n        ], fromSupportedActions);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modelFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"models\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction countTokensResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        \"cachedContentTokenCount\"\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, [\n            \"cachedContentTokenCount\"\n        ], fromCachedContentTokenCount);\n    }\n    return toObject;\n}\nfunction videoFromMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"video\",\n        \"uri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"video\",\n        \"encodedVideo\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"encoding\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"generatedSamples\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\",\n        \"generateVideoResponse\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction videoMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobFromVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataFromVertex(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobFromVertex(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataFromVertex(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentFromVertex(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction citationMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, [\n        \"citations\"\n    ]);\n    if (fromCitations != null) {\n        setValueByPath(toObject, [\n            \"citations\"\n        ], fromCitations);\n    }\n    return toObject;\n}\nfunction urlMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, [\n        \"retrievedUrl\"\n    ]);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, [\n            \"retrievedUrl\"\n        ], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        \"urlRetrievalStatus\"\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, [\n            \"urlRetrievalStatus\"\n        ], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, [\n        \"urlMetadata\"\n    ]);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return urlMetadataFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"urlMetadata\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction candidateFromVertex(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, [\n        \"content\"\n    ]);\n    if (fromContent != null) {\n        setValueByPath(toObject, [\n            \"content\"\n        ], contentFromVertex(fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        \"citationMetadata\"\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, [\n            \"citationMetadata\"\n        ], citationMetadataFromVertex(fromCitationMetadata));\n    }\n    const fromFinishMessage = getValueByPath(fromObject, [\n        \"finishMessage\"\n    ]);\n    if (fromFinishMessage != null) {\n        setValueByPath(toObject, [\n            \"finishMessage\"\n        ], fromFinishMessage);\n    }\n    const fromFinishReason = getValueByPath(fromObject, [\n        \"finishReason\"\n    ]);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, [\n            \"finishReason\"\n        ], fromFinishReason);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        \"urlContextMetadata\"\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, [\n            \"urlContextMetadata\"\n        ], urlContextMetadataFromVertex(fromUrlContextMetadata));\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, [\n        \"avgLogprobs\"\n    ]);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, [\n            \"avgLogprobs\"\n        ], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        \"groundingMetadata\"\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, [\n            \"groundingMetadata\"\n        ], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, [\n        \"index\"\n    ]);\n    if (fromIndex != null) {\n        setValueByPath(toObject, [\n            \"index\"\n        ], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        \"logprobsResult\"\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, [\n            \"logprobsResult\"\n        ], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        \"safetyRatings\"\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, [\n            \"safetyRatings\"\n        ], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, [\n        \"candidates\"\n    ]);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return candidateFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"candidates\"\n        ], transformedList);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromModelVersion = getValueByPath(fromObject, [\n        \"modelVersion\"\n    ]);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, [\n            \"modelVersion\"\n        ], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        \"promptFeedback\"\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, [\n            \"promptFeedback\"\n        ], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, [\n        \"responseId\"\n    ]);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, [\n            \"responseId\"\n        ], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        \"usageMetadata\"\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, [\n            \"usageMetadata\"\n        ], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction contentEmbeddingStatisticsFromVertex(fromObject) {\n    const toObject = {};\n    const fromTruncated = getValueByPath(fromObject, [\n        \"truncated\"\n    ]);\n    if (fromTruncated != null) {\n        setValueByPath(toObject, [\n            \"truncated\"\n        ], fromTruncated);\n    }\n    const fromTokenCount = getValueByPath(fromObject, [\n        \"token_count\"\n    ]);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, [\n            \"tokenCount\"\n        ], fromTokenCount);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromVertex(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, [\n        \"values\"\n    ]);\n    if (fromValues != null) {\n        setValueByPath(toObject, [\n            \"values\"\n        ], fromValues);\n    }\n    const fromStatistics = getValueByPath(fromObject, [\n        \"statistics\"\n    ]);\n    if (fromStatistics != null) {\n        setValueByPath(toObject, [\n            \"statistics\"\n        ], contentEmbeddingStatisticsFromVertex(fromStatistics));\n    }\n    return toObject;\n}\nfunction embedContentMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromBillableCharacterCount = getValueByPath(fromObject, [\n        \"billableCharacterCount\"\n    ]);\n    if (fromBillableCharacterCount != null) {\n        setValueByPath(toObject, [\n            \"billableCharacterCount\"\n        ], fromBillableCharacterCount);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        \"predictions[]\",\n        \"embeddings\"\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return contentEmbeddingFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"embeddings\"\n        ], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], embedContentMetadataFromVertex(fromMetadata));\n    }\n    return toObject;\n}\nfunction imageFromVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"gcsUri\"\n        ], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, [\n            \"imageBytes\"\n        ], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromVertex(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"categories\"\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, [\n            \"categories\"\n        ], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        \"safetyAttributes\",\n        \"scores\"\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, [\n            \"scores\"\n        ], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, [\n        \"contentType\"\n    ]);\n    if (fromContentType != null) {\n        setValueByPath(toObject, [\n            \"contentType\"\n        ], fromContentType);\n    }\n    return toObject;\n}\nfunction generatedImageFromVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromImage != null) {\n        setValueByPath(toObject, [\n            \"image\"\n        ], imageFromVertex(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        \"raiFilteredReason\"\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, [\n            \"raiFilteredReason\"\n        ], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"safetyAttributes\"\n        ], safetyAttributesFromVertex(fromSafetyAttributes));\n    }\n    const fromEnhancedPrompt = getValueByPath(fromObject, [\n        \"prompt\"\n    ]);\n    if (fromEnhancedPrompt != null) {\n        setValueByPath(toObject, [\n            \"enhancedPrompt\"\n        ], fromEnhancedPrompt);\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        \"positivePromptSafetyAttributes\"\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, [\n            \"positivePromptSafetyAttributes\"\n        ], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction editImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction upscaleImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction recontextImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedImages\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction entityLabelFromVertex(fromObject) {\n    const toObject = {};\n    const fromLabel = getValueByPath(fromObject, [\n        \"label\"\n    ]);\n    if (fromLabel != null) {\n        setValueByPath(toObject, [\n            \"label\"\n        ], fromLabel);\n    }\n    const fromScore = getValueByPath(fromObject, [\n        \"score\"\n    ]);\n    if (fromScore != null) {\n        setValueByPath(toObject, [\n            \"score\"\n        ], fromScore);\n    }\n    return toObject;\n}\nfunction generatedImageMaskFromVertex(fromObject) {\n    const toObject = {};\n    const fromMask = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromMask != null) {\n        setValueByPath(toObject, [\n            \"mask\"\n        ], imageFromVertex(fromMask));\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        let transformedList = fromLabels;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return entityLabelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"labels\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction segmentImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedMasks = getValueByPath(fromObject, [\n        \"predictions\"\n    ]);\n    if (fromGeneratedMasks != null) {\n        let transformedList = fromGeneratedMasks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedImageMaskFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedMasks\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction endpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDeployedModelId = getValueByPath(fromObject, [\n        \"deployedModelId\"\n    ]);\n    if (fromDeployedModelId != null) {\n        setValueByPath(toObject, [\n            \"deployedModelId\"\n        ], fromDeployedModelId);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"labels\",\n        \"google-vertex-llm-tuning-base-model-id\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction checkpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromCheckpointId = getValueByPath(fromObject, [\n        \"checkpointId\"\n    ]);\n    if (fromCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"checkpointId\"\n        ], fromCheckpointId);\n    }\n    const fromEpoch = getValueByPath(fromObject, [\n        \"epoch\"\n    ]);\n    if (fromEpoch != null) {\n        setValueByPath(toObject, [\n            \"epoch\"\n        ], fromEpoch);\n    }\n    const fromStep = getValueByPath(fromObject, [\n        \"step\"\n    ]);\n    if (fromStep != null) {\n        setValueByPath(toObject, [\n            \"step\"\n        ], fromStep);\n    }\n    return toObject;\n}\nfunction modelFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        \"displayName\"\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, [\n            \"displayName\"\n        ], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, [\n        \"versionId\"\n    ]);\n    if (fromVersion != null) {\n        setValueByPath(toObject, [\n            \"version\"\n        ], fromVersion);\n    }\n    const fromEndpoints = getValueByPath(fromObject, [\n        \"deployedModels\"\n    ]);\n    if (fromEndpoints != null) {\n        let transformedList = fromEndpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return endpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"endpoints\"\n        ], transformedList);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, [\n            \"tunedModelInfo\"\n        ], tunedModelInfoFromVertex(fromTunedModelInfo));\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        \"defaultCheckpointId\"\n    ]);\n    if (fromDefaultCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"defaultCheckpointId\"\n        ], fromDefaultCheckpointId);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, [\n        \"checkpoints\"\n    ]);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return checkpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"checkpoints\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return modelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"models\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction countTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, [\n        \"totalTokens\"\n    ]);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, [\n            \"totalTokens\"\n        ], fromTotalTokens);\n    }\n    return toObject;\n}\nfunction computeTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromTokensInfo = getValueByPath(fromObject, [\n        \"tokensInfo\"\n    ]);\n    if (fromTokensInfo != null) {\n        setValueByPath(toObject, [\n            \"tokensInfo\"\n        ], fromTokensInfo);\n    }\n    return toObject;\n}\nfunction videoFromVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromUri != null) {\n        setValueByPath(toObject, [\n            \"uri\"\n        ], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        \"bytesBase64Encoded\"\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, [\n            \"videoBytes\"\n        ], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromVideo != null) {\n        setValueByPath(toObject, [\n            \"video\"\n        ], videoFromVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        \"videos\"\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return generatedVideoFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"generatedVideos\"\n        ], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        \"raiMediaFilteredCount\"\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredCount\"\n        ], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        \"raiMediaFilteredReasons\"\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, [\n            \"raiMediaFilteredReasons\"\n        ], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], generateVideosResponseFromVertex(fromResponse));\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const CONTENT_TYPE_HEADER = \"Content-Type\";\nconst SERVER_TIMEOUT_HEADER = \"X-Server-Timeout\";\nconst USER_AGENT_HEADER = \"User-Agent\";\nconst GOOGLE_API_CLIENT_HEADER = \"x-goog-api-client\";\nconst SDK_VERSION = \"1.15.0\"; // x-release-please-version\nconst LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;\nconst VERTEX_AI_API_DEFAULT_VERSION = \"v1beta1\";\nconst GOOGLE_AI_API_DEFAULT_VERSION = \"v1beta\";\nconst responseLineRE = /^data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n/**\n * The ApiClient class is used to send requests to the Gemini API or Vertex AI\n * endpoints.\n */ class ApiClient {\n    constructor(opts){\n        var _a, _b;\n        this.clientOptions = Object.assign(Object.assign({}, opts), {\n            project: opts.project,\n            location: opts.location,\n            apiKey: opts.apiKey,\n            vertexai: opts.vertexai\n        });\n        const initHttpOptions = {};\n        if (this.clientOptions.vertexai) {\n            initHttpOptions.apiVersion = (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();\n            this.normalizeAuthParameters();\n        } else {\n            // Gemini API\n            initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;\n        }\n        initHttpOptions.headers = this.getDefaultHeaders();\n        this.clientOptions.httpOptions = initHttpOptions;\n        if (opts.httpOptions) {\n            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);\n        }\n    }\n    /**\n     * Determines the base URL for Vertex AI based on project and location.\n     * Uses the global endpoint if location is 'global' or if project/location\n     * are not specified (implying API key usage).\n     * @private\n     */ baseUrlFromProjectLocation() {\n        if (this.clientOptions.project && this.clientOptions.location && this.clientOptions.location !== \"global\") {\n            // Regional endpoint\n            return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;\n        }\n        // Global endpoint (covers 'global' location and API key usage)\n        return `https://aiplatform.googleapis.com/`;\n    }\n    /**\n     * Normalizes authentication parameters for Vertex AI.\n     * If project and location are provided, API key is cleared.\n     * If project and location are not provided (implying API key usage),\n     * project and location are cleared.\n     * @private\n     */ normalizeAuthParameters() {\n        if (this.clientOptions.project && this.clientOptions.location) {\n            // Using project/location for auth, clear potential API key\n            this.clientOptions.apiKey = undefined;\n            return;\n        }\n        // Using API key for auth (or no auth provided yet), clear project/location\n        this.clientOptions.project = undefined;\n        this.clientOptions.location = undefined;\n    }\n    isVertexAI() {\n        var _a;\n        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;\n    }\n    getProject() {\n        return this.clientOptions.project;\n    }\n    getLocation() {\n        return this.clientOptions.location;\n    }\n    getApiVersion() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== undefined) {\n            return this.clientOptions.httpOptions.apiVersion;\n        }\n        throw new Error(\"API version is not set.\");\n    }\n    getBaseUrl() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== undefined) {\n            return this.clientOptions.httpOptions.baseUrl;\n        }\n        throw new Error(\"Base URL is not set.\");\n    }\n    getRequestUrl() {\n        return this.getRequestUrlInternal(this.clientOptions.httpOptions);\n    }\n    getHeaders() {\n        if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== undefined) {\n            return this.clientOptions.httpOptions.headers;\n        } else {\n            throw new Error(\"Headers are not set.\");\n        }\n    }\n    getRequestUrlInternal(httpOptions) {\n        if (!httpOptions || httpOptions.baseUrl === undefined || httpOptions.apiVersion === undefined) {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n        const baseUrl = httpOptions.baseUrl.endsWith(\"/\") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;\n        const urlElement = [\n            baseUrl\n        ];\n        if (httpOptions.apiVersion && httpOptions.apiVersion !== \"\") {\n            urlElement.push(httpOptions.apiVersion);\n        }\n        return urlElement.join(\"/\");\n    }\n    getBaseResourcePath() {\n        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;\n    }\n    getApiKey() {\n        return this.clientOptions.apiKey;\n    }\n    getWebsocketBaseUrl() {\n        const baseUrl = this.getBaseUrl();\n        const urlParts = new URL(baseUrl);\n        urlParts.protocol = urlParts.protocol == \"http:\" ? \"ws\" : \"wss\";\n        return urlParts.toString();\n    }\n    setBaseUrl(url) {\n        if (this.clientOptions.httpOptions) {\n            this.clientOptions.httpOptions.baseUrl = url;\n        } else {\n            throw new Error(\"HTTP options are not correctly set.\");\n        }\n    }\n    constructUrl(path, httpOptions, prependProjectLocation) {\n        const urlElement = [\n            this.getRequestUrlInternal(httpOptions)\n        ];\n        if (prependProjectLocation) {\n            urlElement.push(this.getBaseResourcePath());\n        }\n        if (path !== \"\") {\n            urlElement.push(path);\n        }\n        const url = new URL(`${urlElement.join(\"/\")}`);\n        return url;\n    }\n    shouldPrependVertexProjectPath(request) {\n        if (this.clientOptions.apiKey) {\n            return false;\n        }\n        if (!this.clientOptions.vertexai) {\n            return false;\n        }\n        if (request.path.startsWith(\"projects/\")) {\n            // Assume the path already starts with\n            // `projects/<project>/location/<location>`.\n            return false;\n        }\n        if (request.httpMethod === \"GET\" && request.path.startsWith(\"publishers/google/models\")) {\n            // These paths are used by Vertex's models.get and models.list\n            // calls. For base models Vertex does not accept a project/location\n            // prefix (for tuned model the prefix is required).\n            return false;\n        }\n        return true;\n    }\n    async request(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (request.queryParams) {\n            for (const [key, value] of Object.entries(request.queryParams)){\n                url.searchParams.append(key, String(value));\n            }\n        }\n        let requestInit = {};\n        if (request.httpMethod === \"GET\") {\n            if (request.body && request.body !== \"{}\") {\n                throw new Error(\"Request body should be empty for GET request, but got non empty request body\");\n            }\n        } else {\n            requestInit.body = request.body;\n        }\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);\n        return this.unaryApiCall(url, requestInit, request.httpMethod);\n    }\n    patchHttpOptions(baseHttpOptions, requestHttpOptions) {\n        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));\n        for (const [key, value] of Object.entries(requestHttpOptions)){\n            // Records compile to objects.\n            if (typeof value === \"object\") {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);\n            } else if (value !== undefined) {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = value;\n            }\n        }\n        return patchedHttpOptions;\n    }\n    async requestStream(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (!url.searchParams.has(\"alt\") || url.searchParams.get(\"alt\") !== \"sse\") {\n            url.searchParams.set(\"alt\", \"sse\");\n        }\n        let requestInit = {};\n        requestInit.body = request.body;\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);\n        return this.streamApiCall(url, requestInit, request.httpMethod);\n    }\n    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, abortSignal) {\n        if (httpOptions && httpOptions.timeout || abortSignal) {\n            const abortController = new AbortController();\n            const signal = abortController.signal;\n            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {\n                const timeoutHandle = setTimeout(()=>abortController.abort(), httpOptions.timeout);\n                if (timeoutHandle && typeof timeoutHandle.unref === \"function\") {\n                    // call unref to prevent nodejs process from hanging, see\n                    // https://nodejs.org/api/timers.html#timeoutunref\n                    timeoutHandle.unref();\n                }\n            }\n            if (abortSignal) {\n                abortSignal.addEventListener(\"abort\", ()=>{\n                    abortController.abort();\n                });\n            }\n            requestInit.signal = signal;\n        }\n        if (httpOptions && httpOptions.extraBody !== null) {\n            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);\n        }\n        requestInit.headers = await this.getHeadersInternal(httpOptions);\n        return requestInit;\n    }\n    async unaryApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return new HttpResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    async streamApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), {\n            method: httpMethod\n        })).then(async (response)=>{\n            await throwErrorIfNotOK(response);\n            return this.processStreamResponse(response);\n        }).catch((e)=>{\n            if (e instanceof Error) {\n                throw e;\n            } else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    processStreamResponse(response) {\n        var _a;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const decoder = new TextDecoder(\"utf-8\");\n            if (!reader) {\n                throw new Error(\"Response body is empty\");\n            }\n            try {\n                let buffer = \"\";\n                while(true){\n                    const { done, value } = yield __await(reader.read());\n                    if (done) {\n                        if (buffer.trim().length > 0) {\n                            throw new Error(\"Incomplete JSON segment at the end\");\n                        }\n                        break;\n                    }\n                    const chunkString = decoder.decode(value, {\n                        stream: true\n                    });\n                    // Parse and throw an error if the chunk contains an error.\n                    try {\n                        const chunkJson = JSON.parse(chunkString);\n                        if (\"error\" in chunkJson) {\n                            const errorJson = JSON.parse(JSON.stringify(chunkJson[\"error\"]));\n                            const status = errorJson[\"status\"];\n                            const code = errorJson[\"code\"];\n                            const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;\n                            if (code >= 400 && code < 600) {\n                                const apiError = new ApiError({\n                                    message: errorMessage,\n                                    status: code\n                                });\n                                throw apiError;\n                            }\n                        }\n                    } catch (e) {\n                        const error = e;\n                        if (error.name === \"ApiError\") {\n                            throw e;\n                        }\n                    }\n                    buffer += chunkString;\n                    let match = buffer.match(responseLineRE);\n                    while(match){\n                        const processedChunkString = match[1];\n                        try {\n                            const partialResponse = new Response(processedChunkString, {\n                                headers: response === null || response === void 0 ? void 0 : response.headers,\n                                status: response === null || response === void 0 ? void 0 : response.status,\n                                statusText: response === null || response === void 0 ? void 0 : response.statusText\n                            });\n                            yield yield __await(new HttpResponse(partialResponse));\n                            buffer = buffer.slice(match[0].length);\n                            match = buffer.match(responseLineRE);\n                        } catch (e) {\n                            throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);\n                        }\n                    }\n                }\n            } finally{\n                reader.releaseLock();\n            }\n        });\n    }\n    async apiCall(url, requestInit) {\n        return fetch(url, requestInit).catch((e)=>{\n            throw new Error(`exception ${e} sending request`);\n        });\n    }\n    getDefaultHeaders() {\n        const headers = {};\n        const versionHeaderValue = LIBRARY_LABEL + \" \" + this.clientOptions.userAgentExtra;\n        headers[USER_AGENT_HEADER] = versionHeaderValue;\n        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;\n        headers[CONTENT_TYPE_HEADER] = \"application/json\";\n        return headers;\n    }\n    async getHeadersInternal(httpOptions) {\n        const headers = new Headers();\n        if (httpOptions && httpOptions.headers) {\n            for (const [key, value] of Object.entries(httpOptions.headers)){\n                headers.append(key, value);\n            }\n            // Append a timeout header if it is set, note that the timeout option is\n            // in milliseconds but the header is in seconds.\n            if (httpOptions.timeout && httpOptions.timeout > 0) {\n                headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1000)));\n            }\n        }\n        await this.clientOptions.auth.addAuthHeaders(headers);\n        return headers;\n    }\n    /**\n     * Uploads a file asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */ async uploadFile(file, config) {\n        var _a;\n        const fileToUpload = {};\n        if (config != null) {\n            fileToUpload.mimeType = config.mimeType;\n            fileToUpload.name = config.name;\n            fileToUpload.displayName = config.displayName;\n        }\n        if (fileToUpload.name && !fileToUpload.name.startsWith(\"files/\")) {\n            fileToUpload.name = `files/${fileToUpload.name}`;\n        }\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        fileToUpload.sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === \"\") {\n            throw new Error(\"Can not determine mimeType. Please provide mimeType in the config.\");\n        }\n        fileToUpload.mimeType = mimeType;\n        const uploadUrl = await this.fetchUploadUrl(fileToUpload, config);\n        return uploader.upload(file, uploadUrl, this);\n    }\n    /**\n     * Downloads a file asynchronously to the specified path.\n     *\n     * @params params - The parameters for the download request, see {@link\n     * DownloadFileParameters}\n     */ async downloadFile(params) {\n        const downloader = this.clientOptions.downloader;\n        await downloader.download(params, this);\n    }\n    async fetchUploadUrl(file, config) {\n        var _a;\n        let httpOptions = {};\n        if (config === null || config === void 0 ? void 0 : config.httpOptions) {\n            httpOptions = config.httpOptions;\n        } else {\n            httpOptions = {\n                apiVersion: \"\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    \"X-Goog-Upload-Protocol\": \"resumable\",\n                    \"X-Goog-Upload-Command\": \"start\",\n                    \"X-Goog-Upload-Header-Content-Length\": `${file.sizeBytes}`,\n                    \"X-Goog-Upload-Header-Content-Type\": `${file.mimeType}`\n                }\n            };\n        }\n        const body = {\n            \"file\": file\n        };\n        const httpResponse = await this.request({\n            path: formatMap(\"upload/v1beta/files\", body[\"_url\"]),\n            body: JSON.stringify(body),\n            httpMethod: \"POST\",\n            httpOptions\n        });\n        if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {\n            throw new Error(\"Server did not return an HttpResponse or the returned HttpResponse did not have headers.\");\n        }\n        const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a[\"x-goog-upload-url\"];\n        if (uploadUrl === undefined) {\n            throw new Error(\"Failed to get upload url. Server did not return the x-google-upload-url in the headers\");\n        }\n        return uploadUrl;\n    }\n}\nasync function throwErrorIfNotOK(response) {\n    var _a;\n    if (response === undefined) {\n        throw new Error(\"response is undefined\");\n    }\n    if (!response.ok) {\n        const status = response.status;\n        let errorBody;\n        if ((_a = response.headers.get(\"content-type\")) === null || _a === void 0 ? void 0 : _a.includes(\"application/json\")) {\n            errorBody = await response.json();\n        } else {\n            errorBody = {\n                error: {\n                    message: await response.text(),\n                    code: response.status,\n                    status: response.statusText\n                }\n            };\n        }\n        const errorMessage = JSON.stringify(errorBody);\n        if (status >= 400 && status < 600) {\n            const apiError = new ApiError({\n                message: errorMessage,\n                status: status\n            });\n            throw apiError;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * Recursively updates the `requestInit.body` with values from an `extraBody` object.\n *\n * If `requestInit.body` is a string, it's assumed to be JSON and will be parsed.\n * The `extraBody` is then deeply merged into this parsed object.\n * If `requestInit.body` is a Blob, `extraBody` will be ignored, and a warning logged,\n * as merging structured data into an opaque Blob is not supported.\n *\n * The function does not enforce that updated values from `extraBody` have the\n * same type as existing values in `requestInit.body`. Type mismatches during\n * the merge will result in a warning, but the value from `extraBody` will overwrite\n * the original. `extraBody` users are responsible for ensuring `extraBody` has the correct structure.\n *\n * @param requestInit The RequestInit object whose body will be updated.\n * @param extraBody The object containing updates to be merged into `requestInit.body`.\n */ function includeExtraBodyToRequestInit(requestInit, extraBody) {\n    if (!extraBody || Object.keys(extraBody).length === 0) {\n        return;\n    }\n    if (requestInit.body instanceof Blob) {\n        console.warn(\"includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.\");\n        return;\n    }\n    let currentBodyObject = {};\n    // If adding new type to HttpRequest.body, please check the code below to\n    // see if we need to update the logic.\n    if (typeof requestInit.body === \"string\" && requestInit.body.length > 0) {\n        try {\n            const parsedBody = JSON.parse(requestInit.body);\n            if (typeof parsedBody === \"object\" && parsedBody !== null && !Array.isArray(parsedBody)) {\n                currentBodyObject = parsedBody;\n            } else {\n                console.warn(\"includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.\");\n                return;\n            }\n        /*  eslint-disable-next-line @typescript-eslint/no-unused-vars */ } catch (e) {\n            console.warn(\"includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.\");\n            return;\n        }\n    }\n    function deepMerge(target, source) {\n        const output = Object.assign({}, target);\n        for(const key in source){\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                const sourceValue = source[key];\n                const targetValue = output[key];\n                if (sourceValue && typeof sourceValue === \"object\" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === \"object\" && !Array.isArray(targetValue)) {\n                    output[key] = deepMerge(targetValue, sourceValue);\n                } else {\n                    if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {\n                        console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key \"${key}\". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);\n                    }\n                    output[key] = sourceValue;\n                }\n            }\n        }\n        return output;\n    }\n    const mergedBody = deepMerge(currentBodyObject, extraBody);\n    requestInit.body = JSON.stringify(mergedBody);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // TODO: b/416041229 - Determine how to retrieve the MCP package version.\nconst MCP_LABEL = \"mcp_used/unknown\";\n// Whether MCP tool usage is detected from mcpToTool. This is used for\n// telemetry.\nlet hasMcpToolUsageFromMcpToTool = false;\n// Checks whether the list of tools contains any MCP tools.\nfunction hasMcpToolUsage(tools) {\n    for (const tool of tools){\n        if (isMcpCallableTool(tool)) {\n            return true;\n        }\n        if (typeof tool === \"object\" && \"inputSchema\" in tool) {\n            return true;\n        }\n    }\n    return hasMcpToolUsageFromMcpToTool;\n}\n// Sets the MCP version label in the Google API client header.\nfunction setMcpUsageHeader(headers) {\n    var _a;\n    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : \"\";\n    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();\n}\n// Returns true if the object is a MCP CallableTool, otherwise false.\nfunction isMcpCallableTool(object) {\n    return object !== null && typeof object === \"object\" && object instanceof McpCallableTool;\n}\n// List all tools from the MCP client.\nfunction listAllTools(mcpClient, maxTools = 100) {\n    return __asyncGenerator(this, arguments, function* listAllTools_1() {\n        let cursor = undefined;\n        let numTools = 0;\n        while(numTools < maxTools){\n            const t = yield __await(mcpClient.listTools({\n                cursor\n            }));\n            for (const tool of t.tools){\n                yield yield __await(tool);\n                numTools++;\n            }\n            if (!t.nextCursor) {\n                break;\n            }\n            cursor = t.nextCursor;\n        }\n    });\n}\n/**\n * McpCallableTool can be used for model inference and invoking MCP clients with\n * given function call arguments.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */ class McpCallableTool {\n    constructor(mcpClients = [], config){\n        this.mcpTools = [];\n        this.functionNameToMcpClient = {};\n        this.mcpClients = mcpClients;\n        this.config = config;\n    }\n    /**\n     * Creates a McpCallableTool.\n     */ static create(mcpClients, config) {\n        return new McpCallableTool(mcpClients, config);\n    }\n    /**\n     * Validates the function names are not duplicate and initialize the function\n     * name to MCP client mapping.\n     *\n     * @throws {Error} if the MCP tools from the MCP clients have duplicate tool\n     *     names.\n     */ async initialize() {\n        var _a, e_1, _b, _c;\n        if (this.mcpTools.length > 0) {\n            return;\n        }\n        const functionMap = {};\n        const mcpTools = [];\n        for (const mcpClient of this.mcpClients){\n            try {\n                for(var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const mcpTool = _c;\n                    mcpTools.push(mcpTool);\n                    const mcpToolName = mcpTool.name;\n                    if (functionMap[mcpToolName]) {\n                        throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n                    }\n                    functionMap[mcpToolName] = mcpClient;\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        }\n        this.mcpTools = mcpTools;\n        this.functionNameToMcpClient = functionMap;\n    }\n    async tool() {\n        await this.initialize();\n        return mcpToolsToGeminiTool(this.mcpTools, this.config);\n    }\n    async callTool(functionCalls) {\n        await this.initialize();\n        const functionCallResponseParts = [];\n        for (const functionCall of functionCalls){\n            if (functionCall.name in this.functionNameToMcpClient) {\n                const mcpClient = this.functionNameToMcpClient[functionCall.name];\n                let requestOptions = undefined;\n                // TODO: b/424238654 - Add support for finer grained timeout control.\n                if (this.config.timeout) {\n                    requestOptions = {\n                        timeout: this.config.timeout\n                    };\n                }\n                const callToolResponse = await mcpClient.callTool({\n                    name: functionCall.name,\n                    arguments: functionCall.args\n                }, // Set the result schema to undefined to allow MCP to rely on the\n                // default schema.\n                undefined, requestOptions);\n                functionCallResponseParts.push({\n                    functionResponse: {\n                        name: functionCall.name,\n                        response: callToolResponse.isError ? {\n                            error: callToolResponse\n                        } : callToolResponse\n                    }\n                });\n            }\n        }\n        return functionCallResponseParts;\n    }\n}\nfunction isMcpClient(client) {\n    return client !== null && typeof client === \"object\" && \"listTools\" in client && typeof client.listTools === \"function\";\n}\n/**\n * Creates a McpCallableTool from MCP clients and an optional config.\n *\n * The callable tool can invoke the MCP clients with given function call\n * arguments. (often for automatic function calling).\n * Use the config to modify tool parameters such as behavior.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */ function mcpToTool(...args) {\n    // Set MCP usage for telemetry.\n    hasMcpToolUsageFromMcpToTool = true;\n    if (args.length === 0) {\n        throw new Error(\"No MCP clients provided\");\n    }\n    const maybeConfig = args[args.length - 1];\n    if (isMcpClient(maybeConfig)) {\n        return McpCallableTool.create(args, {});\n    }\n    return McpCallableTool.create(args.slice(0, args.length - 1), maybeConfig);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveMusicServerMessage, and then calling the onmessage callback.\n * Note that the first message which is received from the server is a\n * setupComplete message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage$1(apiClient, onmessage, event) {\n    const serverMessage = new LiveMusicServerMessage();\n    let data;\n    if (event.data instanceof Blob) {\n        data = JSON.parse(await event.data.text());\n    } else {\n        data = JSON.parse(event.data);\n    }\n    const response = liveMusicServerMessageFromMldev(data);\n    Object.assign(serverMessage, response);\n    onmessage(serverMessage);\n}\n/**\n   LiveMusic class encapsulates the configuration for live music\n   generation via Lyria Live models.\n\n   @experimental\n  */ class LiveMusic {\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n    }\n    /**\n       Establishes a connection to the specified model and returns a\n       LiveMusicSession object representing that connection.\n  \n       @experimental\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model = 'models/lyria-realtime-exp';\n       const session = await ai.live.music.connect({\n         model: model,\n         callbacks: {\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b;\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"Live music is not supported for Vertex AI.\");\n        }\n        console.warn(\"Live music generation is experimental and may change in future versions.\");\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());\n        const apiKey = this.apiClient.getApiKey();\n        const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        const model = tModel(this.apiClient, params.model);\n        const setup = liveMusicClientSetupToMldev({\n            model\n        });\n        const clientMessage = liveMusicClientMessageToMldev({\n            setup\n        });\n        conn.send(JSON.stringify(clientMessage));\n        return new LiveMusicSession(conn, this.apiClient);\n    }\n}\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class LiveMusicSession {\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    /**\n      Sets inputs to steer music generation. Updates the session's current\n      weighted prompts.\n  \n      @param params - Contains one property, `weightedPrompts`.\n  \n        - `weightedPrompts` to send to the model; weights are normalized to\n          sum to 1.0.\n  \n      @experimental\n     */ async setWeightedPrompts(params) {\n        if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {\n            throw new Error(\"Weighted prompts must be set and contain at least one entry.\");\n        }\n        const setWeightedPromptsParameters = liveMusicSetWeightedPromptsParametersToMldev(params);\n        const clientContent = liveMusicClientContentToMldev(setWeightedPromptsParameters);\n        this.conn.send(JSON.stringify({\n            clientContent\n        }));\n    }\n    /**\n      Sets a configuration to the model. Updates the session's current\n      music generation config.\n  \n      @param params - Contains one property, `musicGenerationConfig`.\n  \n        - `musicGenerationConfig` to set in the model. Passing an empty or\n      undefined config to the model will reset the config to defaults.\n  \n      @experimental\n     */ async setMusicGenerationConfig(params) {\n        if (!params.musicGenerationConfig) {\n            params.musicGenerationConfig = {};\n        }\n        const setConfigParameters = liveMusicSetConfigParametersToMldev(params);\n        const clientMessage = liveMusicClientMessageToMldev(setConfigParameters);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    sendPlaybackControl(playbackControl) {\n        const clientMessage = liveMusicClientMessageToMldev({\n            playbackControl\n        });\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n     * Start the music stream.\n     *\n     * @experimental\n     */ play() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);\n    }\n    /**\n     * Temporarily halt the music stream. Use `play` to resume from the current\n     * position.\n     *\n     * @experimental\n     */ pause() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);\n    }\n    /**\n     * Stop the music stream and reset the state. Retains the current prompts\n     * and config.\n     *\n     * @experimental\n     */ stop() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);\n    }\n    /**\n     * Resets the context of the music generation without stopping it.\n     * Retains the current prompts and config.\n     *\n     * @experimental\n     */ resetContext() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n     */ close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap$1(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders$1(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const FUNCTION_RESPONSE_REQUIRES_ID = \"FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.\";\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveServerMessages, and then calling the onmessage callback. Note that\n * the first message which is received from the server is a setupComplete\n * message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */ async function handleWebSocketMessage(apiClient, onmessage, event) {\n    const serverMessage = new LiveServerMessage();\n    let jsonData;\n    if (event.data instanceof Blob) {\n        jsonData = await event.data.text();\n    } else if (event.data instanceof ArrayBuffer) {\n        jsonData = new TextDecoder().decode(event.data);\n    } else {\n        jsonData = event.data;\n    }\n    const data = JSON.parse(jsonData);\n    if (apiClient.isVertexAI()) {\n        const resp = liveServerMessageFromVertex(data);\n        Object.assign(serverMessage, resp);\n    } else {\n        const resp = liveServerMessageFromMldev(data);\n        Object.assign(serverMessage, resp);\n    }\n    onmessage(serverMessage);\n}\n/**\n   Live class encapsulates the configuration for live interaction with the\n   Generative Language API. It embeds ApiClient for general API settings.\n\n   @experimental\n  */ class Live {\n    constructor(apiClient, auth, webSocketFactory){\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);\n    }\n    /**\n       Establishes a connection to the specified model with the given\n       configuration and returns a Session object representing that connection.\n  \n       @experimental Built-in MCP support is an experimental feature, may change in\n       future versions.\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         },\n         callbacks: {\n           onopen: () => {\n             console.log('Connected to the socket.');\n           },\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */ async connect(params) {\n        var _a, _b, _c, _d, _e, _f;\n        // TODO: b/404946746 - Support per request HTTP options.\n        if (params.config && params.config.httpOptions) {\n            throw new Error(\"The Live module does not support httpOptions at request-level in\" + \" LiveConnectConfig yet. Please use the client-level httpOptions\" + \" configuration instead.\");\n        }\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        let url;\n        const clientHeaders = this.apiClient.getHeaders();\n        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {\n            setMcpUsageHeader(clientHeaders);\n        }\n        const headers = mapToHeaders(clientHeaders);\n        if (this.apiClient.isVertexAI()) {\n            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;\n            await this.auth.addAuthHeaders(headers);\n        } else {\n            const apiKey = this.apiClient.getApiKey();\n            let method = \"BidiGenerateContent\";\n            let keyName = \"key\";\n            if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith(\"auth_tokens/\")) {\n                console.warn(\"Warning: Ephemeral token support is experimental and may change in future versions.\");\n                if (apiVersion !== \"v1alpha\") {\n                    console.warn(\"Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.\");\n                }\n                method = \"BidiGenerateContentConstrained\";\n                keyName = \"access_token\";\n            }\n            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;\n        }\n        let onopenResolve = ()=>{};\n        const onopenPromise = new Promise((resolve)=>{\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function() {\n            var _a;\n            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event)=>{\n                void handleWebSocketMessage(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function(e) {},\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e) {}\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        let transformedModel = tModel(this.apiClient, params.model);\n        if (this.apiClient.isVertexAI() && transformedModel.startsWith(\"publishers/\")) {\n            const project = this.apiClient.getProject();\n            const location = this.apiClient.getLocation();\n            transformedModel = `projects/${project}/locations/${location}/` + transformedModel;\n        }\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === undefined) {\n            // Set default to AUDIO to align with MLDev API.\n            if (params.config === undefined) {\n                params.config = {\n                    responseModalities: [\n                        Modality.AUDIO\n                    ]\n                };\n            } else {\n                params.config.responseModalities = [\n                    Modality.AUDIO\n                ];\n            }\n        }\n        if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {\n            // Raise deprecation warning for generationConfig.\n            console.warn(\"Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).\");\n        }\n        const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];\n        const convertedTools = [];\n        for (const tool of inputTools){\n            if (this.isCallableTool(tool)) {\n                const callableTool = tool;\n                convertedTools.push(await callableTool.tool());\n            } else {\n                convertedTools.push(tool);\n            }\n        }\n        if (convertedTools.length > 0) {\n            params.config.tools = convertedTools;\n        }\n        const liveConnectParameters = {\n            model: transformedModel,\n            config: params.config,\n            callbacks: params.callbacks\n        };\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);\n        } else {\n            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);\n        }\n        delete clientMessage[\"config\"];\n        conn.send(JSON.stringify(clientMessage));\n        return new Session(conn, this.apiClient);\n    }\n    // TODO: b/416041229 - Abstract this method to a common place.\n    isCallableTool(tool) {\n        return \"callTool\" in tool && typeof tool.callTool === \"function\";\n    }\n}\nconst defaultLiveSendClientContentParamerters = {\n    turnComplete: true\n};\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */ class Session {\n    constructor(conn, apiClient){\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    tLiveClientContent(apiClient, params) {\n        if (params.turns !== null && params.turns !== undefined) {\n            let contents = [];\n            try {\n                contents = tContents(params.turns);\n                if (apiClient.isVertexAI()) {\n                    contents = contents.map((item)=>contentToVertex(item));\n                } else {\n                    contents = contents.map((item)=>contentToMldev$1(item));\n                }\n            } catch (_a) {\n                throw new Error(`Failed to parse client content \"turns\", type: '${typeof params.turns}'`);\n            }\n            return {\n                clientContent: {\n                    turns: contents,\n                    turnComplete: params.turnComplete\n                }\n            };\n        }\n        return {\n            clientContent: {\n                turnComplete: params.turnComplete\n            }\n        };\n    }\n    tLiveClienttToolResponse(apiClient, params) {\n        let functionResponses = [];\n        if (params.functionResponses == null) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        if (!Array.isArray(params.functionResponses)) {\n            functionResponses = [\n                params.functionResponses\n            ];\n        } else {\n            functionResponses = params.functionResponses;\n        }\n        if (functionResponses.length === 0) {\n            throw new Error(\"functionResponses is required.\");\n        }\n        for (const functionResponse of functionResponses){\n            if (typeof functionResponse !== \"object\" || functionResponse === null || !(\"name\" in functionResponse) || !(\"response\" in functionResponse)) {\n                throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);\n            }\n            if (!apiClient.isVertexAI() && !(\"id\" in functionResponse)) {\n                throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);\n            }\n        }\n        const clientMessage = {\n            toolResponse: {\n                functionResponses: functionResponses\n            }\n        };\n        return clientMessage;\n    }\n    /**\n      Send a message over the established connection.\n  \n      @param params - Contains two **optional** properties, `turns` and\n          `turnComplete`.\n  \n        - `turns` will be converted to a `Content[]`\n        - `turnComplete: true` [default] indicates that you are done sending\n          content and expect a response. If `turnComplete: false`, the server\n          will wait for additional messages before starting generation.\n  \n      @experimental\n  \n      @remarks\n      There are two ways to send messages to the live API:\n      `sendClientContent` and `sendRealtimeInput`.\n  \n      `sendClientContent` messages are added to the model context **in order**.\n      Having a conversation using `sendClientContent` messages is roughly\n      equivalent to using the `Chat.sendMessageStream`, except that the state of\n      the `chat` history is stored on the API server instead of locally.\n  \n      Because of `sendClientContent`'s order guarantee, the model cannot respons\n      as quickly to `sendClientContent` messages as to `sendRealtimeInput`\n      messages. This makes the biggest difference when sending objects that have\n      significant preprocessing time (typically images).\n  \n      The `sendClientContent` message sends a `Content[]`\n      which has more options than the `Blob` sent by `sendRealtimeInput`.\n  \n      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:\n  \n      - Sending anything that can't be represented as a `Blob` (text,\n      `sendClientContent({turns=\"Hello?\"}`)).\n      - Managing turns when not using audio input and voice activity detection.\n        (`sendClientContent({turnComplete:true})` or the short form\n      `sendClientContent()`)\n      - Prefilling a conversation context\n        ```\n        sendClientContent({\n            turns: [\n              Content({role:user, parts:...}),\n              Content({role:user, parts:...}),\n              ...\n            ]\n        })\n        ```\n      @experimental\n     */ sendClientContent(params) {\n        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);\n        const clientMessage = this.tLiveClientContent(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a realtime message over the established connection.\n  \n      @param params - Contains one property, `media`.\n  \n        - `media` will be converted to a `Blob`\n  \n      @experimental\n  \n      @remarks\n      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).\n  \n      With `sendRealtimeInput` the api will respond to audio automatically\n      based on voice activity detection (VAD).\n  \n      `sendRealtimeInput` is optimized for responsivness at the expense of\n      deterministic ordering guarantees. Audio and video tokens are to the\n      context when they become available.\n  \n      Note: The Call signature expects a `Blob` object, but only a subset\n      of audio and image mimetypes are allowed.\n     */ sendRealtimeInput(params) {\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToVertex(params)\n            };\n        } else {\n            clientMessage = {\n                \"realtimeInput\": liveSendRealtimeInputParametersToMldev(params)\n            };\n        }\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a function response message over the established connection.\n  \n      @param params - Contains property `functionResponses`.\n  \n        - `functionResponses` will be converted to a `functionResponses[]`\n  \n      @remarks\n      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.\n  \n      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.\n  \n      @experimental\n     */ sendToolResponse(params) {\n        if (params.functionResponses == null) {\n            throw new Error(\"Tool response parameters are required.\");\n        }\n        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         }\n       });\n  \n       session.close();\n       ```\n     */ close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap(headers) {\n    const headerMap = {};\n    headers.forEach((value, key)=>{\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)){\n        headers.append(key, value);\n    }\n    return headers;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const DEFAULT_MAX_REMOTE_CALLS = 10;\n/** Returns whether automatic function calling is disabled. */ function shouldDisableAfc(config) {\n    var _a, _b, _c;\n    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {\n        return true;\n    }\n    let callableToolsPresent = false;\n    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []){\n        if (isCallableTool(tool)) {\n            callableToolsPresent = true;\n            break;\n        }\n    }\n    if (!callableToolsPresent) {\n        return true;\n    }\n    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;\n    if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {\n        console.warn(\"Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:\", maxCalls);\n        return true;\n    }\n    return false;\n}\nfunction isCallableTool(tool) {\n    return \"callTool\" in tool && typeof tool.callTool === \"function\";\n}\n// Checks whether the list of tools contains any CallableTools. Will return true\n// if there is at least one CallableTool.\nfunction hasCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool)=>isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n// Checks whether the list of tools contains any non-callable tools. Will return\n// true if there is at least one non-Callable tool.\nfunction hasNonCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool)=>!isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n/**\n * Returns whether to append automatic function calling history to the\n * response.\n */ function shouldAppendAfcHistory(config) {\n    var _a;\n    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Models extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Makes an API request to generate content with a given model.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         * 'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContent({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     candidateCount: 2,\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */ this.generateContent = async (params)=>{\n            var _a, _b, _c, _d, _e;\n            const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n            this.maybeMoveToResponseJsonSchem(params);\n            if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {\n                return await this.generateContentInternal(transformedParams);\n            }\n            if (hasNonCallableTools(params)) {\n                throw new Error(\"Automatic function calling with CallableTools and Tools is not yet supported.\");\n            }\n            let response;\n            let functionResponseContent;\n            const automaticFunctionCallingHistory = tContents(transformedParams.contents);\n            const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n            let remoteCalls = 0;\n            while(remoteCalls < maxRemoteCalls){\n                response = await this.generateContentInternal(transformedParams);\n                if (!response.functionCalls || response.functionCalls.length === 0) {\n                    break;\n                }\n                const responseContent = response.candidates[0].content;\n                const functionResponseParts = [];\n                for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []){\n                    if (isCallableTool(tool)) {\n                        const callableTool = tool;\n                        const parts = await callableTool.callTool(response.functionCalls);\n                        functionResponseParts.push(...parts);\n                    }\n                }\n                remoteCalls++;\n                functionResponseContent = {\n                    role: \"user\",\n                    parts: functionResponseParts\n                };\n                transformedParams.contents = tContents(transformedParams.contents);\n                transformedParams.contents.push(responseContent);\n                transformedParams.contents.push(functionResponseContent);\n                if (shouldAppendAfcHistory(transformedParams.config)) {\n                    automaticFunctionCallingHistory.push(responseContent);\n                    automaticFunctionCallingHistory.push(functionResponseContent);\n                }\n            }\n            if (shouldAppendAfcHistory(transformedParams.config)) {\n                response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;\n            }\n            return response;\n        };\n        /**\n         * Makes an API request to generate content with a given model and yields the\n         * response in chunks.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         *  'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content with streaming response.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContentStream({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     maxOutputTokens: 200,\n         *   }\n         * });\n         * for await (const chunk of response) {\n         *   console.log(chunk);\n         * }\n         * ```\n         */ this.generateContentStream = async (params)=>{\n            this.maybeMoveToResponseJsonSchem(params);\n            if (shouldDisableAfc(params.config)) {\n                const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n                return await this.generateContentStreamInternal(transformedParams);\n            } else {\n                return await this.processAfcStream(params);\n            }\n        };\n        /**\n         * Generates an image based on a text description and configuration.\n         *\n         * @param params - The parameters for generating images.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.generateImages({\n         *  model: 'imagen-3.0-generate-002',\n         *  prompt: 'Robot holding a red skateboard',\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.generateImages = async (params)=>{\n            return await this.generateImagesInternal(params).then((apiResponse)=>{\n                var _a;\n                let positivePromptSafetyAttributes;\n                const generatedImages = [];\n                if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {\n                    for (const generatedImage of apiResponse.generatedImages){\n                        if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === \"Positive Prompt\") {\n                            positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;\n                        } else {\n                            generatedImages.push(generatedImage);\n                        }\n                    }\n                }\n                let response;\n                if (positivePromptSafetyAttributes) {\n                    response = {\n                        generatedImages: generatedImages,\n                        positivePromptSafetyAttributes: positivePromptSafetyAttributes,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse\n                    };\n                } else {\n                    response = {\n                        generatedImages: generatedImages,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse\n                    };\n                }\n                return response;\n            });\n        };\n        this.list = async (params)=>{\n            var _a;\n            const defaultConfig = {\n                queryBase: true\n            };\n            const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);\n            const actualParams = {\n                config: actualConfig\n            };\n            if (this.apiClient.isVertexAI()) {\n                if (!actualParams.config.queryBase) {\n                    if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {\n                        throw new Error(\"Filtering tuned models list for Vertex AI is not currently supported\");\n                    } else {\n                        actualParams.config.filter = \"labels.tune-type:*\";\n                    }\n                }\n            }\n            return new Pager(PagedItem.PAGED_ITEM_MODELS, (x)=>this.listInternal(x), await this.listInternal(actualParams), actualParams);\n        };\n        /**\n         * Edits an image based on a prompt, list of reference images, and configuration.\n         *\n         * @param params - The parameters for editing an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.editImage({\n         *  model: 'imagen-3.0-capability-001',\n         *  prompt: 'Generate an image containing a mug with the product logo [1] visible on the side of the mug.',\n         *  referenceImages: [subjectReferenceImage]\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.editImage = async (params)=>{\n            const paramsInternal = {\n                model: params.model,\n                prompt: params.prompt,\n                referenceImages: [],\n                config: params.config\n            };\n            if (params.referenceImages) {\n                if (params.referenceImages) {\n                    paramsInternal.referenceImages = params.referenceImages.map((img)=>img.toReferenceImageAPI());\n                }\n            }\n            return await this.editImageInternal(paramsInternal);\n        };\n        /**\n         * Upscales an image based on an image, upscale factor, and configuration.\n         * Only supported in Vertex AI currently.\n         *\n         * @param params - The parameters for upscaling an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.upscaleImage({\n         *  model: 'imagen-3.0-generate-002',\n         *  image: image,\n         *  upscaleFactor: 'x2',\n         *  config: {\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */ this.upscaleImage = async (params)=>{\n            let apiConfig = {\n                numberOfImages: 1,\n                mode: \"upscale\"\n            };\n            if (params.config) {\n                apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);\n            }\n            const apiParams = {\n                model: params.model,\n                image: params.image,\n                upscaleFactor: params.upscaleFactor,\n                config: apiConfig\n            };\n            return await this.upscaleImageInternal(apiParams);\n        };\n        /**\n         *  Generates videos based on a text description and configuration.\n         *\n         * @param params - The parameters for generating videos.\n         * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.\n         *\n         * @example\n         * ```ts\n         * const operation = await ai.models.generateVideos({\n         *  model: 'veo-2.0-generate-001',\n         *  prompt: 'A neon hologram of a cat driving at top speed',\n         *  config: {\n         *    numberOfVideos: 1\n         * });\n         *\n         * while (!operation.done) {\n         *   await new Promise(resolve => setTimeout(resolve, 10000));\n         *   operation = await ai.operations.getVideosOperation({operation: operation});\n         * }\n         *\n         * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);\n         * ```\n         */ this.generateVideos = async (params)=>{\n            return await this.generateVideosInternal(params);\n        };\n    }\n    /**\n     * This logic is needed for GenerateContentConfig only.\n     * Previously we made GenerateContentConfig.responseSchema field to accept\n     * unknown. Since v1.9.0, we switch to use backend JSON schema support.\n     * To maintain backward compatibility, we move the data that was treated as\n     * JSON schema from the responseSchema field to the responseJsonSchema field.\n     */ maybeMoveToResponseJsonSchem(params) {\n        if (params.config && params.config.responseSchema) {\n            if (!params.config.responseJsonSchema) {\n                if (Object.keys(params.config.responseSchema).includes(\"$schema\")) {\n                    params.config.responseJsonSchema = params.config.responseSchema;\n                    delete params.config.responseSchema;\n                }\n            }\n        }\n        return;\n    }\n    /**\n     * Transforms the CallableTools in the parameters to be simply Tools, it\n     * copies the params into a new object and replaces the tools, it does not\n     * modify the original params. Also sets the MCP usage header if there are\n     * MCP tools in the parameters.\n     */ async processParamsMaybeAddMcpUsage(params) {\n        var _a, _b, _c;\n        const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;\n        if (!tools) {\n            return params;\n        }\n        const transformedTools = await Promise.all(tools.map(async (tool)=>{\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                return await callableTool.tool();\n            }\n            return tool;\n        }));\n        const newParams = {\n            model: params.model,\n            contents: params.contents,\n            config: Object.assign(Object.assign({}, params.config), {\n                tools: transformedTools\n            })\n        };\n        newParams.config.tools = transformedTools;\n        if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {\n            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};\n            let newHeaders = Object.assign({}, headers);\n            if (Object.keys(newHeaders).length === 0) {\n                newHeaders = this.apiClient.getDefaultHeaders();\n            }\n            setMcpUsageHeader(newHeaders);\n            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), {\n                headers: newHeaders\n            });\n        }\n        return newParams;\n    }\n    async initAfcToolsMap(params) {\n        var _a, _b, _c;\n        const afcTools = new Map();\n        for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []){\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                const toolDeclaration = await callableTool.tool();\n                for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []){\n                    if (!declaration.name) {\n                        throw new Error(\"Function declaration name is required.\");\n                    }\n                    if (afcTools.has(declaration.name)) {\n                        throw new Error(`Duplicate tool declaration name: ${declaration.name}`);\n                    }\n                    afcTools.set(declaration.name, callableTool);\n                }\n            }\n        }\n        return afcTools;\n    }\n    async processAfcStream(params) {\n        var _a, _b, _c;\n        const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n        let wereFunctionsCalled = false;\n        let remoteCallCount = 0;\n        const afcToolsMap = await this.initAfcToolsMap(params);\n        return function(models, afcTools, params) {\n            var _a, _b;\n            return __asyncGenerator(this, arguments, function*() {\n                var _c, e_1, _d, _e;\n                while(remoteCallCount < maxRemoteCalls){\n                    if (wereFunctionsCalled) {\n                        remoteCallCount++;\n                        wereFunctionsCalled = false;\n                    }\n                    const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params));\n                    const response = yield __await(models.generateContentStreamInternal(transformedParams));\n                    const functionResponses = [];\n                    const responseContents = [];\n                    try {\n                        for(var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c = response_1_1.done, !_c; _f = true){\n                            _e = response_1_1.value;\n                            _f = false;\n                            const chunk = _e;\n                            yield yield __await(chunk);\n                            if (chunk.candidates && ((_a = chunk.candidates[0]) === null || _a === void 0 ? void 0 : _a.content)) {\n                                responseContents.push(chunk.candidates[0].content);\n                                for (const part of (_b = chunk.candidates[0].content.parts) !== null && _b !== void 0 ? _b : []){\n                                    if (remoteCallCount < maxRemoteCalls && part.functionCall) {\n                                        if (!part.functionCall.name) {\n                                            throw new Error(\"Function call name was not returned by the model.\");\n                                        }\n                                        if (!afcTools.has(part.functionCall.name)) {\n                                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);\n                                        } else {\n                                            const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([\n                                                part.functionCall\n                                            ]));\n                                            functionResponses.push(...responseParts);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_c && (_d = response_1.return)) yield __await(_d.call(response_1));\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                    if (functionResponses.length > 0) {\n                        wereFunctionsCalled = true;\n                        const typedResponseChunk = new GenerateContentResponse();\n                        typedResponseChunk.candidates = [\n                            {\n                                content: {\n                                    role: \"user\",\n                                    parts: functionResponses\n                                }\n                            }\n                        ];\n                        yield yield __await(typedResponseChunk);\n                        const newContents = [];\n                        newContents.push(...responseContents);\n                        newContents.push({\n                            role: \"user\",\n                            parts: functionResponses\n                        });\n                        const updatedContents = tContents(params.contents).concat(newContents);\n                        params.contents = updatedContents;\n                    } else {\n                        break;\n                    }\n                }\n            });\n        }(this, afcToolsMap, params);\n    }\n    async generateContentInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromVertex(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:generateContent\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateContentResponseFromMldev(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async generateContentStreamInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_2, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a = apiResponse_1_1.done, !_a; _d = true){\n                            _c = apiResponse_1_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromVertex((yield __await(chunk.json())));\n                            resp[\"sdkHttpResponse\"] = {\n                                headers: chunk.headers\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_2_1) {\n                        e_2 = {\n                            error: e_2_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_1.return)) yield __await(_b.call(apiResponse_1));\n                        } finally{\n                            if (e_2) throw e_2.error;\n                        }\n                    }\n                });\n            });\n        } else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:streamGenerateContent?alt=sse\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            });\n            return response.then(function(apiResponse) {\n                return __asyncGenerator(this, arguments, function*() {\n                    var _a, e_3, _b, _c;\n                    try {\n                        for(var _d = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a = apiResponse_2_1.done, !_a; _d = true){\n                            _c = apiResponse_2_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromMldev((yield __await(chunk.json())));\n                            resp[\"sdkHttpResponse\"] = {\n                                headers: chunk.headers\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    } catch (e_3_1) {\n                        e_3 = {\n                            error: e_3_1\n                        };\n                    } finally{\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_2.return)) yield __await(_b.call(apiResponse_2));\n                        } finally{\n                            if (e_3) throw e_3.error;\n                        }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Calculates embeddings for the given contents. Only text is supported.\n     *\n     * @param params - The parameters for embedding contents.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.embedContent({\n     *  model: 'text-embedding-004',\n     *  contents: [\n     *    'What is your name?',\n     *    'What is your favorite color?',\n     *  ],\n     *  config: {\n     *    outputDimensionality: 64,\n     *  },\n     * });\n     * console.log(response);\n     * ```\n     */ async embedContent(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = embedContentParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromVertex(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = embedContentParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:batchEmbedContents\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = embedContentResponseFromMldev(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Generates an image based on a text description and configuration.\n     *\n     * @param params - The parameters for generating images.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateImages({\n     *  model: 'imagen-3.0-generate-002',\n     *  prompt: 'Robot holding a red skateboard',\n     *  config: {\n     *    numberOfImages: 1,\n     *    includeRaiReason: true,\n     *  },\n     * });\n     * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n     * ```\n     */ async generateImagesInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateImagesParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromVertex(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateImagesParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateImagesResponseFromMldev(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async editImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = editImageParametersInternalToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = editImageResponseFromVertex(apiResponse);\n                const typedResp = new EditImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    async upscaleImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = upscaleImageResponseFromVertex(apiResponse);\n                const typedResp = new UpscaleImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Recontextualizes an image.\n     *\n     * There are two types of recontextualization currently supported:\n     * 1) Imagen Product Recontext - Generate images of products in new scenes\n     *    and contexts.\n     * 2) Virtual Try-On: Generate images of persons modeling fashion products.\n     *\n     * @param params - The parameters for recontextualizing an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response1 = await ai.models.recontextImage({\n     *  model: 'imagen-product-recontext-preview-06-30',\n     *  source: {\n     *    prompt: 'In a modern kitchen setting.',\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);\n     *\n     * const response2 = await ai.models.recontextImage({\n     *  model: 'virtual-try-on-preview-08-04',\n     *  source: {\n     *    personImage: personImage,\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);\n     * ```\n     */ async recontextImage(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = recontextImageParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = recontextImageResponseFromVertex(apiResponse);\n                const typedResp = new RecontextImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Segments an image, creating a mask of a specified area.\n     *\n     * @param params - The parameters for segmenting an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.segmentImage({\n     *  model: 'image-segmentation-001',\n     *  source: {\n     *    image: image,\n     *  },\n     *  config: {\n     *    mode: 'foreground',\n     *  },\n     * });\n     * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);\n     * ```\n     */ async segmentImage(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = segmentImageParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predict\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = segmentImageResponseFromVertex(apiResponse);\n                const typedResp = new SegmentImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     * Fetches information about a model by name.\n     *\n     * @example\n     * ```ts\n     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});\n     * ```\n     */ async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listModelsParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{models_url}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listModelsResponseFromVertex(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listModelsParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{models_url}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listModelsResponseFromMldev(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates a tuned model by its name.\n     *\n     * @param params - The parameters for updating the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.update({\n     *   model: 'tuned-model-name',\n     *   config: {\n     *     displayName: 'New display name',\n     *     description: 'New description',\n     *   },\n     * });\n     * ```\n     */ async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = updateModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"PATCH\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a tuned model by its name.\n     *\n     * @param params - The parameters for deleting the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.delete({model: 'tuned-model-name'});\n     * ```\n     */ async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteModelParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteModelResponseFromVertex();\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = deleteModelParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"DELETE\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then(()=>{\n                const resp = deleteModelResponseFromMldev();\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Counts the number of tokens in the given contents. Multimodal input is\n     * supported for Gemini models.\n     *\n     * @param params - The parameters for counting tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.countTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'The quick brown fox jumps over the lazy dog.'\n     * });\n     * console.log(response);\n     * ```\n     */ async countTokens(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = countTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromVertex(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = countTokensParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:countTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = countTokensResponseFromMldev(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Given a list of contents, returns a corresponding TokensInfo containing\n     * the list of tokens and list of token ids.\n     *\n     * This method is not supported by the Gemini Developer API.\n     *\n     * @param params - The parameters for computing tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.computeTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'What is your name?'\n     * });\n     * console.log(response);\n     * ```\n     */ async computeTokens(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = computeTokensParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:computeTokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = computeTokensResponseFromVertex(apiResponse);\n                const typedResp = new ComputeTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    /**\n     *  Generates videos based on a text description and configuration.\n     *\n     * @param params - The parameters for generating videos.\n     * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.\n     *\n     * @example\n     * ```ts\n     * const operation = await ai.models.generateVideos({\n     *  model: 'veo-2.0-generate-001',\n     *  prompt: 'A neon hologram of a cat driving at top speed',\n     *  config: {\n     *    numberOfVideos: 1\n     * });\n     *\n     * while (!operation.done) {\n     *   await new Promise(resolve => setTimeout(resolve, 10000));\n     *   operation = await ai.operations.getVideosOperation({operation: operation});\n     * }\n     *\n     * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);\n     * ```\n     */ async generateVideosInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateVideosParametersToVertex(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromVertex(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = generateVideosParametersToMldev(this.apiClient, params);\n            path = formatMap(\"{model}:predictLongRunning\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = generateVideosOperationFromMldev(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction getOperationParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction getOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction fetchPredictOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        \"operationName\"\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, [\n            \"operationName\"\n        ], fromOperationName);\n    }\n    const fromResourceName = getValueByPath(fromObject, [\n        \"resourceName\"\n    ]);\n    if (fromResourceName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"resourceName\"\n        ], fromResourceName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Operations extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */ async getVideosOperation(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === \"\") {\n            throw new Error(\"Operation name is required.\");\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split(\"/operations/\")[0];\n            let httpOptions = undefined;\n            if (config && \"httpOptions\" in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: {\n                    httpOptions: httpOptions\n                }\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: true\n            });\n        } else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: false\n            });\n        }\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */ async get(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === \"\") {\n            throw new Error(\"Operation name is required.\");\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split(\"/operations/\")[0];\n            let httpOptions = undefined;\n            if (config && \"httpOptions\" in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: {\n                    httpOptions: httpOptions\n                }\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: true\n            });\n        } else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: false\n            });\n        }\n    }\n    async getVideosOperationInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getOperationParametersToVertex(params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        } else {\n            const body = getOperationParametersToMldev(params);\n            path = formatMap(\"{operationName}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        }\n    }\n    async fetchPredictVideosOperationInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = fetchPredictOperationParametersToVertex(params);\n            path = formatMap(\"{resourceName}:fetchPredictOperation\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response;\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ function prebuiltVoiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, [\n        \"voiceName\"\n    ]);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, [\n            \"voiceName\"\n        ], fromVoiceName);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        \"prebuiltVoiceConfig\"\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"prebuiltVoiceConfig\"\n        ], prebuiltVoiceConfigToMldev(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, [\n        \"speaker\"\n    ]);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, [\n            \"speaker\"\n        ], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        \"speakerVoiceConfigs\"\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return speakerVoiceConfigToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"speakerVoiceConfigs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction speechConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, [\n        \"voiceConfig\"\n    ]);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"voiceConfig\"\n        ], voiceConfigToMldev(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        \"multiSpeakerVoiceConfig\"\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, [\n            \"multiSpeakerVoiceConfig\"\n        ], multiSpeakerVoiceConfigToMldev(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, [\n        \"languageCode\"\n    ]);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, [\n            \"languageCode\"\n        ], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction videoMetadataToMldev(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, [\n        \"fps\"\n    ]);\n    if (fromFps != null) {\n        setValueByPath(toObject, [\n            \"fps\"\n        ], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, [\n        \"endOffset\"\n    ]);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, [\n            \"endOffset\"\n        ], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, [\n        \"startOffset\"\n    ]);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, [\n            \"startOffset\"\n        ], fromStartOffset);\n    }\n    return toObject;\n}\nfunction blobToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromData = getValueByPath(fromObject, [\n        \"data\"\n    ]);\n    if (fromData != null) {\n        setValueByPath(toObject, [\n            \"data\"\n        ], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"displayName\"\n    ]) !== undefined) {\n        throw new Error(\"displayName parameter is not supported in Gemini API.\");\n    }\n    const fromFileUri = getValueByPath(fromObject, [\n        \"fileUri\"\n    ]);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, [\n            \"fileUri\"\n        ], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, [\n        \"mimeType\"\n    ]);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, [\n            \"mimeType\"\n        ], fromMimeType);\n    }\n    return toObject;\n}\nfunction partToMldev(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        \"videoMetadata\"\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, [\n            \"videoMetadata\"\n        ], videoMetadataToMldev(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, [\n        \"thought\"\n    ]);\n    if (fromThought != null) {\n        setValueByPath(toObject, [\n            \"thought\"\n        ], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, [\n        \"inlineData\"\n    ]);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, [\n            \"inlineData\"\n        ], blobToMldev(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, [\n        \"fileData\"\n    ]);\n    if (fromFileData != null) {\n        setValueByPath(toObject, [\n            \"fileData\"\n        ], fileDataToMldev(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        \"thoughtSignature\"\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, [\n            \"thoughtSignature\"\n        ], fromThoughtSignature);\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        \"codeExecutionResult\"\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, [\n            \"codeExecutionResult\"\n        ], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        \"executableCode\"\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, [\n            \"executableCode\"\n        ], fromExecutableCode);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, [\n        \"functionCall\"\n    ]);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, [\n            \"functionCall\"\n        ], fromFunctionCall);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        \"functionResponse\"\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, [\n            \"functionResponse\"\n        ], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, [\n        \"text\"\n    ]);\n    if (fromText != null) {\n        setValueByPath(toObject, [\n            \"text\"\n        ], fromText);\n    }\n    return toObject;\n}\nfunction contentToMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, [\n        \"parts\"\n    ]);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return partToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"parts\"\n        ], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, [\n        \"role\"\n    ]);\n    if (fromRole != null) {\n        setValueByPath(toObject, [\n            \"role\"\n        ], fromRole);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, [\n        \"behavior\"\n    ]);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, [\n            \"behavior\"\n        ], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, [\n        \"parameters\"\n    ]);\n    if (fromParameters != null) {\n        setValueByPath(toObject, [\n            \"parameters\"\n        ], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        \"parametersJsonSchema\"\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"parametersJsonSchema\"\n        ], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        \"response\"\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, [\n            \"response\"\n        ], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        \"responseJsonSchema\"\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, [\n            \"responseJsonSchema\"\n        ], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction intervalToMldev(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    return toObject;\n}\nfunction googleSearchToMldev(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        \"timeRangeFilter\"\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, [\n            \"timeRangeFilter\"\n        ], intervalToMldev(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, [\n        \"excludeDomains\"\n    ]) !== undefined) {\n        throw new Error(\"excludeDomains parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, [\n        \"mode\"\n    ]);\n    if (fromMode != null) {\n        setValueByPath(toObject, [\n            \"mode\"\n        ], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        \"dynamicThreshold\"\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, [\n            \"dynamicThreshold\"\n        ], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        \"dynamicRetrievalConfig\"\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, [\n            \"dynamicRetrievalConfig\"\n        ], dynamicRetrievalConfigToMldev(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction urlContextToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction toolComputerUseToMldev(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, [\n        \"environment\"\n    ]);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, [\n            \"environment\"\n        ], fromEnvironment);\n    }\n    return toObject;\n}\nfunction toolToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        \"functionDeclarations\"\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return functionDeclarationToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"functionDeclarations\"\n        ], transformedList);\n    }\n    if (getValueByPath(fromObject, [\n        \"retrieval\"\n    ]) !== undefined) {\n        throw new Error(\"retrieval parameter is not supported in Gemini API.\");\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, [\n        \"googleSearch\"\n    ]);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, [\n            \"googleSearch\"\n        ], googleSearchToMldev(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        \"googleSearchRetrieval\"\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, [\n            \"googleSearchRetrieval\"\n        ], googleSearchRetrievalToMldev(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, [\n        \"enterpriseWebSearch\"\n    ]) !== undefined) {\n        throw new Error(\"enterpriseWebSearch parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"googleMaps\"\n    ]) !== undefined) {\n        throw new Error(\"googleMaps parameter is not supported in Gemini API.\");\n    }\n    const fromUrlContext = getValueByPath(fromObject, [\n        \"urlContext\"\n    ]);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, [\n            \"urlContext\"\n        ], urlContextToMldev());\n    }\n    const fromComputerUse = getValueByPath(fromObject, [\n        \"computerUse\"\n    ]);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, [\n            \"computerUse\"\n        ], toolComputerUseToMldev(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        \"codeExecution\"\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, [\n            \"codeExecution\"\n        ], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, [\n        \"handle\"\n    ]);\n    if (fromHandle != null) {\n        setValueByPath(toObject, [\n            \"handle\"\n        ], fromHandle);\n    }\n    if (getValueByPath(fromObject, [\n        \"transparent\"\n    ]) !== undefined) {\n        throw new Error(\"transparent parameter is not supported in Gemini API.\");\n    }\n    return toObject;\n}\nfunction audioTranscriptionConfigToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction automaticActivityDetectionToMldev(fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, [\n        \"disabled\"\n    ]);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, [\n            \"disabled\"\n        ], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"startOfSpeechSensitivity\"\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"startOfSpeechSensitivity\"\n        ], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        \"endOfSpeechSensitivity\"\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, [\n            \"endOfSpeechSensitivity\"\n        ], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        \"prefixPaddingMs\"\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, [\n            \"prefixPaddingMs\"\n        ], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        \"silenceDurationMs\"\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, [\n            \"silenceDurationMs\"\n        ], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        \"automaticActivityDetection\"\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, [\n            \"automaticActivityDetection\"\n        ], automaticActivityDetectionToMldev(fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        \"activityHandling\"\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, [\n            \"activityHandling\"\n        ], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, [\n        \"turnCoverage\"\n    ]);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, [\n            \"turnCoverage\"\n        ], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction slidingWindowToMldev(fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, [\n        \"targetTokens\"\n    ]);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, [\n            \"targetTokens\"\n        ], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        \"triggerTokens\"\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, [\n            \"triggerTokens\"\n        ], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        \"slidingWindow\"\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, [\n            \"slidingWindow\"\n        ], slidingWindowToMldev(fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction proactivityConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromProactiveAudio = getValueByPath(fromObject, [\n        \"proactiveAudio\"\n    ]);\n    if (fromProactiveAudio != null) {\n        setValueByPath(toObject, [\n            \"proactiveAudio\"\n        ], fromProactiveAudio);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        \"generationConfig\"\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\"\n        ], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        \"responseModalities\"\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"responseModalities\"\n        ], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, [\n        \"temperature\"\n    ]);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"temperature\"\n        ], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, [\n        \"topP\"\n    ]);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topP\"\n        ], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, [\n        \"topK\"\n    ]);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"topK\"\n        ], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        \"maxOutputTokens\"\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"maxOutputTokens\"\n        ], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        \"mediaResolution\"\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"mediaResolution\"\n        ], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, [\n        \"seed\"\n    ]);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"seed\"\n        ], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, [\n        \"speechConfig\"\n    ]);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"speechConfig\"\n        ], speechConfigToMldev(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        \"enableAffectiveDialog\"\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"generationConfig\",\n            \"enableAffectiveDialog\"\n        ], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        \"systemInstruction\"\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"systemInstruction\"\n        ], contentToMldev(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, [\n        \"tools\"\n    ]);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return toolToMldev(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"tools\"\n        ], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        \"sessionResumption\"\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"sessionResumption\"\n        ], sessionResumptionConfigToMldev(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        \"inputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"inputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        \"outputAudioTranscription\"\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"outputAudioTranscription\"\n        ], audioTranscriptionConfigToMldev());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        \"realtimeInputConfig\"\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"realtimeInputConfig\"\n        ], realtimeInputConfigToMldev(fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        \"contextWindowCompression\"\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"contextWindowCompression\"\n        ], contextWindowCompressionConfigToMldev(fromContextWindowCompression));\n    }\n    const fromProactivity = getValueByPath(fromObject, [\n        \"proactivity\"\n    ]);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, [\n            \"setup\",\n            \"proactivity\"\n        ], proactivityConfigToMldev(fromProactivity));\n    }\n    return toObject;\n}\nfunction liveConnectConstraintsToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"setup\",\n            \"model\"\n        ], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], liveConnectConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromExpireTime = getValueByPath(fromObject, [\n        \"expireTime\"\n    ]);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"expireTime\"\n        ], fromExpireTime);\n    }\n    const fromNewSessionExpireTime = getValueByPath(fromObject, [\n        \"newSessionExpireTime\"\n    ]);\n    if (parentObject !== undefined && fromNewSessionExpireTime != null) {\n        setValueByPath(parentObject, [\n            \"newSessionExpireTime\"\n        ], fromNewSessionExpireTime);\n    }\n    const fromUses = getValueByPath(fromObject, [\n        \"uses\"\n    ]);\n    if (parentObject !== undefined && fromUses != null) {\n        setValueByPath(parentObject, [\n            \"uses\"\n        ], fromUses);\n    }\n    const fromLiveConnectConstraints = getValueByPath(fromObject, [\n        \"liveConnectConstraints\"\n    ]);\n    if (parentObject !== undefined && fromLiveConnectConstraints != null) {\n        setValueByPath(parentObject, [\n            \"bidiGenerateContentSetup\"\n        ], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));\n    }\n    const fromLockAdditionalFields = getValueByPath(fromObject, [\n        \"lockAdditionalFields\"\n    ]);\n    if (parentObject !== undefined && fromLockAdditionalFields != null) {\n        setValueByPath(parentObject, [\n            \"fieldMask\"\n        ], fromLockAdditionalFields);\n    }\n    return toObject;\n}\nfunction createAuthTokenParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction authTokenFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ /**\n * Returns a comma-separated list of field masks from a given object.\n *\n * @param setup The object to extract field masks from.\n * @return A comma-separated list of field masks.\n */ function getFieldMasks(setup) {\n    const fields = [];\n    for(const key in setup){\n        if (Object.prototype.hasOwnProperty.call(setup, key)) {\n            const value = setup[key];\n            // 2nd layer, recursively get field masks see TODO(b/418290100)\n            if (typeof value === \"object\" && value != null && Object.keys(value).length > 0) {\n                const field = Object.keys(value).map((kk)=>`${key}.${kk}`);\n                fields.push(...field);\n            } else {\n                fields.push(key); // 1st layer\n            }\n        }\n    }\n    return fields.join(\",\");\n}\n/**\n * Converts bidiGenerateContentSetup.\n * @param requestDict - The request dictionary.\n * @param config - The configuration object.\n * @return - The modified request dictionary.\n */ function convertBidiSetupToTokenSetup(requestDict, config) {\n    // Convert bidiGenerateContentSetup from bidiGenerateContentSetup.setup.\n    let setupForMaskGeneration = null;\n    const bidiGenerateContentSetupValue = requestDict[\"bidiGenerateContentSetup\"];\n    if (typeof bidiGenerateContentSetupValue === \"object\" && bidiGenerateContentSetupValue !== null && \"setup\" in bidiGenerateContentSetupValue) {\n        // Now we know bidiGenerateContentSetupValue is an object and has a 'setup'\n        // property.\n        const innerSetup = bidiGenerateContentSetupValue.setup;\n        if (typeof innerSetup === \"object\" && innerSetup !== null) {\n            // Valid inner setup found.\n            requestDict[\"bidiGenerateContentSetup\"] = innerSetup;\n            setupForMaskGeneration = innerSetup;\n        } else {\n            // `bidiGenerateContentSetupValue.setup` is not a valid object; treat as\n            // if bidiGenerateContentSetup is invalid.\n            delete requestDict[\"bidiGenerateContentSetup\"];\n        }\n    } else if (bidiGenerateContentSetupValue !== undefined) {\n        // `bidiGenerateContentSetup` exists but not in the expected\n        // shape {setup: {...}}; treat as invalid.\n        delete requestDict[\"bidiGenerateContentSetup\"];\n    }\n    const preExistingFieldMask = requestDict[\"fieldMask\"];\n    // Handle mask generation setup.\n    if (setupForMaskGeneration) {\n        const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);\n        if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {\n            // Case 1: lockAdditionalFields is an empty array. Lock only fields from\n            // bidi setup.\n            if (generatedMaskFromBidi) {\n                // Only assign if mask is not empty\n                requestDict[\"fieldMask\"] = generatedMaskFromBidi;\n            } else {\n                delete requestDict[\"fieldMask\"]; // If mask is empty, effectively no\n            // specific fields locked by bidi\n            }\n        } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {\n            // Case 2: Lock fields from bidi setup + additional fields\n            // (preExistingFieldMask).\n            const generationConfigFields = [\n                \"temperature\",\n                \"topK\",\n                \"topP\",\n                \"maxOutputTokens\",\n                \"responseModalities\",\n                \"seed\",\n                \"speechConfig\"\n            ];\n            let mappedFieldsFromPreExisting = [];\n            if (preExistingFieldMask.length > 0) {\n                mappedFieldsFromPreExisting = preExistingFieldMask.map((field)=>{\n                    if (generationConfigFields.includes(field)) {\n                        return `generationConfig.${field}`;\n                    }\n                    return field; // Keep original field name if not in\n                // generationConfigFields\n                });\n            }\n            const finalMaskParts = [];\n            if (generatedMaskFromBidi) {\n                finalMaskParts.push(generatedMaskFromBidi);\n            }\n            if (mappedFieldsFromPreExisting.length > 0) {\n                finalMaskParts.push(...mappedFieldsFromPreExisting);\n            }\n            if (finalMaskParts.length > 0) {\n                requestDict[\"fieldMask\"] = finalMaskParts.join(\",\");\n            } else {\n                // If no fields from bidi and no valid additional fields from\n                // pre-existing mask.\n                delete requestDict[\"fieldMask\"];\n            }\n        } else {\n            // Case 3: \"Lock all fields\" (meaning, don't send a field_mask, let server\n            // defaults apply or all are mutable). This is hit if:\n            //  - `config.lockAdditionalFields` is undefined.\n            //  - `config.lockAdditionalFields` is non-empty, BUT\n            //  `preExistingFieldMask` is null, not a string, or an empty string.\n            delete requestDict[\"fieldMask\"];\n        }\n    } else {\n        // No valid `bidiGenerateContentSetup` was found or extracted.\n        // \"Lock additional null fields if any\".\n        if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {\n            // If there's a pre-existing field mask, it's a string, and it's not\n            // empty, then we should lock all fields.\n            requestDict[\"fieldMask\"] = preExistingFieldMask.join(\",\");\n        } else {\n            delete requestDict[\"fieldMask\"];\n        }\n    }\n    return requestDict;\n}\nclass Tokens extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates an ephemeral auth token resource.\n     *\n     * @experimental\n     *\n     * @remarks\n     * Ephemeral auth tokens is only supported in the Gemini Developer API.\n     * It can be used for the session connection to the Live constrained API.\n     * Support in v1alpha only.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created auth token.\n     *\n     * @example\n     * ```ts\n     * const ai = new GoogleGenAI({\n     *     apiKey: token.name,\n     *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.\n     * });\n     *\n     * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig\n     * // when using the token in Live API sessions. Each session connection can\n     * // use a different configuration.\n     * const config: CreateAuthTokenConfig = {\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 2: If LiveEphemeralParameters is set, lock all fields in\n     * // LiveConnectConfig when using the token in Live API sessions. For\n     * // example, changing `outputAudioTranscription` in the Live API\n     * // connection will be ignored by the API.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     }\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // set, lock LiveConnectConfig with set and additional fields (e.g.\n     * // responseModalities, systemInstruction, temperature in this example) when\n     * // using the token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: ['temperature'],\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // empty array, lock LiveConnectConfig with set fields (e.g.\n     * // responseModalities, systemInstruction in this example) when using the\n     * // token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: [],\n     * }\n     * const token = await ai.tokens.create(config);\n     * ```\n     */ async create(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"The client.tokens.create method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createAuthTokenParametersToMldev(this.apiClient, params);\n            path = formatMap(\"auth_tokens\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(transformedBody),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json();\n            });\n            return response.then((apiResponse)=>{\n                const resp = authTokenFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const GOOGLE_API_KEY_HEADER = \"x-goog-api-key\";\nconst REQUIRED_VERTEX_AI_SCOPE = \"https://www.googleapis.com/auth/cloud-platform\";\nclass NodeAuth {\n    constructor(opts){\n        if (opts.apiKey !== undefined) {\n            this.apiKey = opts.apiKey;\n            return;\n        }\n        const vertexAuthOptions = buildGoogleAuthOptions(opts.googleAuthOptions);\n        this.googleAuth = new google_auth_library__WEBPACK_IMPORTED_MODULE_0__.GoogleAuth(vertexAuthOptions);\n    }\n    async addAuthHeaders(headers) {\n        if (this.apiKey !== undefined) {\n            if (this.apiKey.startsWith(\"auth_tokens/\")) {\n                throw new Error(\"Ephemeral tokens are only supported by the live API.\");\n            }\n            this.addKeyHeader(headers);\n            return;\n        }\n        return this.addGoogleAuthHeaders(headers);\n    }\n    addKeyHeader(headers) {\n        if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {\n            return;\n        }\n        if (this.apiKey === undefined) {\n            // This should never happen, this method is only called\n            // when apiKey is set.\n            throw new Error(\"Trying to set API key header but apiKey is not set\");\n        }\n        headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);\n    }\n    async addGoogleAuthHeaders(headers) {\n        if (this.googleAuth === undefined) {\n            // This should never happen, addGoogleAuthHeaders should only be\n            // called when there is no apiKey set and in these cases googleAuth\n            // is set.\n            throw new Error(\"Trying to set google-auth headers but googleAuth is unset\");\n        }\n        const authHeaders = await this.googleAuth.getRequestHeaders();\n        for(const key in authHeaders){\n            if (headers.get(key) !== null) {\n                continue;\n            }\n            headers.append(key, authHeaders[key]);\n        }\n    }\n}\nfunction buildGoogleAuthOptions(googleAuthOptions) {\n    let authOptions;\n    if (!googleAuthOptions) {\n        authOptions = {\n            scopes: [\n                REQUIRED_VERTEX_AI_SCOPE\n            ]\n        };\n        return authOptions;\n    } else {\n        authOptions = googleAuthOptions;\n        if (!authOptions.scopes) {\n            authOptions.scopes = [\n                REQUIRED_VERTEX_AI_SCOPE\n            ];\n            return authOptions;\n        } else if (typeof authOptions.scopes === \"string\" && authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE || Array.isArray(authOptions.scopes) && authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0) {\n            throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);\n        }\n        return authOptions;\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeDownloader {\n    async download(params, apiClient) {\n        if (params.downloadPath) {\n            const response = await downloadFile(params, apiClient);\n            if (response instanceof HttpResponse) {\n                const writer = (0,fs__WEBPACK_IMPORTED_MODULE_1__.createWriteStream)(params.downloadPath);\n                node_stream__WEBPACK_IMPORTED_MODULE_2__.Readable.fromWeb(response.responseInternal.body).pipe(writer);\n            } else {\n                (0,fs__WEBPACK_IMPORTED_MODULE_1__.writeFile)(params.downloadPath, response, {\n                    encoding: \"base64\"\n                }, (error)=>{\n                    if (error) {\n                        throw new Error(`Failed to write file to ${params.downloadPath}: ${error}`);\n                    }\n                });\n            }\n        }\n    }\n}\nasync function downloadFile(params, apiClient) {\n    var _a, _b, _c;\n    const name = tFileName(params.file);\n    if (name !== undefined) {\n        return await apiClient.request({\n            path: `files/${name}:download`,\n            httpMethod: \"GET\",\n            queryParams: {\n                \"alt\": \"media\"\n            },\n            httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n        });\n    } else if (isGeneratedVideo(params.file)) {\n        const videoBytes = (_c = params.file.video) === null || _c === void 0 ? void 0 : _c.videoBytes;\n        if (typeof videoBytes === \"string\") {\n            return videoBytes;\n        } else {\n            throw new Error(\"Failed to download generated video, Uri or videoBytes not found.\");\n        }\n    } else if (isVideo(params.file)) {\n        const videoBytes = params.file.videoBytes;\n        if (typeof videoBytes === \"string\") {\n            return videoBytes;\n        } else {\n            throw new Error(\"Failed to download video, Uri or videoBytes not found.\");\n        }\n    } else {\n        throw new Error(\"Unsupported file type\");\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeWebSocketFactory {\n    create(url, headers, callbacks) {\n        return new NodeWebSocket(url, headers, callbacks);\n    }\n}\nclass NodeWebSocket {\n    constructor(url, headers, callbacks){\n        this.url = url;\n        this.headers = headers;\n        this.callbacks = callbacks;\n    }\n    connect() {\n        this.ws = new ws__WEBPACK_IMPORTED_MODULE_3__.WebSocket(this.url, {\n            headers: this.headers\n        });\n        this.ws.onopen = this.callbacks.onopen;\n        this.ws.onerror = this.callbacks.onerror;\n        this.ws.onclose = this.callbacks.onclose;\n        this.ws.onmessage = this.callbacks.onmessage;\n    }\n    send(message) {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.send(message);\n    }\n    close() {\n        if (this.ws === undefined) {\n            throw new Error(\"WebSocket is not connected\");\n        }\n        this.ws.close();\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ // Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction getTuningJobParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listTuningJobsConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction tuningExampleToMldev(fromObject) {\n    const toObject = {};\n    const fromTextInput = getValueByPath(fromObject, [\n        \"textInput\"\n    ]);\n    if (fromTextInput != null) {\n        setValueByPath(toObject, [\n            \"textInput\"\n        ], fromTextInput);\n    }\n    const fromOutput = getValueByPath(fromObject, [\n        \"output\"\n    ]);\n    if (fromOutput != null) {\n        setValueByPath(toObject, [\n            \"output\"\n        ], fromOutput);\n    }\n    return toObject;\n}\nfunction tuningDatasetToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]) !== undefined) {\n        throw new Error(\"gcsUri parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"vertexDatasetResource\"\n    ]) !== undefined) {\n        throw new Error(\"vertexDatasetResource parameter is not supported in Gemini API.\");\n    }\n    const fromExamples = getValueByPath(fromObject, [\n        \"examples\"\n    ]);\n    if (fromExamples != null) {\n        let transformedList = fromExamples;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningExampleToMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"examples\",\n            \"examples\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, [\n        \"validationDataset\"\n    ]) !== undefined) {\n        throw new Error(\"validationDataset parameter is not supported in Gemini API.\");\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"displayName\"\n        ], fromTunedModelDisplayName);\n    }\n    if (getValueByPath(fromObject, [\n        \"description\"\n    ]) !== undefined) {\n        throw new Error(\"description parameter is not supported in Gemini API.\");\n    }\n    const fromEpochCount = getValueByPath(fromObject, [\n        \"epochCount\"\n    ]);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"epochCount\"\n        ], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        \"learningRateMultiplier\"\n    ]);\n    if (fromLearningRateMultiplier != null) {\n        setValueByPath(toObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"learningRateMultiplier\"\n        ], fromLearningRateMultiplier);\n    }\n    if (getValueByPath(fromObject, [\n        \"exportLastCheckpointOnly\"\n    ]) !== undefined) {\n        throw new Error(\"exportLastCheckpointOnly parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"preTunedModelCheckpointId\"\n    ]) !== undefined) {\n        throw new Error(\"preTunedModelCheckpointId parameter is not supported in Gemini API.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"adapterSize\"\n    ]) !== undefined) {\n        throw new Error(\"adapterSize parameter is not supported in Gemini API.\");\n    }\n    const fromBatchSize = getValueByPath(fromObject, [\n        \"batchSize\"\n    ]);\n    if (parentObject !== undefined && fromBatchSize != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"batchSize\"\n        ], fromBatchSize);\n    }\n    const fromLearningRate = getValueByPath(fromObject, [\n        \"learningRate\"\n    ]);\n    if (parentObject !== undefined && fromLearningRate != null) {\n        setValueByPath(parentObject, [\n            \"tuningTask\",\n            \"hyperparameters\",\n            \"learningRate\"\n        ], fromLearningRate);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        \"trainingDataset\"\n    ]);\n    if (fromTrainingDataset != null) {\n        setValueByPath(toObject, [\n            \"tuningTask\",\n            \"trainingData\"\n        ], tuningDatasetToMldev(fromTrainingDataset));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createTuningJobConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"_url\",\n            \"name\"\n        ], fromName);\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], fromConfig);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, [\n        \"pageSize\"\n    ]);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageSize\"\n        ], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, [\n        \"pageToken\"\n    ]);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"pageToken\"\n        ], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, [\n        \"filter\"\n    ]);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, [\n            \"_query\",\n            \"filter\"\n        ], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], listTuningJobsConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction tuningDatasetToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (parentObject !== undefined && fromGcsUri != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"trainingDatasetUri\"\n        ], fromGcsUri);\n    }\n    const fromVertexDatasetResource = getValueByPath(fromObject, [\n        \"vertexDatasetResource\"\n    ]);\n    if (parentObject !== undefined && fromVertexDatasetResource != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"trainingDatasetUri\"\n        ], fromVertexDatasetResource);\n    }\n    if (getValueByPath(fromObject, [\n        \"examples\"\n    ]) !== undefined) {\n        throw new Error(\"examples parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction tuningValidationDatasetToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, [\n        \"gcsUri\"\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, [\n            \"validationDatasetUri\"\n        ], fromGcsUri);\n    }\n    const fromVertexDatasetResource = getValueByPath(fromObject, [\n        \"vertexDatasetResource\"\n    ]);\n    if (parentObject !== undefined && fromVertexDatasetResource != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"trainingDatasetUri\"\n        ], fromVertexDatasetResource);\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromValidationDataset = getValueByPath(fromObject, [\n        \"validationDataset\"\n    ]);\n    if (parentObject !== undefined && fromValidationDataset != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\"\n        ], tuningValidationDatasetToVertex(fromValidationDataset, toObject));\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromEpochCount = getValueByPath(fromObject, [\n        \"epochCount\"\n    ]);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"hyperParameters\",\n            \"epochCount\"\n        ], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        \"learningRateMultiplier\"\n    ]);\n    if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"hyperParameters\",\n            \"learningRateMultiplier\"\n        ], fromLearningRateMultiplier);\n    }\n    const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n        \"exportLastCheckpointOnly\"\n    ]);\n    if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"exportLastCheckpointOnly\"\n        ], fromExportLastCheckpointOnly);\n    }\n    const fromPreTunedModelCheckpointId = getValueByPath(fromObject, [\n        \"preTunedModelCheckpointId\"\n    ]);\n    if (fromPreTunedModelCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\",\n            \"checkpointId\"\n        ], fromPreTunedModelCheckpointId);\n    }\n    const fromAdapterSize = getValueByPath(fromObject, [\n        \"adapterSize\"\n    ]);\n    if (parentObject !== undefined && fromAdapterSize != null) {\n        setValueByPath(parentObject, [\n            \"supervisedTuningSpec\",\n            \"hyperParameters\",\n            \"adapterSize\"\n        ], fromAdapterSize);\n    }\n    if (getValueByPath(fromObject, [\n        \"batchSize\"\n    ]) !== undefined) {\n        throw new Error(\"batchSize parameter is not supported in Vertex AI.\");\n    }\n    if (getValueByPath(fromObject, [\n        \"learningRate\"\n    ]) !== undefined) {\n        throw new Error(\"learningRate parameter is not supported in Vertex AI.\");\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        \"trainingDataset\"\n    ]);\n    if (fromTrainingDataset != null) {\n        setValueByPath(toObject, [\n            \"supervisedTuningSpec\",\n            \"trainingDatasetUri\"\n        ], tuningDatasetToVertex(fromTrainingDataset, toObject));\n    }\n    const fromConfig = getValueByPath(fromObject, [\n        \"config\"\n    ]);\n    if (fromConfig != null) {\n        setValueByPath(toObject, [\n            \"config\"\n        ], createTuningJobConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction tunedModelFromMldev(fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, [\n            \"endpoint\"\n        ], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tuningJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"tuningTask\",\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"tuningTask\",\n        \"completeTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, [\n        \"_self\"\n    ]);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, [\n            \"tunedModel\"\n        ], tunedModelFromMldev(fromTunedModel));\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        \"customBaseModel\"\n    ]);\n    if (fromCustomBaseModel != null) {\n        setValueByPath(toObject, [\n            \"customBaseModel\"\n        ], fromCustomBaseModel);\n    }\n    const fromExperiment = getValueByPath(fromObject, [\n        \"experiment\"\n    ]);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, [\n            \"experiment\"\n        ], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromOutputUri = getValueByPath(fromObject, [\n        \"outputUri\"\n    ]);\n    if (fromOutputUri != null) {\n        setValueByPath(toObject, [\n            \"outputUri\"\n        ], fromOutputUri);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, [\n        \"pipelineJob\"\n    ]);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, [\n            \"pipelineJob\"\n        ], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        \"serviceAccount\"\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, [\n            \"serviceAccount\"\n        ], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, [\n        \"tunedModels\"\n    ]);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"tuningJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction tuningOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, [\n        \"metadata\"\n    ]);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, [\n            \"metadata\"\n        ], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, [\n        \"done\"\n    ]);\n    if (fromDone != null) {\n        setValueByPath(toObject, [\n            \"done\"\n        ], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    return toObject;\n}\nfunction tunedModelCheckpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromCheckpointId = getValueByPath(fromObject, [\n        \"checkpointId\"\n    ]);\n    if (fromCheckpointId != null) {\n        setValueByPath(toObject, [\n            \"checkpointId\"\n        ], fromCheckpointId);\n    }\n    const fromEpoch = getValueByPath(fromObject, [\n        \"epoch\"\n    ]);\n    if (fromEpoch != null) {\n        setValueByPath(toObject, [\n            \"epoch\"\n        ], fromEpoch);\n    }\n    const fromStep = getValueByPath(fromObject, [\n        \"step\"\n    ]);\n    if (fromStep != null) {\n        setValueByPath(toObject, [\n            \"step\"\n        ], fromStep);\n    }\n    const fromEndpoint = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, [\n            \"endpoint\"\n        ], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tunedModelFromVertex(fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, [\n        \"model\"\n    ]);\n    if (fromModel != null) {\n        setValueByPath(toObject, [\n            \"model\"\n        ], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, [\n        \"endpoint\"\n    ]);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, [\n            \"endpoint\"\n        ], fromEndpoint);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, [\n        \"checkpoints\"\n    ]);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tunedModelCheckpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"checkpoints\"\n        ], transformedList);\n    }\n    return toObject;\n}\nfunction tuningJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, [\n        \"name\"\n    ]);\n    if (fromName != null) {\n        setValueByPath(toObject, [\n            \"name\"\n        ], fromName);\n    }\n    const fromState = getValueByPath(fromObject, [\n        \"state\"\n    ]);\n    if (fromState != null) {\n        setValueByPath(toObject, [\n            \"state\"\n        ], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        \"createTime\"\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, [\n            \"createTime\"\n        ], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        \"startTime\"\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, [\n            \"startTime\"\n        ], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        \"endTime\"\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, [\n            \"endTime\"\n        ], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        \"updateTime\"\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, [\n            \"updateTime\"\n        ], fromUpdateTime);\n    }\n    const fromError = getValueByPath(fromObject, [\n        \"error\"\n    ]);\n    if (fromError != null) {\n        setValueByPath(toObject, [\n            \"error\"\n        ], fromError);\n    }\n    const fromDescription = getValueByPath(fromObject, [\n        \"description\"\n    ]);\n    if (fromDescription != null) {\n        setValueByPath(toObject, [\n            \"description\"\n        ], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, [\n        \"baseModel\"\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, [\n            \"baseModel\"\n        ], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, [\n        \"tunedModel\"\n    ]);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, [\n            \"tunedModel\"\n        ], tunedModelFromVertex(fromTunedModel));\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        \"preTunedModel\"\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, [\n            \"preTunedModel\"\n        ], fromPreTunedModel);\n    }\n    const fromSupervisedTuningSpec = getValueByPath(fromObject, [\n        \"supervisedTuningSpec\"\n    ]);\n    if (fromSupervisedTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"supervisedTuningSpec\"\n        ], fromSupervisedTuningSpec);\n    }\n    const fromTuningDataStats = getValueByPath(fromObject, [\n        \"tuningDataStats\"\n    ]);\n    if (fromTuningDataStats != null) {\n        setValueByPath(toObject, [\n            \"tuningDataStats\"\n        ], fromTuningDataStats);\n    }\n    const fromEncryptionSpec = getValueByPath(fromObject, [\n        \"encryptionSpec\"\n    ]);\n    if (fromEncryptionSpec != null) {\n        setValueByPath(toObject, [\n            \"encryptionSpec\"\n        ], fromEncryptionSpec);\n    }\n    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [\n        \"partnerModelTuningSpec\"\n    ]);\n    if (fromPartnerModelTuningSpec != null) {\n        setValueByPath(toObject, [\n            \"partnerModelTuningSpec\"\n        ], fromPartnerModelTuningSpec);\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        \"customBaseModel\"\n    ]);\n    if (fromCustomBaseModel != null) {\n        setValueByPath(toObject, [\n            \"customBaseModel\"\n        ], fromCustomBaseModel);\n    }\n    const fromExperiment = getValueByPath(fromObject, [\n        \"experiment\"\n    ]);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, [\n            \"experiment\"\n        ], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, [\n        \"labels\"\n    ]);\n    if (fromLabels != null) {\n        setValueByPath(toObject, [\n            \"labels\"\n        ], fromLabels);\n    }\n    const fromOutputUri = getValueByPath(fromObject, [\n        \"outputUri\"\n    ]);\n    if (fromOutputUri != null) {\n        setValueByPath(toObject, [\n            \"outputUri\"\n        ], fromOutputUri);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, [\n        \"pipelineJob\"\n    ]);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, [\n            \"pipelineJob\"\n        ], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        \"serviceAccount\"\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, [\n            \"serviceAccount\"\n        ], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        \"tunedModelDisplayName\"\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, [\n            \"tunedModelDisplayName\"\n        ], fromTunedModelDisplayName);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        \"sdkHttpResponse\"\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, [\n            \"sdkHttpResponse\"\n        ], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        \"nextPageToken\"\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, [\n            \"nextPageToken\"\n        ], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, [\n        \"tuningJobs\"\n    ]);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item)=>{\n                return tuningJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, [\n            \"tuningJobs\"\n        ], transformedList);\n    }\n    return toObject;\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class Tunings extends BaseModule {\n    constructor(apiClient){\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Gets a TuningJob.\n         *\n         * @param name - The resource name of the tuning job.\n         * @return - A TuningJob object.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.get = async (params)=>{\n            return await this.getInternal(params);\n        };\n        /**\n         * Lists tuning jobs.\n         *\n         * @param config - The configuration for the list request.\n         * @return - A list of tuning jobs.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.list = async (params = {})=>{\n            return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x)=>this.listInternal(x), await this.listInternal(params), params);\n        };\n        /**\n         * Creates a supervised fine-tuning job.\n         *\n         * @param params - The parameters for the tuning job.\n         * @return - A TuningJob operation.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */ this.tune = async (params)=>{\n            if (this.apiClient.isVertexAI()) {\n                if (params.baseModel.startsWith(\"projects/\")) {\n                    const preTunedModel = {\n                        tunedModelName: params.baseModel\n                    };\n                    const paramsPrivate = Object.assign(Object.assign({}, params), {\n                        preTunedModel: preTunedModel\n                    });\n                    paramsPrivate.baseModel = undefined;\n                    return await this.tuneInternal(paramsPrivate);\n                } else {\n                    const paramsPrivate = Object.assign({}, params);\n                    return await this.tuneInternal(paramsPrivate);\n                }\n            } else {\n                const paramsPrivate = Object.assign({}, params);\n                const operation = await this.tuneMldevInternal(paramsPrivate);\n                let tunedModelName = \"\";\n                if (operation[\"metadata\"] !== undefined && operation[\"metadata\"][\"tunedModel\"] !== undefined) {\n                    tunedModelName = operation[\"metadata\"][\"tunedModel\"];\n                } else if (operation[\"name\"] !== undefined && operation[\"name\"].includes(\"/operations/\")) {\n                    tunedModelName = operation[\"name\"].split(\"/operations/\")[0];\n                }\n                const tuningJob = {\n                    name: tunedModelName,\n                    state: JobState.JOB_STATE_QUEUED\n                };\n                return tuningJob;\n            }\n        };\n    }\n    async getInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getTuningJobParametersToVertex(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            const body = getTuningJobParametersToMldev(params);\n            path = formatMap(\"{name}\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listTuningJobsParametersToVertex(params);\n            path = formatMap(\"tuningJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listTuningJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        } else {\n            const body = listTuningJobsParametersToMldev(params);\n            path = formatMap(\"tunedModels\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"GET\",\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = listTuningJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async tuneInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createTuningJobParametersPrivateToVertex(params);\n            path = formatMap(\"tuningJobs\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        } else {\n            throw new Error(\"This method is only supported by the Vertex AI.\");\n        }\n    }\n    async tuneMldevInternal(params) {\n        var _a, _b;\n        let response;\n        let path = \"\";\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error(\"This method is only supported by the Gemini Developer API.\");\n        } else {\n            const body = createTuningJobParametersPrivateToMldev(params);\n            path = formatMap(\"tunedModels\", body[\"_url\"]);\n            queryParams = body[\"_query\"];\n            delete body[\"config\"];\n            delete body[\"_url\"];\n            delete body[\"_query\"];\n            response = this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: \"POST\",\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal\n            }).then((httpResponse)=>{\n                return httpResponse.json().then((jsonResponse)=>{\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse)=>{\n                const resp = tuningOperationFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 8; // bytes\nconst MAX_RETRY_COUNT = 3;\nconst INITIAL_RETRY_DELAY_MS = 1000;\nconst DELAY_MULTIPLIER = 2;\nconst X_GOOG_UPLOAD_STATUS_HEADER_FIELD = \"x-goog-upload-status\";\nasync function uploadBlob(file, uploadUrl, apiClient) {\n    var _a, _b, _c;\n    let fileSize = 0;\n    let offset = 0;\n    let response = new HttpResponse(new Response());\n    let uploadCommand = \"upload\";\n    fileSize = file.size;\n    while(offset < fileSize){\n        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n        const chunk = file.slice(offset, offset + chunkSize);\n        if (offset + chunkSize >= fileSize) {\n            uploadCommand += \", finalize\";\n        }\n        let retryCount = 0;\n        let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n        while(retryCount < MAX_RETRY_COUNT){\n            response = await apiClient.request({\n                path: \"\",\n                body: chunk,\n                httpMethod: \"POST\",\n                httpOptions: {\n                    apiVersion: \"\",\n                    baseUrl: uploadUrl,\n                    headers: {\n                        \"X-Goog-Upload-Command\": uploadCommand,\n                        \"X-Goog-Upload-Offset\": String(offset),\n                        \"Content-Length\": String(chunkSize)\n                    }\n                }\n            });\n            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                break;\n            }\n            retryCount++;\n            await sleep(currentDelayMs);\n            currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n        }\n        offset += chunkSize;\n        // The `x-goog-upload-status` header field can be `active`, `final` and\n        //`cancelled` in resposne.\n        if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"active\") {\n            break;\n        }\n        // TODO(b/401391430) Investigate why the upload status is not finalized\n        // even though all content has been uploaded.\n        if (fileSize <= offset) {\n            throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n        }\n    }\n    const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n    if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n        throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n    }\n    return responseJson[\"file\"];\n}\nasync function getBlobStat(file) {\n    const fileStat = {\n        size: file.size,\n        type: file.type\n    };\n    return fileStat;\n}\nfunction sleep(ms) {\n    return new Promise((resolvePromise)=>setTimeout(resolvePromise, ms));\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ class NodeUploader {\n    async stat(file) {\n        const fileStat = {\n            size: 0,\n            type: undefined\n        };\n        if (typeof file === \"string\") {\n            const originalStat = await fs_promises__WEBPACK_IMPORTED_MODULE_4__.stat(file);\n            fileStat.size = originalStat.size;\n            fileStat.type = this.inferMimeType(file);\n            return fileStat;\n        } else {\n            return await getBlobStat(file);\n        }\n    }\n    async upload(file, uploadUrl, apiClient) {\n        if (typeof file === \"string\") {\n            return await this.uploadFileFromPath(file, uploadUrl, apiClient);\n        } else {\n            return uploadBlob(file, uploadUrl, apiClient);\n        }\n    }\n    /**\n     * Infers the MIME type of a file based on its extension.\n     *\n     * @param filePath The path to the file.\n     * @returns The MIME type of the file, or undefined if it cannot be inferred.\n     */ inferMimeType(filePath) {\n        // Get the file extension.\n        const fileExtension = filePath.slice(filePath.lastIndexOf(\".\") + 1);\n        // Create a map of file extensions to MIME types.\n        const mimeTypes = {\n            \"aac\": \"audio/aac\",\n            \"abw\": \"application/x-abiword\",\n            \"arc\": \"application/x-freearc\",\n            \"avi\": \"video/x-msvideo\",\n            \"azw\": \"application/vnd.amazon.ebook\",\n            \"bin\": \"application/octet-stream\",\n            \"bmp\": \"image/bmp\",\n            \"bz\": \"application/x-bzip\",\n            \"bz2\": \"application/x-bzip2\",\n            \"csh\": \"application/x-csh\",\n            \"css\": \"text/css\",\n            \"csv\": \"text/csv\",\n            \"doc\": \"application/msword\",\n            \"docx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n            \"eot\": \"application/vnd.ms-fontobject\",\n            \"epub\": \"application/epub+zip\",\n            \"gz\": \"application/gzip\",\n            \"gif\": \"image/gif\",\n            \"htm\": \"text/html\",\n            \"html\": \"text/html\",\n            \"ico\": \"image/vnd.microsoft.icon\",\n            \"ics\": \"text/calendar\",\n            \"jar\": \"application/java-archive\",\n            \"jpeg\": \"image/jpeg\",\n            \"jpg\": \"image/jpeg\",\n            \"js\": \"text/javascript\",\n            \"json\": \"application/json\",\n            \"jsonld\": \"application/ld+json\",\n            \"kml\": \"application/vnd.google-earth.kml+xml\",\n            \"kmz\": \"application/vnd.google-earth.kmz+xml\",\n            \"mjs\": \"text/javascript\",\n            \"mp3\": \"audio/mpeg\",\n            \"mp4\": \"video/mp4\",\n            \"mpeg\": \"video/mpeg\",\n            \"mpkg\": \"application/vnd.apple.installer+xml\",\n            \"odt\": \"application/vnd.oasis.opendocument.text\",\n            \"oga\": \"audio/ogg\",\n            \"ogv\": \"video/ogg\",\n            \"ogx\": \"application/ogg\",\n            \"opus\": \"audio/opus\",\n            \"otf\": \"font/otf\",\n            \"png\": \"image/png\",\n            \"pdf\": \"application/pdf\",\n            \"php\": \"application/x-httpd-php\",\n            \"ppt\": \"application/vnd.ms-powerpoint\",\n            \"pptx\": \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n            \"rar\": \"application/vnd.rar\",\n            \"rtf\": \"application/rtf\",\n            \"sh\": \"application/x-sh\",\n            \"svg\": \"image/svg+xml\",\n            \"swf\": \"application/x-shockwave-flash\",\n            \"tar\": \"application/x-tar\",\n            \"tif\": \"image/tiff\",\n            \"tiff\": \"image/tiff\",\n            \"ts\": \"video/mp2t\",\n            \"ttf\": \"font/ttf\",\n            \"txt\": \"text/plain\",\n            \"vsd\": \"application/vnd.visio\",\n            \"wav\": \"audio/wav\",\n            \"weba\": \"audio/webm\",\n            \"webm\": \"video/webm\",\n            \"webp\": \"image/webp\",\n            \"woff\": \"font/woff\",\n            \"woff2\": \"font/woff2\",\n            \"xhtml\": \"application/xhtml+xml\",\n            \"xls\": \"application/vnd.ms-excel\",\n            \"xlsx\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n            \"xml\": \"application/xml\",\n            \"xul\": \"application/vnd.mozilla.xul+xml\",\n            \"zip\": \"application/zip\",\n            \"3gp\": \"video/3gpp\",\n            \"3g2\": \"video/3gpp2\",\n            \"7z\": \"application/x-7z-compressed\"\n        };\n        // Look up the MIME type based on the file extension.\n        const mimeType = mimeTypes[fileExtension.toLowerCase()];\n        // Return the MIME type.\n        return mimeType;\n    }\n    async uploadFileFromPath(file, uploadUrl, apiClient) {\n        var _a, _b, _c;\n        let fileSize = 0;\n        let offset = 0;\n        let response = new HttpResponse(new Response());\n        let uploadCommand = \"upload\";\n        let fileHandle;\n        try {\n            fileHandle = await fs_promises__WEBPACK_IMPORTED_MODULE_4__.open(file, \"r\");\n            if (!fileHandle) {\n                throw new Error(`Failed to open file`);\n            }\n            fileSize = (await fileHandle.stat()).size;\n            while(offset < fileSize){\n                const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n                if (offset + chunkSize >= fileSize) {\n                    uploadCommand += \", finalize\";\n                }\n                const buffer = new Uint8Array(chunkSize);\n                const { bytesRead: bytesRead } = await fileHandle.read(buffer, 0, chunkSize, offset);\n                if (bytesRead !== chunkSize) {\n                    throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);\n                }\n                const chunk = new Blob([\n                    buffer\n                ]);\n                let retryCount = 0;\n                let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n                while(retryCount < MAX_RETRY_COUNT){\n                    response = await apiClient.request({\n                        path: \"\",\n                        body: chunk,\n                        httpMethod: \"POST\",\n                        httpOptions: {\n                            apiVersion: \"\",\n                            baseUrl: uploadUrl,\n                            headers: {\n                                \"X-Goog-Upload-Command\": uploadCommand,\n                                \"X-Goog-Upload-Offset\": String(offset),\n                                \"Content-Length\": String(bytesRead)\n                            }\n                        }\n                    });\n                    if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                        break;\n                    }\n                    retryCount++;\n                    await sleep(currentDelayMs);\n                    currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n                }\n                offset += bytesRead;\n                // The `x-goog-upload-status` header field can be `active`, `final` and\n                //`cancelled` in resposne.\n                if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"active\") {\n                    break;\n                }\n                if (fileSize <= offset) {\n                    throw new Error(\"All content has been uploaded, but the upload status is not finalized.\");\n                }\n            }\n            const responseJson = await (response === null || response === void 0 ? void 0 : response.json());\n            if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== \"final\") {\n                throw new Error(\"Failed to upload file: Upload status is not finalized.\");\n            }\n            return responseJson[\"file\"];\n        } finally{\n            // Ensure the file handle is always closed\n            if (fileHandle) {\n                await fileHandle.close();\n            }\n        }\n    }\n}\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */ const LANGUAGE_LABEL_PREFIX = \"gl-node/\";\n/**\n * The Google GenAI SDK.\n *\n * @remarks\n * Provides access to the GenAI features through either the {@link\n * https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or\n * the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI\n * API}.\n *\n * The {@link GoogleGenAIOptions.vertexai} value determines which of the API\n * services to use.\n *\n * When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be\n * set. When using Vertex AI, both {@link GoogleGenAIOptions.project} and {@link\n * GoogleGenAIOptions.location} must be set, or a {@link\n * GoogleGenAIOptions.apiKey} must be set when using Express Mode.\n *\n * Explicitly passed in values in {@link GoogleGenAIOptions} will always take\n * precedence over environment variables. If both project/location and api_key\n * exist in the environment variables, the project/location will be used.\n *\n * @example\n * Initializing the SDK for using the Gemini API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n *\n * @example\n * Initializing the SDK for using the Vertex AI API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({\n *   vertexai: true,\n *   project: 'PROJECT_ID',\n *   location: 'PROJECT_LOCATION'\n * });\n * ```\n *\n */ class GoogleGenAI {\n    constructor(options){\n        var _a, _b, _c, _d, _e, _f;\n        // Validate explicitly set initializer values.\n        if ((options.project || options.location) && options.apiKey) {\n            throw new Error(\"Project/location and API key are mutually exclusive in the client initializer.\");\n        }\n        this.vertexai = (_b = (_a = options.vertexai) !== null && _a !== void 0 ? _a : getBooleanEnv(\"GOOGLE_GENAI_USE_VERTEXAI\")) !== null && _b !== void 0 ? _b : false;\n        const envApiKey = getApiKeyFromEnv();\n        const envProject = getEnv(\"GOOGLE_CLOUD_PROJECT\");\n        const envLocation = getEnv(\"GOOGLE_CLOUD_LOCATION\");\n        this.apiKey = (_c = options.apiKey) !== null && _c !== void 0 ? _c : envApiKey;\n        this.project = (_d = options.project) !== null && _d !== void 0 ? _d : envProject;\n        this.location = (_e = options.location) !== null && _e !== void 0 ? _e : envLocation;\n        // Handle when to use Vertex AI in express mode (api key)\n        if (options.vertexai) {\n            if ((_f = options.googleAuthOptions) === null || _f === void 0 ? void 0 : _f.credentials) {\n                // Explicit credentials take precedence over implicit api_key.\n                console.debug(\"The user provided Google Cloud credentials will take precedence\" + \" over the API key from the environment variable.\");\n                this.apiKey = undefined;\n            }\n            // Explicit api_key and explicit project/location already handled above.\n            if ((envProject || envLocation) && options.apiKey) {\n                // Explicit api_key takes precedence over implicit project/location.\n                console.debug(\"The user provided Vertex AI API key will take precedence over\" + \" the project/location from the environment variables.\");\n                this.project = undefined;\n                this.location = undefined;\n            } else if ((options.project || options.location) && envApiKey) {\n                // Explicit project/location takes precedence over implicit api_key.\n                console.debug(\"The user provided project/location will take precedence over\" + \" the API key from the environment variables.\");\n                this.apiKey = undefined;\n            } else if ((envProject || envLocation) && envApiKey) {\n                // Implicit project/location takes precedence over implicit api_key.\n                console.debug(\"The project/location from the environment variables will take\" + \" precedence over the API key from the environment variables.\");\n                this.apiKey = undefined;\n            }\n        }\n        const baseUrl = getBaseUrl(options.httpOptions, options.vertexai, getEnv(\"GOOGLE_VERTEX_BASE_URL\"), getEnv(\"GOOGLE_GEMINI_BASE_URL\"));\n        if (baseUrl) {\n            if (options.httpOptions) {\n                options.httpOptions.baseUrl = baseUrl;\n            } else {\n                options.httpOptions = {\n                    baseUrl: baseUrl\n                };\n            }\n        }\n        this.apiVersion = options.apiVersion;\n        const auth = new NodeAuth({\n            apiKey: this.apiKey,\n            googleAuthOptions: options.googleAuthOptions\n        });\n        this.apiClient = new ApiClient({\n            auth: auth,\n            project: this.project,\n            location: this.location,\n            apiVersion: this.apiVersion,\n            apiKey: this.apiKey,\n            vertexai: this.vertexai,\n            httpOptions: options.httpOptions,\n            userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,\n            uploader: new NodeUploader(),\n            downloader: new NodeDownloader()\n        });\n        this.models = new Models(this.apiClient);\n        this.live = new Live(this.apiClient, auth, new NodeWebSocketFactory());\n        this.batches = new Batches(this.apiClient);\n        this.chats = new Chats(this.models, this.apiClient);\n        this.caches = new Caches(this.apiClient);\n        this.files = new Files(this.apiClient);\n        this.operations = new Operations(this.apiClient);\n        this.authTokens = new Tokens(this.apiClient);\n        this.tunings = new Tunings(this.apiClient);\n    }\n}\nfunction getEnv(env) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : undefined;\n}\nfunction getBooleanEnv(env) {\n    return stringToBoolean(getEnv(env));\n}\nfunction stringToBoolean(str) {\n    if (str === undefined) {\n        return false;\n    }\n    return str.toLowerCase() === \"true\";\n}\nfunction getApiKeyFromEnv() {\n    const envGoogleApiKey = getEnv(\"GOOGLE_API_KEY\");\n    const envGeminiApiKey = getEnv(\"GEMINI_API_KEY\");\n    if (envGoogleApiKey && envGeminiApiKey) {\n        console.warn(\"Both GOOGLE_API_KEY and GEMINI_API_KEY are set. Using GOOGLE_API_KEY.\");\n    }\n    return envGoogleApiKey || envGeminiApiKey;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L25vZGUvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ0M7QUFDWDtBQUNWO0FBQ0s7QUFFbEM7Ozs7Q0FJQyxHQUNELElBQUlNLHdCQUF3QkM7QUFDNUIsSUFBSUMsd0JBQXdCRDtBQUM1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELFNBQVNFLG1CQUFtQkMsYUFBYTtJQUNyQ0osd0JBQXdCSSxjQUFjQyxTQUFTO0lBQy9DSCx3QkFBd0JFLGNBQWNFLFNBQVM7QUFDbkQ7QUFDQTs7Q0FFQyxHQUNELFNBQVNDO0lBQ0wsT0FBTztRQUNIRixXQUFXTDtRQUNYTSxXQUFXSjtJQUNmO0FBQ0o7QUFDQTs7Ozs7Q0FLQyxHQUNELFNBQVNNLFdBQVdDLFdBQVcsRUFBRUMsUUFBUSxFQUFFQyxvQkFBb0IsRUFBRUMsb0JBQW9CO0lBQ2pGLElBQUlDLElBQUlDO0lBQ1IsSUFBSSxDQUFFTCxDQUFBQSxnQkFBZ0IsUUFBUUEsZ0JBQWdCLEtBQUssSUFBSSxLQUFLLElBQUlBLFlBQVlNLE9BQU8sR0FBRztRQUNsRixNQUFNQyxrQkFBa0JUO1FBQ3hCLElBQUlHLFVBQVU7WUFDVixPQUFPLENBQUNHLEtBQUtHLGdCQUFnQlYsU0FBUyxNQUFNLFFBQVFPLE9BQU8sS0FBSyxJQUFJQSxLQUFLRjtRQUM3RSxPQUNLO1lBQ0QsT0FBTyxDQUFDRyxLQUFLRSxnQkFBZ0JYLFNBQVMsTUFBTSxRQUFRUyxPQUFPLEtBQUssSUFBSUEsS0FBS0Y7UUFDN0U7SUFDSjtJQUNBLE9BQU9ILFlBQVlNLE9BQU87QUFDOUI7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUU7QUFDTjtBQUNBLFNBQVNDLFVBQVVDLGNBQWMsRUFBRUMsUUFBUTtJQUN2QywyRUFBMkU7SUFDM0UsTUFBTUMsUUFBUTtJQUNkLDBFQUEwRTtJQUMxRSxPQUFPRixlQUFlRyxPQUFPLENBQUNELE9BQU8sQ0FBQ0UsT0FBT0M7UUFDekMsSUFBSUMsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ1IsVUFBVUksTUFBTTtZQUNyRCxNQUFNSyxRQUFRVCxRQUFRLENBQUNJLElBQUk7WUFDM0IsNkRBQTZEO1lBQzdELE9BQU9LLFVBQVU1QixhQUFhNEIsVUFBVSxPQUFPQyxPQUFPRCxTQUFTO1FBQ25FLE9BQ0s7WUFDRCxzQkFBc0I7WUFDdEIsTUFBTSxJQUFJRSxNQUFNLENBQUMsS0FBSyxFQUFFUCxJQUFJLHdCQUF3QixDQUFDO1FBQ3pEO0lBQ0o7QUFDSjtBQUNBLFNBQVNRLGVBQWVDLElBQUksRUFBRUMsSUFBSSxFQUFFTCxLQUFLO0lBQ3JDLElBQUssSUFBSU0sSUFBSSxHQUFHQSxJQUFJRCxLQUFLRSxNQUFNLEdBQUcsR0FBR0QsSUFBSztRQUN0QyxNQUFNWCxNQUFNVSxJQUFJLENBQUNDLEVBQUU7UUFDbkIsSUFBSVgsSUFBSWEsUUFBUSxDQUFDLE9BQU87WUFDcEIsTUFBTUMsVUFBVWQsSUFBSWUsS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUM5QixJQUFJLENBQUVELENBQUFBLFdBQVdMLElBQUcsR0FBSTtnQkFDcEIsSUFBSU8sTUFBTUMsT0FBTyxDQUFDWixRQUFRO29CQUN0QkksSUFBSSxDQUFDSyxRQUFRLEdBQUdFLE1BQU1FLElBQUksQ0FBQzt3QkFBRU4sUUFBUVAsTUFBTU8sTUFBTTtvQkFBQyxHQUFHLElBQU8sRUFBQztnQkFDakUsT0FDSztvQkFDRCxNQUFNLElBQUlMLE1BQU0sQ0FBQyx5Q0FBeUMsRUFBRVAsSUFBSSxDQUFDO2dCQUNyRTtZQUNKO1lBQ0EsSUFBSWdCLE1BQU1DLE9BQU8sQ0FBQ1IsSUFBSSxDQUFDSyxRQUFRLEdBQUc7Z0JBQzlCLE1BQU1LLFlBQVlWLElBQUksQ0FBQ0ssUUFBUTtnQkFDL0IsSUFBSUUsTUFBTUMsT0FBTyxDQUFDWixRQUFRO29CQUN0QixJQUFLLElBQUllLElBQUksR0FBR0EsSUFBSUQsVUFBVVAsTUFBTSxFQUFFUSxJQUFLO3dCQUN2QyxNQUFNQyxRQUFRRixTQUFTLENBQUNDLEVBQUU7d0JBQzFCWixlQUFlYSxPQUFPWCxLQUFLSyxLQUFLLENBQUNKLElBQUksSUFBSU4sS0FBSyxDQUFDZSxFQUFFO29CQUNyRDtnQkFDSixPQUNLO29CQUNELEtBQUssTUFBTUUsS0FBS0gsVUFBVzt3QkFDdkJYLGVBQWVjLEdBQUdaLEtBQUtLLEtBQUssQ0FBQ0osSUFBSSxJQUFJTjtvQkFDekM7Z0JBQ0o7WUFDSjtZQUNBO1FBQ0osT0FDSyxJQUFJTCxJQUFJYSxRQUFRLENBQUMsUUFBUTtZQUMxQixNQUFNQyxVQUFVZCxJQUFJZSxLQUFLLENBQUMsR0FBRyxDQUFDO1lBQzlCLElBQUksQ0FBRUQsQ0FBQUEsV0FBV0wsSUFBRyxHQUFJO2dCQUNwQkEsSUFBSSxDQUFDSyxRQUFRLEdBQUc7b0JBQUMsQ0FBQztpQkFBRTtZQUN4QjtZQUNBLE1BQU1LLFlBQVlWLElBQUksQ0FBQ0ssUUFBUTtZQUMvQk4sZUFBZVcsU0FBUyxDQUFDLEVBQUUsRUFBRVQsS0FBS0ssS0FBSyxDQUFDSixJQUFJLElBQUlOO1lBQ2hEO1FBQ0o7UUFDQSxJQUFJLENBQUNJLElBQUksQ0FBQ1QsSUFBSSxJQUFJLE9BQU9TLElBQUksQ0FBQ1QsSUFBSSxLQUFLLFVBQVU7WUFDN0NTLElBQUksQ0FBQ1QsSUFBSSxHQUFHLENBQUM7UUFDakI7UUFDQVMsT0FBT0EsSUFBSSxDQUFDVCxJQUFJO0lBQ3BCO0lBQ0EsTUFBTXVCLFdBQVdiLElBQUksQ0FBQ0EsS0FBS0UsTUFBTSxHQUFHLEVBQUU7SUFDdEMsTUFBTVksZUFBZWYsSUFBSSxDQUFDYyxTQUFTO0lBQ25DLElBQUlDLGlCQUFpQi9DLFdBQVc7UUFDNUIsSUFBSSxDQUFDNEIsU0FDQSxPQUFPQSxVQUFVLFlBQVlKLE9BQU9TLElBQUksQ0FBQ0wsT0FBT08sTUFBTSxLQUFLLEdBQUk7WUFDaEU7UUFDSjtRQUNBLElBQUlQLFVBQVVtQixjQUFjO1lBQ3hCO1FBQ0o7UUFDQSxJQUFJLE9BQU9BLGlCQUFpQixZQUN4QixPQUFPbkIsVUFBVSxZQUNqQm1CLGlCQUFpQixRQUNqQm5CLFVBQVUsTUFBTTtZQUNoQkosT0FBT3dCLE1BQU0sQ0FBQ0QsY0FBY25CO1FBQ2hDLE9BQ0s7WUFDRCxNQUFNLElBQUlFLE1BQU0sQ0FBQywyQ0FBMkMsRUFBRWdCLFNBQVMsQ0FBQztRQUM1RTtJQUNKLE9BQ0s7UUFDRGQsSUFBSSxDQUFDYyxTQUFTLEdBQUdsQjtJQUNyQjtBQUNKO0FBQ0EsU0FBU3FCLGVBQWVqQixJQUFJLEVBQUVDLElBQUk7SUFDOUIsSUFBSTtRQUNBLElBQUlBLEtBQUtFLE1BQU0sS0FBSyxLQUFLRixJQUFJLENBQUMsRUFBRSxLQUFLLFNBQVM7WUFDMUMsT0FBT0Q7UUFDWDtRQUNBLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJRCxLQUFLRSxNQUFNLEVBQUVELElBQUs7WUFDbEMsSUFBSSxPQUFPRixTQUFTLFlBQVlBLFNBQVMsTUFBTTtnQkFDM0MsT0FBT2hDO1lBQ1g7WUFDQSxNQUFNdUIsTUFBTVUsSUFBSSxDQUFDQyxFQUFFO1lBQ25CLElBQUlYLElBQUlhLFFBQVEsQ0FBQyxPQUFPO2dCQUNwQixNQUFNQyxVQUFVZCxJQUFJZSxLQUFLLENBQUMsR0FBRyxDQUFDO2dCQUM5QixJQUFJRCxXQUFXTCxNQUFNO29CQUNqQixNQUFNVSxZQUFZVixJQUFJLENBQUNLLFFBQVE7b0JBQy9CLElBQUksQ0FBQ0UsTUFBTUMsT0FBTyxDQUFDRSxZQUFZO3dCQUMzQixPQUFPMUM7b0JBQ1g7b0JBQ0EsT0FBTzBDLFVBQVVRLEdBQUcsQ0FBQyxDQUFDTCxJQUFNSSxlQUFlSixHQUFHWixLQUFLSyxLQUFLLENBQUNKLElBQUk7Z0JBQ2pFLE9BQ0s7b0JBQ0QsT0FBT2xDO2dCQUNYO1lBQ0osT0FDSztnQkFDRGdDLE9BQU9BLElBQUksQ0FBQ1QsSUFBSTtZQUNwQjtRQUNKO1FBQ0EsT0FBT1M7SUFDWCxFQUNBLE9BQU9tQixPQUFPO1FBQ1YsSUFBSUEsaUJBQWlCQyxXQUFXO1lBQzVCLE9BQU9wRDtRQUNYO1FBQ0EsTUFBTW1EO0lBQ1Y7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTRSxTQUFTQyxTQUFTO0lBQ3ZCLElBQUksT0FBT0EsY0FBYyxVQUFVO1FBQy9CLE1BQU0sSUFBSXhCLE1BQU07SUFDcEI7SUFDQSxtREFBbUQ7SUFDbkQsT0FBT3dCO0FBQ1g7QUFFQTs7OztDQUlDLEdBQ0QsaUVBQWlFO0FBQ2pFLDZDQUE2QyxHQUM3QyxJQUFJQztBQUNILFVBQVVBLE9BQU87SUFDZDs7S0FFQyxHQUNEQSxPQUFPLENBQUMsc0JBQXNCLEdBQUc7SUFDakM7O0tBRUMsR0FDREEsT0FBTyxDQUFDLGFBQWEsR0FBRztJQUN4Qjs7S0FFQyxHQUNEQSxPQUFPLENBQUMsaUJBQWlCLEdBQUc7SUFDNUI7O0tBRUMsR0FDREEsT0FBTyxDQUFDLDRCQUE0QixHQUFHO0FBQzNDLEdBQUdBLFdBQVlBLENBQUFBLFVBQVUsQ0FBQztBQUMxQixrREFBa0QsR0FDbEQsSUFBSUM7QUFDSCxVQUFVQSxRQUFRO0lBQ2Y7O0tBRUMsR0FDREEsUUFBUSxDQUFDLHVCQUF1QixHQUFHO0lBQ25DOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxTQUFTLEdBQUc7QUFDekIsR0FBR0EsWUFBYUEsQ0FBQUEsV0FBVyxDQUFDO0FBQzVCLG9DQUFvQyxHQUNwQyxJQUFJQztBQUNILFVBQVVBLElBQUk7SUFDWDs7S0FFQyxHQUNEQSxJQUFJLENBQUMsbUJBQW1CLEdBQUc7SUFDM0I7O0tBRUMsR0FDREEsSUFBSSxDQUFDLFNBQVMsR0FBRztJQUNqQjs7S0FFQyxHQUNEQSxJQUFJLENBQUMsU0FBUyxHQUFHO0lBQ2pCOztLQUVDLEdBQ0RBLElBQUksQ0FBQyxVQUFVLEdBQUc7SUFDbEI7O0tBRUMsR0FDREEsSUFBSSxDQUFDLFVBQVUsR0FBRztJQUNsQjs7S0FFQyxHQUNEQSxJQUFJLENBQUMsUUFBUSxHQUFHO0lBQ2hCOztLQUVDLEdBQ0RBLElBQUksQ0FBQyxTQUFTLEdBQUc7SUFDakI7O0tBRUMsR0FDREEsSUFBSSxDQUFDLE9BQU8sR0FBRztBQUNuQixHQUFHQSxRQUFTQSxDQUFBQSxPQUFPLENBQUM7QUFDcEIsNkJBQTZCLEdBQzdCLElBQUlDO0FBQ0gsVUFBVUEsWUFBWTtJQUNuQjs7S0FFQyxHQUNEQSxZQUFZLENBQUMsNEJBQTRCLEdBQUc7SUFDNUM7O0tBRUMsR0FDREEsWUFBWSxDQUFDLDRCQUE0QixHQUFHO0lBQzVDOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxrQ0FBa0MsR0FBRztJQUNsRDs7S0FFQyxHQUNEQSxZQUFZLENBQUMsMkJBQTJCLEdBQUc7SUFDM0M7O0tBRUMsR0FDREEsWUFBWSxDQUFDLGtDQUFrQyxHQUFHO0lBQ2xEOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxnQ0FBZ0MsR0FBRztJQUNoRDs7S0FFQyxHQUNEQSxZQUFZLENBQUMsMkJBQTJCLEdBQUc7SUFDM0M7O0tBRUMsR0FDREEsWUFBWSxDQUFDLHdDQUF3QyxHQUFHO0lBQ3hEOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxpQ0FBaUMsR0FBRztJQUNqRDs7S0FFQyxHQUNEQSxZQUFZLENBQUMsd0NBQXdDLEdBQUc7QUFDNUQsR0FBR0EsZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUM7QUFDcEMsaUpBQWlKLEdBQ2pKLElBQUlDO0FBQ0gsVUFBVUEsZUFBZTtJQUN0Qjs7S0FFQyxHQUNEQSxlQUFlLENBQUMsZ0NBQWdDLEdBQUc7SUFDbkQ7O0tBRUMsR0FDREEsZUFBZSxDQUFDLFdBQVcsR0FBRztJQUM5Qjs7S0FFQyxHQUNEQSxlQUFlLENBQUMsY0FBYyxHQUFHO0FBQ3JDLEdBQUdBLG1CQUFvQkEsQ0FBQUEsa0JBQWtCLENBQUM7QUFDMUMsd0NBQXdDLEdBQ3hDLElBQUlDO0FBQ0gsVUFBVUEsa0JBQWtCO0lBQ3pCOztLQUVDLEdBQ0RBLGtCQUFrQixDQUFDLG1DQUFtQyxHQUFHO0lBQ3pEOztLQUVDLEdBQ0RBLGtCQUFrQixDQUFDLHNCQUFzQixHQUFHO0lBQzVDOztLQUVDLEdBQ0RBLGtCQUFrQixDQUFDLHlCQUF5QixHQUFHO0lBQy9DOztLQUVDLEdBQ0RBLGtCQUFrQixDQUFDLGtCQUFrQixHQUFHO0lBQ3hDOztLQUVDLEdBQ0RBLGtCQUFrQixDQUFDLGFBQWEsR0FBRztJQUNuQzs7S0FFQyxHQUNEQSxrQkFBa0IsQ0FBQyxNQUFNLEdBQUc7QUFDaEMsR0FBR0Esc0JBQXVCQSxDQUFBQSxxQkFBcUIsQ0FBQztBQUNoRCwrREFBK0QsR0FDL0QsSUFBSUM7QUFDSCxVQUFVQSxJQUFJO0lBQ1g7O0tBRUMsR0FDREEsSUFBSSxDQUFDLG1CQUFtQixHQUFHO0lBQzNCOztLQUVDLEdBQ0RBLElBQUksQ0FBQyxlQUFlLEdBQUc7QUFDM0IsR0FBR0EsUUFBU0EsQ0FBQUEsT0FBTyxDQUFDO0FBQ3BCLHlCQUF5QixHQUN6QixJQUFJQztBQUNILFVBQVVBLFFBQVE7SUFDZkEsUUFBUSxDQUFDLHdCQUF3QixHQUFHO0lBQ3BDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxVQUFVLEdBQUc7SUFDdEI7O0tBRUMsR0FDREEsUUFBUSxDQUFDLGVBQWUsR0FBRztJQUMzQjs7S0FFQyxHQUNEQSxRQUFRLENBQUMsa0JBQWtCLEdBQUc7SUFDOUI7O0tBRUMsR0FDREEsUUFBUSxDQUFDLDhCQUE4QixHQUFHO0lBQzFDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxRQUFRLEdBQUc7SUFDcEI7O0tBRUMsR0FDREEsUUFBUSxDQUFDLFlBQVksR0FBRztBQUM1QixHQUFHQSxZQUFhQSxDQUFBQSxXQUFXLENBQUM7QUFDNUIsbURBQW1ELEdBQ25ELElBQUlDO0FBQ0gsVUFBVUEsT0FBTztJQUNkOztLQUVDLEdBQ0RBLE9BQU8sQ0FBQyx1QkFBdUIsR0FBRztJQUNsQzs7S0FFQyxHQUNEQSxPQUFPLENBQUMsZ0JBQWdCLEdBQUc7SUFDM0I7O0tBRUMsR0FDREEsT0FBTyxDQUFDLGlCQUFpQixHQUFHO0FBQ2hDLEdBQUdBLFdBQVlBLENBQUFBLFVBQVUsQ0FBQztBQUMxQixpQ0FBaUMsR0FDakMsSUFBSUM7QUFDSCxVQUFVQSxrQkFBa0I7SUFDekI7O0tBRUMsR0FDREEsa0JBQWtCLENBQUMsbUNBQW1DLEdBQUc7SUFDekQ7O0tBRUMsR0FDREEsa0JBQWtCLENBQUMsK0JBQStCLEdBQUc7SUFDckQ7O0tBRUMsR0FDREEsa0JBQWtCLENBQUMsNkJBQTZCLEdBQUc7SUFDbkQ7O0tBRUMsR0FDREEsa0JBQWtCLENBQUMsK0JBQStCLEdBQUc7SUFDckQ7O0tBRUMsR0FDREEsa0JBQWtCLENBQUMsOEJBQThCLEdBQUc7QUFDeEQsR0FBR0Esc0JBQXVCQSxDQUFBQSxxQkFBcUIsQ0FBQztBQUNoRDs7O0dBR0csR0FDSCxJQUFJQztBQUNILFVBQVVBLFlBQVk7SUFDbkI7O0tBRUMsR0FDREEsWUFBWSxDQUFDLDRCQUE0QixHQUFHO0lBQzVDOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxPQUFPLEdBQUc7SUFDdkI7O0tBRUMsR0FDREEsWUFBWSxDQUFDLGFBQWEsR0FBRztJQUM3Qjs7S0FFQyxHQUNEQSxZQUFZLENBQUMsU0FBUyxHQUFHO0lBQ3pCOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxhQUFhLEdBQUc7SUFDN0I7O0tBRUMsR0FDREEsWUFBWSxDQUFDLFdBQVcsR0FBRztJQUMzQjs7S0FFQyxHQUNEQSxZQUFZLENBQUMsUUFBUSxHQUFHO0lBQ3hCOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxZQUFZLEdBQUc7SUFDNUI7O0tBRUMsR0FDREEsWUFBWSxDQUFDLHFCQUFxQixHQUFHO0lBQ3JDOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxPQUFPLEdBQUc7SUFDdkI7O0tBRUMsR0FDREEsWUFBWSxDQUFDLDBCQUEwQixHQUFHO0lBQzFDOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyxlQUFlLEdBQUc7SUFDL0I7O0tBRUMsR0FDREEsWUFBWSxDQUFDLHVCQUF1QixHQUFHO0FBQzNDLEdBQUdBLGdCQUFpQkEsQ0FBQUEsZUFBZSxDQUFDO0FBQ3BDLHlEQUF5RCxHQUN6RCxJQUFJQztBQUNILFVBQVVBLGVBQWU7SUFDdEI7O0tBRUMsR0FDREEsZUFBZSxDQUFDLCtCQUErQixHQUFHO0lBQ2xEOztLQUVDLEdBQ0RBLGVBQWUsQ0FBQyxhQUFhLEdBQUc7SUFDaEM7O0tBRUMsR0FDREEsZUFBZSxDQUFDLE1BQU0sR0FBRztJQUN6Qjs7S0FFQyxHQUNEQSxlQUFlLENBQUMsU0FBUyxHQUFHO0lBQzVCOztLQUVDLEdBQ0RBLGVBQWUsQ0FBQyxPQUFPLEdBQUc7QUFDOUIsR0FBR0EsbUJBQW9CQSxDQUFBQSxrQkFBa0IsQ0FBQztBQUMxQyxzREFBc0QsR0FDdEQsSUFBSUM7QUFDSCxVQUFVQSxZQUFZO0lBQ25COztLQUVDLEdBQ0RBLFlBQVksQ0FBQyw0QkFBNEIsR0FBRztJQUM1Qzs7S0FFQyxHQUNEQSxZQUFZLENBQUMsMkJBQTJCLEdBQUc7SUFDM0M7O0tBRUMsR0FDREEsWUFBWSxDQUFDLG9CQUFvQixHQUFHO0lBQ3BDOztLQUVDLEdBQ0RBLFlBQVksQ0FBQyx1QkFBdUIsR0FBRztJQUN2Qzs7S0FFQyxHQUNEQSxZQUFZLENBQUMscUJBQXFCLEdBQUc7QUFDekMsR0FBR0EsZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUM7QUFDcEMsaUNBQWlDLEdBQ2pDLElBQUlDO0FBQ0gsVUFBVUEsYUFBYTtJQUNwQjs7S0FFQyxHQUNEQSxhQUFhLENBQUMsNkJBQTZCLEdBQUc7SUFDOUM7O0tBRUMsR0FDREEsYUFBYSxDQUFDLFNBQVMsR0FBRztJQUMxQjs7S0FFQyxHQUNEQSxhQUFhLENBQUMsUUFBUSxHQUFHO0lBQ3pCOztLQUVDLEdBQ0RBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0I7O0tBRUMsR0FDREEsYUFBYSxDQUFDLHFCQUFxQixHQUFHO0lBQ3RDOztLQUVDLEdBQ0RBLGFBQWEsQ0FBQyxlQUFlLEdBQUc7QUFDcEMsR0FBR0EsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztBQUN0QyxvSEFBb0gsR0FDcEgsSUFBSUM7QUFDSCxVQUFVQSxXQUFXO0lBQ2xCOztLQUVDLEdBQ0RBLFdBQVcsQ0FBQywyQkFBMkIsR0FBRztJQUMxQzs7S0FFQyxHQUNEQSxXQUFXLENBQUMsWUFBWSxHQUFHO0lBQzNCOztLQUVDLEdBQ0RBLFdBQVcsQ0FBQyx5QkFBeUIsR0FBRztBQUM1QyxHQUFHQSxlQUFnQkEsQ0FBQUEsY0FBYyxDQUFDO0FBQ2xDLCtCQUErQixHQUMvQixJQUFJQztBQUNILFVBQVVBLFFBQVE7SUFDZjs7S0FFQyxHQUNEQSxRQUFRLENBQUMsdUJBQXVCLEdBQUc7SUFDbkM7O0tBRUMsR0FDREEsUUFBUSxDQUFDLE9BQU8sR0FBRztJQUNuQjs7S0FFQyxHQUNEQSxRQUFRLENBQUMsUUFBUSxHQUFHO0lBQ3BCOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxRQUFRLEdBQUc7QUFDeEIsR0FBR0EsWUFBYUEsQ0FBQUEsV0FBVyxDQUFDO0FBQzVCLGlDQUFpQyxHQUNqQyxJQUFJQztBQUNILFVBQVVBLGVBQWU7SUFDdEI7O0tBRUMsR0FDREEsZUFBZSxDQUFDLCtCQUErQixHQUFHO0lBQ2xEOztLQUVDLEdBQ0RBLGVBQWUsQ0FBQyx1QkFBdUIsR0FBRztJQUMxQzs7S0FFQyxHQUNEQSxlQUFlLENBQUMsMEJBQTBCLEdBQUc7SUFDN0M7O0tBRUMsR0FDREEsZUFBZSxDQUFDLHdCQUF3QixHQUFHO0FBQy9DLEdBQUdBLG1CQUFvQkEsQ0FBQUEsa0JBQWtCLENBQUM7QUFDMUMsZUFBZSxHQUNmLElBQUlDO0FBQ0gsVUFBVUEsUUFBUTtJQUNmOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyx3QkFBd0IsR0FBRztJQUNwQzs7S0FFQyxHQUNEQSxRQUFRLENBQUMsbUJBQW1CLEdBQUc7SUFDL0I7O0tBRUMsR0FDREEsUUFBUSxDQUFDLG9CQUFvQixHQUFHO0lBQ2hDOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxvQkFBb0IsR0FBRztJQUNoQzs7S0FFQyxHQUNEQSxRQUFRLENBQUMsc0JBQXNCLEdBQUc7SUFDbEM7O0tBRUMsR0FDREEsUUFBUSxDQUFDLG1CQUFtQixHQUFHO0lBQy9COztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyx1QkFBdUIsR0FBRztJQUNuQzs7S0FFQyxHQUNEQSxRQUFRLENBQUMsc0JBQXNCLEdBQUc7SUFDbEM7O0tBRUMsR0FDREEsUUFBUSxDQUFDLG1CQUFtQixHQUFHO0lBQy9COztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxvQkFBb0IsR0FBRztJQUNoQzs7S0FFQyxHQUNEQSxRQUFRLENBQUMscUJBQXFCLEdBQUc7SUFDakM7O0tBRUMsR0FDREEsUUFBUSxDQUFDLGdDQUFnQyxHQUFHO0FBQ2hELEdBQUdBLFlBQWFBLENBQUFBLFdBQVcsQ0FBQztBQUM1QixpQkFBaUIsR0FDakIsSUFBSUM7QUFDSCxVQUFVQSxVQUFVO0lBQ2pCOztLQUVDLEdBQ0RBLFVBQVUsQ0FBQywwQkFBMEIsR0FBRztJQUN4Qzs7S0FFQyxHQUNEQSxVQUFVLENBQUMsbUJBQW1CLEdBQUc7SUFDakM7O0tBRUMsR0FDREEsVUFBVSxDQUFDLDJCQUEyQixHQUFHO0FBQzdDLEdBQUdBLGNBQWVBLENBQUFBLGFBQWEsQ0FBQztBQUNoQyx1Q0FBdUMsR0FDdkMsSUFBSUM7QUFDSCxVQUFVQSxXQUFXO0lBQ2xCOztLQUVDLEdBQ0RBLFdBQVcsQ0FBQywyQkFBMkIsR0FBRztJQUMxQzs7S0FFQyxHQUNEQSxXQUFXLENBQUMsbUJBQW1CLEdBQUc7SUFDbEM7O0tBRUMsR0FDREEsV0FBVyxDQUFDLG1CQUFtQixHQUFHO0lBQ2xDOztLQUVDLEdBQ0RBLFdBQVcsQ0FBQyxvQkFBb0IsR0FBRztJQUNuQzs7S0FFQyxHQUNEQSxXQUFXLENBQUMscUJBQXFCLEdBQUc7SUFDcEM7O0tBRUMsR0FDREEsV0FBVyxDQUFDLHVCQUF1QixHQUFHO0lBQ3RDOztLQUVDLEdBQ0RBLFdBQVcsQ0FBQywwQkFBMEIsR0FBRztBQUM3QyxHQUFHQSxlQUFnQkEsQ0FBQUEsY0FBYyxDQUFDO0FBQ2xDLDhDQUE4QyxHQUM5QyxJQUFJQztBQUNILFVBQVVBLDBCQUEwQjtJQUNqQ0EsMEJBQTBCLENBQUMsMkNBQTJDLEdBQUc7SUFDekVBLDBCQUEwQixDQUFDLHFCQUFxQixHQUFHO0lBQ25EQSwwQkFBMEIsQ0FBQyxXQUFXLEdBQUc7SUFDekNBLDBCQUEwQixDQUFDLGtCQUFrQixHQUFHO0FBQ3BELEdBQUdBLDhCQUErQkEsQ0FBQUEsNkJBQTZCLENBQUM7QUFDaEUsMkRBQTJELEdBQzNELElBQUlDO0FBQ0gsVUFBVUEsUUFBUTtJQUNmOztLQUVDLEdBQ0RBLFFBQVEsQ0FBQyxjQUFjLEdBQUc7SUFDMUI7O0tBRUMsR0FDREEsUUFBUSxDQUFDLFdBQVcsR0FBRztJQUN2Qjs7S0FFQyxHQUNEQSxRQUFRLENBQUMsZUFBZSxHQUFHO0FBQy9CLEdBQUdBLFlBQWFBLENBQUFBLFdBQVcsQ0FBQztBQUM1QixrREFBa0QsR0FDbEQsSUFBSUM7QUFDSCxVQUFVQSwwQkFBMEI7SUFDakM7O0tBRUMsR0FDREEsMEJBQTBCLENBQUMsbUJBQW1CLEdBQUc7SUFDakQ7O0tBRUMsR0FDREEsMEJBQTBCLENBQUMsZUFBZSxHQUFHO0FBQ2pELEdBQUdBLDhCQUErQkEsQ0FBQUEsNkJBQTZCLENBQUM7QUFDaEUsb0NBQW9DLEdBQ3BDLElBQUlDO0FBQ0gsVUFBVUEsV0FBVztJQUNsQjs7S0FFQyxHQUNEQSxXQUFXLENBQUMsMEJBQTBCLEdBQUc7SUFDekM7O0tBRUMsR0FDREEsV0FBVyxDQUFDLHNCQUFzQixHQUFHO0FBQ3pDLEdBQUdBLGVBQWdCQSxDQUFBQSxjQUFjLENBQUM7QUFDbEMsaURBQWlELEdBQ2pELElBQUlDO0FBQ0gsVUFBVUEseUJBQXlCO0lBQ2hDOztLQUVDLEdBQ0RBLHlCQUF5QixDQUFDLG1CQUFtQixHQUFHO0lBQ2hEOztLQUVDLEdBQ0RBLHlCQUF5QixDQUFDLE9BQU8sR0FBRztJQUNwQzs7S0FFQyxHQUNEQSx5QkFBeUIsQ0FBQyxNQUFNLEdBQUc7SUFDbkM7O0tBRUMsR0FDREEseUJBQXlCLENBQUMsT0FBTyxHQUFHO0FBQ3hDLEdBQUdBLDZCQUE4QkEsQ0FBQUEsNEJBQTRCLENBQUM7QUFDOUQsMEVBQTBFLEdBQzFFLElBQUlDO0FBQ0gsVUFBVUEsaUJBQWlCO0lBQ3hCQSxpQkFBaUIsQ0FBQyxzQkFBc0IsR0FBRztJQUMzQ0EsaUJBQWlCLENBQUMseUJBQXlCLEdBQUc7SUFDOUNBLGlCQUFpQixDQUFDLGtCQUFrQixHQUFHO0lBQ3ZDQSxpQkFBaUIsQ0FBQyxhQUFhLEdBQUc7QUFDdEMsR0FBR0EscUJBQXNCQSxDQUFBQSxvQkFBb0IsQ0FBQztBQUM5QyxpREFBaUQsR0FDakQsSUFBSUM7QUFDSCxVQUFVQSxnQkFBZ0I7SUFDdkI7O0tBRUMsR0FDREEsZ0JBQWdCLENBQUMsYUFBYSxHQUFHO0lBQ2pDOztLQUVDLEdBQ0RBLGdCQUFnQixDQUFDLGNBQWMsR0FBRztJQUNsQzs7S0FFQyxHQUNEQSxnQkFBZ0IsQ0FBQyxZQUFZLEdBQUc7QUFDcEMsR0FBR0Esb0JBQXFCQSxDQUFBQSxtQkFBbUIsQ0FBQztBQUM1QyxnRUFBZ0UsR0FDaEUsSUFBSUM7QUFDSCxVQUFVQSxtQkFBbUI7SUFDMUI7O0tBRUMsR0FDREEsbUJBQW1CLENBQUMsT0FBTyxHQUFHO0lBQzlCOztLQUVDLEdBQ0RBLG1CQUFtQixDQUFDLEtBQUssR0FBRztJQUM1Qjs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyxLQUFLLEdBQUc7SUFDNUI7O0tBRUMsR0FDREEsbUJBQW1CLENBQUMsS0FBSyxHQUFHO0lBQzVCOztLQUVDLEdBQ0RBLG1CQUFtQixDQUFDLEtBQUssR0FBRztJQUM1Qjs7S0FFQyxHQUNEQSxtQkFBbUIsQ0FBQyxLQUFLLEdBQUc7SUFDNUI7O0tBRUMsR0FDREEsbUJBQW1CLENBQUMsS0FBSyxHQUFHO0lBQzVCOztLQUVDLEdBQ0RBLG1CQUFtQixDQUFDLEtBQUssR0FBRztBQUNoQyxHQUFHQSx1QkFBd0JBLENBQUFBLHNCQUFzQixDQUFDO0FBQ2xELCtEQUErRCxHQUMvRCxJQUFJQztBQUNILFVBQVVBLGlCQUFpQjtJQUN4QkEsaUJBQWlCLENBQUMsb0JBQW9CLEdBQUc7SUFDekNBLGlCQUFpQixDQUFDLDBCQUEwQixHQUFHO0lBQy9DQSxpQkFBaUIsQ0FBQyx1QkFBdUIsR0FBRztJQUM1Q0EsaUJBQWlCLENBQUMsdUJBQXVCLEdBQUc7SUFDNUNBLGlCQUFpQixDQUFDLHFCQUFxQixHQUFHO0FBQzlDLEdBQUdBLHFCQUFzQkEsQ0FBQUEsb0JBQW9CLENBQUM7QUFDOUMscUVBQXFFLEdBQ3JFLElBQUlDO0FBQ0gsVUFBVUEsb0JBQW9CO0lBQzNCQSxvQkFBb0IsQ0FBQyx1QkFBdUIsR0FBRztJQUMvQ0Esb0JBQW9CLENBQUMscUJBQXFCLEdBQUc7SUFDN0NBLG9CQUFvQixDQUFDLHdCQUF3QixHQUFHO0lBQ2hEQSxvQkFBb0IsQ0FBQyx5QkFBeUIsR0FBRztBQUNyRCxHQUFHQSx3QkFBeUJBLENBQUFBLHVCQUF1QixDQUFDO0FBQ3BELHFFQUFxRSxHQUNyRSxJQUFJQztBQUNILFVBQVVBLG9CQUFvQjtJQUMzQkEsb0JBQW9CLENBQUMsdUJBQXVCLEdBQUc7SUFDL0NBLG9CQUFvQixDQUFDLHNCQUFzQixHQUFHO0lBQzlDQSxvQkFBb0IsQ0FBQyxzQkFBc0IsR0FBRztJQUM5Q0Esb0JBQW9CLENBQUMsdUJBQXVCLEdBQUc7QUFDbkQsR0FBR0Esd0JBQXlCQSxDQUFBQSx1QkFBdUIsQ0FBQztBQUNwRCw4Q0FBOEMsR0FDOUMsSUFBSUM7QUFDSCxVQUFVQSxRQUFRO0lBQ2ZBLFFBQVEsQ0FBQyxvQkFBb0IsR0FBRztJQUNoQ0EsUUFBUSxDQUFDLDRCQUE0QixHQUFHO0lBQ3hDQSxRQUFRLENBQUMsOEJBQThCLEdBQUc7SUFDMUNBLFFBQVEsQ0FBQyxxQkFBcUIsR0FBRztJQUNqQ0EsUUFBUSxDQUFDLCtCQUErQixHQUFHO0lBQzNDQSxRQUFRLENBQUMsa0JBQWtCLEdBQUc7SUFDOUJBLFFBQVEsQ0FBQyxtQkFBbUIsR0FBRztJQUMvQkEsUUFBUSxDQUFDLDBCQUEwQixHQUFHO0FBQzFDLEdBQUdBLFlBQWFBLENBQUFBLFdBQVcsQ0FBQztBQUM1QixnREFBZ0QsR0FDaEQsSUFBSUM7QUFDSCxVQUFVQSxXQUFXO0lBQ2xCQSxXQUFXLENBQUMsYUFBYSxHQUFHO0lBQzVCQSxXQUFXLENBQUMsYUFBYSxHQUFHO0lBQzVCQSxXQUFXLENBQUMsU0FBUyxHQUFHO0lBQ3hCQSxXQUFXLENBQUMsV0FBVyxHQUFHO0lBQzFCQSxXQUFXLENBQUMsY0FBYyxHQUFHO0FBQ2pDLEdBQUdBLGVBQWdCQSxDQUFBQSxjQUFjLENBQUM7QUFDbEMsd0VBQXdFLEdBQ3hFLElBQUlDO0FBQ0gsVUFBVUEsdUJBQXVCO0lBQzlCOzs7S0FHQyxHQUNEQSx1QkFBdUIsQ0FBQyxZQUFZLEdBQUc7SUFDdkM7OztLQUdDLEdBQ0RBLHVCQUF1QixDQUFDLFdBQVcsR0FBRztBQUMxQyxHQUFHQSwyQkFBNEJBLENBQUFBLDBCQUEwQixDQUFDO0FBQzFELHVDQUF1QyxHQUN2QyxJQUFJQztBQUNILFVBQVVBLFNBQVM7SUFDaEJBLFNBQVMsQ0FBQyxvQkFBb0IsR0FBRztJQUNqQ0EsU0FBUyxDQUFDLGFBQWEsR0FBRztJQUMxQkEsU0FBUyxDQUFDLFNBQVMsR0FBRztJQUN0QkEsU0FBUyxDQUFDLFNBQVMsR0FBRztBQUMxQixHQUFHQSxhQUFjQSxDQUFBQSxZQUFZLENBQUM7QUFDOUIsd0JBQXdCLEdBQ3hCLElBQUlDO0FBQ0gsVUFBVUEsVUFBVTtJQUNqQkEsVUFBVSxDQUFDLHFCQUFxQixHQUFHO0lBQ25DQSxVQUFVLENBQUMsV0FBVyxHQUFHO0lBQ3pCQSxVQUFVLENBQUMsWUFBWSxHQUFHO0FBQzlCLEdBQUdBLGNBQWVBLENBQUFBLGFBQWEsQ0FBQztBQUNoQywrQkFBK0IsR0FDL0IsSUFBSUM7QUFDSCxVQUFVQSxhQUFhO0lBQ3BCOztLQUVDLEdBQ0RBLGFBQWEsQ0FBQyx1QkFBdUIsR0FBRztJQUN4Qzs7S0FFQyxHQUNEQSxhQUFhLENBQUMsT0FBTyxHQUFHO0lBQ3hCOztLQUVDLEdBQ0RBLGFBQWEsQ0FBQyxRQUFRLEdBQUc7SUFDekI7O0tBRUMsR0FDREEsYUFBYSxDQUFDLFFBQVEsR0FBRztJQUN6Qjs7S0FFQyxHQUNEQSxhQUFhLENBQUMsUUFBUSxHQUFHO0lBQ3pCOztLQUVDLEdBQ0RBLGFBQWEsQ0FBQyxXQUFXLEdBQUc7QUFDaEMsR0FBR0EsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztBQUN0QyxpQ0FBaUMsR0FDakMsSUFBSUM7QUFDSCxVQUFVQSxnQkFBZ0I7SUFDdkI7O0tBRUMsR0FDREEsZ0JBQWdCLENBQUMsZ0NBQWdDLEdBQUc7SUFDcEQ7O0tBRUMsR0FDREEsZ0JBQWdCLENBQUMseUJBQXlCLEdBQUc7SUFDN0M7O0tBRUMsR0FDREEsZ0JBQWdCLENBQUMsd0JBQXdCLEdBQUc7QUFDaEQsR0FBR0Esb0JBQXFCQSxDQUFBQSxtQkFBbUIsQ0FBQztBQUM1QywrQkFBK0IsR0FDL0IsSUFBSUM7QUFDSCxVQUFVQSxjQUFjO0lBQ3JCOztLQUVDLEdBQ0RBLGNBQWMsQ0FBQyw4QkFBOEIsR0FBRztJQUNoRDs7S0FFQyxHQUNEQSxjQUFjLENBQUMsdUJBQXVCLEdBQUc7SUFDekM7O0tBRUMsR0FDREEsY0FBYyxDQUFDLHNCQUFzQixHQUFHO0FBQzVDLEdBQUdBLGtCQUFtQkEsQ0FBQUEsaUJBQWlCLENBQUM7QUFDeEMsa0RBQWtELEdBQ2xELElBQUlDO0FBQ0gsVUFBVUEsZ0JBQWdCO0lBQ3ZCOztLQUVDLEdBQ0RBLGdCQUFnQixDQUFDLGdDQUFnQyxHQUFHO0lBQ3BEOztLQUVDLEdBQ0RBLGdCQUFnQixDQUFDLCtCQUErQixHQUFHO0lBQ25EOztLQUVDLEdBQ0RBLGdCQUFnQixDQUFDLGtCQUFrQixHQUFHO0FBQzFDLEdBQUdBLG9CQUFxQkEsQ0FBQUEsbUJBQW1CLENBQUM7QUFDNUMsOERBQThELEdBQzlELElBQUlDO0FBQ0gsVUFBVUEsWUFBWTtJQUNuQjs7S0FFQyxHQUNEQSxZQUFZLENBQUMsNEJBQTRCLEdBQUc7SUFDNUM7O0tBRUMsR0FDREEsWUFBWSxDQUFDLDhCQUE4QixHQUFHO0lBQzlDOztLQUVDLEdBQ0RBLFlBQVksQ0FBQywwQkFBMEIsR0FBRztBQUM5QyxHQUFHQSxnQkFBaUJBLENBQUFBLGVBQWUsQ0FBQztBQUNwQyx3RUFBd0UsR0FDeEUsSUFBSUM7QUFDSCxVQUFVQSwwQkFBMEI7SUFDakM7O0tBRUMsR0FDREEsMEJBQTBCLENBQUMseUJBQXlCLEdBQUc7SUFDdkQ7O0tBRUMsR0FDREEsMEJBQTBCLENBQUMsU0FBUyxHQUFHO0lBQ3ZDOztLQUVDLEdBQ0RBLDBCQUEwQixDQUFDLFlBQVksR0FBRztJQUMxQzs7S0FFQyxHQUNEQSwwQkFBMEIsQ0FBQyxZQUFZLEdBQUc7QUFDOUMsR0FBR0EsOEJBQStCQSxDQUFBQSw2QkFBNkIsQ0FBQztBQUNoRSxrQ0FBa0MsR0FDbEMsSUFBSUM7QUFDSCxVQUFVQSxLQUFLO0lBQ1o7O0tBRUMsR0FDREEsS0FBSyxDQUFDLG9CQUFvQixHQUFHO0lBQzdCOztLQUVDLEdBQ0RBLEtBQUssQ0FBQyxrQkFBa0IsR0FBRztJQUMzQjs7S0FFQyxHQUNEQSxLQUFLLENBQUMsNEJBQTRCLEdBQUc7SUFDckM7O0tBRUMsR0FDREEsS0FBSyxDQUFDLGtCQUFrQixHQUFHO0lBQzNCOztLQUVDLEdBQ0RBLEtBQUssQ0FBQyx1QkFBdUIsR0FBRztJQUNoQzs7S0FFQyxHQUNEQSxLQUFLLENBQUMsdUJBQXVCLEdBQUc7SUFDaEM7O0tBRUMsR0FDREEsS0FBSyxDQUFDLGtCQUFrQixHQUFHO0lBQzNCOztLQUVDLEdBQ0RBLEtBQUssQ0FBQyw0QkFBNEIsR0FBRztJQUNyQzs7S0FFQyxHQUNEQSxLQUFLLENBQUMsa0JBQWtCLEdBQUc7SUFDM0I7O0tBRUMsR0FDREEsS0FBSyxDQUFDLHVCQUF1QixHQUFHO0lBQ2hDOztLQUVDLEdBQ0RBLEtBQUssQ0FBQyx1QkFBdUIsR0FBRztJQUNoQzs7S0FFQyxHQUNEQSxLQUFLLENBQUMsdUJBQXVCLEdBQUc7SUFDaEM7O0tBRUMsR0FDREEsS0FBSyxDQUFDLHVCQUF1QixHQUFHO0FBQ3BDLEdBQUdBLFNBQVVBLENBQUFBLFFBQVEsQ0FBQztBQUN0QixrQ0FBa0MsR0FDbEMsSUFBSUM7QUFDSCxVQUFVQSxtQkFBbUI7SUFDMUI7O0tBRUMsR0FDREEsbUJBQW1CLENBQUMsb0NBQW9DLEdBQUc7SUFDM0Q7OztLQUdDLEdBQ0RBLG1CQUFtQixDQUFDLFVBQVUsR0FBRztJQUNqQzs7O0tBR0MsR0FDREEsbUJBQW1CLENBQUMsWUFBWSxHQUFHO0lBQ25DOzs7S0FHQyxHQUNEQSxtQkFBbUIsQ0FBQyxlQUFlLEdBQUc7QUFDMUMsR0FBR0EsdUJBQXdCQSxDQUFBQSxzQkFBc0IsQ0FBQztBQUNsRCxrRUFBa0UsR0FDbEUsSUFBSUM7QUFDSCxVQUFVQSx3QkFBd0I7SUFDL0I7O0tBRUMsR0FDREEsd0JBQXdCLENBQUMsK0JBQStCLEdBQUc7SUFDM0Q7O0tBRUMsR0FDREEsd0JBQXdCLENBQUMsT0FBTyxHQUFHO0lBQ25DOztLQUVDLEdBQ0RBLHdCQUF3QixDQUFDLFFBQVEsR0FBRztJQUNwQzs7O0tBR0MsR0FDREEsd0JBQXdCLENBQUMsT0FBTyxHQUFHO0lBQ25DOzs7S0FHQyxHQUNEQSx3QkFBd0IsQ0FBQyxnQkFBZ0IsR0FBRztBQUNoRCxHQUFHQSw0QkFBNkJBLENBQUFBLDJCQUEyQixDQUFDO0FBQzVELHlCQUF5QixHQUN6QixNQUFNQztBQUNOO0FBQ0E7O0NBRUMsR0FDRCxTQUFTQyxrQkFBa0JDLEdBQUcsRUFBRUMsUUFBUTtJQUNwQyxPQUFPO1FBQ0hDLFVBQVU7WUFDTkMsU0FBU0g7WUFDVEMsVUFBVUE7UUFDZDtJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELFNBQVNHLG1CQUFtQkMsSUFBSTtJQUM1QixPQUFPO1FBQ0hBLE1BQU1BO0lBQ1Y7QUFDSjtBQUNBOztDQUVDLEdBQ0QsU0FBU0MsMkJBQTJCQyxJQUFJLEVBQUVDLElBQUk7SUFDMUMsT0FBTztRQUNIQyxjQUFjO1lBQ1ZGLE1BQU1BO1lBQ05DLE1BQU1BO1FBQ1Y7SUFDSjtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxTQUFTRSwrQkFBK0JDLEVBQUUsRUFBRUosSUFBSSxFQUFFSyxRQUFRO0lBQ3RELE9BQU87UUFDSEMsa0JBQWtCO1lBQ2RGLElBQUlBO1lBQ0pKLE1BQU1BO1lBQ05LLFVBQVVBO1FBQ2Q7SUFDSjtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxTQUFTRSxxQkFBcUJwRixJQUFJLEVBQUV1RSxRQUFRO0lBQ3hDLE9BQU87UUFDSGMsWUFBWTtZQUNSckYsTUFBTUE7WUFDTnVFLFVBQVVBO1FBQ2Q7SUFDSjtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxTQUFTZSxrQ0FBa0NDLE9BQU8sRUFBRUMsTUFBTTtJQUN0RCxPQUFPO1FBQ0hDLHFCQUFxQjtZQUNqQkYsU0FBU0E7WUFDVEMsUUFBUUE7UUFDWjtJQUNKO0FBQ0o7QUFDQTs7Q0FFQyxHQUNELFNBQVNFLDZCQUE2QkMsSUFBSSxFQUFFQyxRQUFRO0lBQ2hELE9BQU87UUFDSEMsZ0JBQWdCO1lBQ1pGLE1BQU1BO1lBQ05DLFVBQVVBO1FBQ2Q7SUFDSjtBQUNKO0FBQ0EsU0FBU0UsUUFBUUMsR0FBRztJQUNoQixJQUFJLE9BQU9BLFFBQVEsWUFBWUEsUUFBUSxNQUFNO1FBQ3pDLE9BQVEsY0FBY0EsT0FDbEIsVUFBVUEsT0FDVixrQkFBa0JBLE9BQ2xCLHNCQUFzQkEsT0FDdEIsZ0JBQWdCQSxPQUNoQixtQkFBbUJBLE9BQ25CLHlCQUF5QkEsT0FDekIsb0JBQW9CQTtJQUM1QjtJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVNDLFNBQVNDLFlBQVk7SUFDMUIsTUFBTUMsUUFBUSxFQUFFO0lBQ2hCLElBQUksT0FBT0QsaUJBQWlCLFVBQVU7UUFDbENDLE1BQU1DLElBQUksQ0FBQ3pCLG1CQUFtQnVCO0lBQ2xDLE9BQ0ssSUFBSUgsUUFBUUcsZUFBZTtRQUM1QkMsTUFBTUMsSUFBSSxDQUFDRjtJQUNmLE9BQ0ssSUFBSTFGLE1BQU1DLE9BQU8sQ0FBQ3lGLGVBQWU7UUFDbEMsSUFBSUEsYUFBYTlGLE1BQU0sS0FBSyxHQUFHO1lBQzNCLE1BQU0sSUFBSUwsTUFBTTtRQUNwQjtRQUNBLEtBQUssTUFBTXNHLFFBQVFILGFBQWM7WUFDN0IsSUFBSSxPQUFPRyxTQUFTLFVBQVU7Z0JBQzFCRixNQUFNQyxJQUFJLENBQUN6QixtQkFBbUIwQjtZQUNsQyxPQUNLLElBQUlOLFFBQVFNLE9BQU87Z0JBQ3BCRixNQUFNQyxJQUFJLENBQUNDO1lBQ2YsT0FDSztnQkFDRCxNQUFNLElBQUl0RyxNQUFNO1lBQ3BCO1FBQ0o7SUFDSixPQUNLO1FBQ0QsTUFBTSxJQUFJQSxNQUFNO0lBQ3BCO0lBQ0EsT0FBT29HO0FBQ1g7QUFDQTs7Q0FFQyxHQUNELFNBQVNHLGtCQUFrQkosWUFBWTtJQUNuQyxPQUFPO1FBQ0hLLE1BQU07UUFDTkosT0FBT0YsU0FBU0M7SUFDcEI7QUFDSjtBQUNBOztDQUVDLEdBQ0QsU0FBU00sbUJBQW1CTixZQUFZO0lBQ3BDLE9BQU87UUFDSEssTUFBTTtRQUNOSixPQUFPRixTQUFTQztJQUNwQjtBQUNKO0FBQ0EsMkNBQTJDLEdBQzNDLE1BQU1PO0lBQ0ZDLFlBQVl2QixRQUFRLENBQUU7UUFDbEIsdUJBQXVCO1FBQ3ZCLE1BQU13QixVQUFVLENBQUM7UUFDakIsS0FBSyxNQUFNQyxRQUFRekIsU0FBU3dCLE9BQU8sQ0FBQ0UsT0FBTyxHQUFJO1lBQzNDRixPQUFPLENBQUNDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBR0EsSUFBSSxDQUFDLEVBQUU7UUFDOUI7UUFDQSxJQUFJLENBQUNELE9BQU8sR0FBR0E7UUFDZiw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDRyxnQkFBZ0IsR0FBRzNCO0lBQzVCO0lBQ0E0QixPQUFPO1FBQ0gsT0FBTyxJQUFJLENBQUNELGdCQUFnQixDQUFDQyxJQUFJO0lBQ3JDO0FBQ0o7QUFDQSw2REFBNkQsR0FDN0QsTUFBTUM7QUFDTjtBQUNBLHNDQUFzQyxHQUN0QyxNQUFNQztBQUNOO0FBQ0EsNERBQTRELEdBQzVELE1BQU1DO0lBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXFCQyxHQUNELElBQUl0QyxPQUFPO1FBQ1AsSUFBSS9GLElBQUlDLElBQUlxSSxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUNoQyxJQUFJLENBQUMsQ0FBQ0osS0FBSyxDQUFDRCxLQUFLLENBQUNySSxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDNEksVUFBVSxNQUFNLFFBQVE1SSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNEksT0FBTyxNQUFNLFFBQVFQLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2hCLEtBQUssTUFBTSxRQUFRaUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaEgsTUFBTSxNQUFNLEdBQUc7WUFDN08sT0FBT25DO1FBQ1g7UUFDQSxJQUFJLElBQUksQ0FBQ3dKLFVBQVUsSUFBSSxJQUFJLENBQUNBLFVBQVUsQ0FBQ3JILE1BQU0sR0FBRyxHQUFHO1lBQy9DdUgsUUFBUUMsSUFBSSxDQUFDO1FBQ2pCO1FBQ0EsSUFBSWhELE9BQU87UUFDWCxJQUFJaUQsa0JBQWtCO1FBQ3RCLE1BQU1DLGVBQWUsRUFBRTtRQUN2QixLQUFLLE1BQU16QixRQUFRLENBQUNtQixLQUFLLENBQUNELEtBQUssQ0FBQ0QsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ0ksVUFBVSxNQUFNLFFBQVFKLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLEVBQUUsTUFBTSxRQUFRQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdJLE9BQU8sTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdwQixLQUFLLE1BQU0sUUFBUXFCLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsQ0FBRTtZQUN6TyxLQUFLLE1BQU0sQ0FBQ08sV0FBV0MsV0FBVyxJQUFJdkksT0FBT29ILE9BQU8sQ0FBQ1IsTUFBTztnQkFDeEQsSUFBSTBCLGNBQWMsVUFDZEEsY0FBYyxhQUNiQyxDQUFBQSxlQUFlLFFBQVFBLGVBQWUvSixTQUFRLEdBQUk7b0JBQ25ENkosYUFBYTFCLElBQUksQ0FBQzJCO2dCQUN0QjtZQUNKO1lBQ0EsSUFBSSxPQUFPMUIsS0FBS3pCLElBQUksS0FBSyxVQUFVO2dCQUMvQixJQUFJLE9BQU95QixLQUFLNEIsT0FBTyxLQUFLLGFBQWE1QixLQUFLNEIsT0FBTyxFQUFFO29CQUNuRDtnQkFDSjtnQkFDQUosa0JBQWtCO2dCQUNsQmpELFFBQVF5QixLQUFLekIsSUFBSTtZQUNyQjtRQUNKO1FBQ0EsSUFBSWtELGFBQWExSCxNQUFNLEdBQUcsR0FBRztZQUN6QnVILFFBQVFDLElBQUksQ0FBQyxDQUFDLHlCQUF5QixFQUFFRSxhQUFhLCtIQUErSCxDQUFDO1FBQzFMO1FBQ0EsdURBQXVEO1FBQ3ZELE9BQU9ELGtCQUFrQmpELE9BQU8zRztJQUNwQztJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNELElBQUlnQyxPQUFPO1FBQ1AsSUFBSXBCLElBQUlDLElBQUlxSSxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUNoQyxJQUFJLENBQUMsQ0FBQ0osS0FBSyxDQUFDRCxLQUFLLENBQUNySSxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDNEksVUFBVSxNQUFNLFFBQVE1SSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNEksT0FBTyxNQUFNLFFBQVFQLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2hCLEtBQUssTUFBTSxRQUFRaUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaEgsTUFBTSxNQUFNLEdBQUc7WUFDN08sT0FBT25DO1FBQ1g7UUFDQSxJQUFJLElBQUksQ0FBQ3dKLFVBQVUsSUFBSSxJQUFJLENBQUNBLFVBQVUsQ0FBQ3JILE1BQU0sR0FBRyxHQUFHO1lBQy9DdUgsUUFBUUMsSUFBSSxDQUFDO1FBQ2pCO1FBQ0EsSUFBSTNILE9BQU87UUFDWCxNQUFNaUksZUFBZSxFQUFFO1FBQ3ZCLEtBQUssTUFBTTdCLFFBQVEsQ0FBQ21CLEtBQUssQ0FBQ0QsS0FBSyxDQUFDRCxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDSSxVQUFVLE1BQU0sUUFBUUosT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUMsRUFBRSxNQUFNLFFBQVFDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0ksT0FBTyxNQUFNLFFBQVFILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3BCLEtBQUssTUFBTSxRQUFRcUIsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRSxDQUFFO1lBQ3pPLEtBQUssTUFBTSxDQUFDTyxXQUFXQyxXQUFXLElBQUl2SSxPQUFPb0gsT0FBTyxDQUFDUixNQUFPO2dCQUN4RCxJQUFJMEIsY0FBYyxnQkFDYkMsQ0FBQUEsZUFBZSxRQUFRQSxlQUFlL0osU0FBUSxHQUFJO29CQUNuRGlLLGFBQWE5QixJQUFJLENBQUMyQjtnQkFDdEI7WUFDSjtZQUNBLElBQUkxQixLQUFLZixVQUFVLElBQUksT0FBT2UsS0FBS2YsVUFBVSxDQUFDckYsSUFBSSxLQUFLLFVBQVU7Z0JBQzdEQSxRQUFRa0ksS0FBSzlCLEtBQUtmLFVBQVUsQ0FBQ3JGLElBQUk7WUFDckM7UUFDSjtRQUNBLElBQUlpSSxhQUFhOUgsTUFBTSxHQUFHLEdBQUc7WUFDekJ1SCxRQUFRQyxJQUFJLENBQUMsQ0FBQyx5QkFBeUIsRUFBRU0sYUFBYSwrSEFBK0gsQ0FBQztRQUMxTDtRQUNBLE9BQU9qSSxLQUFLRyxNQUFNLEdBQUcsSUFBSWdJLEtBQUtuSSxRQUFRaEM7SUFDMUM7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0E0Q0MsR0FDRCxJQUFJb0ssZ0JBQWdCO1FBQ2hCLElBQUl4SixJQUFJQyxJQUFJcUksSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7UUFDaEMsSUFBSSxDQUFDLENBQUNKLEtBQUssQ0FBQ0QsS0FBSyxDQUFDckksS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQzRJLFVBQVUsTUFBTSxRQUFRNUksT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUMsRUFBRSxNQUFNLFFBQVFDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRJLE9BQU8sTUFBTSxRQUFRUCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdoQixLQUFLLE1BQU0sUUFBUWlCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2hILE1BQU0sTUFBTSxHQUFHO1lBQzdPLE9BQU9uQztRQUNYO1FBQ0EsSUFBSSxJQUFJLENBQUN3SixVQUFVLElBQUksSUFBSSxDQUFDQSxVQUFVLENBQUNySCxNQUFNLEdBQUcsR0FBRztZQUMvQ3VILFFBQVFDLElBQUksQ0FBQztRQUNqQjtRQUNBLE1BQU1TLGdCQUFnQixDQUFDYixLQUFLLENBQUNELEtBQUssQ0FBQ0QsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ0ksVUFBVSxNQUFNLFFBQVFKLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLEVBQUUsTUFBTSxRQUFRQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdJLE9BQU8sTUFBTSxRQUFRSCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdwQixLQUFLLE1BQU0sUUFBUXFCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2MsTUFBTSxDQUFDLENBQUNqQyxPQUFTQSxLQUFLckIsWUFBWSxFQUFFN0QsR0FBRyxDQUFDLENBQUNrRixPQUFTQSxLQUFLckIsWUFBWSxFQUFFc0QsTUFBTSxDQUFDLENBQUN0RCxlQUFpQkEsaUJBQWlCL0c7UUFDbFcsSUFBSSxDQUFDb0ssa0JBQWtCLFFBQVFBLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJQSxjQUFjakksTUFBTSxNQUFNLEdBQUc7WUFDNUYsT0FBT25DO1FBQ1g7UUFDQSxPQUFPb0s7SUFDWDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBc0JDLEdBQ0QsSUFBSXZDLGlCQUFpQjtRQUNqQixJQUFJakgsSUFBSUMsSUFBSXFJLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUllO1FBQ3BDLElBQUksQ0FBQyxDQUFDbkIsS0FBSyxDQUFDRCxLQUFLLENBQUNySSxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDNEksVUFBVSxNQUFNLFFBQVE1SSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNEksT0FBTyxNQUFNLFFBQVFQLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2hCLEtBQUssTUFBTSxRQUFRaUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaEgsTUFBTSxNQUFNLEdBQUc7WUFDN08sT0FBT25DO1FBQ1g7UUFDQSxJQUFJLElBQUksQ0FBQ3dKLFVBQVUsSUFBSSxJQUFJLENBQUNBLFVBQVUsQ0FBQ3JILE1BQU0sR0FBRyxHQUFHO1lBQy9DdUgsUUFBUUMsSUFBSSxDQUFDO1FBQ2pCO1FBQ0EsTUFBTTlCLGlCQUFpQixDQUFDMEIsS0FBSyxDQUFDRCxLQUFLLENBQUNELEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNJLFVBQVUsTUFBTSxRQUFRSixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxPQUFPLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHcEIsS0FBSyxNQUFNLFFBQVFxQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdjLE1BQU0sQ0FBQyxDQUFDakMsT0FBU0EsS0FBS1AsY0FBYyxFQUFFM0UsR0FBRyxDQUFDLENBQUNrRixPQUFTQSxLQUFLUCxjQUFjLEVBQUV3QyxNQUFNLENBQUMsQ0FBQ3hDLGlCQUFtQkEsbUJBQW1CN0g7UUFDM1csSUFBSSxDQUFDNkgsbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUksS0FBSyxJQUFJQSxlQUFlMUYsTUFBTSxNQUFNLEdBQUc7WUFDL0YsT0FBT25DO1FBQ1g7UUFDQSxPQUFPLENBQUNzSyxLQUFLekMsbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUksS0FBSyxJQUFJQSxjQUFjLENBQUMsRUFBRSxNQUFNLFFBQVF5QyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUczQyxJQUFJO0lBQ2hKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXFCQyxHQUNELElBQUlGLHNCQUFzQjtRQUN0QixJQUFJN0csSUFBSUMsSUFBSXFJLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUllO1FBQ3BDLElBQUksQ0FBQyxDQUFDbkIsS0FBSyxDQUFDRCxLQUFLLENBQUNySSxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDNEksVUFBVSxNQUFNLFFBQVE1SSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNEksT0FBTyxNQUFNLFFBQVFQLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2hCLEtBQUssTUFBTSxRQUFRaUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaEgsTUFBTSxNQUFNLEdBQUc7WUFDN08sT0FBT25DO1FBQ1g7UUFDQSxJQUFJLElBQUksQ0FBQ3dKLFVBQVUsSUFBSSxJQUFJLENBQUNBLFVBQVUsQ0FBQ3JILE1BQU0sR0FBRyxHQUFHO1lBQy9DdUgsUUFBUUMsSUFBSSxDQUFDO1FBQ2pCO1FBQ0EsTUFBTWxDLHNCQUFzQixDQUFDOEIsS0FBSyxDQUFDRCxLQUFLLENBQUNELEtBQUssQ0FBQ0QsS0FBSyxJQUFJLENBQUNJLFVBQVUsTUFBTSxRQUFRSixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxPQUFPLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHcEIsS0FBSyxNQUFNLFFBQVFxQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdjLE1BQU0sQ0FBQyxDQUFDakMsT0FBU0EsS0FBS1gsbUJBQW1CLEVBQUV2RSxHQUFHLENBQUMsQ0FBQ2tGLE9BQVNBLEtBQUtYLG1CQUFtQixFQUFFNEMsTUFBTSxDQUFDLENBQUM1QyxzQkFBd0JBLHdCQUF3QnpIO1FBQ3BZLElBQUksQ0FBQ3lILHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CdEYsTUFBTSxNQUFNLEdBQUc7WUFDOUcsT0FBT25DO1FBQ1g7UUFDQSxPQUFPLENBQUNzSyxLQUFLN0Msd0JBQXdCLFFBQVFBLHdCQUF3QixLQUFLLElBQUksS0FBSyxJQUFJQSxtQkFBbUIsQ0FBQyxFQUFFLE1BQU0sUUFBUTZDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzlDLE1BQU07SUFDaks7QUFDSjtBQUNBLDJDQUEyQyxHQUMzQyxNQUFNK0M7QUFDTjtBQUNBLGdDQUFnQyxHQUNoQyxNQUFNQztBQUNOO0FBQ0EsK0NBQStDLEdBQy9DLE1BQU1DO0FBQ047QUFDQSxNQUFNQztBQUNOO0FBQ0EsZ0NBQWdDLEdBQ2hDLE1BQU1DO0FBQ047QUFDQSxnQ0FBZ0MsR0FDaEMsTUFBTUM7QUFDTjtBQUNBLE1BQU1DO0FBQ047QUFDQSxNQUFNQztBQUNOO0FBQ0Esa0NBQWtDLEdBQ2xDLE1BQU1DO0FBQ047QUFDQSxtQ0FBbUMsR0FDbkMsTUFBTUM7QUFDTjtBQUNBLG9DQUFvQyxHQUNwQyxNQUFNQztBQUNOO0FBQ0EsOENBQThDLEdBQzlDLE1BQU1DO0FBQ047QUFDQSw2Q0FBNkMsR0FDN0MsTUFBTUM7QUFDTjtBQUNBLE1BQU1DO0FBQ047QUFDQSx3Q0FBd0MsR0FDeEMsTUFBTUM7QUFDTjtBQUNBLHlDQUF5QyxHQUN6QyxNQUFNQztBQUNOO0FBQ0EseUNBQXlDLEdBQ3pDLE1BQU1DO0FBQ047QUFDQSw4Q0FBOEMsR0FDOUMsTUFBTUM7QUFDTjtBQUNBLDBDQUEwQyxHQUMxQyxNQUFNQztBQUNOO0FBQ0EsOENBQThDLEdBQzlDLE1BQU1DO0FBQ047QUFDQTs7Ozs7R0FLRyxHQUNILE1BQU1DO0lBQ0YsNkRBQTZELEdBQzdEQyxzQkFBc0I7UUFDbEIsTUFBTUMsb0JBQW9CO1lBQ3RCQyxlQUFlO1lBQ2ZDLGdCQUFnQixJQUFJLENBQUNBLGNBQWM7WUFDbkNDLGFBQWEsSUFBSSxDQUFDQSxXQUFXO1FBQ2pDO1FBQ0EsT0FBT0g7SUFDWDtBQUNKO0FBQ0E7Ozs7Ozs7OztHQVNHLEdBQ0gsTUFBTUk7SUFDRiw2REFBNkQsR0FDN0RMLHNCQUFzQjtRQUNsQixNQUFNQyxvQkFBb0I7WUFDdEJDLGVBQWU7WUFDZkMsZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYztZQUNuQ0MsYUFBYSxJQUFJLENBQUNBLFdBQVc7WUFDN0JFLGlCQUFpQixJQUFJLENBQUNDLE1BQU07UUFDaEM7UUFDQSxPQUFPTjtJQUNYO0FBQ0o7QUFDQTs7Ozs7Ozs7O0dBU0csR0FDSCxNQUFNTztJQUNGLDZEQUE2RCxHQUM3RFIsc0JBQXNCO1FBQ2xCLE1BQU1DLG9CQUFvQjtZQUN0QkMsZUFBZTtZQUNmQyxnQkFBZ0IsSUFBSSxDQUFDQSxjQUFjO1lBQ25DQyxhQUFhLElBQUksQ0FBQ0EsV0FBVztZQUM3Qkssb0JBQW9CLElBQUksQ0FBQ0YsTUFBTTtRQUNuQztRQUNBLE9BQU9OO0lBQ1g7QUFDSjtBQUNBOzs7Ozs7O0dBT0csR0FDSCxNQUFNUztJQUNGLDZEQUE2RCxHQUM3RFYsc0JBQXNCO1FBQ2xCLE1BQU1DLG9CQUFvQjtZQUN0QkMsZUFBZTtZQUNmQyxnQkFBZ0IsSUFBSSxDQUFDQSxjQUFjO1lBQ25DQyxhQUFhLElBQUksQ0FBQ0EsV0FBVztZQUM3Qk8sa0JBQWtCLElBQUksQ0FBQ0osTUFBTTtRQUNqQztRQUNBLE9BQU9OO0lBQ1g7QUFDSjtBQUNBOzs7Ozs7O0dBT0csR0FDSCxNQUFNVztJQUNGLDREQUE0RCxHQUM1RFosc0JBQXNCO1FBQ2xCLE1BQU1DLG9CQUFvQjtZQUN0QkMsZUFBZTtZQUNmQyxnQkFBZ0IsSUFBSSxDQUFDQSxjQUFjO1lBQ25DQyxhQUFhLElBQUksQ0FBQ0EsV0FBVztZQUM3QlMsb0JBQW9CLElBQUksQ0FBQ04sTUFBTTtRQUNuQztRQUNBLE9BQU9OO0lBQ1g7QUFDSjtBQUNBLG1DQUFtQyxHQUNuQyxNQUFNYTtJQUNGOzs7Ozs7S0FNQyxHQUNELElBQUkvRixPQUFPO1FBQ1AsSUFBSS9GLElBQUlDLElBQUlxSTtRQUNaLElBQUl2QyxPQUFPO1FBQ1gsSUFBSWdHLG1CQUFtQjtRQUN2QixNQUFNOUMsZUFBZSxFQUFFO1FBQ3ZCLEtBQUssTUFBTXpCLFFBQVEsQ0FBQ2MsS0FBSyxDQUFDckksS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ2dNLGFBQWEsTUFBTSxRQUFRaE0sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaU0sU0FBUyxNQUFNLFFBQVFoTSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdxSCxLQUFLLE1BQU0sUUFBUWdCLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsQ0FBRTtZQUM1TCxLQUFLLE1BQU0sQ0FBQ1ksV0FBV0MsV0FBVyxJQUFJdkksT0FBT29ILE9BQU8sQ0FBQ1IsTUFBTztnQkFDeEQsSUFBSTBCLGNBQWMsVUFDZEEsY0FBYyxhQUNkQyxlQUFlLE1BQU07b0JBQ3JCRixhQUFhMUIsSUFBSSxDQUFDMkI7Z0JBQ3RCO1lBQ0o7WUFDQSxJQUFJLE9BQU8xQixLQUFLekIsSUFBSSxLQUFLLFVBQVU7Z0JBQy9CLElBQUksT0FBT3lCLEtBQUs0QixPQUFPLEtBQUssYUFBYTVCLEtBQUs0QixPQUFPLEVBQUU7b0JBQ25EO2dCQUNKO2dCQUNBMkMsbUJBQW1CO2dCQUNuQmhHLFFBQVF5QixLQUFLekIsSUFBSTtZQUNyQjtRQUNKO1FBQ0EsSUFBSWtELGFBQWExSCxNQUFNLEdBQUcsR0FBRztZQUN6QnVILFFBQVFDLElBQUksQ0FBQyxDQUFDLHlCQUF5QixFQUFFRSxhQUFhLCtIQUErSCxDQUFDO1FBQzFMO1FBQ0EsdURBQXVEO1FBQ3ZELE9BQU84QyxtQkFBbUJoRyxPQUFPM0c7SUFDckM7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsSUFBSWdDLE9BQU87UUFDUCxJQUFJcEIsSUFBSUMsSUFBSXFJO1FBQ1osSUFBSWxILE9BQU87UUFDWCxNQUFNaUksZUFBZSxFQUFFO1FBQ3ZCLEtBQUssTUFBTTdCLFFBQVEsQ0FBQ2MsS0FBSyxDQUFDckksS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ2dNLGFBQWEsTUFBTSxRQUFRaE0sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaU0sU0FBUyxNQUFNLFFBQVFoTSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdxSCxLQUFLLE1BQU0sUUFBUWdCLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsQ0FBRTtZQUM1TCxLQUFLLE1BQU0sQ0FBQ1ksV0FBV0MsV0FBVyxJQUFJdkksT0FBT29ILE9BQU8sQ0FBQ1IsTUFBTztnQkFDeEQsSUFBSTBCLGNBQWMsZ0JBQWdCQyxlQUFlLE1BQU07b0JBQ25ERSxhQUFhOUIsSUFBSSxDQUFDMkI7Z0JBQ3RCO1lBQ0o7WUFDQSxJQUFJMUIsS0FBS2YsVUFBVSxJQUFJLE9BQU9lLEtBQUtmLFVBQVUsQ0FBQ3JGLElBQUksS0FBSyxVQUFVO2dCQUM3REEsUUFBUWtJLEtBQUs5QixLQUFLZixVQUFVLENBQUNyRixJQUFJO1lBQ3JDO1FBQ0o7UUFDQSxJQUFJaUksYUFBYTlILE1BQU0sR0FBRyxHQUFHO1lBQ3pCdUgsUUFBUUMsSUFBSSxDQUFDLENBQUMseUJBQXlCLEVBQUVNLGFBQWEsK0hBQStILENBQUM7UUFDMUw7UUFDQSxPQUFPakksS0FBS0csTUFBTSxHQUFHLElBQUlnSSxLQUFLbkksUUFBUWhDO0lBQzFDO0FBQ0o7QUFDQSwrQ0FBK0MsR0FDL0MsTUFBTThNO0lBQ0Y7OztLQUdDLEdBQ0RDLGlCQUFpQixFQUFFQyxXQUFXLEVBQUVDLFVBQVUsRUFBRyxFQUFFO1FBQzNDLE1BQU1DLFlBQVksSUFBSUo7UUFDdEJJLFVBQVVyRyxJQUFJLEdBQUdtRyxXQUFXLENBQUMsT0FBTztRQUNwQ0UsVUFBVUMsUUFBUSxHQUFHSCxXQUFXLENBQUMsV0FBVztRQUM1Q0UsVUFBVUUsSUFBSSxHQUFHSixXQUFXLENBQUMsT0FBTztRQUNwQ0UsVUFBVS9KLEtBQUssR0FBRzZKLFdBQVcsQ0FBQyxRQUFRO1FBQ3RDLElBQUlDLFlBQVk7WUFDWixNQUFNL0YsV0FBVzhGLFdBQVcsQ0FBQyxXQUFXO1lBQ3hDLElBQUk5RixVQUFVO2dCQUNWLE1BQU1tRyxvQkFBb0IsSUFBSXBDO2dCQUM5QixNQUFNcUMsaUJBQWlCcEcsUUFBUSxDQUFDLFNBQVM7Z0JBQ3pDbUcsa0JBQWtCRSxlQUFlLEdBQUdELG1CQUFtQixRQUFRQSxtQkFBbUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsZUFBZXBLLEdBQUcsQ0FBQyxDQUFDc0s7b0JBQ3BILE9BQU87d0JBQ0hDLE9BQU87NEJBQ0huSCxLQUFLa0gsY0FBYyxDQUFDLFNBQVM7NEJBQzdCRSxZQUFZRixjQUFjLENBQUMscUJBQXFCLEdBQzFDbkssU0FBU21LLGNBQWMsQ0FBQyxxQkFBcUIsSUFDN0N4Tjs0QkFDTnVHLFVBQVVpSCxjQUFjLENBQUMsV0FBVzt3QkFDeEM7b0JBQ0o7Z0JBQ0o7Z0JBQ0FILGtCQUFrQk0scUJBQXFCLEdBQUd6RyxRQUFRLENBQUMsd0JBQXdCO2dCQUMzRW1HLGtCQUFrQk8sdUJBQXVCLEdBQUcxRyxRQUFRLENBQUMsMEJBQTBCO2dCQUMvRWdHLFVBQVVoRyxRQUFRLEdBQUdtRztZQUN6QjtRQUNKLE9BQ0s7WUFDRCxNQUFNbkcsV0FBVzhGLFdBQVcsQ0FBQyxXQUFXO1lBQ3hDLElBQUk5RixVQUFVO2dCQUNWLE1BQU1tRyxvQkFBb0IsSUFBSXBDO2dCQUM5QixNQUFNNEMseUJBQXlCM0csUUFBUSxDQUFDLHdCQUF3QjtnQkFDaEUsTUFBTW9HLGlCQUFpQk8sMkJBQTJCLFFBQVFBLDJCQUEyQixLQUFLLElBQUksS0FBSyxJQUFJQSxzQkFBc0IsQ0FBQyxtQkFBbUI7Z0JBQ2pKUixrQkFBa0JFLGVBQWUsR0FBR0QsbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUksS0FBSyxJQUFJQSxlQUFlcEssR0FBRyxDQUFDLENBQUNzSztvQkFDcEgsTUFBTUMsUUFBUUQsY0FBYyxDQUFDLFFBQVE7b0JBQ3JDLE9BQU87d0JBQ0hDLE9BQU87NEJBQ0huSCxLQUFLbUgsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUssQ0FBQyxNQUFNOzRCQUMvREMsWUFBWSxDQUFDRCxVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBSyxDQUFDLGVBQWUsSUFDMUVwSyxTQUFTb0ssVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUssQ0FBQyxlQUFlLElBQzVFek47NEJBQ051RyxVQUFVaUgsY0FBYyxDQUFDLFdBQVc7d0JBQ3hDO29CQUNKO2dCQUNKO2dCQUNBSCxrQkFBa0JNLHFCQUFxQixHQUFHRSwyQkFBMkIsUUFBUUEsMkJBQTJCLEtBQUssSUFBSSxLQUFLLElBQUlBLHNCQUFzQixDQUFDLHdCQUF3QjtnQkFDektSLGtCQUFrQk8sdUJBQXVCLEdBQUdDLDJCQUEyQixRQUFRQSwyQkFBMkIsS0FBSyxJQUFJLEtBQUssSUFBSUEsc0JBQXNCLENBQUMsMEJBQTBCO2dCQUM3S1gsVUFBVWhHLFFBQVEsR0FBR21HO1lBQ3pCO1FBQ0o7UUFDQSxPQUFPSDtJQUNYO0FBQ0o7QUFDQTs7Ozs7Ozs7O0dBU0csR0FDSCxNQUFNWTtBQUNOO0FBQ0EsMkRBQTJELEdBQzNELE1BQU1DO0lBQ0Z0RixhQUFjO1FBQ1YsMkNBQTJDLEdBQzNDLElBQUksQ0FBQ3VGLGlCQUFpQixHQUFHLEVBQUU7SUFDL0I7QUFDSjtBQUNBLDBEQUEwRCxHQUMxRCxNQUFNQztJQUNGOzs7OztLQUtDLEdBQ0QsSUFBSUMsYUFBYTtRQUNiLElBQUksSUFBSSxDQUFDdEIsYUFBYSxJQUNsQixJQUFJLENBQUNBLGFBQWEsQ0FBQ3VCLFdBQVcsSUFDOUIsSUFBSSxDQUFDdkIsYUFBYSxDQUFDdUIsV0FBVyxDQUFDaE0sTUFBTSxHQUFHLEdBQUc7WUFDM0MsT0FBTyxJQUFJLENBQUN5SyxhQUFhLENBQUN1QixXQUFXLENBQUMsRUFBRTtRQUM1QztRQUNBLE9BQU9uTztJQUNYO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU29PLE9BQU9DLFNBQVMsRUFBRUMsS0FBSztJQUM1QixJQUFJLENBQUNBLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3JDLE1BQU0sSUFBSXhNLE1BQU07SUFDcEI7SUFDQSxJQUFJdU0sVUFBVXBCLFVBQVUsSUFBSTtRQUN4QixJQUFJcUIsTUFBTUMsVUFBVSxDQUFDLGtCQUNqQkQsTUFBTUMsVUFBVSxDQUFDLGdCQUNqQkQsTUFBTUMsVUFBVSxDQUFDLFlBQVk7WUFDN0IsT0FBT0Q7UUFDWCxPQUNLLElBQUlBLE1BQU1FLE9BQU8sQ0FBQyxRQUFRLEdBQUc7WUFDOUIsTUFBTXRHLFFBQVFvRyxNQUFNRyxLQUFLLENBQUMsS0FBSztZQUMvQixPQUFPLENBQUMsV0FBVyxFQUFFdkcsS0FBSyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUVBLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN0RCxPQUNLO1lBQ0QsT0FBTyxDQUFDLHlCQUF5QixFQUFFb0csTUFBTSxDQUFDO1FBQzlDO0lBQ0osT0FDSztRQUNELElBQUlBLE1BQU1DLFVBQVUsQ0FBQyxjQUFjRCxNQUFNQyxVQUFVLENBQUMsaUJBQWlCO1lBQ2pFLE9BQU9EO1FBQ1gsT0FDSztZQUNELE9BQU8sQ0FBQyxPQUFPLEVBQUVBLE1BQU0sQ0FBQztRQUM1QjtJQUNKO0FBQ0o7QUFDQSxTQUFTSSxhQUFhTCxTQUFTLEVBQUVDLEtBQUs7SUFDbEMsTUFBTUssbUJBQW1CUCxPQUFPQyxXQUFXQztJQUMzQyxJQUFJLENBQUNLLGtCQUFrQjtRQUNuQixPQUFPO0lBQ1g7SUFDQSxJQUFJQSxpQkFBaUJKLFVBQVUsQ0FBQyxrQkFBa0JGLFVBQVVwQixVQUFVLElBQUk7UUFDdEUsNkRBQTZEO1FBQzdELE9BQU8sQ0FBQyxTQUFTLEVBQUVvQixVQUFVTyxVQUFVLEdBQUcsV0FBVyxFQUFFUCxVQUFVUSxXQUFXLEdBQUcsQ0FBQyxFQUFFRixpQkFBaUIsQ0FBQztJQUN4RyxPQUNLLElBQUlBLGlCQUFpQkosVUFBVSxDQUFDLGNBQWNGLFVBQVVwQixVQUFVLElBQUk7UUFDdkUsT0FBTyxDQUFDLFNBQVMsRUFBRW9CLFVBQVVPLFVBQVUsR0FBRyxXQUFXLEVBQUVQLFVBQVVRLFdBQVcsR0FBRyxtQkFBbUIsRUFBRUYsaUJBQWlCLENBQUM7SUFDMUgsT0FDSztRQUNELE9BQU9BO0lBQ1g7QUFDSjtBQUNBLFNBQVNHLE9BQU9DLEtBQUs7SUFDakIsSUFBSXhNLE1BQU1DLE9BQU8sQ0FBQ3VNLFFBQVE7UUFDdEIsT0FBT0EsTUFBTTdMLEdBQUcsQ0FBQyxDQUFDOEwsT0FBU0MsTUFBTUQ7SUFDckMsT0FDSztRQUNELE9BQU87WUFBQ0MsTUFBTUY7U0FBTztJQUN6QjtBQUNKO0FBQ0EsU0FBU0UsTUFBTUQsSUFBSTtJQUNmLElBQUksT0FBT0EsU0FBUyxZQUFZQSxTQUFTLE1BQU07UUFDM0MsT0FBT0E7SUFDWDtJQUNBLE1BQU0sSUFBSWxOLE1BQU0sQ0FBQyxzREFBc0QsRUFBRSxPQUFPa04sS0FBSyxDQUFDO0FBQzFGO0FBQ0EsU0FBU0UsV0FBV0YsSUFBSTtJQUNwQixNQUFNRyxrQkFBa0JGLE1BQU1EO0lBQzlCLElBQUlHLGdCQUFnQjVJLFFBQVEsSUFDeEI0SSxnQkFBZ0I1SSxRQUFRLENBQUNnSSxVQUFVLENBQUMsV0FBVztRQUMvQyxPQUFPWTtJQUNYO0lBQ0EsTUFBTSxJQUFJck4sTUFBTSxDQUFDLHVCQUF1QixFQUFFcU4sZ0JBQWdCNUksUUFBUSxDQUFDLENBQUM7QUFDeEU7QUFDQSxTQUFTNkksV0FBV0osSUFBSTtJQUNwQixNQUFNRyxrQkFBa0JGLE1BQU1EO0lBQzlCLElBQUlHLGdCQUFnQjVJLFFBQVEsSUFDeEI0SSxnQkFBZ0I1SSxRQUFRLENBQUNnSSxVQUFVLENBQUMsV0FBVztRQUMvQyxPQUFPWTtJQUNYO0lBQ0EsTUFBTSxJQUFJck4sTUFBTSxDQUFDLHVCQUF1QixFQUFFcU4sZ0JBQWdCNUksUUFBUSxDQUFDLENBQUM7QUFDeEU7QUFDQSxTQUFTOEksTUFBTUMsTUFBTTtJQUNqQixJQUFJQSxXQUFXLFFBQVFBLFdBQVd0UCxXQUFXO1FBQ3pDLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJLE9BQU93TixXQUFXLFVBQVU7UUFDNUIsT0FBT0E7SUFDWDtJQUNBLElBQUksT0FBT0EsV0FBVyxVQUFVO1FBQzVCLE9BQU87WUFBRTNJLE1BQU0ySTtRQUFPO0lBQzFCO0lBQ0EsTUFBTSxJQUFJeE4sTUFBTSxDQUFDLHVCQUF1QixFQUFFLE9BQU93TixPQUFPLENBQUM7QUFDN0Q7QUFDQSxTQUFTQyxPQUFPRCxNQUFNO0lBQ2xCLElBQUlBLFdBQVcsUUFDWEEsV0FBV3RQLGFBQ1Z1QyxNQUFNQyxPQUFPLENBQUM4TSxXQUFXQSxPQUFPbk4sTUFBTSxLQUFLLEdBQUk7UUFDaEQsTUFBTSxJQUFJTCxNQUFNO0lBQ3BCO0lBQ0EsSUFBSVMsTUFBTUMsT0FBTyxDQUFDOE0sU0FBUztRQUN2QixPQUFPQSxPQUFPcE0sR0FBRyxDQUFDLENBQUNzTSxPQUFTSCxNQUFNRztJQUN0QztJQUNBLE9BQU87UUFBQ0gsTUFBTUM7S0FBUTtBQUMxQjtBQUNBLFNBQVNHLFdBQVdILE1BQU07SUFDdEIsT0FBUUEsV0FBVyxRQUNmQSxXQUFXdFAsYUFDWCxPQUFPc1AsV0FBVyxZQUNsQixXQUFXQSxVQUNYL00sTUFBTUMsT0FBTyxDQUFDOE0sT0FBT3BILEtBQUs7QUFDbEM7QUFDQSxTQUFTd0gsb0JBQW9CSixNQUFNO0lBQy9CLE9BQVFBLFdBQVcsUUFDZkEsV0FBV3RQLGFBQ1gsT0FBT3NQLFdBQVcsWUFDbEIsa0JBQWtCQTtBQUMxQjtBQUNBLFNBQVNLLHdCQUF3QkwsTUFBTTtJQUNuQyxPQUFRQSxXQUFXLFFBQ2ZBLFdBQVd0UCxhQUNYLE9BQU9zUCxXQUFXLFlBQ2xCLHNCQUFzQkE7QUFDOUI7QUFDQSxTQUFTTSxTQUFTTixNQUFNO0lBQ3BCLElBQUlBLFdBQVcsUUFBUUEsV0FBV3RQLFdBQVc7UUFDekMsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUkyTixXQUFXSCxTQUFTO1FBQ3BCLHNEQUFzRDtRQUN0RCx1QkFBdUI7UUFDdkIsT0FBT0E7SUFDWDtJQUNBLE9BQU87UUFDSGhILE1BQU07UUFDTkosT0FBT3FILE9BQU9EO0lBQ2xCO0FBQ0o7QUFDQSxTQUFTTyxrQkFBa0J4QixTQUFTLEVBQUVpQixNQUFNO0lBQ3hDLElBQUksQ0FBQ0EsUUFBUTtRQUNULE9BQU8sRUFBRTtJQUNiO0lBQ0EsSUFBSWpCLFVBQVVwQixVQUFVLE1BQU0xSyxNQUFNQyxPQUFPLENBQUM4TSxTQUFTO1FBQ2pELE9BQU9BLE9BQU9RLE9BQU8sQ0FBQyxDQUFDTjtZQUNuQixNQUFNL0YsVUFBVW1HLFNBQVNKO1lBQ3pCLElBQUkvRixRQUFRdkIsS0FBSyxJQUNidUIsUUFBUXZCLEtBQUssQ0FBQy9GLE1BQU0sR0FBRyxLQUN2QnNILFFBQVF2QixLQUFLLENBQUMsRUFBRSxDQUFDdkIsSUFBSSxLQUFLM0csV0FBVztnQkFDckMsT0FBTztvQkFBQ3lKLFFBQVF2QixLQUFLLENBQUMsRUFBRSxDQUFDdkIsSUFBSTtpQkFBQztZQUNsQztZQUNBLE9BQU8sRUFBRTtRQUNiO0lBQ0osT0FDSyxJQUFJMEgsVUFBVXBCLFVBQVUsSUFBSTtRQUM3QixNQUFNeEQsVUFBVW1HLFNBQVNOO1FBQ3pCLElBQUk3RixRQUFRdkIsS0FBSyxJQUNidUIsUUFBUXZCLEtBQUssQ0FBQy9GLE1BQU0sR0FBRyxLQUN2QnNILFFBQVF2QixLQUFLLENBQUMsRUFBRSxDQUFDdkIsSUFBSSxLQUFLM0csV0FBVztZQUNyQyxPQUFPO2dCQUFDeUosUUFBUXZCLEtBQUssQ0FBQyxFQUFFLENBQUN2QixJQUFJO2FBQUM7UUFDbEM7UUFDQSxPQUFPLEVBQUU7SUFDYjtJQUNBLElBQUlwRSxNQUFNQyxPQUFPLENBQUM4TSxTQUFTO1FBQ3ZCLE9BQU9BLE9BQU9wTSxHQUFHLENBQUMsQ0FBQ3NNLE9BQVNJLFNBQVNKO0lBQ3pDO0lBQ0EsT0FBTztRQUFDSSxTQUFTTjtLQUFRO0FBQzdCO0FBQ0EsU0FBU1MsVUFBVVQsTUFBTTtJQUNyQixJQUFJQSxXQUFXLFFBQ1hBLFdBQVd0UCxhQUNWdUMsTUFBTUMsT0FBTyxDQUFDOE0sV0FBV0EsT0FBT25OLE1BQU0sS0FBSyxHQUFJO1FBQ2hELE1BQU0sSUFBSUwsTUFBTTtJQUNwQjtJQUNBLElBQUksQ0FBQ1MsTUFBTUMsT0FBTyxDQUFDOE0sU0FBUztRQUN4QixxRUFBcUU7UUFDckUsSUFBSUksb0JBQW9CSixXQUFXSyx3QkFBd0JMLFNBQVM7WUFDaEUsTUFBTSxJQUFJeE4sTUFBTTtRQUNwQjtRQUNBLE9BQU87WUFBQzhOLFNBQVNOO1NBQVE7SUFDN0I7SUFDQSxNQUFNVSxTQUFTLEVBQUU7SUFDakIsTUFBTUMsbUJBQW1CLEVBQUU7SUFDM0IsTUFBTUMsaUJBQWlCVCxXQUFXSCxNQUFNLENBQUMsRUFBRTtJQUMzQyxLQUFLLE1BQU1FLFFBQVFGLE9BQVE7UUFDdkIsTUFBTWEsWUFBWVYsV0FBV0Q7UUFDN0IsSUFBSVcsYUFBYUQsZ0JBQWdCO1lBQzdCLE1BQU0sSUFBSXBPLE1BQU07UUFDcEI7UUFDQSxJQUFJcU8sV0FBVztZQUNYLG9FQUFvRTtZQUNwRSxpREFBaUQ7WUFDakRILE9BQU83SCxJQUFJLENBQUNxSDtRQUNoQixPQUNLLElBQUlFLG9CQUFvQkYsU0FBU0csd0JBQXdCSCxPQUFPO1lBQ2pFLE1BQU0sSUFBSTFOLE1BQU07UUFDcEIsT0FDSztZQUNEbU8saUJBQWlCOUgsSUFBSSxDQUFDcUg7UUFDMUI7SUFDSjtJQUNBLElBQUksQ0FBQ1UsZ0JBQWdCO1FBQ2pCRixPQUFPN0gsSUFBSSxDQUFDO1lBQUVHLE1BQU07WUFBUUosT0FBT3FILE9BQU9VO1FBQWtCO0lBQ2hFO0lBQ0EsT0FBT0Q7QUFDWDtBQUNBOzs7Ozs7QUFNQSxHQUNBLFNBQVNJLHdCQUF3QkMsUUFBUSxFQUFFQyxlQUFlO0lBQ3RELElBQUlELFNBQVNFLFFBQVEsQ0FBQyxTQUFTO1FBQzNCRCxlQUFlLENBQUMsV0FBVyxHQUFHO0lBQ2xDO0lBQ0EsTUFBTUUsa0JBQWtCSCxTQUFTaEcsTUFBTSxDQUFDLENBQUNvRyxPQUFTQSxTQUFTO0lBQzNELElBQUlELGdCQUFnQnJPLE1BQU0sS0FBSyxHQUFHO1FBQzlCbU8sZUFBZSxDQUFDLE9BQU8sR0FBRzlPLE9BQU9rUCxNQUFNLENBQUNqTixNQUFNOE0sUUFBUSxDQUFDQyxlQUFlLENBQUMsRUFBRSxDQUFDRyxXQUFXLE1BQy9FSCxlQUFlLENBQUMsRUFBRSxDQUFDRyxXQUFXLEtBQzlCbE4sS0FBS21OLGdCQUFnQjtJQUMvQixPQUNLO1FBQ0ROLGVBQWUsQ0FBQyxRQUFRLEdBQUcsRUFBRTtRQUM3QixLQUFLLE1BQU1wTyxLQUFLc08sZ0JBQWlCO1lBQzdCRixlQUFlLENBQUMsUUFBUSxDQUFDbkksSUFBSSxDQUFDO2dCQUMxQixRQUFRM0csT0FBT2tQLE1BQU0sQ0FBQ2pOLE1BQU04TSxRQUFRLENBQUNyTyxFQUFFeU8sV0FBVyxNQUM1Q3pPLEVBQUV5TyxXQUFXLEtBQ2JsTixLQUFLbU4sZ0JBQWdCO1lBQy9CO1FBQ0o7SUFDSjtBQUNKO0FBQ0EsU0FBU0Msa0JBQWtCQyxXQUFXO0lBQ2xDLE1BQU1DLGNBQWMsQ0FBQztJQUNyQixNQUFNQyxtQkFBbUI7UUFBQztLQUFRO0lBQ2xDLE1BQU1DLHVCQUF1QjtRQUFDO0tBQVE7SUFDdEMsTUFBTUMsdUJBQXVCO1FBQUM7S0FBYTtJQUMzQyxJQUFJSixXQUFXLENBQUMsT0FBTyxJQUFJQSxXQUFXLENBQUMsUUFBUSxFQUFFO1FBQzdDLE1BQU0sSUFBSWhQLE1BQU07SUFDcEI7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF5Q0EsR0FDQSxNQUFNcVAsZ0JBQWdCTCxXQUFXLENBQUMsUUFBUTtJQUMxQyxJQUFJSyxpQkFBaUIsUUFBUUEsY0FBY2hQLE1BQU0sSUFBSSxHQUFHO1FBQ3BELElBQUlnUCxhQUFhLENBQUMsRUFBRSxDQUFDLE9BQU8sS0FBSyxRQUFRO1lBQ3JDSixXQUFXLENBQUMsV0FBVyxHQUFHO1lBQzFCRCxjQUFjSyxhQUFhLENBQUMsRUFBRTtRQUNsQyxPQUNLLElBQUlBLGFBQWEsQ0FBQyxFQUFFLENBQUMsT0FBTyxLQUFLLFFBQVE7WUFDMUNKLFdBQVcsQ0FBQyxXQUFXLEdBQUc7WUFDMUJELGNBQWNLLGFBQWEsQ0FBQyxFQUFFO1FBQ2xDO0lBQ0o7SUFDQSxJQUFJTCxXQUFXLENBQUMsT0FBTyxZQUFZdk8sT0FBTztRQUN0QzZOLHdCQUF3QlUsV0FBVyxDQUFDLE9BQU8sRUFBRUM7SUFDakQ7SUFDQSxLQUFLLE1BQU0sQ0FBQ2pILFdBQVdDLFdBQVcsSUFBSXZJLE9BQU9vSCxPQUFPLENBQUNrSSxhQUFjO1FBQy9ELCtDQUErQztRQUMvQyxJQUFJL0csY0FBYyxNQUFNO1lBQ3BCO1FBQ0o7UUFDQSxJQUFJRCxhQUFhLFFBQVE7WUFDckIsSUFBSUMsZUFBZSxRQUFRO2dCQUN2QixNQUFNLElBQUlqSSxNQUFNO1lBQ3BCO1lBQ0EsSUFBSWlJLHNCQUFzQnhILE9BQU87Z0JBRzdCO1lBQ0o7WUFDQXdPLFdBQVcsQ0FBQyxPQUFPLEdBQUd2UCxPQUFPa1AsTUFBTSxDQUFDak4sTUFBTThNLFFBQVEsQ0FBQ3hHLFdBQVc0RyxXQUFXLE1BQ25FNUcsV0FBVzRHLFdBQVcsS0FDdEJsTixLQUFLbU4sZ0JBQWdCO1FBQy9CLE9BQ0ssSUFBSUksaUJBQWlCVCxRQUFRLENBQUN6RyxZQUFZO1lBQzNDaUgsV0FBVyxDQUFDakgsVUFBVSxHQUNsQitHLGtCQUFrQjlHO1FBQzFCLE9BQ0ssSUFBSWtILHFCQUFxQlYsUUFBUSxDQUFDekcsWUFBWTtZQUMvQyxNQUFNc0gsdUJBQXVCLEVBQUU7WUFDL0IsS0FBSyxNQUFNNUIsUUFBUXpGLFdBQVk7Z0JBQzNCLElBQUl5RixJQUFJLENBQUMsT0FBTyxJQUFJLFFBQVE7b0JBQ3hCdUIsV0FBVyxDQUFDLFdBQVcsR0FBRztvQkFDMUI7Z0JBQ0o7Z0JBQ0FLLHFCQUFxQmpKLElBQUksQ0FBQzBJLGtCQUFrQnJCO1lBQ2hEO1lBQ0F1QixXQUFXLENBQUNqSCxVQUFVLEdBQ2xCc0g7UUFDUixPQUNLLElBQUlGLHFCQUFxQlgsUUFBUSxDQUFDekcsWUFBWTtZQUMvQyxNQUFNdUgsdUJBQXVCLENBQUM7WUFDOUIsS0FBSyxNQUFNLENBQUM5UCxLQUFLSyxNQUFNLElBQUlKLE9BQU9vSCxPQUFPLENBQUNtQixZQUFhO2dCQUNuRHNILG9CQUFvQixDQUFDOVAsSUFBSSxHQUFHc1Asa0JBQWtCalA7WUFDbEQ7WUFDQW1QLFdBQVcsQ0FBQ2pILFVBQVUsR0FDbEJ1SDtRQUNSLE9BQ0s7WUFDRCxtRUFBbUU7WUFDbkUsSUFBSXZILGNBQWMsd0JBQXdCO2dCQUN0QztZQUNKO1lBQ0FpSCxXQUFXLENBQUNqSCxVQUFVLEdBQUdDO1FBQzdCO0lBQ0o7SUFDQSxPQUFPZ0g7QUFDWDtBQUNBLDhFQUE4RTtBQUM5RSw4RUFBOEU7QUFDOUUsZ0ZBQWdGO0FBQ2hGLDRCQUE0QjtBQUM1Qiw4SEFBOEg7QUFDOUgsNkNBQTZDO0FBQzdDLG9IQUFvSDtBQUNwSCw0RUFBNEU7QUFDNUUsMEVBQTBFO0FBQzFFLGdCQUFnQjtBQUNoQixTQUFTTyxRQUFRQyxNQUFNO0lBQ25CLE9BQU9WLGtCQUFrQlU7QUFDN0I7QUFDQSxTQUFTQyxjQUFjQyxZQUFZO0lBQy9CLElBQUksT0FBT0EsaUJBQWlCLFVBQVU7UUFDbEMsT0FBT0E7SUFDWCxPQUNLLElBQUksT0FBT0EsaUJBQWlCLFVBQVU7UUFDdkMsT0FBTztZQUNIQyxhQUFhO2dCQUNUQyxxQkFBcUI7b0JBQ2pCQyxXQUFXSDtnQkFDZjtZQUNKO1FBQ0o7SUFDSixPQUNLO1FBQ0QsTUFBTSxJQUFJM1AsTUFBTSxDQUFDLCtCQUErQixFQUFFLE9BQU8yUCxhQUFhLENBQUM7SUFDM0U7QUFDSjtBQUNBLFNBQVNJLGtCQUFrQkosWUFBWTtJQUNuQyxJQUFJLDZCQUE2QkEsY0FBYztRQUMzQyxNQUFNLElBQUkzUCxNQUFNO0lBQ3BCO0lBQ0EsT0FBTzJQO0FBQ1g7QUFDQSxTQUFTSyxNQUFNQyxJQUFJO0lBQ2YsSUFBSUEsS0FBS0Msb0JBQW9CLEVBQUU7UUFDM0IsS0FBSyxNQUFNQyx1QkFBdUJGLEtBQUtDLG9CQUFvQixDQUFFO1lBQ3pELElBQUlDLG9CQUFvQkMsVUFBVSxFQUFFO2dCQUNoQyxJQUFJLENBQUMxUSxPQUFPUyxJQUFJLENBQUNnUSxvQkFBb0JDLFVBQVUsRUFBRTNCLFFBQVEsQ0FBQyxZQUFZO29CQUNsRTBCLG9CQUFvQkMsVUFBVSxHQUFHckIsa0JBQWtCb0Isb0JBQW9CQyxVQUFVO2dCQUNyRixPQUNLO29CQUNELElBQUksQ0FBQ0Qsb0JBQW9CRSxvQkFBb0IsRUFBRTt3QkFDM0NGLG9CQUFvQkUsb0JBQW9CLEdBQ3BDRixvQkFBb0JDLFVBQVU7d0JBQ2xDLE9BQU9ELG9CQUFvQkMsVUFBVTtvQkFDekM7Z0JBQ0o7WUFDSjtZQUNBLElBQUlELG9CQUFvQi9LLFFBQVEsRUFBRTtnQkFDOUIsSUFBSSxDQUFDMUYsT0FBT1MsSUFBSSxDQUFDZ1Esb0JBQW9CL0ssUUFBUSxFQUFFcUosUUFBUSxDQUFDLFlBQVk7b0JBQ2hFMEIsb0JBQW9CL0ssUUFBUSxHQUFHMkosa0JBQWtCb0Isb0JBQW9CL0ssUUFBUTtnQkFDakYsT0FDSztvQkFDRCxJQUFJLENBQUMrSyxvQkFBb0JHLGtCQUFrQixFQUFFO3dCQUN6Q0gsb0JBQW9CRyxrQkFBa0IsR0FDbENILG9CQUFvQi9LLFFBQVE7d0JBQ2hDLE9BQU8rSyxvQkFBb0IvSyxRQUFRO29CQUN2QztnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU82SztBQUNYO0FBQ0EsU0FBU00sT0FBT0MsS0FBSztJQUNqQix5Q0FBeUM7SUFDekMsSUFBSUEsVUFBVXRTLGFBQWFzUyxVQUFVLE1BQU07UUFDdkMsTUFBTSxJQUFJeFEsTUFBTTtJQUNwQjtJQUNBLElBQUksQ0FBQ1MsTUFBTUMsT0FBTyxDQUFDOFAsUUFBUTtRQUN2QixNQUFNLElBQUl4USxNQUFNO0lBQ3BCO0lBQ0EsTUFBTWtPLFNBQVMsRUFBRTtJQUNqQixLQUFLLE1BQU0rQixRQUFRTyxNQUFPO1FBQ3RCdEMsT0FBTzdILElBQUksQ0FBQzRKO0lBQ2hCO0lBQ0EsT0FBTy9CO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbURDLEdBQ0QsU0FBU3VDLGFBQWFDLE1BQU0sRUFBRUQsWUFBWSxFQUFFRSxjQUFjLEVBQUVDLG9CQUFvQixDQUFDO0lBQzdFLE1BQU1DLHFCQUFxQixDQUFDSixhQUFhaEUsVUFBVSxDQUFDLENBQUMsRUFBRWtFLGVBQWUsQ0FBQyxDQUFDLEtBQ3BFRixhQUFhOUQsS0FBSyxDQUFDLEtBQUt0TSxNQUFNLEtBQUt1UTtJQUN2QyxJQUFJRixPQUFPdkYsVUFBVSxJQUFJO1FBQ3JCLElBQUlzRixhQUFhaEUsVUFBVSxDQUFDLGNBQWM7WUFDdEMsT0FBT2dFO1FBQ1gsT0FDSyxJQUFJQSxhQUFhaEUsVUFBVSxDQUFDLGVBQWU7WUFDNUMsT0FBTyxDQUFDLFNBQVMsRUFBRWlFLE9BQU81RCxVQUFVLEdBQUcsQ0FBQyxFQUFFMkQsYUFBYSxDQUFDO1FBQzVELE9BQ0ssSUFBSUEsYUFBYWhFLFVBQVUsQ0FBQyxDQUFDLEVBQUVrRSxlQUFlLENBQUMsQ0FBQyxHQUFHO1lBQ3BELE9BQU8sQ0FBQyxTQUFTLEVBQUVELE9BQU81RCxVQUFVLEdBQUcsV0FBVyxFQUFFNEQsT0FBTzNELFdBQVcsR0FBRyxDQUFDLEVBQUUwRCxhQUFhLENBQUM7UUFDOUYsT0FDSyxJQUFJSSxvQkFBb0I7WUFDekIsT0FBTyxDQUFDLFNBQVMsRUFBRUgsT0FBTzVELFVBQVUsR0FBRyxXQUFXLEVBQUU0RCxPQUFPM0QsV0FBVyxHQUFHLENBQUMsRUFBRTRELGVBQWUsQ0FBQyxFQUFFRixhQUFhLENBQUM7UUFDaEgsT0FDSztZQUNELE9BQU9BO1FBQ1g7SUFDSjtJQUNBLElBQUlJLG9CQUFvQjtRQUNwQixPQUFPLENBQUMsRUFBRUYsZUFBZSxDQUFDLEVBQUVGLGFBQWEsQ0FBQztJQUM5QztJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTSyxtQkFBbUJ2RSxTQUFTLEVBQUV4SCxJQUFJO0lBQ3ZDLElBQUksT0FBT0EsU0FBUyxVQUFVO1FBQzFCLE1BQU0sSUFBSS9FLE1BQU07SUFDcEI7SUFDQSxPQUFPeVEsYUFBYWxFLFdBQVd4SCxNQUFNO0FBQ3pDO0FBQ0EsU0FBU2dNLGlCQUFpQkMsTUFBTTtJQUM1QixPQUFRQTtRQUNKLEtBQUs7WUFDRCxPQUFPO1FBQ1gsS0FBSztZQUNELE9BQU87UUFDWCxLQUFLO1lBQ0QsT0FBTztRQUNYLEtBQUs7WUFDRCxPQUFPO1FBQ1g7WUFDSSxPQUFPQTtJQUNmO0FBQ0o7QUFDQSxTQUFTQyxPQUFPQyxjQUFjO0lBQzFCLE9BQU8zUCxTQUFTMlA7QUFDcEI7QUFDQSxTQUFTQyxRQUFRM0QsTUFBTTtJQUNuQixPQUFRQSxXQUFXLFFBQ2ZBLFdBQVd0UCxhQUNYLE9BQU9zUCxXQUFXLFlBQ2xCLFVBQVVBO0FBQ2xCO0FBQ0EsU0FBUzRELGlCQUFpQjVELE1BQU07SUFDNUIsT0FBUUEsV0FBVyxRQUNmQSxXQUFXdFAsYUFDWCxPQUFPc1AsV0FBVyxZQUNsQixXQUFXQTtBQUNuQjtBQUNBLFNBQVM2RCxRQUFRN0QsTUFBTTtJQUNuQixPQUFRQSxXQUFXLFFBQ2ZBLFdBQVd0UCxhQUNYLE9BQU9zUCxXQUFXLFlBQ2xCLFNBQVNBO0FBQ2pCO0FBQ0EsU0FBUzhELFVBQVVDLFFBQVE7SUFDdkIsSUFBSXpTO0lBQ0osSUFBSWlHO0lBQ0osSUFBSW9NLFFBQVFJLFdBQVc7UUFDbkJ4TSxPQUFPd00sU0FBU3hNLElBQUk7SUFDeEI7SUFDQSxJQUFJc00sUUFBUUUsV0FBVztRQUNuQnhNLE9BQU93TSxTQUFTL00sR0FBRztRQUNuQixJQUFJTyxTQUFTN0csV0FBVztZQUNwQixPQUFPQTtRQUNYO0lBQ0o7SUFDQSxJQUFJa1QsaUJBQWlCRyxXQUFXO1FBQzVCeE0sT0FBTyxDQUFDakcsS0FBS3lTLFNBQVM1RixLQUFLLE1BQU0sUUFBUTdNLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzBGLEdBQUc7UUFDeEUsSUFBSU8sU0FBUzdHLFdBQVc7WUFDcEIsT0FBT0E7UUFDWDtJQUNKO0lBQ0EsSUFBSSxPQUFPcVQsYUFBYSxVQUFVO1FBQzlCeE0sT0FBT3dNO0lBQ1g7SUFDQSxJQUFJeE0sU0FBUzdHLFdBQVc7UUFDcEIsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUkrRSxLQUFLMEgsVUFBVSxDQUFDLGFBQWE7UUFDN0IsTUFBTStFLFNBQVN6TSxLQUFLNEgsS0FBSyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1FBQ3RDLE1BQU1uTixRQUFRZ1MsT0FBT2hTLEtBQUssQ0FBQztRQUMzQixJQUFJQSxVQUFVLE1BQU07WUFDaEIsTUFBTSxJQUFJUSxNQUFNLENBQUMscUNBQXFDLEVBQUUrRSxLQUFLLENBQUM7UUFDbEU7UUFDQUEsT0FBT3ZGLEtBQUssQ0FBQyxFQUFFO0lBQ25CLE9BQ0ssSUFBSXVGLEtBQUswSCxVQUFVLENBQUMsV0FBVztRQUNoQzFILE9BQU9BLEtBQUs0SCxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUU7SUFDbEM7SUFDQSxPQUFPNUg7QUFDWDtBQUNBLFNBQVMwTSxXQUFXbEYsU0FBUyxFQUFFbUYsVUFBVTtJQUNyQyxJQUFJQztJQUNKLElBQUlwRixVQUFVcEIsVUFBVSxJQUFJO1FBQ3hCd0csTUFBTUQsYUFBYSw2QkFBNkI7SUFDcEQsT0FDSztRQUNEQyxNQUFNRCxhQUFhLFdBQVc7SUFDbEM7SUFDQSxPQUFPQztBQUNYO0FBQ0EsU0FBU0MsZUFBZXhNLFFBQVE7SUFDNUIsS0FBSyxNQUFNM0YsT0FBTztRQUFDO1FBQVU7UUFBZTtLQUFrQixDQUFFO1FBQzVELElBQUlvUyxTQUFTek0sVUFBVTNGLE1BQU07WUFDekIsT0FBTzJGLFFBQVEsQ0FBQzNGLElBQUk7UUFDeEI7SUFDSjtJQUNBLE9BQU8sRUFBRTtBQUNiO0FBQ0EsU0FBU29TLFNBQVMzUixJQUFJLEVBQUU4SCxTQUFTO0lBQzdCLE9BQU85SCxTQUFTLFFBQVEsT0FBT0EsU0FBUyxZQUFZOEgsYUFBYTlIO0FBQ3JFO0FBQ0EsU0FBUzRSLGdCQUFnQkMsT0FBTyxFQUFFMUgsU0FBUyxDQUFDLENBQUM7SUFDekMsTUFBTTJILGdCQUFnQkQ7SUFDdEIsTUFBTTVCLHNCQUFzQjtRQUN4QnBMLE1BQU1pTixhQUFhLENBQUMsT0FBTztRQUMzQkMsYUFBYUQsYUFBYSxDQUFDLGNBQWM7UUFDekMzQixzQkFBc0IyQixhQUFhLENBQUMsY0FBYztJQUN0RDtJQUNBLElBQUkzSCxPQUFPNkgsUUFBUSxFQUFFO1FBQ2pCL0IsbUJBQW1CLENBQUMsV0FBVyxHQUFHOUYsT0FBTzZILFFBQVE7SUFDckQ7SUFDQSxNQUFNQyxhQUFhO1FBQ2ZqQyxzQkFBc0I7WUFDbEJDO1NBQ0g7SUFDTDtJQUNBLE9BQU9nQztBQUNYO0FBQ0E7OztDQUdDLEdBQ0QsU0FBU0MscUJBQXFCQyxRQUFRLEVBQUVoSSxTQUFTLENBQUMsQ0FBQztJQUMvQyxNQUFNNkYsdUJBQXVCLEVBQUU7SUFDL0IsTUFBTW9DLFlBQVksSUFBSUM7SUFDdEIsS0FBSyxNQUFNUixXQUFXTSxTQUFVO1FBQzVCLE1BQU1HLGNBQWNULFFBQVFoTixJQUFJO1FBQ2hDLElBQUl1TixVQUFVRyxHQUFHLENBQUNELGNBQWM7WUFDNUIsTUFBTSxJQUFJeFMsTUFBTSxDQUFDLHdCQUF3QixFQUFFd1MsWUFBWSw2REFBNkQsQ0FBQztRQUN6SDtRQUNBRixVQUFVSSxHQUFHLENBQUNGO1FBQ2QsTUFBTUwsYUFBYUwsZ0JBQWdCQyxTQUFTMUg7UUFDNUMsSUFBSThILFdBQVdqQyxvQkFBb0IsRUFBRTtZQUNqQ0EscUJBQXFCN0osSUFBSSxJQUFJOEwsV0FBV2pDLG9CQUFvQjtRQUNoRTtJQUNKO0lBQ0EsT0FBTztRQUFFQSxzQkFBc0JBO0lBQXFCO0FBQ3hEO0FBQ0EsMEVBQTBFO0FBQzFFLFNBQVN5QyxnQkFBZ0JwRyxTQUFTLEVBQUVxRyxHQUFHO0lBQ25DLElBQUksT0FBT0EsUUFBUSxZQUFZLENBQUNuUyxNQUFNQyxPQUFPLENBQUNrUyxNQUFNO1FBQ2hELElBQUlyRyxhQUFhQSxVQUFVcEIsVUFBVSxJQUFJO1lBQ3JDLElBQUl5SCxJQUFJQyxNQUFNLElBQUlELElBQUlFLFdBQVcsRUFBRTtnQkFDL0IsTUFBTSxJQUFJOVMsTUFBTTtZQUNwQixPQUNLLElBQUksQ0FBQzRTLElBQUlDLE1BQU0sSUFBSSxDQUFDRCxJQUFJRSxXQUFXLEVBQUU7Z0JBQ3RDLE1BQU0sSUFBSTlTLE1BQU07WUFDcEI7UUFDSixPQUNLO1lBQ0QsK0RBQStEO1lBQy9ELElBQUk0UyxJQUFJRyxlQUFlLElBQUlILElBQUlJLFFBQVEsRUFBRTtnQkFDckMsTUFBTSxJQUFJaFQsTUFBTTtZQUNwQixPQUNLLElBQUksQ0FBQzRTLElBQUlHLGVBQWUsSUFBSSxDQUFDSCxJQUFJSSxRQUFRLEVBQUU7Z0JBQzVDLE1BQU0sSUFBSWhULE1BQU07WUFDcEI7UUFDSjtRQUNBLE9BQU80UztJQUNYLE9BRUssSUFBSW5TLE1BQU1DLE9BQU8sQ0FBQ2tTLE1BQU07UUFDekIsT0FBTztZQUFFRyxpQkFBaUJIO1FBQUk7SUFDbEMsT0FDSyxJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUM5QixJQUFJQSxJQUFJbkcsVUFBVSxDQUFDLFVBQVU7WUFDekIsT0FBTztnQkFDSHdHLFFBQVE7Z0JBQ1JKLFFBQVE7b0JBQUNEO2lCQUFJO1lBQ2pCO1FBQ0osT0FDSyxJQUFJQSxJQUFJbkcsVUFBVSxDQUFDLFVBQVU7WUFDOUIsT0FBTztnQkFDSHdHLFFBQVE7Z0JBQ1JILGFBQWFGO1lBQ2pCO1FBQ0osT0FDSyxJQUFJQSxJQUFJbkcsVUFBVSxDQUFDLFdBQVc7WUFDL0IsT0FBTztnQkFDSHVHLFVBQVVKO1lBQ2Q7UUFDSjtJQUNKO0lBQ0EsTUFBTSxJQUFJNVMsTUFBTSxDQUFDLG9CQUFvQixFQUFFNFMsSUFBSSxDQUFDO0FBQ2hEO0FBQ0EsU0FBU00scUJBQXFCQyxJQUFJO0lBQzlCLElBQUksT0FBT0EsU0FBUyxVQUFVO1FBQzFCLE9BQU9BO0lBQ1g7SUFDQSxNQUFNQyxhQUFhRDtJQUNuQixJQUFJQyxXQUFXM0csVUFBVSxDQUFDLFVBQVU7UUFDaEMsT0FBTztZQUNId0csUUFBUTtZQUNSSixRQUFRTztRQUNaO0lBQ0osT0FDSyxJQUFJQSxXQUFXM0csVUFBVSxDQUFDLFVBQVU7UUFDckMsT0FBTztZQUNId0csUUFBUTtZQUNSSCxhQUFhTTtRQUNqQjtJQUNKLE9BQ0s7UUFDRCxNQUFNLElBQUlwVCxNQUFNLENBQUMseUJBQXlCLEVBQUVvVCxXQUFXLENBQUM7SUFDNUQ7QUFDSjtBQUNBLFNBQVNDLGNBQWM5RyxTQUFTLEVBQUV4SCxJQUFJO0lBQ2xDLE1BQU11TyxhQUFhdk87SUFDbkIsSUFBSSxDQUFDd0gsVUFBVXBCLFVBQVUsSUFBSTtRQUN6QixNQUFNb0ksZUFBZTtRQUNyQixJQUFJQSxhQUFhQyxJQUFJLENBQUNGLGFBQWE7WUFDL0IsT0FBT0EsV0FBVzNHLEtBQUssQ0FBQyxLQUFLOEcsR0FBRztRQUNwQyxPQUNLO1lBQ0QsTUFBTSxJQUFJelQsTUFBTSxDQUFDLHdCQUF3QixFQUFFc1QsV0FBVyxDQUFDLENBQUM7UUFDNUQ7SUFDSjtJQUNBLE1BQU1JLGdCQUFnQjtJQUN0QixJQUFJQSxjQUFjRixJQUFJLENBQUNGLGFBQWE7UUFDaEMsT0FBT0EsV0FBVzNHLEtBQUssQ0FBQyxLQUFLOEcsR0FBRztJQUNwQyxPQUNLLElBQUksUUFBUUQsSUFBSSxDQUFDRixhQUFhO1FBQy9CLE9BQU9BO0lBQ1gsT0FDSztRQUNELE1BQU0sSUFBSXRULE1BQU0sQ0FBQyx3QkFBd0IsRUFBRXNULFdBQVcsQ0FBQyxDQUFDO0lBQzVEO0FBQ0o7QUFDQSxTQUFTSyxVQUFVQyxLQUFLO0lBQ3BCLE1BQU1DLGNBQWNEO0lBQ3BCLElBQUlDLGdCQUFnQiwyQkFBMkI7UUFDM0MsT0FBTztJQUNYLE9BQ0ssSUFBSUEsZ0JBQWdCLHVCQUF1QjtRQUM1QyxPQUFPO0lBQ1gsT0FDSyxJQUFJQSxnQkFBZ0IseUJBQXlCO1FBQzlDLE9BQU87SUFDWCxPQUNLLElBQUlBLGdCQUFnQixzQkFBc0I7UUFDM0MsT0FBTztJQUNYLE9BQ0ssSUFBSUEsZ0JBQWdCLHlCQUF5QjtRQUM5QyxPQUFPO0lBQ1gsT0FDSztRQUNELE9BQU9BO0lBQ1g7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTQyx1QkFBdUJDLFVBQVU7SUFDdEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1DLFVBQVU5UyxlQUFlNFMsWUFBWTtRQUFDO0tBQU07SUFDbEQsSUFBSUUsV0FBVyxNQUFNO1FBQ2pCaFUsZUFBZStULFVBQVU7WUFBQztTQUFNLEVBQUVDO0lBQ3RDO0lBQ0EsTUFBTUMsZ0JBQWdCL1MsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlHLGlCQUFpQixNQUFNO1FBQ3ZCalUsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVFO0lBQzVDO0lBQ0EsTUFBTUMsa0JBQWtCaFQsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlJLG1CQUFtQixNQUFNO1FBQ3pCbFUsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVHO0lBQzlDO0lBQ0EsT0FBT0g7QUFDWDtBQUNBLFNBQVNJLGNBQWNMLFVBQVU7SUFDN0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLElBQUk3UyxlQUFlNFMsWUFBWTtRQUFDO0tBQWMsTUFBTTdWLFdBQVc7UUFDM0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU1xVSxXQUFXbFQsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlNLFlBQVksTUFBTTtRQUNsQnBVLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFSztJQUN2QztJQUNBLE1BQU1DLGVBQWVuVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU8sZ0JBQWdCLE1BQU07UUFDdEJyVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRU07SUFDM0M7SUFDQSxPQUFPTjtBQUNYO0FBQ0EsU0FBU08sa0JBQWtCUixVQUFVO0lBQ2pDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJN1MsZUFBZTRTLFlBQVk7UUFBQztLQUFjLE1BQU03VixXQUFXO1FBQzNELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNd1UsY0FBY3JULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJUyxlQUFlLE1BQU07UUFDckJ2VSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVE7SUFDMUM7SUFDQSxNQUFNRixlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVNTLGNBQWNWLFVBQVU7SUFDN0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1VLG9CQUFvQnZULGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJVyxxQkFBcUIsTUFBTTtRQUMzQnpVLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRUYsdUJBQXVCWTtJQUN2RTtJQUNBLE1BQU1DLGNBQWN4VCxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSVksZUFBZSxNQUFNO1FBQ3JCMVUsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUVXO0lBQzFDO0lBQ0EsTUFBTUMsaUJBQWlCelQsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlhLGtCQUFrQixNQUFNO1FBQ3hCM1UsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVJLGNBQWNRO0lBQzNEO0lBQ0EsTUFBTUMsZUFBZTFULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJYyxnQkFBZ0IsTUFBTTtRQUN0QjVVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFTyxrQkFBa0JNO0lBQzdEO0lBQ0EsTUFBTUMsdUJBQXVCM1QsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUllLHdCQUF3QixNQUFNO1FBQzlCN1UsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFYztJQUNuRDtJQUNBLE1BQU1DLDBCQUEwQjVULGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJZ0IsMkJBQTJCLE1BQU07UUFDakM5VSxlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUVlO0lBQ3REO0lBQ0EsTUFBTUMscUJBQXFCN1QsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUlpQixzQkFBc0IsTUFBTTtRQUM1Qi9VLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRWdCO0lBQ2pEO0lBQ0EsTUFBTUMsbUJBQW1COVQsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlrQixvQkFBb0IsTUFBTTtRQUMxQmhWLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFaUI7SUFDL0M7SUFDQSxNQUFNQyx1QkFBdUIvVCxlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSW1CLHdCQUF3QixNQUFNO1FBQzlCalYsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFa0I7SUFDbkQ7SUFDQSxNQUFNQyxXQUFXaFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlvQixZQUFZLE1BQU07UUFDbEJsVixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRW1CO0lBQ3ZDO0lBQ0EsT0FBT25CO0FBQ1g7QUFDQSxTQUFTb0IsaUJBQWlCckIsVUFBVTtJQUNoQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFCLFlBQVlsVSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXNCLGFBQWEsTUFBTTtRQUNuQixJQUFJQyxrQkFBa0JEO1FBQ3RCLElBQUk1VSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBTytHLGNBQWMvRztZQUN6QjtRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRXNCO0lBQ3hDO0lBQ0EsTUFBTUMsV0FBV3BVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJd0IsWUFBWSxNQUFNO1FBQ2xCdFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV1QjtJQUN2QztJQUNBLE9BQU92QjtBQUNYO0FBQ0EsU0FBU3dCLGdCQUFnQnpCLFVBQVU7SUFDL0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15QixZQUFZdFUsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkwQixhQUFhLE1BQU07UUFDbkJ4VixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRXlCO0lBQ3hDO0lBQ0EsTUFBTUMsY0FBY3ZVLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJMkIsZUFBZSxNQUFNO1FBQ3JCelYsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUUwQjtJQUMxQztJQUNBLE1BQU1DLGtCQUFrQnhVLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJNEIsbUJBQW1CLE1BQU07UUFDekIxVixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRTJCO0lBQzlDO0lBQ0EsTUFBTUMsV0FBV3pVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJNkIsWUFBWSxNQUFNO1FBQ2xCM1YsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUU0QjtJQUN2QztJQUNBLE1BQU1DLGNBQWMxVSxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSThCLGVBQWUsTUFBTTtRQUNyQjVWLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFNkI7SUFDMUM7SUFDQSxNQUFNQyxhQUFhM1UsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkrQixjQUFjLE1BQU07UUFDcEI3VixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRThCO0lBQ3pDO0lBQ0EsTUFBTUMsWUFBWTVVLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJZ0MsYUFBYSxNQUFNO1FBQ25COVYsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUUrQjtJQUN4QztJQUNBLE1BQU1DLGVBQWU3VSxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWlDLGdCQUFnQixNQUFNO1FBQ3RCL1YsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVnQztJQUMzQztJQUNBLE1BQU1DLGdCQUFnQjlVLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJa0MsaUJBQWlCLE1BQU07UUFDdkJoVyxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRWlDO0lBQzVDO0lBQ0EsTUFBTUMsb0JBQW9CL1UsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUltQyxxQkFBcUIsTUFBTTtRQUMzQmpXLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRWtDO0lBQ2hEO0lBQ0EsTUFBTUMsY0FBY2hWLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJb0MsZUFBZSxNQUFNO1FBQ3JCbFcsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUVtQztJQUMxQztJQUNBLE1BQU1DLGVBQWVqVixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXFDLGdCQUFnQixNQUFNO1FBQ3RCblcsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVvQztJQUMzQztJQUNBLE1BQU1DLGdCQUFnQmxWLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJc0MsaUJBQWlCLE1BQU07UUFDdkJwVyxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRXFDO0lBQzVDO0lBQ0EsTUFBTUMsb0JBQW9CblYsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUl1QyxxQkFBcUIsTUFBTTtRQUMzQnJXLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXNDO0lBQ2hEO0lBQ0EsTUFBTUMsY0FBY3BWLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJd0MsZUFBZSxNQUFNO1FBQ3JCdFcsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUV1QztJQUMxQztJQUNBLE1BQU1DLGVBQWVyVixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXlDLGdCQUFnQixNQUFNO1FBQ3RCdlcsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUV3QztJQUMzQztJQUNBLE1BQU1DLGNBQWN0VixlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSTBDLGVBQWUsTUFBTTtRQUNyQnhXLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFeUM7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUJ2VixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSTJDLGtCQUFrQixNQUFNO1FBQ3hCelcsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUUwQztJQUM3QztJQUNBLE1BQU1DLHVCQUF1QnhWLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJNEMsd0JBQXdCLE1BQU07UUFDOUIxVyxlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUUyQztJQUNuRDtJQUNBLE1BQU1DLGVBQWV6VixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSTZDLGdCQUFnQixNQUFNO1FBQ3RCM1csZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUU0QztJQUMzQztJQUNBLE1BQU1DLFlBQVkxVixlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSThDLGFBQWEsTUFBTTtRQUNuQjVXLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFNkM7SUFDeEM7SUFDQSxNQUFNQyxXQUFXM1YsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrQyxZQUFZLE1BQU07UUFDbEI3VyxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRThDO0lBQ3ZDO0lBQ0EsT0FBTzlDO0FBQ1g7QUFDQSxTQUFTK0MsdUJBQXVCaEQsVUFBVTtJQUN0QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSTdTLGVBQWU0UyxZQUFZO1FBQUM7S0FBUyxNQUFNN1YsV0FBVztRQUN0RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTWdYLGVBQWU3VixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWlELGdCQUFnQixNQUFNO1FBQ3RCL1csZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVnRDtJQUMzQztJQUNBLE1BQU1DLGdCQUFnQjlWLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJa0QsaUJBQWlCLE1BQU07UUFDdkJoWCxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRWlEO0lBQzVDO0lBQ0EsT0FBT2pEO0FBQ1g7QUFDQSxTQUFTa0QsNkJBQTZCbkQsVUFBVTtJQUM1QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW1ELGVBQWVoVyxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSW9ELGdCQUFnQixNQUFNO1FBQ3RCbFgsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVtRDtJQUMzQztJQUNBLE1BQU14QixrQkFBa0J4VSxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTRCLG1CQUFtQixNQUFNO1FBQ3pCMVYsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUUyQjtJQUM5QztJQUNBLE1BQU1wRSxXQUFXcFEsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl4QyxZQUFZLE1BQU07UUFDbEJ0UixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXpDO0lBQ3ZDO0lBQ0EsTUFBTTZGLGlCQUFpQmpXLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJcUQsa0JBQWtCLE1BQU07UUFDeEJuWCxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRW9EO0lBQzdDO0lBQ0EsTUFBTUMsMkJBQTJCbFcsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUlzRCw0QkFBNEIsTUFBTTtRQUNsQ3BYLGVBQWUrVCxVQUFVO1lBQUM7U0FBdUIsRUFBRXFEO0lBQ3ZEO0lBQ0EsTUFBTUMsZUFBZW5XLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJdUQsZ0JBQWdCLE1BQU07UUFDdEJyWCxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRXNEO0lBQzNDO0lBQ0EsTUFBTUMseUJBQXlCcFcsZUFBZTRTLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUl3RCwwQkFBMEIsTUFBTTtRQUNoQ3RYLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRXVEO0lBQ3JEO0lBQ0EsT0FBT3ZEO0FBQ1g7QUFDQSxTQUFTd0Qsa0JBQWtCekQsVUFBVTtJQUNqQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlELGdCQUFnQnRXLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJMEQsaUJBQWlCLE1BQU07UUFDdkJ4WCxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRXlEO0lBQzVDO0lBQ0EsTUFBTUMsY0FBY3ZXLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJMkQsZUFBZSxNQUFNO1FBQ3JCelgsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUUwRDtJQUMxQztJQUNBLE9BQU8xRDtBQUNYO0FBQ0EsU0FBUzJELHNCQUFzQjVELFVBQVU7SUFDckMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU00RCxzQkFBc0J6VyxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTZELHVCQUF1QixNQUFNO1FBQzdCM1gsZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFd0Qsa0JBQWtCSTtJQUNwRTtJQUNBLElBQUl6VyxlQUFlNFMsWUFBWTtRQUFDO0tBQWlCLE1BQU03VixXQUFXO1FBQzlELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPZ1U7QUFDWDtBQUNBLFNBQVM2RCxnQ0FBZ0M5RCxVQUFVO0lBQy9DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEQsV0FBVzNXLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJK0QsWUFBWSxNQUFNO1FBQ2xCN1gsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUU4RDtJQUN2QztJQUNBLE1BQU1DLHVCQUF1QjVXLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJZ0Usd0JBQXdCLE1BQU07UUFDOUI5WCxlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUUrRDtJQUNuRDtJQUNBLE9BQU8vRDtBQUNYO0FBQ0EsU0FBU2dFLCtCQUErQmpFLFVBQVU7SUFDOUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pRSw2QkFBNkI5VyxlQUFlNFMsWUFBWTtRQUMxRDtLQUNIO0lBQ0QsSUFBSWtFLDhCQUE4QixNQUFNO1FBQ3BDaFksZUFBZStULFVBQVU7WUFBQztTQUF5QixFQUFFNkQsZ0NBQWdDSTtJQUN6RjtJQUNBLE9BQU9qRTtBQUNYO0FBQ0EsU0FBU2tFO0lBQ0wsTUFBTWxFLFdBQVcsQ0FBQztJQUNsQixPQUFPQTtBQUNYO0FBQ0EsU0FBU21FLHlCQUF5QnBFLFVBQVU7SUFDeEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vRSxrQkFBa0JqWCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXFFLG1CQUFtQixNQUFNO1FBQ3pCblksZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVvRTtJQUM5QztJQUNBLE9BQU9wRTtBQUNYO0FBQ0EsU0FBU3FFLGNBQWN0RSxVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNc0UsMkJBQTJCblgsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUl1RSw0QkFBNEIsTUFBTTtRQUNsQyxJQUFJaEQsa0JBQWtCZ0Q7UUFDdEIsSUFBSTdYLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPd0osNkJBQTZCeEo7WUFDeEM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUF1QixFQUFFc0I7SUFDdkQ7SUFDQSxJQUFJblUsZUFBZTRTLFlBQVk7UUFBQztLQUFZLE1BQU03VixXQUFXO1FBQ3pELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNdVksbUJBQW1CcFgsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUl3RSxvQkFBb0IsTUFBTTtRQUMxQnRZLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFMkQsc0JBQXNCWTtJQUNyRTtJQUNBLE1BQU1DLDRCQUE0QnJYLGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJeUUsNkJBQTZCLE1BQU07UUFDbkN2WSxlQUFlK1QsVUFBVTtZQUFDO1NBQXdCLEVBQUVnRSwrQkFBK0JRO0lBQ3ZGO0lBQ0EsSUFBSXJYLGVBQWU0UyxZQUFZO1FBQUM7S0FBc0IsTUFBTTdWLFdBQVc7UUFDbkUsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUltQixlQUFlNFMsWUFBWTtRQUFDO0tBQWEsTUFBTTdWLFdBQVc7UUFDMUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU15WSxpQkFBaUJ0WCxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSTBFLGtCQUFrQixNQUFNO1FBQ3hCeFksZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVrRTtJQUM3QztJQUNBLE1BQU1RLGtCQUFrQnZYLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJMkUsbUJBQW1CLE1BQU07UUFDekJ6WSxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRW1FLHlCQUF5Qk87SUFDdkU7SUFDQSxNQUFNQyxvQkFBb0J4WCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSTRFLHFCQUFxQixNQUFNO1FBQzNCMVksZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFMkU7SUFDaEQ7SUFDQSxPQUFPM0U7QUFDWDtBQUNBLFNBQVM0RSwrQkFBK0I3RSxVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEQsV0FBVzNXLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJK0QsWUFBWSxNQUFNO1FBQ2xCN1gsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUU4RDtJQUN2QztJQUNBLE1BQU1lLDJCQUEyQjFYLGVBQWU0UyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJOEUsNEJBQTRCLE1BQU07UUFDbEM1WSxlQUFlK1QsVUFBVTtZQUFDO1NBQXVCLEVBQUU2RTtJQUN2RDtJQUNBLE9BQU83RTtBQUNYO0FBQ0EsU0FBUzhFLGdCQUFnQi9FLFVBQVU7SUFDL0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0rRSxlQUFlNVgsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlnRixnQkFBZ0IsTUFBTTtRQUN0QjlZLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFK0U7SUFDM0M7SUFDQSxNQUFNQyxnQkFBZ0I3WCxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSWlGLGlCQUFpQixNQUFNO1FBQ3ZCL1ksZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVnRjtJQUM1QztJQUNBLE9BQU9oRjtBQUNYO0FBQ0EsU0FBU2lGLHlCQUF5QmxGLFVBQVU7SUFDeEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1rRixhQUFhL1gsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUltRixjQUFjLE1BQU07UUFDcEJqWixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRThFLGdCQUFnQkk7SUFDekQ7SUFDQSxNQUFNQyxtQkFBbUJoWSxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSW9GLG9CQUFvQixNQUFNO1FBQzFCbFosZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVtRjtJQUMvQztJQUNBLE9BQU9uRjtBQUNYO0FBQ0EsU0FBU29GLG9CQUFvQnJGLFVBQVU7SUFDbkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1xRiw0QkFBNEJsWSxlQUFlNFMsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSXNGLDZCQUE2QixNQUFNO1FBQ25DcFosZUFBZStULFVBQVU7WUFBQztTQUF3QixFQUFFNEUsK0JBQStCUztJQUN2RjtJQUNBLE1BQU1DLHNCQUFzQm5ZLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJdUYsdUJBQXVCLE1BQU07UUFDN0JyWixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVpRix5QkFBeUJLO0lBQzNFO0lBQ0EsT0FBT3RGO0FBQ1g7QUFDQSxTQUFTdUYsNkJBQTZCeEYsVUFBVTtJQUM1QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXdGLGdCQUFnQnJZLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJeUYsaUJBQWlCLE1BQU07UUFDdkJ2WixlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRXdGO0lBQzVDO0lBQ0EsT0FBT3hGO0FBQ1g7QUFDQSxTQUFTeUYscUJBQXFCMUYsVUFBVTtJQUNwQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTBGLDBCQUEwQnZZLGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJMkYsMkJBQTJCLE1BQU07UUFDakN6WixlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUV1Riw2QkFBNkJHO0lBQ25GO0lBQ0EsT0FBTzFGO0FBQ1g7QUFDQSxTQUFTMkYsNEJBQTRCNUYsVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTRGLGNBQWN6WSxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSTZGLGVBQWUsTUFBTTtRQUNyQjNaLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFNEY7SUFDMUM7SUFDQSxNQUFNQyxrQkFBa0IxWSxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSThGLG1CQUFtQixNQUFNO1FBQ3pCNVosZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUV5RixxQkFBcUJJO0lBQ25FO0lBQ0EsT0FBTzdGO0FBQ1g7QUFDQSxTQUFTOEYsaUNBQWlDL0YsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTStGLDBCQUEwQjVZLGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJZ0csMkJBQTJCLE1BQU07UUFDakMsSUFBSXpFLGtCQUFrQnlFO1FBQ3RCLElBQUl0WixNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT2lNLDRCQUE0QmpNO1lBQ3ZDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBc0IsRUFBRXNCO0lBQ3REO0lBQ0EsT0FBT3RCO0FBQ1g7QUFDQSxTQUFTZ0csc0JBQXNCakcsVUFBVTtJQUNyQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZGLGtCQUFrQjFZLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJOEYsbUJBQW1CLE1BQU07UUFDekI1WixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXlGLHFCQUFxQkk7SUFDbkU7SUFDQSxNQUFNSSw4QkFBOEI5WSxlQUFlNFMsWUFBWTtRQUMzRDtLQUNIO0lBQ0QsSUFBSWtHLCtCQUErQixNQUFNO1FBQ3JDaGEsZUFBZStULFVBQVU7WUFBQztTQUEwQixFQUFFOEYsaUNBQWlDRztJQUMzRjtJQUNBLE1BQU1kLG1CQUFtQmhZLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJb0Ysb0JBQW9CLE1BQU07UUFDMUJsWixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRW1GO0lBQy9DO0lBQ0EsT0FBT25GO0FBQ1g7QUFDQSxTQUFTa0csd0JBQXdCbkcsVUFBVTtJQUN2QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW1HLHNCQUFzQmhaLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJb0csdUJBQXVCLE1BQU07UUFDN0JsYSxlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVtRztJQUNsRDtJQUNBLE1BQU1DLHFCQUFxQmpaLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJcUcsc0JBQXNCLE1BQU07UUFDNUJuYSxlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVvRztJQUNqRDtJQUNBLE9BQU9wRztBQUNYO0FBQ0EsU0FBU3FHLCtCQUErQjlOLFNBQVMsRUFBRXdILFVBQVUsRUFBRXVHLFlBQVk7SUFDdkUsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNdUcsd0JBQXdCcFosZUFBZTRTLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhcWMseUJBQXlCLE1BQU07UUFDN0R0YSxlQUFlcWEsY0FBYztZQUFDO1NBQW9CLEVBQUVsRixpQkFBaUJ0SCxTQUFTeU07SUFDbEY7SUFDQSxNQUFNQyxrQkFBa0JyWixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXlHLG1CQUFtQixNQUFNO1FBQ3pCdmEsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUV3RztJQUM5QztJQUNBLE1BQU1DLFdBQVd0WixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTBHLFlBQVksTUFBTTtRQUNsQnhhLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFeUc7SUFDdkM7SUFDQSxNQUFNQyxXQUFXdlosZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkyRyxZQUFZLE1BQU07UUFDbEJ6YSxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRTBHO0lBQ3ZDO0lBQ0EsTUFBTUMscUJBQXFCeFosZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUk0RyxzQkFBc0IsTUFBTTtRQUM1QjFhLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRTJHO0lBQ2pEO0lBQ0EsTUFBTUMsc0JBQXNCelosZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUk2Ryx1QkFBdUIsTUFBTTtRQUM3QjNhLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRTRHO0lBQ2xEO0lBQ0EsTUFBTUMsb0JBQW9CMVosZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUk4RyxxQkFBcUIsTUFBTTtRQUMzQjVhLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRTZHO0lBQ2hEO0lBQ0EsTUFBTUMsdUJBQXVCM1osZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUkrRyx3QkFBd0IsTUFBTTtRQUM5QjdhLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRThHO0lBQ25EO0lBQ0EsTUFBTUMsZUFBZTVaLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJZ0gsZ0JBQWdCLE1BQU07UUFDdEI5YSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRStHO0lBQzNDO0lBQ0EsTUFBTUMsc0JBQXNCN1osZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlpSCx1QkFBdUIsTUFBTTtRQUM3Qi9hLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRWdIO0lBQ2xEO0lBQ0EsTUFBTUMsdUJBQXVCOVosZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlrSCx3QkFBd0IsTUFBTTtRQUM5QmhiLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWlIO0lBQ25EO0lBQ0EsTUFBTUMsV0FBVy9aLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJbUgsWUFBWSxNQUFNO1FBQ2xCamIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVrSDtJQUN2QztJQUNBLE1BQU1DLHVCQUF1QmhhLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJb0gsd0JBQXdCLE1BQU07UUFDOUJsYixlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVtSDtJQUNuRDtJQUNBLE1BQU1DLHFCQUFxQmphLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJcUgsc0JBQXNCLE1BQU07UUFDNUJuYixlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUV3QixnQkFBZ0JoRyxRQUFRNEw7SUFDekU7SUFDQSxNQUFNN0QseUJBQXlCcFcsZUFBZTRTLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUl3RCwwQkFBMEIsTUFBTTtRQUNoQ3RYLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRXVEO0lBQ3JEO0lBQ0EsSUFBSXBXLGVBQWU0UyxZQUFZO1FBQUM7S0FBZ0IsTUFBTTdWLFdBQVc7UUFDN0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUltQixlQUFlNFMsWUFBWTtRQUFDO0tBQXVCLE1BQU03VixXQUFXO1FBQ3BFLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNcWIscUJBQXFCbGEsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhbWQsc0JBQXNCLE1BQU07UUFDMUQsSUFBSS9GLGtCQUFrQitGO1FBQ3RCLElBQUk1YSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3FKLHVCQUF1QnJKO1lBQ2xDO1FBQ0o7UUFDQXpOLGVBQWVxYSxjQUFjO1lBQUM7U0FBaUIsRUFBRWhGO0lBQ3JEO0lBQ0EsTUFBTWdHLFlBQVluYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXVHLGlCQUFpQnBjLGFBQWFvZCxhQUFhLE1BQU07UUFDakQsSUFBSWhHLGtCQUFrQi9FLE9BQU8rSztRQUM3QixJQUFJN2EsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU8ySyxjQUFjckksTUFBTXRDO1lBQy9CO1FBQ0o7UUFDQXpOLGVBQWVxYSxjQUFjO1lBQUM7U0FBUSxFQUFFaEY7SUFDNUM7SUFDQSxNQUFNaUcsaUJBQWlCcGEsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUl1RyxpQkFBaUJwYyxhQUFhcWQsa0JBQWtCLE1BQU07UUFDdER0YixlQUFlcWEsY0FBYztZQUFDO1NBQWEsRUFBRWxCLG9CQUFvQm1DO0lBQ3JFO0lBQ0EsSUFBSXBhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUyxNQUFNN1YsV0FBVztRQUN0RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXdiLG9CQUFvQnJhLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXNkLHFCQUFxQixNQUFNO1FBQ3pEdmIsZUFBZXFhLGNBQWM7WUFBQztTQUFnQixFQUFFeEosbUJBQW1CdkUsV0FBV2lQO0lBQ2xGO0lBQ0EsTUFBTUMseUJBQXlCdGEsZUFBZTRTLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUkwSCwwQkFBMEIsTUFBTTtRQUNoQ3hiLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRXlIO0lBQ3JEO0lBQ0EsTUFBTUMsc0JBQXNCdmEsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkySCx1QkFBdUIsTUFBTTtRQUM3QnpiLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRTBIO0lBQ2xEO0lBQ0EsTUFBTUMsbUJBQW1CeGEsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUk0SCxvQkFBb0IsTUFBTTtRQUMxQjFiLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFZ0csc0JBQXNCdEssY0FBY2lNO0lBQ25GO0lBQ0EsSUFBSXhhLGVBQWU0UyxZQUFZO1FBQUM7S0FBaUIsTUFBTTdWLFdBQVc7UUFDOUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU00YixxQkFBcUJ6YSxlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSTZILHNCQUFzQixNQUFNO1FBQzVCM2IsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFa0csd0JBQXdCMEI7SUFDekU7SUFDQSxPQUFPNUg7QUFDWDtBQUNBLFNBQVM2SCxzQkFBc0J0UCxTQUFTLEVBQUV3SCxVQUFVO0lBQ2hELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEgsWUFBWTNhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK0gsYUFBYSxNQUFNO1FBQ25CN2IsZUFBZStULFVBQVU7WUFBQztZQUFXO1NBQVEsRUFBRTFILE9BQU9DLFdBQVd1UDtJQUNyRTtJQUNBLE1BQU1DLGVBQWU1YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWdJLGdCQUFnQixNQUFNO1FBQ3RCLElBQUl6RyxrQkFBa0JySCxVQUFVOE47UUFDaEMsSUFBSXRiLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPMEgsaUJBQWlCMUg7WUFDNUI7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztZQUFXO1NBQVcsRUFBRXNCO0lBQ3REO0lBQ0EsTUFBTTBHLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7WUFBVztTQUFtQixFQUFFcUcsK0JBQStCOU4sV0FBV3lQLFlBQVloSTtJQUNwSDtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTaUksc0JBQXNCMVAsU0FBUyxFQUFFd0gsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSTdTLGVBQWU0UyxZQUFZO1FBQUM7S0FBUyxNQUFNN1YsV0FBVztRQUN0RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBUyxNQUFNN1YsV0FBVztRQUN0RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBYyxNQUFNN1YsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTWtjLGVBQWUvYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSW1JLGdCQUFnQixNQUFNO1FBQ3RCamMsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVrSTtJQUMzQztJQUNBLE1BQU1DLHNCQUFzQmhiLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJb0ksdUJBQXVCLE1BQU07UUFDN0IsSUFBSTdHLGtCQUFrQjZHO1FBQ3RCLElBQUkxYixNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT21PLHNCQUFzQnRQLFdBQVdtQjtZQUM1QztRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1lBQVk7U0FBVyxFQUFFc0I7SUFDdkQ7SUFDQSxPQUFPdEI7QUFDWDtBQUNBLFNBQVNvSSw0QkFBNEJySSxVQUFVLEVBQUV1RyxZQUFZO0lBQ3pELE1BQU10RyxXQUFXLENBQUM7SUFDbEIsTUFBTXFJLGtCQUFrQmxiLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJdUcsaUJBQWlCcGMsYUFBYW1lLG1CQUFtQixNQUFNO1FBQ3ZEcGMsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1NBQWMsRUFBRStCO0lBQzNEO0lBQ0EsSUFBSWxiLGVBQWU0UyxZQUFZO1FBQUM7S0FBTyxNQUFNN1YsV0FBVztRQUNwRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT2dVO0FBQ1g7QUFDQSxTQUFTc0ksZ0NBQWdDL1AsU0FBUyxFQUFFd0gsVUFBVTtJQUMxRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFRLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDbEU7SUFDQSxNQUFNUyxVQUFVcGIsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUl3SSxXQUFXLE1BQU07UUFDakJ0YyxlQUFlK1QsVUFBVTtZQUFDO1lBQVM7U0FBYyxFQUFFaUksc0JBQXNCMVAsV0FBV29HLGdCQUFnQnBHLFdBQVdnUTtJQUNuSDtJQUNBLE1BQU1QLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFb0ksNEJBQTRCSixZQUFZaEk7SUFDakY7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU3dJLDZCQUE2QmpRLFNBQVMsRUFBRXdILFVBQVU7SUFDdkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU16QyxXQUFXcFEsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl4QyxZQUFZLE1BQU07UUFDbEJ0UixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFWCxjQUFjOUcsV0FBV2dGO0lBQ3hFO0lBQ0EsTUFBTXlLLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFZ0k7SUFDekM7SUFDQSxPQUFPaEk7QUFDWDtBQUNBLFNBQVN5SSxnQ0FBZ0NsUSxTQUFTLEVBQUV3SCxVQUFVO0lBQzFELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRVgsY0FBYzlHLFdBQVdnRjtJQUN4RTtJQUNBLE1BQU15SyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWdJO0lBQ3pDO0lBQ0EsT0FBT2hJO0FBQ1g7QUFDQSxTQUFTMEksMkJBQTJCM0ksVUFBVSxFQUFFdUcsWUFBWTtJQUN4RCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU0ySSxlQUFleGIsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUl1RyxpQkFBaUJwYyxhQUFheWUsZ0JBQWdCLE1BQU07UUFDcEQxYyxlQUFlcWEsY0FBYztZQUFDO1lBQVU7U0FBVyxFQUFFcUM7SUFDekQ7SUFDQSxNQUFNQyxnQkFBZ0J6YixlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSXVHLGlCQUFpQnBjLGFBQWEwZSxpQkFBaUIsTUFBTTtRQUNyRDNjLGVBQWVxYSxjQUFjO1lBQUM7WUFBVTtTQUFZLEVBQUVzQztJQUMxRDtJQUNBLElBQUl6YixlQUFlNFMsWUFBWTtRQUFDO0tBQVMsTUFBTTdWLFdBQVc7UUFDdEQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU9nVTtBQUNYO0FBQ0EsU0FBUzZJLCtCQUErQjlJLFVBQVU7SUFDOUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1nSSxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRTBJLDJCQUEyQlYsWUFBWWhJO0lBQ2hGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVM4SSxnQ0FBZ0N2USxTQUFTLEVBQUV3SCxVQUFVO0lBQzFELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRVgsY0FBYzlHLFdBQVdnRjtJQUN4RTtJQUNBLE1BQU15SyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWdJO0lBQ3pDO0lBQ0EsT0FBT2hJO0FBQ1g7QUFDQSxTQUFTK0ksdUJBQXVCaEosVUFBVTtJQUN0QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThCLGFBQWEzVSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSStCLGNBQWMsTUFBTTtRQUNwQjdWLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRThCO0lBQ2xEO0lBQ0EsTUFBTWtILGFBQWE3YixlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlKLGNBQWMsTUFBTTtRQUNwQi9jLGVBQWUrVCxVQUFVO1lBQUM7WUFBYTtTQUFPLEVBQUVnSjtJQUNwRDtJQUNBLE1BQU1DLGtCQUFrQjliLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJa0osbUJBQW1CLE1BQU07UUFDekJoZCxlQUFlK1QsVUFBVTtZQUFDO1lBQWtCO1NBQVcsRUFBRWlKO0lBQzdEO0lBQ0EsSUFBSTliLGVBQWU0UyxZQUFZO1FBQUM7S0FBVyxNQUFNN1YsV0FBVztRQUN4RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBa0IsTUFBTTdWLFdBQVc7UUFDL0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU9nVTtBQUNYO0FBQ0EsU0FBU2tKLDRCQUE0Qm5KLFVBQVU7SUFDM0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04QixhQUFhM1UsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkrQixjQUFjLE1BQU07UUFDcEI3VixlQUFlK1QsVUFBVTtZQUFDO1NBQW9CLEVBQUU4QjtJQUNwRDtJQUNBLE1BQU1rSCxhQUFhN2IsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSixjQUFjLE1BQU07UUFDcEIvYyxlQUFlK1QsVUFBVTtZQUFDO1lBQWtCO1NBQWtCLEVBQUVnSjtJQUNwRTtJQUNBLE1BQU1DLGtCQUFrQjliLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJa0osbUJBQW1CLE1BQU07UUFDekJoZCxlQUFlK1QsVUFBVTtZQUFDO1lBQXVCO1NBQVksRUFBRWlKO0lBQ25FO0lBQ0EsSUFBSTliLGVBQWU0UyxZQUFZO1FBQUM7S0FBVyxNQUFNN1YsV0FBVztRQUN4RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBbUIsTUFBTTdWLFdBQVc7UUFDaEUsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU9nVTtBQUNYO0FBQ0EsU0FBU21KLDZCQUE2QnBKLFVBQVUsRUFBRXVHLFlBQVk7SUFDMUQsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNcUksa0JBQWtCbGIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUl1RyxpQkFBaUJwYyxhQUFhbWUsbUJBQW1CLE1BQU07UUFDdkRwYyxlQUFlcWEsY0FBYztZQUFDO1NBQWMsRUFBRStCO0lBQ2xEO0lBQ0EsTUFBTWUsV0FBV2pjLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWtmLFlBQVksTUFBTTtRQUNoRG5kLGVBQWVxYSxjQUFjO1lBQUM7U0FBZSxFQUFFNEMsNEJBQTRCaEsscUJBQXFCa0s7SUFDcEc7SUFDQSxPQUFPcEo7QUFDWDtBQUNBLFNBQVNxSixpQ0FBaUM5USxTQUFTLEVBQUV3SCxVQUFVO0lBQzNELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEgsWUFBWTNhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK0gsYUFBYSxNQUFNO1FBQ25CN2IsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDMUQ7SUFDQSxNQUFNUyxVQUFVcGIsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUl3SSxXQUFXLE1BQU07UUFDakJ0YyxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRStJLHVCQUF1QnBLLGdCQUFnQnBHLFdBQVdnUTtJQUNoRztJQUNBLE1BQU1QLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFbUosNkJBQTZCbkIsWUFBWWhJO0lBQ2xGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNzSiw4QkFBOEIvUSxTQUFTLEVBQUV3SCxVQUFVO0lBQ3hELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRVgsY0FBYzlHLFdBQVdnRjtJQUN4RTtJQUNBLE1BQU15SyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWdJO0lBQ3pDO0lBQ0EsT0FBT2hJO0FBQ1g7QUFDQSxTQUFTdUosaUNBQWlDaFIsU0FBUyxFQUFFd0gsVUFBVTtJQUMzRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXpDLFdBQVdwUSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXhDLFlBQVksTUFBTTtRQUNsQnRSLGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUVYLGNBQWM5RyxXQUFXZ0Y7SUFDeEU7SUFDQSxNQUFNeUssYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVnSTtJQUN6QztJQUNBLE9BQU9oSTtBQUNYO0FBQ0EsU0FBU3dKLDRCQUE0QnpKLFVBQVUsRUFBRXVHLFlBQVk7SUFDekQsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNMkksZUFBZXhiLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJdUcsaUJBQWlCcGMsYUFBYXllLGdCQUFnQixNQUFNO1FBQ3BEMWMsZUFBZXFhLGNBQWM7WUFBQztZQUFVO1NBQVcsRUFBRXFDO0lBQ3pEO0lBQ0EsTUFBTUMsZ0JBQWdCemIsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUl1RyxpQkFBaUJwYyxhQUFhMGUsaUJBQWlCLE1BQU07UUFDckQzYyxlQUFlcWEsY0FBYztZQUFDO1lBQVU7U0FBWSxFQUFFc0M7SUFDMUQ7SUFDQSxNQUFNYSxhQUFhdGMsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUl1RyxpQkFBaUJwYyxhQUFhdWYsY0FBYyxNQUFNO1FBQ2xEeGQsZUFBZXFhLGNBQWM7WUFBQztZQUFVO1NBQVMsRUFBRW1EO0lBQ3ZEO0lBQ0EsT0FBT3pKO0FBQ1g7QUFDQSxTQUFTMEosZ0NBQWdDM0osVUFBVTtJQUMvQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWdJLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFd0osNEJBQTRCeEIsWUFBWWhJO0lBQ2pGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVMySixpQ0FBaUNwUixTQUFTLEVBQUV3SCxVQUFVO0lBQzNELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRVgsY0FBYzlHLFdBQVdnRjtJQUN4RTtJQUNBLE1BQU15SyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWdJO0lBQ3pDO0lBQ0EsT0FBT2hJO0FBQ1g7QUFDQSxTQUFTNEoseUJBQXlCN0osVUFBVTtJQUN4QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTUMsVUFBVTlTLGVBQWU0UyxZQUFZO1FBQUM7S0FBTTtJQUNsRCxJQUFJRSxXQUFXLE1BQU07UUFDakJoVSxlQUFlK1QsVUFBVTtZQUFDO1NBQU0sRUFBRUM7SUFDdEM7SUFDQSxNQUFNQyxnQkFBZ0IvUyxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSUcsaUJBQWlCLE1BQU07UUFDdkJqVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRUU7SUFDNUM7SUFDQSxNQUFNQyxrQkFBa0JoVCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSUksbUJBQW1CLE1BQU07UUFDekJsVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRUc7SUFDOUM7SUFDQSxPQUFPSDtBQUNYO0FBQ0EsU0FBUzZKLGdCQUFnQjlKLFVBQVU7SUFDL0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1LLFdBQVdsVCxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSU0sWUFBWSxNQUFNO1FBQ2xCcFUsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVLO0lBQ3ZDO0lBQ0EsTUFBTUMsZUFBZW5ULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJTyxnQkFBZ0IsTUFBTTtRQUN0QnJVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFTTtJQUMzQztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTOEosb0JBQW9CL0osVUFBVTtJQUNuQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTVEsY0FBY3JULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJUyxlQUFlLE1BQU07UUFDckJ2VSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVE7SUFDMUM7SUFDQSxNQUFNRixlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVMrSixnQkFBZ0JoSyxVQUFVO0lBQy9CLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNVSxvQkFBb0J2VCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSVcscUJBQXFCLE1BQU07UUFDM0J6VSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUU0Six5QkFBeUJsSjtJQUN6RTtJQUNBLE1BQU1DLGNBQWN4VCxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSVksZUFBZSxNQUFNO1FBQ3JCMVUsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUVXO0lBQzFDO0lBQ0EsTUFBTUMsaUJBQWlCelQsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlhLGtCQUFrQixNQUFNO1FBQ3hCM1UsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUU2SixnQkFBZ0JqSjtJQUM3RDtJQUNBLE1BQU1DLGVBQWUxVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWMsZ0JBQWdCLE1BQU07UUFDdEI1VSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRThKLG9CQUFvQmpKO0lBQy9EO0lBQ0EsTUFBTUMsdUJBQXVCM1QsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUllLHdCQUF3QixNQUFNO1FBQzlCN1UsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFYztJQUNuRDtJQUNBLE1BQU1DLDBCQUEwQjVULGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJZ0IsMkJBQTJCLE1BQU07UUFDakM5VSxlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUVlO0lBQ3REO0lBQ0EsTUFBTUMscUJBQXFCN1QsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUlpQixzQkFBc0IsTUFBTTtRQUM1Qi9VLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRWdCO0lBQ2pEO0lBQ0EsTUFBTUMsbUJBQW1COVQsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlrQixvQkFBb0IsTUFBTTtRQUMxQmhWLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFaUI7SUFDL0M7SUFDQSxNQUFNQyx1QkFBdUIvVCxlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSW1CLHdCQUF3QixNQUFNO1FBQzlCalYsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFa0I7SUFDbkQ7SUFDQSxNQUFNQyxXQUFXaFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlvQixZQUFZLE1BQU07UUFDbEJsVixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRW1CO0lBQ3ZDO0lBQ0EsT0FBT25CO0FBQ1g7QUFDQSxTQUFTZ0ssbUJBQW1CakssVUFBVTtJQUNsQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFCLFlBQVlsVSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXNCLGFBQWEsTUFBTTtRQUNuQixJQUFJQyxrQkFBa0JEO1FBQ3RCLElBQUk1VSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3FRLGdCQUFnQnJRO1lBQzNCO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFc0I7SUFDeEM7SUFDQSxNQUFNQyxXQUFXcFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl3QixZQUFZLE1BQU07UUFDbEJ0VixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXVCO0lBQ3ZDO0lBQ0EsT0FBT3ZCO0FBQ1g7QUFDQSxTQUFTaUssNEJBQTRCbEssVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWtLLGdCQUFnQi9jLGVBQWU0UyxZQUFZO1FBQUM7S0FBa0I7SUFDcEUsSUFBSW1LLGlCQUFpQixNQUFNO1FBQ3ZCamUsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVrSztJQUM1QztJQUNBLE9BQU9sSztBQUNYO0FBQ0EsU0FBU21LLHVCQUF1QnBLLFVBQVU7SUFDdEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vSyxtQkFBbUJqZCxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXFLLG9CQUFvQixNQUFNO1FBQzFCbmUsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVvSztJQUMvQztJQUNBLE1BQU1DLHlCQUF5QmxkLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJc0ssMEJBQTBCLE1BQU07UUFDaENwZSxlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUVxSztJQUNyRDtJQUNBLE9BQU9ySztBQUNYO0FBQ0EsU0FBU3NLLDhCQUE4QnZLLFVBQVU7SUFDN0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU11SyxrQkFBa0JwZCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXdLLG1CQUFtQixNQUFNO1FBQ3pCLElBQUlqSixrQkFBa0JpSjtRQUN0QixJQUFJOWQsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU95USx1QkFBdUJ6UTtZQUNsQztRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXNCO0lBQzlDO0lBQ0EsT0FBT3RCO0FBQ1g7QUFDQSxTQUFTd0sscUJBQXFCekssVUFBVTtJQUNwQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlLLGNBQWN0ZCxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSTBLLGVBQWUsTUFBTTtRQUNyQnhlLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFZ0ssbUJBQW1CUztJQUM3RDtJQUNBLE1BQU1DLHVCQUF1QnZkLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJMkssd0JBQXdCLE1BQU07UUFDOUJ6ZSxlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVpSyw0QkFBNEJTO0lBQy9FO0lBQ0EsTUFBTUMsaUJBQWlCeGQsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUk0SyxrQkFBa0IsTUFBTTtRQUN4QjFlLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFMks7SUFDN0M7SUFDQSxNQUFNQyxtQkFBbUJ6ZCxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSTZLLG9CQUFvQixNQUFNO1FBQzFCM2UsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUU0SztJQUMvQztJQUNBLE1BQU1DLHlCQUF5QjFkLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJOEssMEJBQTBCLE1BQU07UUFDaEM1ZSxlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUVzSyw4QkFBOEJPO0lBQ25GO0lBQ0EsTUFBTUMsa0JBQWtCM2QsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrSyxtQkFBbUIsTUFBTTtRQUN6QjdlLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFOEs7SUFDOUM7SUFDQSxNQUFNQyx3QkFBd0I1ZCxlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSWdMLHlCQUF5QixNQUFNO1FBQy9COWUsZUFBZStULFVBQVU7WUFBQztTQUFvQixFQUFFK0s7SUFDcEQ7SUFDQSxNQUFNQyxZQUFZN2QsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlpTCxhQUFhLE1BQU07UUFDbkIvZSxlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRWdMO0lBQ3hDO0lBQ0EsTUFBTUMscUJBQXFCOWQsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUlrTCxzQkFBc0IsTUFBTTtRQUM1QmhmLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRWlMO0lBQ2pEO0lBQ0EsTUFBTUMsb0JBQW9CL2QsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUltTCxxQkFBcUIsTUFBTTtRQUMzQmpmLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRWtMO0lBQ2hEO0lBQ0EsT0FBT2xMO0FBQ1g7QUFDQSxTQUFTbUwsbUNBQW1DcEwsVUFBVTtJQUNsRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9MLHNCQUFzQmplLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcUwsdUJBQXVCLE1BQU07UUFDN0JuZixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVvTDtJQUNsRDtJQUNBLE1BQU1DLGlCQUFpQmxlLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJc0wsa0JBQWtCLE1BQU07UUFDeEIsSUFBSS9KLGtCQUFrQitKO1FBQ3RCLElBQUk1ZSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBTzhRLHFCQUFxQjlRO1lBQ2hDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFc0I7SUFDN0M7SUFDQSxNQUFNZ0ssbUJBQW1CbmUsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUl1TCxvQkFBb0IsTUFBTTtRQUMxQnJmLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFc0w7SUFDL0M7SUFDQSxNQUFNQyxxQkFBcUJwZSxlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXdMLHNCQUFzQixNQUFNO1FBQzVCdGYsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFdUw7SUFDakQ7SUFDQSxNQUFNQyxpQkFBaUJyZSxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXlMLGtCQUFrQixNQUFNO1FBQ3hCdmYsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUV3TDtJQUM3QztJQUNBLE1BQU1DLG9CQUFvQnRlLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJMEwscUJBQXFCLE1BQU07UUFDM0J4ZixlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUV5TDtJQUNoRDtJQUNBLE9BQU96TDtBQUNYO0FBQ0EsU0FBUzBMLGtCQUFrQjNMLFVBQVU7SUFDakMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0yTCxjQUFjeGUsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUk0TCxlQUFlLE1BQU07UUFDckIxZixlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRTJMO0lBQzFDO0lBQ0EsTUFBTUMsV0FBV3plLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJNkwsWUFBWSxNQUFNO1FBQ2xCM2YsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUU0TDtJQUN2QztJQUNBLE1BQU1DLGNBQWMxZSxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSThMLGVBQWUsTUFBTTtRQUNyQjVmLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFNkw7SUFDMUM7SUFDQSxPQUFPN0w7QUFDWDtBQUNBLFNBQVM4TCx5QkFBeUIvTCxVQUFVO0lBQ3hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNc0QsZUFBZW5XLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJdUQsZ0JBQWdCLE1BQU07UUFDdEJyWCxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRW1MLG1DQUFtQzdIO0lBQzlFO0lBQ0EsTUFBTXlJLFlBQVk1ZSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSWdNLGFBQWEsTUFBTTtRQUNuQjlmLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFMEwsa0JBQWtCSztJQUMxRDtJQUNBLE9BQU8vTDtBQUNYO0FBQ0EsU0FBU2dNLDZCQUE2QmpNLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1rSSxlQUFlL2EsZUFBZTRTLFlBQVk7UUFBQztLQUFnQjtJQUNqRSxJQUFJbUksZ0JBQWdCLE1BQU07UUFDdEJqYyxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRWtJO0lBQzNDO0lBQ0EsTUFBTStELHVCQUF1QjllLGVBQWU0UyxZQUFZO1FBQ3BEO1FBQ0E7S0FDSDtJQUNELElBQUlrTSx3QkFBd0IsTUFBTTtRQUM5QixJQUFJM0ssa0JBQWtCMks7UUFDdEIsSUFBSXhmLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPb1MseUJBQXlCcFM7WUFDcEM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFc0I7SUFDbkQ7SUFDQSxPQUFPdEI7QUFDWDtBQUNBLFNBQVNrTSxrQkFBa0JuTSxVQUFVO0lBQ2pDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV6QztJQUN2QztJQUNBLE1BQU04SyxrQkFBa0JsYixlQUFlNFMsWUFBWTtRQUMvQztRQUNBO0tBQ0g7SUFDRCxJQUFJc0ksbUJBQW1CLE1BQU07UUFDekJwYyxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXFJO0lBQzlDO0lBQ0EsTUFBTThELFlBQVloZixlQUFlNFMsWUFBWTtRQUFDO1FBQVk7S0FBUTtJQUNsRSxJQUFJb00sYUFBYSxNQUFNO1FBQ25CbGdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFTCxVQUFVd007SUFDbEQ7SUFDQSxNQUFNQyxpQkFBaUJqZixlQUFlNFMsWUFBWTtRQUM5QztRQUNBO0tBQ0g7SUFDRCxJQUFJcU0sa0JBQWtCLE1BQU07UUFDeEJuZ0IsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVvTTtJQUM3QztJQUNBLE1BQU0xSSxjQUFjdlcsZUFBZTRTLFlBQVk7UUFDM0M7UUFDQTtLQUNIO0lBQ0QsSUFBSTJELGVBQWUsTUFBTTtRQUNyQnpYLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFMEQ7SUFDMUM7SUFDQSxNQUFNMkksaUJBQWlCbGYsZUFBZTRTLFlBQVk7UUFDOUM7UUFDQTtLQUNIO0lBQ0QsSUFBSXNNLGtCQUFrQixNQUFNO1FBQ3hCcGdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFcU07SUFDN0M7SUFDQSxNQUFNdkUsWUFBWTNhLGVBQWU0UyxZQUFZO1FBQUM7UUFBWTtLQUFRO0lBQ2xFLElBQUkrSCxhQUFhLE1BQU07UUFDbkI3YixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRThIO0lBQ3hDO0lBQ0EsTUFBTXNCLFdBQVdqYyxlQUFlNFMsWUFBWTtRQUFDO1FBQVk7S0FBUztJQUNsRSxJQUFJcUosWUFBWSxNQUFNO1FBQ2xCbmQsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVnTSw2QkFBNkI1QztJQUNwRTtJQUNBLE9BQU9wSjtBQUNYO0FBQ0EsU0FBU3NNLCtCQUErQnZNLFVBQVU7SUFDOUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vTCxzQkFBc0JqZSxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSXFMLHVCQUF1QixNQUFNO1FBQzdCbmYsZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFb0w7SUFDbEQ7SUFDQSxNQUFNbUIsb0JBQW9CcGYsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUl3TSxxQkFBcUIsTUFBTTtRQUMzQnRnQixlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUV1TTtJQUNoRDtJQUNBLE1BQU1DLGdCQUFnQnJmLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUMvRCxJQUFJeU0saUJBQWlCLE1BQU07UUFDdkIsSUFBSWxMLGtCQUFrQmtMO1FBQ3RCLElBQUkvZixNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3dTLGtCQUFrQnhTO1lBQzdCO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFc0I7SUFDNUM7SUFDQSxPQUFPdEI7QUFDWDtBQUNBLFNBQVN5TSwyQkFBMkIxTSxVQUFVO0lBQzFDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0wsc0JBQXNCamUsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxTCx1QkFBdUIsTUFBTTtRQUM3Qm5mLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW9MO0lBQ2xEO0lBQ0EsTUFBTTdOLFdBQVdwUSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXhDLFlBQVksTUFBTTtRQUNsQnRSLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFekM7SUFDdkM7SUFDQSxNQUFNbVAsV0FBV3ZmLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJMk0sWUFBWSxNQUFNO1FBQ2xCemdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFME07SUFDdkM7SUFDQSxNQUFNWCxZQUFZNWUsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlnTSxhQUFhLE1BQU07UUFDbkI5ZixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRTBMLGtCQUFrQks7SUFDMUQ7SUFDQSxPQUFPL0w7QUFDWDtBQUNBLFNBQVMyTSxtQkFBbUI1TSxVQUFVO0lBQ2xDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMkwsY0FBY3hlLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJNEwsZUFBZSxNQUFNO1FBQ3JCMWYsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUUyTDtJQUMxQztJQUNBLE1BQU1DLFdBQVd6ZSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTZMLFlBQVksTUFBTTtRQUNsQjNmLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFNEw7SUFDdkM7SUFDQSxNQUFNQyxjQUFjMWUsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUk4TCxlQUFlLE1BQU07UUFDckI1ZixlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRTZMO0lBQzFDO0lBQ0EsT0FBTzdMO0FBQ1g7QUFDQSxTQUFTNE0seUJBQXlCN00sVUFBVTtJQUN4QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThCLGFBQWEzVSxlQUFlNFMsWUFBWTtRQUFDO0tBQWtCO0lBQ2pFLElBQUkrQixjQUFjLE1BQU07UUFDcEI3VixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRThCO0lBQ3pDO0lBQ0EsTUFBTWtILGFBQWE3YixlQUFlNFMsWUFBWTtRQUFDO1FBQWE7S0FBTztJQUNuRSxJQUFJaUosY0FBYyxNQUFNO1FBQ3BCL2MsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVnSjtJQUN6QztJQUNBLE1BQU1DLGtCQUFrQjliLGVBQWU0UyxZQUFZO1FBQy9DO1FBQ0E7S0FDSDtJQUNELElBQUlrSixtQkFBbUIsTUFBTTtRQUN6QmhkLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFaUo7SUFDOUM7SUFDQSxPQUFPako7QUFDWDtBQUNBLFNBQVM2TSw4QkFBOEI5TSxVQUFVO0lBQzdDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEIsYUFBYTNVLGVBQWU0UyxZQUFZO1FBQUM7S0FBb0I7SUFDbkUsSUFBSStCLGNBQWMsTUFBTTtRQUNwQjdWLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFOEI7SUFDekM7SUFDQSxNQUFNa0gsYUFBYTdiLGVBQWU0UyxZQUFZO1FBQzFDO1FBQ0E7S0FDSDtJQUNELElBQUlpSixjQUFjLE1BQU07UUFDcEIvYyxlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWdKO0lBQ3pDO0lBQ0EsTUFBTUMsa0JBQWtCOWIsZUFBZTRTLFlBQVk7UUFDL0M7UUFDQTtLQUNIO0lBQ0QsSUFBSWtKLG1CQUFtQixNQUFNO1FBQ3pCaGQsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVpSjtJQUM5QztJQUNBLE9BQU9qSjtBQUNYO0FBQ0EsU0FBUzhNLG1CQUFtQi9NLFVBQVU7SUFDbEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU16QyxXQUFXcFEsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl4QyxZQUFZLE1BQU07UUFDbEJ0UixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXpDO0lBQ3ZDO0lBQ0EsTUFBTThLLGtCQUFrQmxiLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJc0ksbUJBQW1CLE1BQU07UUFDekJwYyxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXFJO0lBQzlDO0lBQ0EsTUFBTThELFlBQVloZixlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSW9NLGFBQWEsTUFBTTtRQUNuQmxnQixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRUwsVUFBVXdNO0lBQ2xEO0lBQ0EsTUFBTUosWUFBWTVlLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJZ00sYUFBYSxNQUFNO1FBQ25COWYsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUUyTSxtQkFBbUJaO0lBQzNEO0lBQ0EsTUFBTUssaUJBQWlCamYsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlxTSxrQkFBa0IsTUFBTTtRQUN4Qm5nQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRW9NO0lBQzdDO0lBQ0EsTUFBTTNJLGdCQUFnQnRXLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJMEQsaUJBQWlCLE1BQU07UUFDdkJ4WCxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRXlEO0lBQzVDO0lBQ0EsTUFBTUMsY0FBY3ZXLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJMkQsZUFBZSxNQUFNO1FBQ3JCelgsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUUwRDtJQUMxQztJQUNBLE1BQU0ySSxpQkFBaUJsZixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXNNLGtCQUFrQixNQUFNO1FBQ3hCcGdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFcU07SUFDN0M7SUFDQSxNQUFNdkUsWUFBWTNhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK0gsYUFBYSxNQUFNO1FBQ25CN2IsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUU4SDtJQUN4QztJQUNBLE1BQU1TLFVBQVVwYixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDMUQsSUFBSXdJLFdBQVcsTUFBTTtRQUNqQnRjLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFNE0seUJBQXlCckU7SUFDL0Q7SUFDQSxNQUFNYSxXQUFXamMsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQzVELElBQUlxSixZQUFZLE1BQU07UUFDbEJuZCxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRTZNLDhCQUE4QnpEO0lBQ3JFO0lBQ0EsT0FBT3BKO0FBQ1g7QUFDQSxTQUFTK00sZ0NBQWdDaE4sVUFBVTtJQUMvQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9MLHNCQUFzQmplLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcUwsdUJBQXVCLE1BQU07UUFDN0JuZixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVvTDtJQUNsRDtJQUNBLE1BQU1tQixvQkFBb0JwZixlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXdNLHFCQUFxQixNQUFNO1FBQzNCdGdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXVNO0lBQ2hEO0lBQ0EsTUFBTUMsZ0JBQWdCcmYsZUFBZTRTLFlBQVk7UUFDN0M7S0FDSDtJQUNELElBQUl5TSxpQkFBaUIsTUFBTTtRQUN2QixJQUFJbEwsa0JBQWtCa0w7UUFDdEIsSUFBSS9mLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPb1QsbUJBQW1CcFQ7WUFDOUI7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVzQjtJQUM1QztJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBU2dOLDRCQUE0QmpOLFVBQVU7SUFDM0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vTCxzQkFBc0JqZSxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSXFMLHVCQUF1QixNQUFNO1FBQzdCbmYsZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFb0w7SUFDbEQ7SUFDQSxNQUFNN04sV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV6QztJQUN2QztJQUNBLE1BQU1tUCxXQUFXdmYsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkyTSxZQUFZLE1BQU07UUFDbEJ6Z0IsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUUwTTtJQUN2QztJQUNBLE1BQU1YLFlBQVk1ZSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSWdNLGFBQWEsTUFBTTtRQUNuQjlmLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFMk0sbUJBQW1CWjtJQUMzRDtJQUNBLE9BQU8vTDtBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNELElBQUlpTjtBQUNILFVBQVVBLFNBQVM7SUFDaEJBLFNBQVMsQ0FBQyx3QkFBd0IsR0FBRztJQUNyQ0EsU0FBUyxDQUFDLG9CQUFvQixHQUFHO0lBQ2pDQSxTQUFTLENBQUMseUJBQXlCLEdBQUc7SUFDdENBLFNBQVMsQ0FBQyxtQkFBbUIsR0FBRztJQUNoQ0EsU0FBUyxDQUFDLDZCQUE2QixHQUFHO0FBQzlDLEdBQUdBLGFBQWNBLENBQUFBLFlBQVksQ0FBQztBQUM5Qjs7Q0FFQyxHQUNELE1BQU1DO0lBQ0Z2YSxZQUFZNUIsSUFBSSxFQUFFb2MsT0FBTyxFQUFFL2IsUUFBUSxFQUFFZ2MsTUFBTSxDQUFFO1FBQ3pDLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEVBQUU7UUFDdEIsSUFBSSxDQUFDQyxjQUFjLEdBQUcsQ0FBQztRQUN2QixJQUFJLENBQUNDLGVBQWUsR0FBR0o7UUFDdkIsSUFBSSxDQUFDSyxJQUFJLENBQUN6YyxNQUFNSyxVQUFVZ2M7SUFDOUI7SUFDQUksS0FBS3pjLElBQUksRUFBRUssUUFBUSxFQUFFZ2MsTUFBTSxFQUFFO1FBQ3pCLElBQUl0aUIsSUFBSUM7UUFDUixJQUFJLENBQUMwaUIsWUFBWSxHQUFHMWM7UUFDcEIsSUFBSSxDQUFDc2MsWUFBWSxHQUFHamMsUUFBUSxDQUFDLElBQUksQ0FBQ3FjLFlBQVksQ0FBQyxJQUFJLEVBQUU7UUFDckQsSUFBSSxDQUFDQyx1QkFBdUIsR0FBR3RjLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTdWMsZUFBZTtRQUMzRyxJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJQyxnQkFBZ0I7WUFBRXhYLFFBQVEsQ0FBQztRQUFFO1FBQ2pDLElBQUksQ0FBQytXLFVBQVUxaEIsT0FBT1MsSUFBSSxDQUFDaWhCLFFBQVEvZ0IsTUFBTSxLQUFLLEdBQUc7WUFDN0N3aEIsZ0JBQWdCO2dCQUFFeFgsUUFBUSxDQUFDO1lBQUU7UUFDakMsT0FDSyxJQUFJLE9BQU8rVyxXQUFXLFVBQVU7WUFDakNTLGdCQUFnQm5pQixPQUFPd0IsTUFBTSxDQUFDLENBQUMsR0FBR2tnQjtRQUN0QyxPQUNLO1lBQ0RTLGdCQUFnQlQ7UUFDcEI7UUFDQSxJQUFJUyxhQUFhLENBQUMsU0FBUyxFQUFFO1lBQ3pCQSxhQUFhLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBR3pjLFFBQVEsQ0FBQyxnQkFBZ0I7UUFDcEU7UUFDQSxJQUFJLENBQUNrYyxjQUFjLEdBQUdPO1FBQ3RCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQ2pCLENBQUMvaUIsS0FBSyxDQUFDRCxLQUFLK2lCLGFBQWEsQ0FBQyxTQUFTLE1BQU0sUUFBUS9pQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxXQUFXLE1BQU0sUUFBUUMsT0FBTyxLQUFLLElBQUlBLEtBQUssSUFBSSxDQUFDc2lCLFlBQVksQ0FBQ2hoQixNQUFNO0lBQzNKO0lBQ0EwaEIsYUFBYTNjLFFBQVEsRUFBRTtRQUNuQixJQUFJLENBQUNvYyxJQUFJLENBQUMsSUFBSSxDQUFDQyxZQUFZLEVBQUVyYyxVQUFVLElBQUksQ0FBQ2tjLGNBQWM7SUFDOUQ7SUFDQTs7Ozs7O0tBTUMsR0FDRCxJQUFJVSxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUNYLFlBQVk7SUFDNUI7SUFDQTs7S0FFQyxHQUNELElBQUl0YyxPQUFPO1FBQ1AsT0FBTyxJQUFJLENBQUMwYyxZQUFZO0lBQzVCO0lBQ0E7Ozs7O0tBS0MsR0FDRCxJQUFJUSxXQUFXO1FBQ1gsT0FBTyxJQUFJLENBQUNILGdCQUFnQjtJQUNoQztJQUNBOztLQUVDLEdBQ0QsSUFBSUgsa0JBQWtCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDRCx1QkFBdUI7SUFDdkM7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsSUFBSU4sU0FBUztRQUNULE9BQU8sSUFBSSxDQUFDRSxjQUFjO0lBQzlCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJWSxhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUNiLFlBQVksQ0FBQ2hoQixNQUFNO0lBQ25DO0lBQ0E7O0tBRUMsR0FDRDhoQixRQUFRQyxLQUFLLEVBQUU7UUFDWCxPQUFPLElBQUksQ0FBQ2YsWUFBWSxDQUFDZSxNQUFNO0lBQ25DO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7S0FnQkMsR0FDRCxDQUFDQyxPQUFPQyxhQUFhLENBQUMsR0FBRztRQUNyQixPQUFPO1lBQ0hDLE1BQU07Z0JBQ0YsSUFBSSxJQUFJLENBQUNYLFdBQVcsSUFBSSxJQUFJLENBQUNNLFVBQVUsRUFBRTtvQkFDckMsSUFBSSxJQUFJLENBQUNNLFdBQVcsSUFBSTt3QkFDcEIsTUFBTSxJQUFJLENBQUNDLFFBQVE7b0JBQ3ZCLE9BQ0s7d0JBQ0QsT0FBTzs0QkFBRTNpQixPQUFPNUI7NEJBQVdvTixNQUFNO3dCQUFLO29CQUMxQztnQkFDSjtnQkFDQSxNQUFNb0MsT0FBTyxJQUFJLENBQUN5VSxPQUFPLENBQUMsSUFBSSxDQUFDUCxXQUFXO2dCQUMxQyxJQUFJLENBQUNBLFdBQVcsSUFBSTtnQkFDcEIsT0FBTztvQkFBRTloQixPQUFPNE47b0JBQU1wQyxNQUFNO2dCQUFNO1lBQ3RDO1lBQ0FvWCxRQUFRO2dCQUNKLE9BQU87b0JBQUU1aUIsT0FBTzVCO29CQUFXb04sTUFBTTtnQkFBSztZQUMxQztRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQkMsR0FDRCxNQUFNbVgsV0FBVztRQUNiLElBQUksQ0FBQyxJQUFJLENBQUNELFdBQVcsSUFBSTtZQUNyQixNQUFNLElBQUl4aUIsTUFBTTtRQUNwQjtRQUNBLE1BQU1vRixXQUFXLE1BQU0sSUFBSSxDQUFDbWMsZUFBZSxDQUFDLElBQUksQ0FBQ0gsTUFBTTtRQUN2RCxJQUFJLENBQUNXLFlBQVksQ0FBQzNjO1FBQ2xCLE9BQU8sSUFBSSxDQUFDNGMsSUFBSTtJQUNwQjtJQUNBOztLQUVDLEdBQ0RRLGNBQWM7UUFDVixJQUFJMWpCO1FBQ0osSUFBSSxDQUFDLENBQUNBLEtBQUssSUFBSSxDQUFDc2lCLE1BQU0sQ0FBQyxTQUFTLE1BQU0sUUFBUXRpQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxZQUFZLE1BQU1aLFdBQVc7WUFDbkcsT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNYO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTXlrQixnQkFBZ0J6akI7SUFDbEJ5SCxZQUFZNEYsU0FBUyxDQUFFO1FBQ25CLEtBQUs7UUFDTCxJQUFJLENBQUNBLFNBQVMsR0FBR0E7UUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBaUJDLEdBQ0QsSUFBSSxDQUFDcVcsTUFBTSxHQUFHLE9BQU94QjtZQUNqQixJQUFJdGlCLElBQUlDO1lBQ1IsSUFBSSxJQUFJLENBQUN3TixTQUFTLENBQUNwQixVQUFVLElBQUk7Z0JBQzdCLE1BQU0wWCxZQUFZQyxLQUFLQyxHQUFHO2dCQUMxQixNQUFNQyxlQUFlSCxVQUFVSSxRQUFRO2dCQUN2QyxJQUFJeGlCLE1BQU1DLE9BQU8sQ0FBQzBnQixPQUFPeE8sR0FBRyxHQUFHO29CQUMzQixNQUFNLElBQUk1UyxNQUFNLGdFQUNaO2dCQUNSO2dCQUNBb2hCLE9BQU8vVyxNQUFNLEdBQUcrVyxPQUFPL1csTUFBTSxJQUFJLENBQUM7Z0JBQ2xDLElBQUkrVyxPQUFPL1csTUFBTSxDQUFDNlksV0FBVyxLQUFLaGxCLFdBQVc7b0JBQ3pDa2pCLE9BQU8vVyxNQUFNLENBQUM2WSxXQUFXLEdBQUc7Z0JBQ2hDO2dCQUNBLElBQUk5QixPQUFPL1csTUFBTSxDQUFDOEksSUFBSSxLQUFLalYsYUFBYSxPQUFPa2pCLE9BQU94TyxHQUFHLEtBQUssVUFBVTtvQkFDcEUsSUFBSXdPLE9BQU94TyxHQUFHLENBQUNuRyxVQUFVLENBQUMsWUFBWTJVLE9BQU94TyxHQUFHLENBQUN0UyxRQUFRLENBQUMsV0FBVzt3QkFDakU4Z0IsT0FBTy9XLE1BQU0sQ0FBQzhJLElBQUksR0FBRyxDQUFDLEVBQUVpTyxPQUFPeE8sR0FBRyxDQUFDcFMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztvQkFDMUQsT0FDSyxJQUFJNGdCLE9BQU94TyxHQUFHLENBQUNuRyxVQUFVLENBQUMsVUFBVTt3QkFDckMyVSxPQUFPL1csTUFBTSxDQUFDOEksSUFBSSxHQUNkLENBQUMsRUFBRWlPLE9BQU94TyxHQUFHLENBQUMsTUFBTSxFQUFFb1EsYUFBYSxDQUFDO29CQUM1QyxPQUNLO3dCQUNELE1BQU0sSUFBSWhqQixNQUFNLHdCQUF3Qm9oQixPQUFPeE8sR0FBRztvQkFDdEQ7Z0JBQ0o7WUFDSixPQUNLO2dCQUNELElBQUluUyxNQUFNQyxPQUFPLENBQUMwZ0IsT0FBT3hPLEdBQUcsS0FDdkIsT0FBT3dPLE9BQU94TyxHQUFHLEtBQUssWUFBWXdPLE9BQU94TyxHQUFHLENBQUNHLGVBQWUsRUFBRztvQkFDaEUsb0RBQW9EO29CQUNwRCxJQUFJb1EsT0FBTztvQkFDWCxJQUFJQyxjQUFjLENBQUM7b0JBQ25CLE1BQU1DLE9BQU8vRyxnQ0FBZ0MsSUFBSSxDQUFDL1AsU0FBUyxFQUFFNlU7b0JBQzdEK0IsT0FBT2hrQixVQUFVLGdDQUFnQ2trQixJQUFJLENBQUMsT0FBTztvQkFDN0RELGNBQWNDLElBQUksQ0FBQyxTQUFTO29CQUM1Qix3Q0FBd0M7b0JBQ3hDLDRDQUE0QztvQkFDNUMsTUFBTUMsUUFBUUQsSUFBSSxDQUFDLFFBQVE7b0JBQzNCLE1BQU1FLGNBQWNELEtBQUssQ0FBQyxjQUFjO29CQUN4QyxNQUFNRSxrQkFBa0JELFdBQVcsQ0FBQyxXQUFXO29CQUMvQyxNQUFNRSxXQUFXRCxlQUFlLENBQUMsV0FBVztvQkFDNUMsTUFBTUUsY0FBYyxFQUFFO29CQUN0QixLQUFLLE1BQU12QyxXQUFXc0MsU0FBVTt3QkFDNUIsTUFBTUUsY0FBY3hDO3dCQUNwQixJQUFJd0MsV0FBVyxDQUFDLG9CQUFvQixFQUFFOzRCQUNsQyxNQUFNQyx5QkFBeUJELFdBQVcsQ0FBQyxvQkFBb0I7NEJBQy9ELE9BQU9BLFdBQVcsQ0FBQyxvQkFBb0I7NEJBQ3ZDLE1BQU1FLGlCQUFpQkYsV0FBVyxDQUFDLFVBQVU7NEJBQzdDRSxjQUFjLENBQUMsb0JBQW9CLEdBQUdEOzRCQUN0Q0QsV0FBVyxDQUFDLFVBQVUsR0FBR0U7d0JBQzdCO3dCQUNBSCxZQUFZcmQsSUFBSSxDQUFDc2Q7b0JBQ3JCO29CQUNBSCxlQUFlLENBQUMsV0FBVyxHQUFHRTtvQkFDOUIsT0FBT0wsSUFBSSxDQUFDLFNBQVM7b0JBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO29CQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztvQkFDckIsTUFBTWplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUMxQjRVLE9BQU8sQ0FBQzt3QkFDVGdDLE1BQU1BO3dCQUNOQyxhQUFhQTt3QkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjt3QkFDckJXLFlBQVk7d0JBQ1p0bEIsYUFBYSxDQUFDSSxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVzt3QkFDckZ1bEIsYUFBYSxDQUFDbGxCLEtBQUtxaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdEwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2xCLFdBQVc7b0JBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQzt3QkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtvQkFDNUI7b0JBQ0EsT0FBTzVCLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO3dCQUNsQixNQUFNa1osT0FBT2xFLGtCQUFrQmhWO3dCQUMvQixPQUFPa1o7b0JBQ1g7Z0JBQ0o7WUFDSjtZQUNBLE9BQU8sTUFBTSxJQUFJLENBQUNDLGNBQWMsQ0FBQ2pEO1FBQ3JDO1FBQ0E7Ozs7Ozs7Ozs7Ozs7U0FhQyxHQUNELElBQUksQ0FBQ2tELElBQUksR0FBRyxPQUFPbEQsU0FBUyxDQUFDLENBQUM7WUFDMUIsT0FBTyxJQUFJRixNQUFNRCxVQUFVc0QscUJBQXFCLEVBQUUsQ0FBQ0MsSUFBTSxJQUFJLENBQUNDLFlBQVksQ0FBQ0QsSUFBSSxNQUFNLElBQUksQ0FBQ0MsWUFBWSxDQUFDckQsU0FBU0E7UUFDcEg7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNELE1BQU1pRCxlQUFlakQsTUFBTSxFQUFFO1FBQ3pCLElBQUl0aUIsSUFBSUMsSUFBSXFJLElBQUlDO1FBQ2hCLElBQUlqQztRQUNKLElBQUkrZCxPQUFPO1FBQ1gsSUFBSUMsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDN1csU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCLE1BQU1rWSxPQUFPaEcsaUNBQWlDLElBQUksQ0FBQzlRLFNBQVMsRUFBRTZVO1lBQzlEK0IsT0FBT2hrQixVQUFVLHVCQUF1QmtrQixJQUFJLENBQUMsT0FBTztZQUNwREQsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QixTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU90RCxtQkFBbUI1VjtnQkFDaEMsT0FBT2taO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTWYsT0FBTy9HLGdDQUFnQyxJQUFJLENBQUMvUCxTQUFTLEVBQUU2VTtZQUM3RCtCLE9BQU9oa0IsVUFBVSxnQ0FBZ0Nra0IsSUFBSSxDQUFDLE9BQU87WUFDN0RELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUMwSSxLQUFLZ2EsT0FBTy9XLE1BQU0sTUFBTSxRQUFRakQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMUksV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDNWMsS0FBSytaLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWhELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRjLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJO1lBQzVCO1lBQ0EsT0FBTzVCLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBT2xFLGtCQUFrQmhWO2dCQUMvQixPQUFPa1o7WUFDWDtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7OztLQVVDLEdBQ0QsTUFBTU0sSUFBSXRELE1BQU0sRUFBRTtRQUNkLElBQUl0aUIsSUFBSUMsSUFBSXFJLElBQUlDO1FBQ2hCLElBQUlqQztRQUNKLElBQUkrZCxPQUFPO1FBQ1gsSUFBSUMsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDN1csU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCLE1BQU1rWSxPQUFPL0YsOEJBQThCLElBQUksQ0FBQy9RLFNBQVMsRUFBRTZVO1lBQzNEK0IsT0FBT2hrQixVQUFVLDhCQUE4QmtrQixJQUFJLENBQUMsT0FBTztZQUMzREQsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QixTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU90RCxtQkFBbUI1VjtnQkFDaEMsT0FBT2taO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTWYsT0FBTzdHLDZCQUE2QixJQUFJLENBQUNqUSxTQUFTLEVBQUU2VTtZQUMxRCtCLE9BQU9oa0IsVUFBVSxrQkFBa0Jra0IsSUFBSSxDQUFDLE9BQU87WUFDL0NELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUMwSSxLQUFLZ2EsT0FBTy9XLE1BQU0sTUFBTSxRQUFRakQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMUksV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDNWMsS0FBSytaLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWhELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRjLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJO1lBQzVCO1lBQ0EsT0FBTzVCLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBT2xFLGtCQUFrQmhWO2dCQUMvQixPQUFPa1o7WUFDWDtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7OztLQVVDLEdBQ0QsTUFBTU8sT0FBT3ZELE1BQU0sRUFBRTtRQUNqQixJQUFJdGlCLElBQUlDLElBQUlxSSxJQUFJQztRQUNoQixJQUFJOGIsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNa1ksT0FBTzlGLGlDQUFpQyxJQUFJLENBQUNoUixTQUFTLEVBQUU2VTtZQUM5RCtCLE9BQU9oa0IsVUFBVSxxQ0FBcUNra0IsSUFBSSxDQUFDLE9BQU87WUFDbEVELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE1BQU0sSUFBSSxDQUFDOVcsU0FBUyxDQUFDNFUsT0FBTyxDQUFDO2dCQUN6QmdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDSSxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDbGxCLEtBQUtxaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdEwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2xCLFdBQVc7WUFDekY7UUFDSixPQUNLO1lBQ0QsTUFBTVosT0FBTzVHLGdDQUFnQyxJQUFJLENBQUNsUSxTQUFTLEVBQUU2VTtZQUM3RCtCLE9BQU9oa0IsVUFBVSx5QkFBeUJra0IsSUFBSSxDQUFDLE9BQU87WUFDdERELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE1BQU0sSUFBSSxDQUFDOVcsU0FBUyxDQUFDNFUsT0FBTyxDQUFDO2dCQUN6QmdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDMEksS0FBS2dhLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWpELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzFJLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQzVjLEtBQUsrWixPQUFPL1csTUFBTSxNQUFNLFFBQVFoRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc0YyxXQUFXO1lBQ3pGO1FBQ0o7SUFDSjtJQUNBLE1BQU1RLGFBQWFyRCxNQUFNLEVBQUU7UUFDdkIsSUFBSXRpQixJQUFJQyxJQUFJcUksSUFBSUM7UUFDaEIsSUFBSWpDO1FBQ0osSUFBSStkLE9BQU87UUFDWCxJQUFJQyxjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUM3VyxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTWtZLE9BQU8zRixnQ0FBZ0MwRDtZQUM3QytCLE9BQU9oa0IsVUFBVSx1QkFBdUJra0IsSUFBSSxDQUFDLE9BQU87WUFDcERELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUNJLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVsQixhQUFhLENBQUNsbEIsS0FBS3FpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF0TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbEIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUksR0FBR2tkLElBQUksQ0FBQyxDQUFDVTtvQkFDN0IsTUFBTXhmLFdBQVd3ZjtvQkFDakJ4ZixTQUFTdWMsZUFBZSxHQUFHO3dCQUN2Qi9hLFNBQVN1ZCxhQUFhdmQsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU9yRCxnQ0FBZ0M3VjtnQkFDN0MsTUFBTTJaLFlBQVksSUFBSWxiO2dCQUN0QmpLLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTXhCLE9BQU94RywrQkFBK0J1RTtZQUM1QytCLE9BQU9oa0IsVUFBVSxXQUFXa2tCLElBQUksQ0FBQyxPQUFPO1lBQ3hDRCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDMEksS0FBS2dhLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWpELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzFJLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQzVjLEtBQUsrWixPQUFPL1csTUFBTSxNQUFNLFFBQVFoRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc0YyxXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSSxHQUFHa2QsSUFBSSxDQUFDLENBQUNVO29CQUM3QixNQUFNeGYsV0FBV3dmO29CQUNqQnhmLFNBQVN1YyxlQUFlLEdBQUc7d0JBQ3ZCL2EsU0FBU3VkLGFBQWF2ZCxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBTzlELCtCQUErQnBWO2dCQUM1QyxNQUFNMlosWUFBWSxJQUFJbGI7Z0JBQ3RCakssT0FBT3dCLE1BQU0sQ0FBQzJqQixXQUFXVDtnQkFDekIsT0FBT1M7WUFDWDtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7OztLQVVDLEdBQ0QsTUFBTUMsT0FBTzFELE1BQU0sRUFBRTtRQUNqQixJQUFJdGlCLElBQUlDLElBQUlxSSxJQUFJQztRQUNoQixJQUFJakM7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNa1ksT0FBTzFGLGlDQUFpQyxJQUFJLENBQUNwUixTQUFTLEVBQUU2VTtZQUM5RCtCLE9BQU9oa0IsVUFBVSw4QkFBOEJra0IsSUFBSSxDQUFDLE9BQU87WUFDM0RELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUNJLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVsQixhQUFhLENBQUNsbEIsS0FBS3FpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF0TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbEIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUksR0FBR2tkLElBQUksQ0FBQyxDQUFDVTtvQkFDN0IsTUFBTXhmLFdBQVd3ZjtvQkFDakJ4ZixTQUFTdWMsZUFBZSxHQUFHO3dCQUN2Qi9hLFNBQVN1ZCxhQUFhdmQsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU9wRCw0QkFBNEI5VjtnQkFDekMsT0FBT2taO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTWYsT0FBT3ZHLGdDQUFnQyxJQUFJLENBQUN2USxTQUFTLEVBQUU2VTtZQUM3RCtCLE9BQU9oa0IsVUFBVSxrQkFBa0Jra0IsSUFBSSxDQUFDLE9BQU87WUFDL0NELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUMwSSxLQUFLZ2EsT0FBTy9XLE1BQU0sTUFBTSxRQUFRakQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMUksV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDNWMsS0FBSytaLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWhELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRjLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJLEdBQUdrZCxJQUFJLENBQUMsQ0FBQ1U7b0JBQzdCLE1BQU14ZixXQUFXd2Y7b0JBQ2pCeGYsU0FBU3VjLGVBQWUsR0FBRzt3QkFDdkIvYSxTQUFTdWQsYUFBYXZkLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPM0QsMkJBQTJCdlY7Z0JBQ3hDLE9BQU9rWjtZQUNYO1FBQ0o7SUFDSjtBQUNKO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNXLHVCQUF1QmhSLFVBQVU7SUFDdEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1DLFVBQVU5UyxlQUFlNFMsWUFBWTtRQUFDO0tBQU07SUFDbEQsSUFBSUUsV0FBVyxNQUFNO1FBQ2pCaFUsZUFBZStULFVBQVU7WUFBQztTQUFNLEVBQUVDO0lBQ3RDO0lBQ0EsTUFBTUMsZ0JBQWdCL1MsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlHLGlCQUFpQixNQUFNO1FBQ3ZCalUsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVFO0lBQzVDO0lBQ0EsTUFBTUMsa0JBQWtCaFQsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlJLG1CQUFtQixNQUFNO1FBQ3pCbFUsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVHO0lBQzlDO0lBQ0EsT0FBT0g7QUFDWDtBQUNBLFNBQVNnUixjQUFjalIsVUFBVTtJQUM3QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSTdTLGVBQWU0UyxZQUFZO1FBQUM7S0FBYyxNQUFNN1YsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXFVLFdBQVdsVCxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSU0sWUFBWSxNQUFNO1FBQ2xCcFUsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVLO0lBQ3ZDO0lBQ0EsTUFBTUMsZUFBZW5ULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJTyxnQkFBZ0IsTUFBTTtRQUN0QnJVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFTTtJQUMzQztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTaVIsa0JBQWtCbFIsVUFBVTtJQUNqQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSTdTLGVBQWU0UyxZQUFZO1FBQUM7S0FBYyxNQUFNN1YsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXdVLGNBQWNyVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSVMsZUFBZSxNQUFNO1FBQ3JCdlUsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUVRO0lBQzFDO0lBQ0EsTUFBTUYsZUFBZW5ULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJTyxnQkFBZ0IsTUFBTTtRQUN0QnJVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFTTtJQUMzQztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTa1IsY0FBY25SLFVBQVU7SUFDN0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1VLG9CQUFvQnZULGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJVyxxQkFBcUIsTUFBTTtRQUMzQnpVLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRStRLHVCQUF1QnJRO0lBQ3ZFO0lBQ0EsTUFBTUMsY0FBY3hULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJWSxlQUFlLE1BQU07UUFDckIxVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVc7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUJ6VCxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWEsa0JBQWtCLE1BQU07UUFDeEIzVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRWdSLGNBQWNwUTtJQUMzRDtJQUNBLE1BQU1DLGVBQWUxVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWMsZ0JBQWdCLE1BQU07UUFDdEI1VSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRWlSLGtCQUFrQnBRO0lBQzdEO0lBQ0EsTUFBTUMsdUJBQXVCM1QsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUllLHdCQUF3QixNQUFNO1FBQzlCN1UsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFYztJQUNuRDtJQUNBLE1BQU1DLDBCQUEwQjVULGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJZ0IsMkJBQTJCLE1BQU07UUFDakM5VSxlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUVlO0lBQ3REO0lBQ0EsTUFBTUMscUJBQXFCN1QsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUlpQixzQkFBc0IsTUFBTTtRQUM1Qi9VLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRWdCO0lBQ2pEO0lBQ0EsTUFBTUMsbUJBQW1COVQsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlrQixvQkFBb0IsTUFBTTtRQUMxQmhWLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFaUI7SUFDL0M7SUFDQSxNQUFNQyx1QkFBdUIvVCxlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSW1CLHdCQUF3QixNQUFNO1FBQzlCalYsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFa0I7SUFDbkQ7SUFDQSxNQUFNQyxXQUFXaFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlvQixZQUFZLE1BQU07UUFDbEJsVixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRW1CO0lBQ3ZDO0lBQ0EsT0FBT25CO0FBQ1g7QUFDQSxTQUFTbVIsaUJBQWlCcFIsVUFBVTtJQUNoQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFCLFlBQVlsVSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXNCLGFBQWEsTUFBTTtRQUNuQixJQUFJQyxrQkFBa0JEO1FBQ3RCLElBQUk1VSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3dYLGNBQWN4WDtZQUN6QjtRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRXNCO0lBQ3hDO0lBQ0EsTUFBTUMsV0FBV3BVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJd0IsWUFBWSxNQUFNO1FBQ2xCdFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV1QjtJQUN2QztJQUNBLE9BQU92QjtBQUNYO0FBQ0EsU0FBU29SLDZCQUE2QnJSLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1tRCxlQUFlaFcsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlvRCxnQkFBZ0IsTUFBTTtRQUN0QmxYLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFbUQ7SUFDM0M7SUFDQSxNQUFNeEIsa0JBQWtCeFUsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUk0QixtQkFBbUIsTUFBTTtRQUN6QjFWLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFMkI7SUFDOUM7SUFDQSxNQUFNcEUsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV6QztJQUN2QztJQUNBLE1BQU02RixpQkFBaUJqVyxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXFELGtCQUFrQixNQUFNO1FBQ3hCblgsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVvRDtJQUM3QztJQUNBLE1BQU1DLDJCQUEyQmxXLGVBQWU0UyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJc0QsNEJBQTRCLE1BQU07UUFDbENwWCxlQUFlK1QsVUFBVTtZQUFDO1NBQXVCLEVBQUVxRDtJQUN2RDtJQUNBLE1BQU1DLGVBQWVuVyxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXVELGdCQUFnQixNQUFNO1FBQ3RCclgsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVzRDtJQUMzQztJQUNBLE1BQU1DLHlCQUF5QnBXLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJd0QsMEJBQTBCLE1BQU07UUFDaEN0WCxlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUV1RDtJQUNyRDtJQUNBLE9BQU92RDtBQUNYO0FBQ0EsU0FBU3FSLGtCQUFrQnRSLFVBQVU7SUFDakMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15RCxnQkFBZ0J0VyxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSTBELGlCQUFpQixNQUFNO1FBQ3ZCeFgsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUV5RDtJQUM1QztJQUNBLE1BQU1DLGNBQWN2VyxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSTJELGVBQWUsTUFBTTtRQUNyQnpYLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFMEQ7SUFDMUM7SUFDQSxPQUFPMUQ7QUFDWDtBQUNBLFNBQVNzUixzQkFBc0J2UixVQUFVO0lBQ3JDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNEQsc0JBQXNCelcsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUk2RCx1QkFBdUIsTUFBTTtRQUM3QjNYLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRXFSLGtCQUFrQnpOO0lBQ3BFO0lBQ0EsSUFBSXpXLGVBQWU0UyxZQUFZO1FBQUM7S0FBaUIsTUFBTTdWLFdBQVc7UUFDOUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU9nVTtBQUNYO0FBQ0EsU0FBU3VSLGdDQUFnQ3hSLFVBQVU7SUFDL0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04RCxXQUFXM1csZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrRCxZQUFZLE1BQU07UUFDbEI3WCxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRThEO0lBQ3ZDO0lBQ0EsTUFBTUMsdUJBQXVCNVcsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlnRSx3QkFBd0IsTUFBTTtRQUM5QjlYLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRStEO0lBQ25EO0lBQ0EsT0FBTy9EO0FBQ1g7QUFDQSxTQUFTd1IsK0JBQStCelIsVUFBVTtJQUM5QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWlFLDZCQUE2QjlXLGVBQWU0UyxZQUFZO1FBQzFEO0tBQ0g7SUFDRCxJQUFJa0UsOEJBQThCLE1BQU07UUFDcENoWSxlQUFlK1QsVUFBVTtZQUFDO1NBQXlCLEVBQUV1UixnQ0FBZ0N0TjtJQUN6RjtJQUNBLE9BQU9qRTtBQUNYO0FBQ0EsU0FBU3lSO0lBQ0wsTUFBTXpSLFdBQVcsQ0FBQztJQUNsQixPQUFPQTtBQUNYO0FBQ0EsU0FBUzBSLHlCQUF5QjNSLFVBQVU7SUFDeEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vRSxrQkFBa0JqWCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXFFLG1CQUFtQixNQUFNO1FBQ3pCblksZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVvRTtJQUM5QztJQUNBLE9BQU9wRTtBQUNYO0FBQ0EsU0FBUzJSLGNBQWM1UixVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNc0UsMkJBQTJCblgsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUl1RSw0QkFBNEIsTUFBTTtRQUNsQyxJQUFJaEQsa0JBQWtCZ0Q7UUFDdEIsSUFBSTdYLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPMFgsNkJBQTZCMVg7WUFDeEM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUF1QixFQUFFc0I7SUFDdkQ7SUFDQSxJQUFJblUsZUFBZTRTLFlBQVk7UUFBQztLQUFZLE1BQU03VixXQUFXO1FBQ3pELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNdVksbUJBQW1CcFgsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUl3RSxvQkFBb0IsTUFBTTtRQUMxQnRZLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFc1Isc0JBQXNCL007SUFDckU7SUFDQSxNQUFNQyw0QkFBNEJyWCxlQUFlNFMsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSXlFLDZCQUE2QixNQUFNO1FBQ25DdlksZUFBZStULFVBQVU7WUFBQztTQUF3QixFQUFFd1IsK0JBQStCaE47SUFDdkY7SUFDQSxJQUFJclgsZUFBZTRTLFlBQVk7UUFBQztLQUFzQixNQUFNN1YsV0FBVztRQUNuRSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBYSxNQUFNN1YsV0FBVztRQUMxRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXlZLGlCQUFpQnRYLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJMEUsa0JBQWtCLE1BQU07UUFDeEJ4WSxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXlSO0lBQzdDO0lBQ0EsTUFBTS9NLGtCQUFrQnZYLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJMkUsbUJBQW1CLE1BQU07UUFDekJ6WSxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRTBSLHlCQUF5QmhOO0lBQ3ZFO0lBQ0EsTUFBTUMsb0JBQW9CeFgsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUk0RSxxQkFBcUIsTUFBTTtRQUMzQjFZLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRTJFO0lBQ2hEO0lBQ0EsT0FBTzNFO0FBQ1g7QUFDQSxTQUFTNFIsK0JBQStCN1IsVUFBVTtJQUM5QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThELFdBQVczVyxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSStELFlBQVksTUFBTTtRQUNsQjdYLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFOEQ7SUFDdkM7SUFDQSxNQUFNZSwyQkFBMkIxWCxlQUFlNFMsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSThFLDRCQUE0QixNQUFNO1FBQ2xDNVksZUFBZStULFVBQVU7WUFBQztTQUF1QixFQUFFNkU7SUFDdkQ7SUFDQSxPQUFPN0U7QUFDWDtBQUNBLFNBQVM2UixnQkFBZ0I5UixVQUFVO0lBQy9CLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNK0UsZUFBZTVYLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJZ0YsZ0JBQWdCLE1BQU07UUFDdEI5WSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRStFO0lBQzNDO0lBQ0EsTUFBTUMsZ0JBQWdCN1gsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlpRixpQkFBaUIsTUFBTTtRQUN2Qi9ZLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFZ0Y7SUFDNUM7SUFDQSxPQUFPaEY7QUFDWDtBQUNBLFNBQVM4Uix5QkFBeUIvUixVQUFVO0lBQ3hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNa0YsYUFBYS9YLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJbUYsY0FBYyxNQUFNO1FBQ3BCalosZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUU2UixnQkFBZ0IzTTtJQUN6RDtJQUNBLE1BQU1DLG1CQUFtQmhZLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJb0Ysb0JBQW9CLE1BQU07UUFDMUJsWixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRW1GO0lBQy9DO0lBQ0EsT0FBT25GO0FBQ1g7QUFDQSxTQUFTK1Isb0JBQW9CaFMsVUFBVTtJQUNuQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFGLDRCQUE0QmxZLGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJc0YsNkJBQTZCLE1BQU07UUFDbkNwWixlQUFlK1QsVUFBVTtZQUFDO1NBQXdCLEVBQUU0UiwrQkFBK0J2TTtJQUN2RjtJQUNBLE1BQU1DLHNCQUFzQm5ZLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJdUYsdUJBQXVCLE1BQU07UUFDN0JyWixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUU4Uix5QkFBeUJ4TTtJQUMzRTtJQUNBLE9BQU90RjtBQUNYO0FBQ0EsU0FBU2dTLGlDQUFpQ2pTLFVBQVUsRUFBRXVHLFlBQVk7SUFDOUQsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNaVMsVUFBVTlrQixlQUFlNFMsWUFBWTtRQUFDO0tBQU07SUFDbEQsSUFBSXVHLGlCQUFpQnBjLGFBQWErbkIsV0FBVyxNQUFNO1FBQy9DaG1CLGVBQWVxYSxjQUFjO1lBQUM7U0FBTSxFQUFFMkw7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUIva0IsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUl1RyxpQkFBaUJwYyxhQUFhZ29CLGtCQUFrQixNQUFNO1FBQ3REam1CLGVBQWVxYSxjQUFjO1lBQUM7U0FBYSxFQUFFNEw7SUFDakQ7SUFDQSxNQUFNN0osa0JBQWtCbGIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUl1RyxpQkFBaUJwYyxhQUFhbWUsbUJBQW1CLE1BQU07UUFDdkRwYyxlQUFlcWEsY0FBYztZQUFDO1NBQWMsRUFBRStCO0lBQ2xEO0lBQ0EsTUFBTU4sZUFBZTVhLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJdUcsaUJBQWlCcGMsYUFBYTZkLGdCQUFnQixNQUFNO1FBQ3BELElBQUl6RyxrQkFBa0JySCxVQUFVOE47UUFDaEMsSUFBSXRiLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPeVgsaUJBQWlCelg7WUFDNUI7UUFDSjtRQUNBek4sZUFBZXFhLGNBQWM7WUFBQztTQUFXLEVBQUVoRjtJQUMvQztJQUNBLE1BQU1pRix3QkFBd0JwWixlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFxYyx5QkFBeUIsTUFBTTtRQUM3RHRhLGVBQWVxYSxjQUFjO1lBQUM7U0FBb0IsRUFBRTZLLGlCQUFpQnJYLFNBQVN5TTtJQUNsRjtJQUNBLE1BQU1lLFlBQVluYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXVHLGlCQUFpQnBjLGFBQWFvZCxhQUFhLE1BQU07UUFDakQsSUFBSWhHLGtCQUFrQmdHO1FBQ3RCLElBQUk3YSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT2lZLGNBQWNqWTtZQUN6QjtRQUNKO1FBQ0F6TixlQUFlcWEsY0FBYztZQUFDO1NBQVEsRUFBRWhGO0lBQzVDO0lBQ0EsTUFBTWlHLGlCQUFpQnBhLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJdUcsaUJBQWlCcGMsYUFBYXFkLGtCQUFrQixNQUFNO1FBQ3REdGIsZUFBZXFhLGNBQWM7WUFBQztTQUFhLEVBQUV5TCxvQkFBb0J4SztJQUNyRTtJQUNBLElBQUlwYSxlQUFlNFMsWUFBWTtRQUFDO0tBQWEsTUFBTTdWLFdBQVc7UUFDMUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU9nVTtBQUNYO0FBQ0EsU0FBU21TLHFDQUFxQzVaLFNBQVMsRUFBRXdILFVBQVU7SUFDL0QsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04SCxZQUFZM2EsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrSCxhQUFhLE1BQU07UUFDbkI3YixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRXBILGFBQWFMLFdBQVd1UDtJQUNoRTtJQUNBLE1BQU1FLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFZ1MsaUNBQWlDaEssWUFBWWhJO0lBQ3RGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNvUyxrQ0FBa0M3WixTQUFTLEVBQUV3SCxVQUFVO0lBQzVELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRWxELG1CQUFtQnZFLFdBQVdnRjtJQUM3RTtJQUNBLE1BQU15SyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWdJO0lBQ3pDO0lBQ0EsT0FBT2hJO0FBQ1g7QUFDQSxTQUFTcVMscUNBQXFDOVosU0FBUyxFQUFFd0gsVUFBVTtJQUMvRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXpDLFdBQVdwUSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXhDLFlBQVksTUFBTTtRQUNsQnRSLGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUVsRCxtQkFBbUJ2RSxXQUFXZ0Y7SUFDN0U7SUFDQSxNQUFNeUssYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVnSTtJQUN6QztJQUNBLE9BQU9oSTtBQUNYO0FBQ0EsU0FBU3NTLGlDQUFpQ3ZTLFVBQVUsRUFBRXVHLFlBQVk7SUFDOUQsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNaVMsVUFBVTlrQixlQUFlNFMsWUFBWTtRQUFDO0tBQU07SUFDbEQsSUFBSXVHLGlCQUFpQnBjLGFBQWErbkIsV0FBVyxNQUFNO1FBQy9DaG1CLGVBQWVxYSxjQUFjO1lBQUM7U0FBTSxFQUFFMkw7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUIva0IsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUl1RyxpQkFBaUJwYyxhQUFhZ29CLGtCQUFrQixNQUFNO1FBQ3REam1CLGVBQWVxYSxjQUFjO1lBQUM7U0FBYSxFQUFFNEw7SUFDakQ7SUFDQSxPQUFPbFM7QUFDWDtBQUNBLFNBQVN1UyxxQ0FBcUNoYSxTQUFTLEVBQUV3SCxVQUFVO0lBQy9ELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRWxELG1CQUFtQnZFLFdBQVdnRjtJQUM3RTtJQUNBLE1BQU15SyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRXNTLGlDQUFpQ3RLLFlBQVloSTtJQUN0RjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTd1MsZ0NBQWdDelMsVUFBVSxFQUFFdUcsWUFBWTtJQUM3RCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU0ySSxlQUFleGIsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUl1RyxpQkFBaUJwYyxhQUFheWUsZ0JBQWdCLE1BQU07UUFDcEQxYyxlQUFlcWEsY0FBYztZQUFDO1lBQVU7U0FBVyxFQUFFcUM7SUFDekQ7SUFDQSxNQUFNQyxnQkFBZ0J6YixlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSXVHLGlCQUFpQnBjLGFBQWEwZSxpQkFBaUIsTUFBTTtRQUNyRDNjLGVBQWVxYSxjQUFjO1lBQUM7WUFBVTtTQUFZLEVBQUVzQztJQUMxRDtJQUNBLE9BQU81STtBQUNYO0FBQ0EsU0FBU3lTLG9DQUFvQzFTLFVBQVU7SUFDbkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1nSSxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRXdTLGdDQUFnQ3hLLFlBQVloSTtJQUNyRjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTMFMsd0JBQXdCM1MsVUFBVTtJQUN2QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTUMsVUFBVTlTLGVBQWU0UyxZQUFZO1FBQUM7S0FBTTtJQUNsRCxJQUFJRSxXQUFXLE1BQU07UUFDakJoVSxlQUFlK1QsVUFBVTtZQUFDO1NBQU0sRUFBRUM7SUFDdEM7SUFDQSxNQUFNQyxnQkFBZ0IvUyxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSUcsaUJBQWlCLE1BQU07UUFDdkJqVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRUU7SUFDNUM7SUFDQSxNQUFNQyxrQkFBa0JoVCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSUksbUJBQW1CLE1BQU07UUFDekJsVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRUc7SUFDOUM7SUFDQSxPQUFPSDtBQUNYO0FBQ0EsU0FBUzJTLGVBQWU1UyxVQUFVO0lBQzlCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNcUksa0JBQWtCbGIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlzSSxtQkFBbUIsTUFBTTtRQUN6QnBjLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFcUk7SUFDOUM7SUFDQSxNQUFNaEksV0FBV2xULGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJTSxZQUFZLE1BQU07UUFDbEJwVSxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRUs7SUFDdkM7SUFDQSxNQUFNQyxlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVM0UyxtQkFBbUI3UyxVQUFVO0lBQ2xDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNcUksa0JBQWtCbGIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlzSSxtQkFBbUIsTUFBTTtRQUN6QnBjLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFcUk7SUFDOUM7SUFDQSxNQUFNN0gsY0FBY3JULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJUyxlQUFlLE1BQU07UUFDckJ2VSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVE7SUFDMUM7SUFDQSxNQUFNRixlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVM2UyxlQUFlOVMsVUFBVTtJQUM5QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTVUsb0JBQW9CdlQsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlXLHFCQUFxQixNQUFNO1FBQzNCelUsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFMFMsd0JBQXdCaFM7SUFDeEU7SUFDQSxNQUFNQyxjQUFjeFQsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUlZLGVBQWUsTUFBTTtRQUNyQjFVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFVztJQUMxQztJQUNBLE1BQU1DLGlCQUFpQnpULGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJYSxrQkFBa0IsTUFBTTtRQUN4QjNVLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFMlMsZUFBZS9SO0lBQzVEO0lBQ0EsTUFBTUMsZUFBZTFULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJYyxnQkFBZ0IsTUFBTTtRQUN0QjVVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFNFMsbUJBQW1CL1I7SUFDOUQ7SUFDQSxNQUFNQyx1QkFBdUIzVCxlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSWUsd0JBQXdCLE1BQU07UUFDOUI3VSxlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVjO0lBQ25EO0lBQ0EsTUFBTUMsMEJBQTBCNVQsZUFBZTRTLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUlnQiwyQkFBMkIsTUFBTTtRQUNqQzlVLGVBQWUrVCxVQUFVO1lBQUM7U0FBc0IsRUFBRWU7SUFDdEQ7SUFDQSxNQUFNQyxxQkFBcUI3VCxlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSWlCLHNCQUFzQixNQUFNO1FBQzVCL1UsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFZ0I7SUFDakQ7SUFDQSxNQUFNQyxtQkFBbUI5VCxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSWtCLG9CQUFvQixNQUFNO1FBQzFCaFYsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVpQjtJQUMvQztJQUNBLE1BQU1DLHVCQUF1Qi9ULGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJbUIsd0JBQXdCLE1BQU07UUFDOUJqVixlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVrQjtJQUNuRDtJQUNBLE1BQU1DLFdBQVdoVSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSW9CLFlBQVksTUFBTTtRQUNsQmxWLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFbUI7SUFDdkM7SUFDQSxPQUFPbkI7QUFDWDtBQUNBLFNBQVM4UyxrQkFBa0IvUyxVQUFVO0lBQ2pDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNcUIsWUFBWWxVLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJc0IsYUFBYSxNQUFNO1FBQ25CLElBQUlDLGtCQUFrQkQ7UUFDdEIsSUFBSTVVLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPbVosZUFBZW5aO1lBQzFCO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFc0I7SUFDeEM7SUFDQSxNQUFNQyxXQUFXcFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl3QixZQUFZLE1BQU07UUFDbEJ0VixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXVCO0lBQ3ZDO0lBQ0EsT0FBT3ZCO0FBQ1g7QUFDQSxTQUFTK1MsOEJBQThCaFQsVUFBVTtJQUM3QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSTdTLGVBQWU0UyxZQUFZO1FBQUM7S0FBVyxNQUFNN1YsV0FBVztRQUN4RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTTJWLGtCQUFrQnhVLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJNEIsbUJBQW1CLE1BQU07UUFDekIxVixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRTJCO0lBQzlDO0lBQ0EsTUFBTXBFLFdBQVdwUSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXhDLFlBQVksTUFBTTtRQUNsQnRSLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFekM7SUFDdkM7SUFDQSxNQUFNNkYsaUJBQWlCalcsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlxRCxrQkFBa0IsTUFBTTtRQUN4Qm5YLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFb0Q7SUFDN0M7SUFDQSxNQUFNQywyQkFBMkJsVyxlQUFlNFMsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSXNELDRCQUE0QixNQUFNO1FBQ2xDcFgsZUFBZStULFVBQVU7WUFBQztTQUF1QixFQUFFcUQ7SUFDdkQ7SUFDQSxNQUFNQyxlQUFlblcsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUl1RCxnQkFBZ0IsTUFBTTtRQUN0QnJYLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFc0Q7SUFDM0M7SUFDQSxNQUFNQyx5QkFBeUJwVyxlQUFlNFMsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSXdELDBCQUEwQixNQUFNO1FBQ2hDdFgsZUFBZStULFVBQVU7WUFBQztTQUFxQixFQUFFdUQ7SUFDckQ7SUFDQSxPQUFPdkQ7QUFDWDtBQUNBLFNBQVNnVCxtQkFBbUJqVCxVQUFVO0lBQ2xDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUQsZ0JBQWdCdFcsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUkwRCxpQkFBaUIsTUFBTTtRQUN2QnhYLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFeUQ7SUFDNUM7SUFDQSxNQUFNQyxjQUFjdlcsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUkyRCxlQUFlLE1BQU07UUFDckJ6WCxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRTBEO0lBQzFDO0lBQ0EsT0FBTzFEO0FBQ1g7QUFDQSxTQUFTaVQsdUJBQXVCbFQsVUFBVTtJQUN0QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTRELHNCQUFzQnpXLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJNkQsdUJBQXVCLE1BQU07UUFDN0IzWCxlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVnVCxtQkFBbUJwUDtJQUNyRTtJQUNBLE1BQU1zUCxxQkFBcUIvbEIsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUltVCxzQkFBc0IsTUFBTTtRQUM1QmpuQixlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVrVDtJQUNqRDtJQUNBLE9BQU9sVDtBQUNYO0FBQ0EsU0FBU21ULGlDQUFpQ3BULFVBQVU7SUFDaEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04RCxXQUFXM1csZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrRCxZQUFZLE1BQU07UUFDbEI3WCxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRThEO0lBQ3ZDO0lBQ0EsTUFBTUMsdUJBQXVCNVcsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlnRSx3QkFBd0IsTUFBTTtRQUM5QjlYLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRStEO0lBQ25EO0lBQ0EsT0FBTy9EO0FBQ1g7QUFDQSxTQUFTb1QsZ0NBQWdDclQsVUFBVTtJQUMvQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWlFLDZCQUE2QjlXLGVBQWU0UyxZQUFZO1FBQzFEO0tBQ0g7SUFDRCxJQUFJa0UsOEJBQThCLE1BQU07UUFDcENoWSxlQUFlK1QsVUFBVTtZQUFDO1NBQXlCLEVBQUVtVCxpQ0FBaUNsUDtJQUMxRjtJQUNBLE9BQU9qRTtBQUNYO0FBQ0EsU0FBU3FULDhCQUE4QnRULFVBQVU7SUFDN0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1rVCxxQkFBcUIvbEIsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUltVCxzQkFBc0IsTUFBTTtRQUM1QmpuQixlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVrVDtJQUNqRDtJQUNBLE9BQU9sVDtBQUNYO0FBQ0EsU0FBU3NULHVCQUF1QnZULFVBQVU7SUFDdEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU11VCxtQkFBbUJwbUIsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUl3VCxvQkFBb0IsTUFBTTtRQUMxQnRuQixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRXVUO0lBQy9DO0lBQ0EsT0FBT3ZUO0FBQ1g7QUFDQSxTQUFTd1QscUJBQXFCelQsVUFBVTtJQUNwQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlULG1CQUFtQnRtQixlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSTBULG9CQUFvQixNQUFNO1FBQzFCeG5CLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFc1QsdUJBQXVCRztJQUN0RTtJQUNBLE1BQU1DLGVBQWV2bUIsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUkyVCxnQkFBZ0IsTUFBTTtRQUN0QnpuQixlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRTBUO0lBQzNDO0lBQ0EsTUFBTUMsaUNBQWlDeG1CLGVBQWU0UyxZQUFZO1FBQzlEO0tBQ0g7SUFDRCxJQUFJNFQsa0NBQWtDLE1BQU07UUFDeEMxbkIsZUFBZStULFVBQVU7WUFBQztTQUE2QixFQUFFMlQ7SUFDN0Q7SUFDQSxNQUFNQywwQkFBMEJ6bUIsZUFBZTRTLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUk2VCwyQkFBMkIsTUFBTTtRQUNqQzNuQixlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUU0VDtJQUN0RDtJQUNBLE1BQU1DLGtCQUFrQjFtQixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSThULG1CQUFtQixNQUFNO1FBQ3pCNW5CLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFNlQ7SUFDOUM7SUFDQSxNQUFNQyxpQkFBaUIzbUIsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkrVCxrQkFBa0IsTUFBTTtRQUN4QjduQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRThUO0lBQzdDO0lBQ0EsT0FBTzlUO0FBQ1g7QUFDQSxTQUFTK1QscUJBQXFCaFUsVUFBVTtJQUNwQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWdVLGlCQUFpQjdtQixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWlVLGtCQUFrQixNQUFNO1FBQ3hCL25CLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFd1QscUJBQXFCUTtJQUNsRTtJQUNBLE9BQU9oVTtBQUNYO0FBQ0EsU0FBU2lVO0lBQ0wsTUFBTWpVLFdBQVcsQ0FBQztJQUNsQixPQUFPQTtBQUNYO0FBQ0EsU0FBU2tVLDBCQUEwQm5VLFVBQVU7SUFDekMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vRSxrQkFBa0JqWCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXFFLG1CQUFtQixNQUFNO1FBQ3pCblksZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVvRTtJQUM5QztJQUNBLE9BQU9wRTtBQUNYO0FBQ0EsU0FBU21VLGVBQWVwVSxVQUFVO0lBQzlCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNc0UsMkJBQTJCblgsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUl1RSw0QkFBNEIsTUFBTTtRQUNsQyxJQUFJaEQsa0JBQWtCZ0Q7UUFDdEIsSUFBSTdYLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPcVosOEJBQThCclo7WUFDekM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUF1QixFQUFFc0I7SUFDdkQ7SUFDQSxNQUFNOFMsZ0JBQWdCam5CLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJcVUsaUJBQWlCLE1BQU07UUFDdkJub0IsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVvVTtJQUM1QztJQUNBLE1BQU03UCxtQkFBbUJwWCxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXdFLG9CQUFvQixNQUFNO1FBQzFCdFksZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVpVCx1QkFBdUIxTztJQUN0RTtJQUNBLE1BQU1DLDRCQUE0QnJYLGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJeUUsNkJBQTZCLE1BQU07UUFDbkN2WSxlQUFlK1QsVUFBVTtZQUFDO1NBQXdCLEVBQUVvVCxnQ0FBZ0M1TztJQUN4RjtJQUNBLE1BQU02UCwwQkFBMEJsbkIsZUFBZTRTLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUlzVSwyQkFBMkIsTUFBTTtRQUNqQ3BvQixlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUVxVCw4QkFBOEJnQjtJQUNwRjtJQUNBLE1BQU1DLGlCQUFpQm5uQixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXVVLGtCQUFrQixNQUFNO1FBQ3hCcm9CLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFK1QscUJBQXFCTztJQUNsRTtJQUNBLE1BQU03UCxpQkFBaUJ0WCxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSTBFLGtCQUFrQixNQUFNO1FBQ3hCeFksZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVpVTtJQUM3QztJQUNBLE1BQU12UCxrQkFBa0J2WCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTJFLG1CQUFtQixNQUFNO1FBQ3pCelksZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVrVSwwQkFBMEJ4UDtJQUN4RTtJQUNBLE1BQU1DLG9CQUFvQnhYLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJNEUscUJBQXFCLE1BQU07UUFDM0IxWSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUUyRTtJQUNoRDtJQUNBLE9BQU8zRTtBQUNYO0FBQ0EsU0FBU3VVLGdDQUFnQ3hVLFVBQVU7SUFDL0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04RCxXQUFXM1csZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrRCxZQUFZLE1BQU07UUFDbEI3WCxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRThEO0lBQ3ZDO0lBQ0EsTUFBTWUsMkJBQTJCMVgsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUk4RSw0QkFBNEIsTUFBTTtRQUNsQzVZLGVBQWUrVCxVQUFVO1lBQUM7U0FBdUIsRUFBRTZFO0lBQ3ZEO0lBQ0EsT0FBTzdFO0FBQ1g7QUFDQSxTQUFTd1UsaUJBQWlCelUsVUFBVTtJQUNoQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTStFLGVBQWU1WCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWdGLGdCQUFnQixNQUFNO1FBQ3RCOVksZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUUrRTtJQUMzQztJQUNBLE1BQU1DLGdCQUFnQjdYLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJaUYsaUJBQWlCLE1BQU07UUFDdkIvWSxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRWdGO0lBQzVDO0lBQ0EsT0FBT2hGO0FBQ1g7QUFDQSxTQUFTeVUsMEJBQTBCMVUsVUFBVTtJQUN6QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWtGLGFBQWEvWCxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSW1GLGNBQWMsTUFBTTtRQUNwQmpaLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFd1UsaUJBQWlCdFA7SUFDMUQ7SUFDQSxNQUFNQyxtQkFBbUJoWSxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSW9GLG9CQUFvQixNQUFNO1FBQzFCbFosZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVtRjtJQUMvQztJQUNBLE9BQU9uRjtBQUNYO0FBQ0EsU0FBUzBVLHFCQUFxQjNVLFVBQVU7SUFDcEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1xRiw0QkFBNEJsWSxlQUFlNFMsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSXNGLDZCQUE2QixNQUFNO1FBQ25DcFosZUFBZStULFVBQVU7WUFBQztTQUF3QixFQUFFdVUsZ0NBQWdDbFA7SUFDeEY7SUFDQSxNQUFNQyxzQkFBc0JuWSxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSXVGLHVCQUF1QixNQUFNO1FBQzdCclosZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFeVUsMEJBQTBCblA7SUFDNUU7SUFDQSxPQUFPdEY7QUFDWDtBQUNBLFNBQVMyVSxrQ0FBa0M1VSxVQUFVLEVBQUV1RyxZQUFZO0lBQy9ELE1BQU10RyxXQUFXLENBQUM7SUFDbEIsTUFBTWlTLFVBQVU5a0IsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUl1RyxpQkFBaUJwYyxhQUFhK25CLFdBQVcsTUFBTTtRQUMvQ2htQixlQUFlcWEsY0FBYztZQUFDO1NBQU0sRUFBRTJMO0lBQzFDO0lBQ0EsTUFBTUMsaUJBQWlCL2tCLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJdUcsaUJBQWlCcGMsYUFBYWdvQixrQkFBa0IsTUFBTTtRQUN0RGptQixlQUFlcWEsY0FBYztZQUFDO1NBQWEsRUFBRTRMO0lBQ2pEO0lBQ0EsTUFBTTdKLGtCQUFrQmxiLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJdUcsaUJBQWlCcGMsYUFBYW1lLG1CQUFtQixNQUFNO1FBQ3ZEcGMsZUFBZXFhLGNBQWM7WUFBQztTQUFjLEVBQUUrQjtJQUNsRDtJQUNBLE1BQU1OLGVBQWU1YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXVHLGlCQUFpQnBjLGFBQWE2ZCxnQkFBZ0IsTUFBTTtRQUNwRCxJQUFJekcsa0JBQWtCckgsVUFBVThOO1FBQ2hDLElBQUl0YixNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT29aLGtCQUFrQnBaO1lBQzdCO1FBQ0o7UUFDQXpOLGVBQWVxYSxjQUFjO1lBQUM7U0FBVyxFQUFFaEY7SUFDL0M7SUFDQSxNQUFNaUYsd0JBQXdCcFosZUFBZTRTLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhcWMseUJBQXlCLE1BQU07UUFDN0R0YSxlQUFlcWEsY0FBYztZQUFDO1NBQW9CLEVBQUV3TSxrQkFBa0JoWixTQUFTeU07SUFDbkY7SUFDQSxNQUFNZSxZQUFZbmEsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUl1RyxpQkFBaUJwYyxhQUFhb2QsYUFBYSxNQUFNO1FBQ2pELElBQUloRyxrQkFBa0JnRztRQUN0QixJQUFJN2EsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU95YSxlQUFlemE7WUFDMUI7UUFDSjtRQUNBek4sZUFBZXFhLGNBQWM7WUFBQztTQUFRLEVBQUVoRjtJQUM1QztJQUNBLE1BQU1pRyxpQkFBaUJwYSxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXVHLGlCQUFpQnBjLGFBQWFxZCxrQkFBa0IsTUFBTTtRQUN0RHRiLGVBQWVxYSxjQUFjO1lBQUM7U0FBYSxFQUFFb08scUJBQXFCbk47SUFDdEU7SUFDQSxNQUFNcU4saUJBQWlCem5CLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJdUcsaUJBQWlCcGMsYUFBYTBxQixrQkFBa0IsTUFBTTtRQUN0RDNvQixlQUFlcWEsY0FBYztZQUFDO1lBQW1CO1NBQWEsRUFBRXNPO0lBQ3BFO0lBQ0EsT0FBTzVVO0FBQ1g7QUFDQSxTQUFTNlUsc0NBQXNDdGMsU0FBUyxFQUFFd0gsVUFBVTtJQUNoRSxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFcEgsYUFBYUwsV0FBV3VQO0lBQ2hFO0lBQ0EsTUFBTUUsYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUUyVSxrQ0FBa0MzTSxZQUFZaEk7SUFDdkY7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBUzhVLG1DQUFtQ3ZjLFNBQVMsRUFBRXdILFVBQVU7SUFDN0QsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU16QyxXQUFXcFEsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl4QyxZQUFZLE1BQU07UUFDbEJ0UixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFbEQsbUJBQW1CdkUsV0FBV2dGO0lBQzdFO0lBQ0EsTUFBTXlLLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFZ0k7SUFDekM7SUFDQSxPQUFPaEk7QUFDWDtBQUNBLFNBQVMrVSxzQ0FBc0N4YyxTQUFTLEVBQUV3SCxVQUFVO0lBQ2hFLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRWxELG1CQUFtQnZFLFdBQVdnRjtJQUM3RTtJQUNBLE1BQU15SyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWdJO0lBQ3pDO0lBQ0EsT0FBT2hJO0FBQ1g7QUFDQSxTQUFTZ1Ysa0NBQWtDalYsVUFBVSxFQUFFdUcsWUFBWTtJQUMvRCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pUyxVQUFVOWtCLGVBQWU0UyxZQUFZO1FBQUM7S0FBTTtJQUNsRCxJQUFJdUcsaUJBQWlCcGMsYUFBYStuQixXQUFXLE1BQU07UUFDL0NobUIsZUFBZXFhLGNBQWM7WUFBQztTQUFNLEVBQUUyTDtJQUMxQztJQUNBLE1BQU1DLGlCQUFpQi9rQixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXVHLGlCQUFpQnBjLGFBQWFnb0Isa0JBQWtCLE1BQU07UUFDdERqbUIsZUFBZXFhLGNBQWM7WUFBQztTQUFhLEVBQUU0TDtJQUNqRDtJQUNBLE9BQU9sUztBQUNYO0FBQ0EsU0FBU2lWLHNDQUFzQzFjLFNBQVMsRUFBRXdILFVBQVU7SUFDaEUsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU16QyxXQUFXcFEsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl4QyxZQUFZLE1BQU07UUFDbEJ0UixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFbEQsbUJBQW1CdkUsV0FBV2dGO0lBQzdFO0lBQ0EsTUFBTXlLLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFZ1Ysa0NBQWtDaE4sWUFBWWhJO0lBQ3ZGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNrVixpQ0FBaUNuVixVQUFVLEVBQUV1RyxZQUFZO0lBQzlELE1BQU10RyxXQUFXLENBQUM7SUFDbEIsTUFBTTJJLGVBQWV4YixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXVHLGlCQUFpQnBjLGFBQWF5ZSxnQkFBZ0IsTUFBTTtRQUNwRDFjLGVBQWVxYSxjQUFjO1lBQUM7WUFBVTtTQUFXLEVBQUVxQztJQUN6RDtJQUNBLE1BQU1DLGdCQUFnQnpiLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJdUcsaUJBQWlCcGMsYUFBYTBlLGlCQUFpQixNQUFNO1FBQ3JEM2MsZUFBZXFhLGNBQWM7WUFBQztZQUFVO1NBQVksRUFBRXNDO0lBQzFEO0lBQ0EsT0FBTzVJO0FBQ1g7QUFDQSxTQUFTbVYscUNBQXFDcFYsVUFBVTtJQUNwRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWdJLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFa1YsaUNBQWlDbE4sWUFBWWhJO0lBQ3RGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNvVix1QkFBdUJyVixVQUFVO0lBQ3RDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV6QztJQUN2QztJQUNBLE1BQU04SyxrQkFBa0JsYixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXNJLG1CQUFtQixNQUFNO1FBQ3pCcGMsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVxSTtJQUM5QztJQUNBLE1BQU1QLFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFOEg7SUFDeEM7SUFDQSxNQUFNc0UsaUJBQWlCamYsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlxTSxrQkFBa0IsTUFBTTtRQUN4Qm5nQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRW9NO0lBQzdDO0lBQ0EsTUFBTUMsaUJBQWlCbGYsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlzTSxrQkFBa0IsTUFBTTtRQUN4QnBnQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXFNO0lBQzdDO0lBQ0EsTUFBTTZGLGlCQUFpQi9rQixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSW1TLGtCQUFrQixNQUFNO1FBQ3hCam1CLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFa1M7SUFDN0M7SUFDQSxNQUFNekcsb0JBQW9CdGUsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUkwTCxxQkFBcUIsTUFBTTtRQUMzQnhmLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXlMO0lBQ2hEO0lBQ0EsT0FBT3pMO0FBQ1g7QUFDQSxTQUFTcVY7SUFDTCxNQUFNclYsV0FBVyxDQUFDO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQSxTQUFTc1Ysb0NBQW9DdlYsVUFBVTtJQUNuRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9MLHNCQUFzQmplLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcUwsdUJBQXVCLE1BQU07UUFDN0JuZixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVvTDtJQUNsRDtJQUNBLE1BQU1tQixvQkFBb0JwZixlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXdNLHFCQUFxQixNQUFNO1FBQzNCdGdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXVNO0lBQ2hEO0lBQ0EsTUFBTWdKLHFCQUFxQnBvQixlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXdWLHNCQUFzQixNQUFNO1FBQzVCLElBQUlqVSxrQkFBa0JpVTtRQUN0QixJQUFJOW9CLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPMGIsdUJBQXVCMWI7WUFDbEM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFc0I7SUFDakQ7SUFDQSxPQUFPdEI7QUFDWDtBQUNBLFNBQVN3Vix3QkFBd0J6VixVQUFVO0lBQ3ZDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV6QztJQUN2QztJQUNBLE1BQU04SyxrQkFBa0JsYixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXNJLG1CQUFtQixNQUFNO1FBQ3pCcGMsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVxSTtJQUM5QztJQUNBLE1BQU1QLFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFOEg7SUFDeEM7SUFDQSxNQUFNc0UsaUJBQWlCamYsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlxTSxrQkFBa0IsTUFBTTtRQUN4Qm5nQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRW9NO0lBQzdDO0lBQ0EsTUFBTUMsaUJBQWlCbGYsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlzTSxrQkFBa0IsTUFBTTtRQUN4QnBnQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXFNO0lBQzdDO0lBQ0EsTUFBTTZGLGlCQUFpQi9rQixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSW1TLGtCQUFrQixNQUFNO1FBQ3hCam1CLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFa1M7SUFDN0M7SUFDQSxNQUFNekcsb0JBQW9CdGUsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUkwTCxxQkFBcUIsTUFBTTtRQUMzQnhmLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXlMO0lBQ2hEO0lBQ0EsT0FBT3pMO0FBQ1g7QUFDQSxTQUFTeVY7SUFDTCxNQUFNelYsV0FBVyxDQUFDO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQSxTQUFTMFYscUNBQXFDM1YsVUFBVTtJQUNwRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9MLHNCQUFzQmplLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcUwsdUJBQXVCLE1BQU07UUFDN0JuZixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVvTDtJQUNsRDtJQUNBLE1BQU1tQixvQkFBb0JwZixlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXdNLHFCQUFxQixNQUFNO1FBQzNCdGdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXVNO0lBQ2hEO0lBQ0EsTUFBTWdKLHFCQUFxQnBvQixlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXdWLHNCQUFzQixNQUFNO1FBQzVCLElBQUlqVSxrQkFBa0JpVTtRQUN0QixJQUFJOW9CLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPOGIsd0JBQXdCOWI7WUFDbkM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFc0I7SUFDakQ7SUFDQSxPQUFPdEI7QUFDWDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNMlYsZUFBZXpxQjtJQUNqQnlILFlBQVk0RixTQUFTLENBQUU7UUFDbkIsS0FBSztRQUNMLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtRQUNqQjs7Ozs7Ozs7Ozs7OztTQWFDLEdBQ0QsSUFBSSxDQUFDK1gsSUFBSSxHQUFHLE9BQU9sRCxTQUFTLENBQUMsQ0FBQztZQUMxQixPQUFPLElBQUlGLE1BQU1ELFVBQVUySSwwQkFBMEIsRUFBRSxDQUFDcEYsSUFBTSxJQUFJLENBQUNDLFlBQVksQ0FBQ0QsSUFBSSxNQUFNLElBQUksQ0FBQ0MsWUFBWSxDQUFDckQsU0FBU0E7UUFDekg7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBeUJDLEdBQ0QsTUFBTXdCLE9BQU94QixNQUFNLEVBQUU7UUFDakIsSUFBSXRpQixJQUFJQyxJQUFJcUksSUFBSUM7UUFDaEIsSUFBSWpDO1FBQ0osSUFBSStkLE9BQU87UUFDWCxJQUFJQyxjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUM3VyxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTWtZLE9BQU93RixzQ0FBc0MsSUFBSSxDQUFDdGMsU0FBUyxFQUFFNlU7WUFDbkUrQixPQUFPaGtCLFVBQVUsa0JBQWtCa2tCLElBQUksQ0FBQyxPQUFPO1lBQy9DRCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDSSxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDbGxCLEtBQUtxaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdEwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2xCLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJO1lBQzVCO1lBQ0EsT0FBTzVCLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBT29GLHdCQUF3QnRlO2dCQUNyQyxPQUFPa1o7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNZixPQUFPOEMscUNBQXFDLElBQUksQ0FBQzVaLFNBQVMsRUFBRTZVO1lBQ2xFK0IsT0FBT2hrQixVQUFVLGtCQUFrQmtrQixJQUFJLENBQUMsT0FBTztZQUMvQ0QsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQzBJLEtBQUtnYSxPQUFPL1csTUFBTSxNQUFNLFFBQVFqRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcxSSxXQUFXO2dCQUNyRnVsQixhQUFhLENBQUM1YyxLQUFLK1osT0FBTy9XLE1BQU0sTUFBTSxRQUFRaEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNGMsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUk7WUFDNUI7WUFDQSxPQUFPNUIsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPZ0YsdUJBQXVCbGU7Z0JBQ3BDLE9BQU9rWjtZQUNYO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNTSxJQUFJdEQsTUFBTSxFQUFFO1FBQ2QsSUFBSXRpQixJQUFJQyxJQUFJcUksSUFBSUM7UUFDaEIsSUFBSWpDO1FBQ0osSUFBSStkLE9BQU87UUFDWCxJQUFJQyxjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUM3VyxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTWtZLE9BQU95RixtQ0FBbUMsSUFBSSxDQUFDdmMsU0FBUyxFQUFFNlU7WUFDaEUrQixPQUFPaGtCLFVBQVUsVUFBVWtrQixJQUFJLENBQUMsT0FBTztZQUN2Q0QsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QixTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU9vRix3QkFBd0J0ZTtnQkFDckMsT0FBT2taO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTWYsT0FBTytDLGtDQUFrQyxJQUFJLENBQUM3WixTQUFTLEVBQUU2VTtZQUMvRCtCLE9BQU9oa0IsVUFBVSxVQUFVa2tCLElBQUksQ0FBQyxPQUFPO1lBQ3ZDRCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDMEksS0FBS2dhLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWpELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzFJLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQzVjLEtBQUsrWixPQUFPL1csTUFBTSxNQUFNLFFBQVFoRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc0YyxXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QixTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU9nRix1QkFBdUJsZTtnQkFDcEMsT0FBT2taO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7S0FVQyxHQUNELE1BQU1VLE9BQU8xRCxNQUFNLEVBQUU7UUFDakIsSUFBSXRpQixJQUFJQyxJQUFJcUksSUFBSUM7UUFDaEIsSUFBSWpDO1FBQ0osSUFBSStkLE9BQU87UUFDWCxJQUFJQyxjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUM3VyxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTWtZLE9BQU8wRixzQ0FBc0MsSUFBSSxDQUFDeGMsU0FBUyxFQUFFNlU7WUFDbkUrQixPQUFPaGtCLFVBQVUsVUFBVWtrQixJQUFJLENBQUMsT0FBTztZQUN2Q0QsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QixTQUFTOGUsSUFBSSxDQUFDO2dCQUNqQixNQUFNRSxPQUFPcUY7Z0JBQ2IsTUFBTTVFLFlBQVksSUFBSXhiO2dCQUN0QjNKLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTXhCLE9BQU9nRCxxQ0FBcUMsSUFBSSxDQUFDOVosU0FBUyxFQUFFNlU7WUFDbEUrQixPQUFPaGtCLFVBQVUsVUFBVWtrQixJQUFJLENBQUMsT0FBTztZQUN2Q0QsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQzBJLEtBQUtnYSxPQUFPL1csTUFBTSxNQUFNLFFBQVFqRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcxSSxXQUFXO2dCQUNyRnVsQixhQUFhLENBQUM1YyxLQUFLK1osT0FBTy9XLE1BQU0sTUFBTSxRQUFRaEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNGMsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUk7WUFDNUI7WUFDQSxPQUFPNUIsU0FBUzhlLElBQUksQ0FBQztnQkFDakIsTUFBTUUsT0FBT2lGO2dCQUNiLE1BQU14RSxZQUFZLElBQUl4YjtnQkFDdEIzSixPQUFPd0IsTUFBTSxDQUFDMmpCLFdBQVdUO2dCQUN6QixPQUFPUztZQUNYO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7O0tBYUMsR0FDRCxNQUFNZ0YsT0FBT3pJLE1BQU0sRUFBRTtRQUNqQixJQUFJdGlCLElBQUlDLElBQUlxSSxJQUFJQztRQUNoQixJQUFJakM7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNa1ksT0FBTzRGLHNDQUFzQyxJQUFJLENBQUMxYyxTQUFTLEVBQUU2VTtZQUNuRStCLE9BQU9oa0IsVUFBVSxVQUFVa2tCLElBQUksQ0FBQyxPQUFPO1lBQ3ZDRCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDSSxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDbGxCLEtBQUtxaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdEwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2xCLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJO1lBQzVCO1lBQ0EsT0FBTzVCLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBT29GLHdCQUF3QnRlO2dCQUNyQyxPQUFPa1o7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNZixPQUFPa0QscUNBQXFDLElBQUksQ0FBQ2hhLFNBQVMsRUFBRTZVO1lBQ2xFK0IsT0FBT2hrQixVQUFVLFVBQVVra0IsSUFBSSxDQUFDLE9BQU87WUFDdkNELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUMwSSxLQUFLZ2EsT0FBTy9XLE1BQU0sTUFBTSxRQUFRakQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMUksV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDNWMsS0FBSytaLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWhELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRjLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJO1lBQzVCO1lBQ0EsT0FBTzVCLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBT2dGLHVCQUF1QmxlO2dCQUNwQyxPQUFPa1o7WUFDWDtRQUNKO0lBQ0o7SUFDQSxNQUFNSyxhQUFhckQsTUFBTSxFQUFFO1FBQ3ZCLElBQUl0aUIsSUFBSUMsSUFBSXFJLElBQUlDO1FBQ2hCLElBQUlqQztRQUNKLElBQUkrZCxPQUFPO1FBQ1gsSUFBSUMsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDN1csU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCLE1BQU1rWSxPQUFPOEYscUNBQXFDL0g7WUFDbEQrQixPQUFPaGtCLFVBQVUsa0JBQWtCa2tCLElBQUksQ0FBQyxPQUFPO1lBQy9DRCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDSSxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDbGxCLEtBQUtxaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdEwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2xCLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJLEdBQUdrZCxJQUFJLENBQUMsQ0FBQ1U7b0JBQzdCLE1BQU14ZixXQUFXd2Y7b0JBQ2pCeGYsU0FBU3VjLGVBQWUsR0FBRzt3QkFDdkIvYSxTQUFTdWQsYUFBYXZkLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPc0YscUNBQXFDeGU7Z0JBQ2xELE1BQU0yWixZQUFZLElBQUl2YjtnQkFDdEI1SixPQUFPd0IsTUFBTSxDQUFDMmpCLFdBQVdUO2dCQUN6QixPQUFPUztZQUNYO1FBQ0osT0FDSztZQUNELE1BQU14QixPQUFPb0Qsb0NBQW9DckY7WUFDakQrQixPQUFPaGtCLFVBQVUsa0JBQWtCa2tCLElBQUksQ0FBQyxPQUFPO1lBQy9DRCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDMEksS0FBS2dhLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWpELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzFJLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQzVjLEtBQUsrWixPQUFPL1csTUFBTSxNQUFNLFFBQVFoRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc0YyxXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSSxHQUFHa2QsSUFBSSxDQUFDLENBQUNVO29CQUM3QixNQUFNeGYsV0FBV3dmO29CQUNqQnhmLFNBQVN1YyxlQUFlLEdBQUc7d0JBQ3ZCL2EsU0FBU3VkLGFBQWF2ZCxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBT2tGLG9DQUFvQ3BlO2dCQUNqRCxNQUFNMlosWUFBWSxJQUFJdmI7Z0JBQ3RCNUosT0FBT3dCLE1BQU0sQ0FBQzJqQixXQUFXVDtnQkFDekIsT0FBT1M7WUFDWDtRQUNKO0lBQ0o7QUFDSjtBQUVBOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUM5RSw4REFBOEQsR0FHOUQsU0FBU2lGLFNBQVNDLENBQUM7SUFDZixJQUFJQyxJQUFJLE9BQU8zSCxXQUFXLGNBQWNBLE9BQU80SCxRQUFRLEVBQUVDLElBQUlGLEtBQUtELENBQUMsQ0FBQ0MsRUFBRSxFQUFFNXBCLElBQUk7SUFDNUUsSUFBSThwQixHQUFHLE9BQU9BLEVBQUVycUIsSUFBSSxDQUFDa3FCO0lBQ3JCLElBQUlBLEtBQUssT0FBT0EsRUFBRTFwQixNQUFNLEtBQUssVUFBVSxPQUFPO1FBQzFDa2lCLE1BQU07WUFDRixJQUFJd0gsS0FBSzNwQixLQUFLMnBCLEVBQUUxcEIsTUFBTSxFQUFFMHBCLElBQUksS0FBSztZQUNqQyxPQUFPO2dCQUFFanFCLE9BQU9pcUIsS0FBS0EsQ0FBQyxDQUFDM3BCLElBQUk7Z0JBQUVrTCxNQUFNLENBQUN5ZTtZQUFFO1FBQzFDO0lBQ0o7SUFDQSxNQUFNLElBQUl6b0IsVUFBVTBvQixJQUFJLDRCQUE0QjtBQUN4RDtBQUVBLFNBQVNHLFFBQVFDLENBQUM7SUFDZCxPQUFPLElBQUksWUFBWUQsVUFBVyxLQUFJLENBQUNDLENBQUMsR0FBR0EsR0FBRyxJQUFJLElBQUksSUFBSUQsUUFBUUM7QUFDdEU7QUFFQSxTQUFTQyxpQkFBaUJDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxTQUFTO0lBQ3BELElBQUksQ0FBQ25JLE9BQU9DLGFBQWEsRUFBRSxNQUFNLElBQUloaEIsVUFBVTtJQUMvQyxJQUFJbXBCLElBQUlELFVBQVVFLEtBQUssQ0FBQ0osU0FBU0MsY0FBYyxFQUFFLEdBQUducUIsR0FBR3VxQixJQUFJLEVBQUU7SUFDN0QsT0FBT3ZxQixJQUFJVixPQUFPa2pCLE1BQU0sQ0FBQyxDQUFDLE9BQU9nSSxrQkFBa0IsYUFBYUEsZ0JBQWdCbHJCLE1BQUssRUFBR0MsU0FBUyxHQUFHa3JCLEtBQUssU0FBU0EsS0FBSyxVQUFVQSxLQUFLLFVBQVVDLGNBQWMxcUIsQ0FBQyxDQUFDaWlCLE9BQU9DLGFBQWEsQ0FBQyxHQUFHO1FBQWMsT0FBTyxJQUFJO0lBQUUsR0FBR2xpQjtJQUN0TixTQUFTMHFCLFlBQVlDLENBQUM7UUFBSSxPQUFPLFNBQVVYLENBQUM7WUFBSSxPQUFPWSxRQUFRQyxPQUFPLENBQUNiLEdBQUdsRyxJQUFJLENBQUM2RyxHQUFHRztRQUFTO0lBQUc7SUFDOUYsU0FBU0wsS0FBS00sQ0FBQyxFQUFFSixDQUFDO1FBQUksSUFBSU4sQ0FBQyxDQUFDVSxFQUFFLEVBQUU7WUFBRS9xQixDQUFDLENBQUMrcUIsRUFBRSxHQUFHLFNBQVVmLENBQUM7Z0JBQUksT0FBTyxJQUFJWSxRQUFRLFNBQVVJLENBQUMsRUFBRUMsQ0FBQztvQkFBSVYsRUFBRXRrQixJQUFJLENBQUM7d0JBQUM4a0I7d0JBQUdmO3dCQUFHZ0I7d0JBQUdDO3FCQUFFLElBQUksS0FBS0MsT0FBT0gsR0FBR2Y7Z0JBQUk7WUFBSTtZQUFHLElBQUlXLEdBQUczcUIsQ0FBQyxDQUFDK3FCLEVBQUUsR0FBR0osRUFBRTNxQixDQUFDLENBQUMrcUIsRUFBRTtRQUFHO0lBQUU7SUFDdkssU0FBU0csT0FBT0gsQ0FBQyxFQUFFZixDQUFDO1FBQUksSUFBSTtZQUFFbUIsS0FBS2QsQ0FBQyxDQUFDVSxFQUFFLENBQUNmO1FBQUssRUFBRSxPQUFPb0IsR0FBRztZQUFFQyxPQUFPZCxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRWE7UUFBSTtJQUFFO0lBQ2pGLFNBQVNELEtBQUtHLENBQUM7UUFBSUEsRUFBRTVyQixLQUFLLFlBQVlxcUIsVUFBVWEsUUFBUUMsT0FBTyxDQUFDUyxFQUFFNXJCLEtBQUssQ0FBQ3NxQixDQUFDLEVBQUVsRyxJQUFJLENBQUN5SCxTQUFTVCxVQUFVTyxPQUFPZCxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRWU7SUFBSTtJQUN2SCxTQUFTQyxRQUFRN3JCLEtBQUs7UUFBSXdyQixPQUFPLFFBQVF4ckI7SUFBUTtJQUNqRCxTQUFTb3JCLE9BQU9wckIsS0FBSztRQUFJd3JCLE9BQU8sU0FBU3hyQjtJQUFRO0lBQ2pELFNBQVMyckIsT0FBT1YsQ0FBQyxFQUFFWCxDQUFDO1FBQUksSUFBSVcsRUFBRVgsSUFBSU8sRUFBRWlCLEtBQUssSUFBSWpCLEVBQUV0cUIsTUFBTSxFQUFFaXJCLE9BQU9YLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFQSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7SUFBRztBQUNyRjtBQUVBLFNBQVNrQixjQUFjOUIsQ0FBQztJQUNwQixJQUFJLENBQUMxSCxPQUFPQyxhQUFhLEVBQUUsTUFBTSxJQUFJaGhCLFVBQVU7SUFDL0MsSUFBSTRvQixJQUFJSCxDQUFDLENBQUMxSCxPQUFPQyxhQUFhLENBQUMsRUFBRWxpQjtJQUNqQyxPQUFPOHBCLElBQUlBLEVBQUVycUIsSUFBSSxDQUFDa3FCLEtBQU1BLENBQUFBLElBQUksT0FBT0QsYUFBYSxhQUFhQSxTQUFTQyxLQUFLQSxDQUFDLENBQUMxSCxPQUFPNEgsUUFBUSxDQUFDLElBQUk3cEIsSUFBSSxDQUFDLEdBQUd5cUIsS0FBSyxTQUFTQSxLQUFLLFVBQVVBLEtBQUssV0FBV3pxQixDQUFDLENBQUNpaUIsT0FBT0MsYUFBYSxDQUFDLEdBQUc7UUFBYyxPQUFPLElBQUk7SUFBRSxHQUFHbGlCLENBQUFBO0lBQzlNLFNBQVN5cUIsS0FBS00sQ0FBQztRQUFJL3FCLENBQUMsQ0FBQytxQixFQUFFLEdBQUdwQixDQUFDLENBQUNvQixFQUFFLElBQUksU0FBVWYsQ0FBQztZQUFJLE9BQU8sSUFBSVksUUFBUSxTQUFVQyxPQUFPLEVBQUVDLE1BQU07Z0JBQUlkLElBQUlMLENBQUMsQ0FBQ29CLEVBQUUsQ0FBQ2YsSUFBSXFCLE9BQU9SLFNBQVNDLFFBQVFkLEVBQUU5ZSxJQUFJLEVBQUU4ZSxFQUFFdHFCLEtBQUs7WUFBRztRQUFJO0lBQUc7SUFDL0osU0FBUzJyQixPQUFPUixPQUFPLEVBQUVDLE1BQU0sRUFBRW5xQixDQUFDLEVBQUVxcEIsQ0FBQztRQUFJWSxRQUFRQyxPQUFPLENBQUNiLEdBQUdsRyxJQUFJLENBQUMsU0FBU2tHLENBQUM7WUFBSWEsUUFBUTtnQkFBRW5yQixPQUFPc3FCO2dCQUFHOWUsTUFBTXZLO1lBQUU7UUFBSSxHQUFHbXFCO0lBQVM7QUFDL0g7QUFFQSxPQUFPWSxvQkFBb0IsYUFBYUEsa0JBQWtCLFNBQVV6cUIsS0FBSyxFQUFFMHFCLFVBQVUsRUFBRUMsT0FBTztJQUMxRixJQUFJUixJQUFJLElBQUl4ckIsTUFBTWdzQjtJQUNsQixPQUFPUixFQUFFem1CLElBQUksR0FBRyxtQkFBbUJ5bUIsRUFBRW5xQixLQUFLLEdBQUdBLE9BQU9tcUIsRUFBRU8sVUFBVSxHQUFHQSxZQUFZUDtBQUNuRjtBQUVBOzs7O0NBSUMsR0FDRDs7Q0FFQyxHQUNELFNBQVNTLGdCQUFnQjdtQixRQUFRO0lBQzdCLElBQUl0RztJQUNKLElBQUlzRyxTQUFTc0MsVUFBVSxJQUFJeEosYUFBYWtILFNBQVNzQyxVQUFVLENBQUNySCxNQUFNLEtBQUssR0FBRztRQUN0RSxPQUFPO0lBQ1g7SUFDQSxNQUFNc0gsVUFBVSxDQUFDN0ksS0FBS3NHLFNBQVNzQyxVQUFVLENBQUMsRUFBRSxNQUFNLFFBQVE1SSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc2SSxPQUFPO0lBQzdGLElBQUlBLFlBQVl6SixXQUFXO1FBQ3ZCLE9BQU87SUFDWDtJQUNBLE9BQU9ndUIsZUFBZXZrQjtBQUMxQjtBQUNBLFNBQVN1a0IsZUFBZXZrQixPQUFPO0lBQzNCLElBQUlBLFFBQVF2QixLQUFLLEtBQUtsSSxhQUFheUosUUFBUXZCLEtBQUssQ0FBQy9GLE1BQU0sS0FBSyxHQUFHO1FBQzNELE9BQU87SUFDWDtJQUNBLEtBQUssTUFBTWlHLFFBQVFxQixRQUFRdkIsS0FBSyxDQUFFO1FBQzlCLElBQUlFLFNBQVNwSSxhQUFhd0IsT0FBT1MsSUFBSSxDQUFDbUcsTUFBTWpHLE1BQU0sS0FBSyxHQUFHO1lBQ3RELE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0E7Ozs7O0NBS0MsR0FDRCxTQUFTOHJCLGdCQUFnQkMsT0FBTztJQUM1QiwwQkFBMEI7SUFDMUIsSUFBSUEsUUFBUS9yQixNQUFNLEtBQUssR0FBRztRQUN0QjtJQUNKO0lBQ0EsS0FBSyxNQUFNc0gsV0FBV3lrQixRQUFTO1FBQzNCLElBQUl6a0IsUUFBUW5CLElBQUksS0FBSyxVQUFVbUIsUUFBUW5CLElBQUksS0FBSyxTQUFTO1lBQ3JELE1BQU0sSUFBSXhHLE1BQU0sQ0FBQyxvQ0FBb0MsRUFBRTJILFFBQVFuQixJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzFFO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTNmxCLHNCQUFzQkMsb0JBQW9CO0lBQy9DLElBQUlBLHlCQUF5QnB1QixhQUFhb3VCLHFCQUFxQmpzQixNQUFNLEtBQUssR0FBRztRQUN6RSxPQUFPLEVBQUU7SUFDYjtJQUNBLE1BQU1rc0IsaUJBQWlCLEVBQUU7SUFDekIsTUFBTWxzQixTQUFTaXNCLHFCQUFxQmpzQixNQUFNO0lBQzFDLElBQUlELElBQUk7SUFDUixNQUFPQSxJQUFJQyxPQUFRO1FBQ2YsSUFBSWlzQixvQkFBb0IsQ0FBQ2xzQixFQUFFLENBQUNvRyxJQUFJLEtBQUssUUFBUTtZQUN6QytsQixlQUFlbG1CLElBQUksQ0FBQ2ltQixvQkFBb0IsQ0FBQ2xzQixFQUFFO1lBQzNDQTtRQUNKLE9BQ0s7WUFDRCxNQUFNb3NCLGNBQWMsRUFBRTtZQUN0QixJQUFJQyxVQUFVO1lBQ2QsTUFBT3JzQixJQUFJQyxVQUFVaXNCLG9CQUFvQixDQUFDbHNCLEVBQUUsQ0FBQ29HLElBQUksS0FBSyxRQUFTO2dCQUMzRGdtQixZQUFZbm1CLElBQUksQ0FBQ2ltQixvQkFBb0IsQ0FBQ2xzQixFQUFFO2dCQUN4QyxJQUFJcXNCLFdBQVcsQ0FBQ1AsZUFBZUksb0JBQW9CLENBQUNsc0IsRUFBRSxHQUFHO29CQUNyRHFzQixVQUFVO2dCQUNkO2dCQUNBcnNCO1lBQ0o7WUFDQSxJQUFJcXNCLFNBQVM7Z0JBQ1RGLGVBQWVsbUIsSUFBSSxJQUFJbW1CO1lBQzNCLE9BQ0s7Z0JBQ0QsNERBQTREO2dCQUM1REQsZUFBZTlZLEdBQUc7WUFDdEI7UUFDSjtJQUNKO0lBQ0EsT0FBTzhZO0FBQ1g7QUFDQTs7Q0FFQyxHQUNELE1BQU1HO0lBQ0YvbEIsWUFBWWdtQixZQUFZLEVBQUVwZ0IsU0FBUyxDQUFFO1FBQ2pDLElBQUksQ0FBQ29nQixZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ3BnQixTQUFTLEdBQUdBO0lBQ3JCO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXFCQyxHQUNEcVcsT0FBT3hCLE1BQU0sRUFBRTtRQUNYLE9BQU8sSUFBSXdMLEtBQUssSUFBSSxDQUFDcmdCLFNBQVMsRUFBRSxJQUFJLENBQUNvZ0IsWUFBWSxFQUFFdkwsT0FBTzVVLEtBQUssRUFBRTRVLE9BQU8vVyxNQUFNLEVBQzlFLHFFQUFxRTtRQUNyRSxnQkFBZ0I7UUFDaEJ3aUIsZ0JBQWdCekwsT0FBT2dMLE9BQU87SUFDbEM7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELE1BQU1RO0lBQ0ZqbUIsWUFBWTRGLFNBQVMsRUFBRW9nQixZQUFZLEVBQUVuZ0IsS0FBSyxFQUFFbkMsU0FBUyxDQUFDLENBQUMsRUFBRStoQixVQUFVLEVBQUUsQ0FBRTtRQUNuRSxJQUFJLENBQUM3ZixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ29nQixZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ25nQixLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDbkMsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQytoQixPQUFPLEdBQUdBO1FBQ2YsNEVBQTRFO1FBQzVFLFNBQVM7UUFDVCxJQUFJLENBQUNVLFdBQVcsR0FBRzlCLFFBQVFDLE9BQU87UUFDbENrQixnQkFBZ0JDO0lBQ3BCO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FtQkMsR0FDRCxNQUFNVyxZQUFZM0wsTUFBTSxFQUFFO1FBQ3RCLElBQUl0aUI7UUFDSixNQUFNLElBQUksQ0FBQ2d1QixXQUFXO1FBQ3RCLE1BQU1FLGVBQWVsZixTQUFTc1QsT0FBTzRLLE9BQU87UUFDNUMsTUFBTWlCLGtCQUFrQixJQUFJLENBQUNOLFlBQVksQ0FBQ08sZUFBZSxDQUFDO1lBQ3REMWdCLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1lBQ2pCMmdCLFVBQVUsSUFBSSxDQUFDQyxVQUFVLENBQUMsTUFBTUMsTUFBTSxDQUFDTDtZQUN2QzNpQixRQUFRLENBQUN2TCxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJQSxLQUFLLElBQUksQ0FBQ3VMLE1BQU07UUFDN0U7UUFDQSxJQUFJLENBQUN5aUIsV0FBVyxHQUFHLENBQUM7WUFDaEIsSUFBSWh1QixJQUFJQyxJQUFJcUk7WUFDWixNQUFNaEMsV0FBVyxNQUFNNm5CO1lBQ3ZCLE1BQU1LLGdCQUFnQixDQUFDdnVCLEtBQUssQ0FBQ0QsS0FBS3NHLFNBQVNzQyxVQUFVLE1BQU0sUUFBUTVJLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLEVBQUUsTUFBTSxRQUFRQyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc0SSxPQUFPO1lBQ2xKLG9FQUFvRTtZQUNwRSxzRUFBc0U7WUFDdEUsNENBQTRDO1lBQzVDLE1BQU00bEIsc0NBQXNDbm9CLFNBQVNvb0IsK0JBQStCO1lBQ3BGLE1BQU1wTCxRQUFRLElBQUksQ0FBQ2dMLFVBQVUsQ0FBQyxNQUFNL3NCLE1BQU07WUFDMUMsSUFBSW10QixrQ0FBa0MsRUFBRTtZQUN4QyxJQUFJRCx1Q0FBdUMsTUFBTTtnQkFDN0NDLGtDQUNJLENBQUNwbUIsS0FBS21tQixvQ0FBb0Mvc0IsS0FBSyxDQUFDNGhCLE1BQUssTUFBTyxRQUFRaGIsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtZQUNuRztZQUNBLE1BQU1vbEIsY0FBY2MsZ0JBQWdCO2dCQUFDQTthQUFjLEdBQUcsRUFBRTtZQUN4RCxJQUFJLENBQUNHLGFBQWEsQ0FBQ1QsY0FBY1IsYUFBYWdCO1lBQzlDO1FBQ0o7UUFDQSxNQUFNLElBQUksQ0FBQ1YsV0FBVyxDQUFDWSxLQUFLLENBQUM7WUFDekIsdURBQXVEO1lBQ3ZELElBQUksQ0FBQ1osV0FBVyxHQUFHOUIsUUFBUUMsT0FBTztRQUN0QztRQUNBLE9BQU9nQztJQUNYO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXFCQyxHQUNELE1BQU1VLGtCQUFrQnZNLE1BQU0sRUFBRTtRQUM1QixJQUFJdGlCO1FBQ0osTUFBTSxJQUFJLENBQUNndUIsV0FBVztRQUN0QixNQUFNRSxlQUFlbGYsU0FBU3NULE9BQU80SyxPQUFPO1FBQzVDLE1BQU00QixpQkFBaUIsSUFBSSxDQUFDakIsWUFBWSxDQUFDa0IscUJBQXFCLENBQUM7WUFDM0RyaEIsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakIyZ0IsVUFBVSxJQUFJLENBQUNDLFVBQVUsQ0FBQyxNQUFNQyxNQUFNLENBQUNMO1lBQ3ZDM2lCLFFBQVEsQ0FBQ3ZMLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUlBLEtBQUssSUFBSSxDQUFDdUwsTUFBTTtRQUM3RTtRQUNBLDJFQUEyRTtRQUMzRSxxRUFBcUU7UUFDckUsNENBQTRDO1FBQzVDLElBQUksQ0FBQ3lpQixXQUFXLEdBQUdjLGVBQ2QxSixJQUFJLENBQUMsSUFBTWhtQixXQUNYd3ZCLEtBQUssQ0FBQyxJQUFNeHZCO1FBQ2pCLE1BQU1rSCxXQUFXLE1BQU13b0I7UUFDdkIsTUFBTTFmLFNBQVMsSUFBSSxDQUFDNGYscUJBQXFCLENBQUMxb0IsVUFBVTRuQjtRQUNwRCxPQUFPOWU7SUFDWDtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBc0JDLEdBQ0RrZixXQUFXVyxVQUFVLEtBQUssRUFBRTtRQUN4QixNQUFNM0IsVUFBVTJCLFVBQ1YxQixzQkFBc0IsSUFBSSxDQUFDRCxPQUFPLElBQ2xDLElBQUksQ0FBQ0EsT0FBTztRQUNsQixxRUFBcUU7UUFDckUsZ0JBQWdCO1FBQ2hCLE9BQU9TLGdCQUFnQlQ7SUFDM0I7SUFDQTBCLHNCQUFzQkYsY0FBYyxFQUFFWixZQUFZLEVBQUU7UUFDaEQsSUFBSWx1QixJQUFJQztRQUNSLE9BQU9zckIsaUJBQWlCLElBQUksRUFBRTJELFdBQVcsVUFBVUM7WUFDL0MsSUFBSTdtQixJQUFJOG1CLEtBQUs3bUIsSUFBSUM7WUFDakIsTUFBTWdtQixnQkFBZ0IsRUFBRTtZQUN4QixJQUFJO2dCQUNBLElBQUssSUFBSS9sQixLQUFLLE1BQU00bUIsbUJBQW1CdEMsY0FBYytCLGlCQUFpQlEsb0JBQW9CQSxxQkFBcUIsTUFBTWpFLFFBQVFnRSxpQkFBaUI1TCxJQUFJLEtBQUtuYixLQUFLZ25CLG1CQUFtQjlpQixJQUFJLEVBQUUsQ0FBQ2xFLElBQUlHLEtBQUssS0FBTTtvQkFDak1ELEtBQUs4bUIsbUJBQW1CdHVCLEtBQUs7b0JBQzdCeUgsS0FBSztvQkFDTCxNQUFNOG1CLFFBQVEvbUI7b0JBQ2QsSUFBSTJrQixnQkFBZ0JvQyxRQUFRO3dCQUN4QixNQUFNMW1CLFVBQVUsQ0FBQzVJLEtBQUssQ0FBQ0QsS0FBS3V2QixNQUFNM21CLFVBQVUsTUFBTSxRQUFRNUksT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUMsRUFBRSxNQUFNLFFBQVFDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRJLE9BQU87d0JBQ3pJLElBQUlBLFlBQVl6SixXQUFXOzRCQUN2Qm92QixjQUFjam5CLElBQUksQ0FBQ3NCO3dCQUN2QjtvQkFDSjtvQkFDQSxNQUFNLE1BQU13aUIsUUFBUWtFO2dCQUN4QjtZQUNKLEVBQ0EsT0FBT0MsT0FBTztnQkFBRUosTUFBTTtvQkFBRTdzQixPQUFPaXRCO2dCQUFNO1lBQUcsU0FDaEM7Z0JBQ0osSUFBSTtvQkFDQSxJQUFJLENBQUMvbUIsTUFBTSxDQUFDSCxNQUFPQyxDQUFBQSxLQUFLOG1CLGlCQUFpQnpMLE1BQU0sR0FBRyxNQUFNeUgsUUFBUTlpQixHQUFHeEgsSUFBSSxDQUFDc3VCO2dCQUM1RSxTQUNRO29CQUFFLElBQUlELEtBQUssTUFBTUEsSUFBSTdzQixLQUFLO2dCQUFFO1lBQ3hDO1lBQ0EsSUFBSSxDQUFDb3NCLGFBQWEsQ0FBQ1QsY0FBY007UUFDckM7SUFDSjtJQUNBRyxjQUFjYyxTQUFTLEVBQUUvQixXQUFXLEVBQUVnQiwrQkFBK0IsRUFBRTtRQUNuRSxJQUFJZ0IsaUJBQWlCLEVBQUU7UUFDdkIsSUFBSWhDLFlBQVluc0IsTUFBTSxHQUFHLEtBQ3JCbXNCLFlBQVlpQyxLQUFLLENBQUMsQ0FBQzltQixVQUFZQSxRQUFRbkIsSUFBSSxLQUFLdEksWUFBWTtZQUM1RHN3QixpQkFBaUJoQztRQUNyQixPQUNLO1lBQ0QsMEVBQTBFO1lBQzFFLHdEQUF3RDtZQUN4RGdDLGVBQWVub0IsSUFBSSxDQUFDO2dCQUNoQkcsTUFBTTtnQkFDTkosT0FBTyxFQUFFO1lBQ2I7UUFDSjtRQUNBLElBQUlvbkIsbUNBQ0FBLGdDQUFnQ250QixNQUFNLEdBQUcsR0FBRztZQUM1QyxJQUFJLENBQUMrckIsT0FBTyxDQUFDL2xCLElBQUksSUFBSWdtQixzQkFBc0JtQjtRQUMvQyxPQUNLO1lBQ0QsSUFBSSxDQUFDcEIsT0FBTyxDQUFDL2xCLElBQUksQ0FBQ2tvQjtRQUN0QjtRQUNBLElBQUksQ0FBQ25DLE9BQU8sQ0FBQy9sQixJQUFJLElBQUltb0I7SUFDekI7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1FLGlCQUFpQjF1QjtJQUNuQjJHLFlBQVlnb0IsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0EsUUFBUTNDLE9BQU87UUFDckIsSUFBSSxDQUFDam5CLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2lNLE1BQU0sR0FBRzJkLFFBQVEzZCxNQUFNO1FBQzVCdFIsT0FBT2t2QixjQUFjLENBQUMsSUFBSSxFQUFFRixTQUFTL3VCLFNBQVM7SUFDbEQ7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRCxpRUFBaUU7QUFDakUsU0FBU2t2Qix1QkFBdUI5YSxVQUFVLEVBQUV1RyxZQUFZO0lBQ3BELE1BQU10RyxXQUFXLENBQUM7SUFDbEIsTUFBTTJJLGVBQWV4YixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXVHLGlCQUFpQnBjLGFBQWF5ZSxnQkFBZ0IsTUFBTTtRQUNwRDFjLGVBQWVxYSxjQUFjO1lBQUM7WUFBVTtTQUFXLEVBQUVxQztJQUN6RDtJQUNBLE1BQU1DLGdCQUFnQnpiLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJdUcsaUJBQWlCcGMsYUFBYTBlLGlCQUFpQixNQUFNO1FBQ3JEM2MsZUFBZXFhLGNBQWM7WUFBQztZQUFVO1NBQVksRUFBRXNDO0lBQzFEO0lBQ0EsT0FBTzVJO0FBQ1g7QUFDQSxTQUFTOGEsMkJBQTJCL2EsVUFBVTtJQUMxQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWdJLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFNmEsdUJBQXVCN1MsWUFBWWhJO0lBQzVFO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVMrYSxrQkFBa0JoYixVQUFVO0lBQ2pDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMkwsY0FBY3hlLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJNEwsZUFBZSxNQUFNO1FBQ3JCMWYsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUUyTDtJQUMxQztJQUNBLE1BQU1FLGNBQWMxZSxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSThMLGVBQWUsTUFBTTtRQUNyQjVmLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFNkw7SUFDMUM7SUFDQSxNQUFNRCxXQUFXemUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUk2TCxZQUFZLE1BQU07UUFDbEIzZixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRTRMO0lBQ3ZDO0lBQ0EsT0FBTzVMO0FBQ1g7QUFDQSxTQUFTZ2IsWUFBWWpiLFVBQVU7SUFDM0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU16QyxXQUFXcFEsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl4QyxZQUFZLE1BQU07UUFDbEJ0UixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXpDO0lBQ3ZDO0lBQ0EsTUFBTThLLGtCQUFrQmxiLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJc0ksbUJBQW1CLE1BQU07UUFDekJwYyxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXFJO0lBQzlDO0lBQ0EsTUFBTS9ILGVBQWVuVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU8sZ0JBQWdCLE1BQU07UUFDdEJyVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRU07SUFDM0M7SUFDQSxNQUFNMmEsZ0JBQWdCOXRCLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJa2IsaUJBQWlCLE1BQU07UUFDdkJodkIsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVpYjtJQUM1QztJQUNBLE1BQU03TyxpQkFBaUJqZixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXFNLGtCQUFrQixNQUFNO1FBQ3hCbmdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFb007SUFDN0M7SUFDQSxNQUFNOE8scUJBQXFCL3RCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJbWIsc0JBQXNCLE1BQU07UUFDNUJqdkIsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFa2I7SUFDakQ7SUFDQSxNQUFNN08saUJBQWlCbGYsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlzTSxrQkFBa0IsTUFBTTtRQUN4QnBnQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXFNO0lBQzdDO0lBQ0EsTUFBTThPLGlCQUFpQmh1QixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSW9iLGtCQUFrQixNQUFNO1FBQ3hCbHZCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFbWI7SUFDN0M7SUFDQSxNQUFNQyxVQUFVanVCLGVBQWU0UyxZQUFZO1FBQUM7S0FBTTtJQUNsRCxJQUFJcWIsV0FBVyxNQUFNO1FBQ2pCbnZCLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFb2I7SUFDdEM7SUFDQSxNQUFNQyxrQkFBa0JsdUIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlzYixtQkFBbUIsTUFBTTtRQUN6QnB2QixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXFiO0lBQzlDO0lBQ0EsTUFBTWxQLFlBQVloZixlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSW9NLGFBQWEsTUFBTTtRQUNuQmxnQixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRW1NO0lBQ3hDO0lBQ0EsTUFBTW1QLGFBQWFudUIsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUl1YixjQUFjLE1BQU07UUFDcEJydkIsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVzYjtJQUN6QztJQUNBLE1BQU01YSxvQkFBb0J2VCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSVcscUJBQXFCLE1BQU07UUFDM0J6VSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVVO0lBQ2hEO0lBQ0EsTUFBTXFMLFlBQVk1ZSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSWdNLGFBQWEsTUFBTTtRQUNuQjlmLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFK2Esa0JBQWtCaFA7SUFDMUQ7SUFDQSxPQUFPL0w7QUFDWDtBQUNBLFNBQVN1Yiw0QkFBNEJ4YixVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNd2IsV0FBV3J1QixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXliLFlBQVksTUFBTTtRQUNsQnZ2QixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRWdiLFlBQVlRO0lBQ25EO0lBQ0EsTUFBTXhULGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFZ0k7SUFDekM7SUFDQSxPQUFPaEk7QUFDWDtBQUNBLFNBQVN5Yix5QkFBeUIxYixVQUFVO0lBQ3hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRTFDLFVBQVVDO0lBQ3pEO0lBQ0EsTUFBTXlLLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFZ0k7SUFDekM7SUFDQSxPQUFPaEk7QUFDWDtBQUNBLFNBQVMwYiw0QkFBNEIzYixVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRTFDLFVBQVVDO0lBQ3pEO0lBQ0EsTUFBTXlLLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFZ0k7SUFDekM7SUFDQSxPQUFPaEk7QUFDWDtBQUNBLFNBQVMyYixvQkFBb0I1YixVQUFVO0lBQ25DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMkwsY0FBY3hlLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJNEwsZUFBZSxNQUFNO1FBQ3JCMWYsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUUyTDtJQUMxQztJQUNBLE1BQU1FLGNBQWMxZSxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSThMLGVBQWUsTUFBTTtRQUNyQjVmLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFNkw7SUFDMUM7SUFDQSxNQUFNRCxXQUFXemUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUk2TCxZQUFZLE1BQU07UUFDbEIzZixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRTRMO0lBQ3ZDO0lBQ0EsT0FBTzVMO0FBQ1g7QUFDQSxTQUFTNGIsY0FBYzdiLFVBQVU7SUFDN0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU16QyxXQUFXcFEsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl4QyxZQUFZLE1BQU07UUFDbEJ0UixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXpDO0lBQ3ZDO0lBQ0EsTUFBTThLLGtCQUFrQmxiLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJc0ksbUJBQW1CLE1BQU07UUFDekJwYyxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXFJO0lBQzlDO0lBQ0EsTUFBTS9ILGVBQWVuVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU8sZ0JBQWdCLE1BQU07UUFDdEJyVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRU07SUFDM0M7SUFDQSxNQUFNMmEsZ0JBQWdCOXRCLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJa2IsaUJBQWlCLE1BQU07UUFDdkJodkIsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVpYjtJQUM1QztJQUNBLE1BQU03TyxpQkFBaUJqZixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXFNLGtCQUFrQixNQUFNO1FBQ3hCbmdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFb007SUFDN0M7SUFDQSxNQUFNOE8scUJBQXFCL3RCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJbWIsc0JBQXNCLE1BQU07UUFDNUJqdkIsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFa2I7SUFDakQ7SUFDQSxNQUFNN08saUJBQWlCbGYsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlzTSxrQkFBa0IsTUFBTTtRQUN4QnBnQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXFNO0lBQzdDO0lBQ0EsTUFBTThPLGlCQUFpQmh1QixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSW9iLGtCQUFrQixNQUFNO1FBQ3hCbHZCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFbWI7SUFDN0M7SUFDQSxNQUFNQyxVQUFVanVCLGVBQWU0UyxZQUFZO1FBQUM7S0FBTTtJQUNsRCxJQUFJcWIsV0FBVyxNQUFNO1FBQ2pCbnZCLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFb2I7SUFDdEM7SUFDQSxNQUFNQyxrQkFBa0JsdUIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlzYixtQkFBbUIsTUFBTTtRQUN6QnB2QixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXFiO0lBQzlDO0lBQ0EsTUFBTWxQLFlBQVloZixlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSW9NLGFBQWEsTUFBTTtRQUNuQmxnQixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRW1NO0lBQ3hDO0lBQ0EsTUFBTW1QLGFBQWFudUIsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUl1YixjQUFjLE1BQU07UUFDcEJydkIsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVzYjtJQUN6QztJQUNBLE1BQU01YSxvQkFBb0J2VCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSVcscUJBQXFCLE1BQU07UUFDM0J6VSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVVO0lBQ2hEO0lBQ0EsTUFBTXFMLFlBQVk1ZSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSWdNLGFBQWEsTUFBTTtRQUNuQjlmLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFMmIsb0JBQW9CNVA7SUFDNUQ7SUFDQSxPQUFPL0w7QUFDWDtBQUNBLFNBQVM2YiwyQkFBMkI5YixVQUFVO0lBQzFDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0wsc0JBQXNCamUsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxTCx1QkFBdUIsTUFBTTtRQUM3Qm5mLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW9MO0lBQ2xEO0lBQ0EsTUFBTW1CLG9CQUFvQnBmLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJd00scUJBQXFCLE1BQU07UUFDM0J0Z0IsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFdU07SUFDaEQ7SUFDQSxNQUFNdVAsWUFBWTN1QixlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStiLGFBQWEsTUFBTTtRQUNuQixJQUFJeGEsa0JBQWtCd2E7UUFDdEIsSUFBSXJ2QixNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT2tpQixjQUFjbGlCO1lBQ3pCO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFc0I7SUFDeEM7SUFDQSxPQUFPdEI7QUFDWDtBQUNBLFNBQVMrYiw0QkFBNEJoYyxVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0wsc0JBQXNCamUsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxTCx1QkFBdUIsTUFBTTtRQUM3Qm5mLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW9MO0lBQ2xEO0lBQ0EsT0FBT3BMO0FBQ1g7QUFDQSxTQUFTZ2M7SUFDTCxNQUFNaGMsV0FBVyxDQUFDO0lBQ2xCLE9BQU9BO0FBQ1g7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTWljLGNBQWMvd0I7SUFDaEJ5SCxZQUFZNEYsU0FBUyxDQUFFO1FBQ25CLEtBQUs7UUFDTCxJQUFJLENBQUNBLFNBQVMsR0FBR0E7UUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7U0FnQkMsR0FDRCxJQUFJLENBQUMrWCxJQUFJLEdBQUcsT0FBT2xELFNBQVMsQ0FBQyxDQUFDO1lBQzFCLE9BQU8sSUFBSUYsTUFBTUQsVUFBVWlQLGdCQUFnQixFQUFFLENBQUMxTCxJQUFNLElBQUksQ0FBQ0MsWUFBWSxDQUFDRCxJQUFJLE1BQU0sSUFBSSxDQUFDQyxZQUFZLENBQUNyRCxTQUFTQTtRQUMvRztJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQTBDQyxHQUNELE1BQU0rTyxPQUFPL08sTUFBTSxFQUFFO1FBQ2pCLElBQUksSUFBSSxDQUFDN1UsU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCLE1BQU0sSUFBSW5MLE1BQU07UUFDcEI7UUFDQSxPQUFPLElBQUksQ0FBQ3VNLFNBQVMsQ0FDaEI2akIsVUFBVSxDQUFDaFAsT0FBT2lQLElBQUksRUFBRWpQLE9BQU8vVyxNQUFNLEVBQ3JDNlosSUFBSSxDQUFDLENBQUM5ZTtZQUNQLE1BQU1pckIsT0FBT1QsY0FBY3hxQjtZQUMzQixPQUFPaXJCO1FBQ1g7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7S0FlQyxHQUNELE1BQU1DLFNBQVNsUCxNQUFNLEVBQUU7UUFDbkIsTUFBTSxJQUFJLENBQUM3VSxTQUFTLENBQUNna0IsWUFBWSxDQUFDblA7SUFDdEM7SUFDQSxNQUFNcUQsYUFBYXJELE1BQU0sRUFBRTtRQUN2QixJQUFJdGlCLElBQUlDO1FBQ1IsSUFBSXFHO1FBQ0osSUFBSStkLE9BQU87UUFDWCxJQUFJQyxjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUM3VyxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTSxJQUFJbkwsTUFBTTtRQUNwQixPQUNLO1lBQ0QsTUFBTXFqQixPQUFPeUwsMkJBQTJCMU47WUFDeEMrQixPQUFPaGtCLFVBQVUsU0FBU2trQixJQUFJLENBQUMsT0FBTztZQUN0Q0QsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSSxHQUFHa2QsSUFBSSxDQUFDLENBQUNVO29CQUM3QixNQUFNeGYsV0FBV3dmO29CQUNqQnhmLFNBQVN1YyxlQUFlLEdBQUc7d0JBQ3ZCL2EsU0FBU3VkLGFBQWF2ZCxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBT3lMLDJCQUEyQjNrQjtnQkFDeEMsTUFBTTJaLFlBQVksSUFBSXRiO2dCQUN0QjdKLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSjtJQUNKO0lBQ0EsTUFBTVIsZUFBZWpELE1BQU0sRUFBRTtRQUN6QixJQUFJdGlCLElBQUlDO1FBQ1IsSUFBSXFHO1FBQ0osSUFBSStkLE9BQU87UUFDWCxJQUFJQyxjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUM3VyxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTSxJQUFJbkwsTUFBTTtRQUNwQixPQUNLO1lBQ0QsTUFBTXFqQixPQUFPa00sNEJBQTRCbk87WUFDekMrQixPQUFPaGtCLFVBQVUsdUJBQXVCa2tCLElBQUksQ0FBQyxPQUFPO1lBQ3BERCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDSSxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDbGxCLEtBQUtxaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdEwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2xCLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJO1lBQzVCO1lBQ0EsT0FBTzVCLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBTzJMLDRCQUE0QjdrQjtnQkFDekMsTUFBTTJaLFlBQVksSUFBSXJiO2dCQUN0QjlKLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7O0tBY0MsR0FDRCxNQUFNSCxJQUFJdEQsTUFBTSxFQUFFO1FBQ2QsSUFBSXRpQixJQUFJQztRQUNSLElBQUlxRztRQUNKLElBQUkrZCxPQUFPO1FBQ1gsSUFBSUMsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDN1csU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCLE1BQU0sSUFBSW5MLE1BQU07UUFDcEIsT0FDSztZQUNELE1BQU1xakIsT0FBT29NLHlCQUF5QnJPO1lBQ3RDK0IsT0FBT2hrQixVQUFVLGdCQUFnQmtrQixJQUFJLENBQUMsT0FBTztZQUM3Q0QsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QixTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU93TCxjQUFjMWtCO2dCQUMzQixPQUFPa1o7WUFDWDtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDRCxNQUFNVSxPQUFPMUQsTUFBTSxFQUFFO1FBQ2pCLElBQUl0aUIsSUFBSUM7UUFDUixJQUFJcUc7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNLElBQUluTCxNQUFNO1FBQ3BCLE9BQ0s7WUFDRCxNQUFNcWpCLE9BQU9xTSw0QkFBNEJ0TztZQUN6QytCLE9BQU9oa0IsVUFBVSxnQkFBZ0Jra0IsSUFBSSxDQUFDLE9BQU87WUFDN0NELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUNJLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVsQixhQUFhLENBQUNsbEIsS0FBS3FpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF0TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbEIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUk7WUFDNUI7WUFDQSxPQUFPNUIsU0FBUzhlLElBQUksQ0FBQztnQkFDakIsTUFBTUUsT0FBTzRMO2dCQUNiLE1BQU1uTCxZQUFZLElBQUlwYjtnQkFDdEIvSixPQUFPd0IsTUFBTSxDQUFDMmpCLFdBQVdUO2dCQUN6QixPQUFPUztZQUNYO1FBQ0o7SUFDSjtBQUNKO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVMyTCw2QkFBNkJ6YyxVQUFVO0lBQzVDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNd0YsZ0JBQWdCclksZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUl5RixpQkFBaUIsTUFBTTtRQUN2QnZaLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFd0Y7SUFDNUM7SUFDQSxPQUFPeEY7QUFDWDtBQUNBLFNBQVN5YyxxQkFBcUIxYyxVQUFVO0lBQ3BDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMEYsMEJBQTBCdlksZUFBZTRTLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkyRiwyQkFBMkIsTUFBTTtRQUNqQ3paLGVBQWUrVCxVQUFVO1lBQUM7U0FBc0IsRUFBRXdjLDZCQUE2QjlXO0lBQ25GO0lBQ0EsT0FBTzFGO0FBQ1g7QUFDQSxTQUFTMGMsNEJBQTRCM2MsVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTRGLGNBQWN6WSxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSTZGLGVBQWUsTUFBTTtRQUNyQjNaLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFNEY7SUFDMUM7SUFDQSxNQUFNQyxrQkFBa0IxWSxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSThGLG1CQUFtQixNQUFNO1FBQ3pCNVosZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUV5YyxxQkFBcUI1VztJQUNuRTtJQUNBLE9BQU83RjtBQUNYO0FBQ0EsU0FBUzJjLGlDQUFpQzVjLFVBQVU7SUFDaEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0rRiwwQkFBMEI1WSxlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSWdHLDJCQUEyQixNQUFNO1FBQ2pDLElBQUl6RSxrQkFBa0J5RTtRQUN0QixJQUFJdFosTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU9nakIsNEJBQTRCaGpCO1lBQ3ZDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBc0IsRUFBRXNCO0lBQ3REO0lBQ0EsT0FBT3RCO0FBQ1g7QUFDQSxTQUFTNGMsc0JBQXNCN2MsVUFBVTtJQUNyQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZGLGtCQUFrQjFZLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJOEYsbUJBQW1CLE1BQU07UUFDekI1WixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXljLHFCQUFxQjVXO0lBQ25FO0lBQ0EsTUFBTUksOEJBQThCOVksZUFBZTRTLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUlrRywrQkFBK0IsTUFBTTtRQUNyQ2hhLGVBQWUrVCxVQUFVO1lBQUM7U0FBMEIsRUFBRTJjLGlDQUFpQzFXO0lBQzNGO0lBQ0EsTUFBTWQsbUJBQW1CaFksZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlvRixvQkFBb0IsTUFBTTtRQUMxQmxaLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFbUY7SUFDL0M7SUFDQSxPQUFPbkY7QUFDWDtBQUNBLFNBQVM2Yyx1QkFBdUI5YyxVQUFVO0lBQ3RDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNQyxVQUFVOVMsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUlFLFdBQVcsTUFBTTtRQUNqQmhVLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFQztJQUN0QztJQUNBLE1BQU1DLGdCQUFnQi9TLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJRyxpQkFBaUIsTUFBTTtRQUN2QmpVLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFRTtJQUM1QztJQUNBLE1BQU1DLGtCQUFrQmhULGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJSSxtQkFBbUIsTUFBTTtRQUN6QmxVLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFRztJQUM5QztJQUNBLE9BQU9IO0FBQ1g7QUFDQSxTQUFTOGMsY0FBYy9jLFVBQVU7SUFDN0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLElBQUk3UyxlQUFlNFMsWUFBWTtRQUFDO0tBQWMsTUFBTTdWLFdBQVc7UUFDM0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU1xVSxXQUFXbFQsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlNLFlBQVksTUFBTTtRQUNsQnBVLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFSztJQUN2QztJQUNBLE1BQU1DLGVBQWVuVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU8sZ0JBQWdCLE1BQU07UUFDdEJyVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRU07SUFDM0M7SUFDQSxPQUFPTjtBQUNYO0FBQ0EsU0FBUytjLGtCQUFrQmhkLFVBQVU7SUFDakMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLElBQUk3UyxlQUFlNFMsWUFBWTtRQUFDO0tBQWMsTUFBTTdWLFdBQVc7UUFDM0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU13VSxjQUFjclQsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUlTLGVBQWUsTUFBTTtRQUNyQnZVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFUTtJQUMxQztJQUNBLE1BQU1GLGVBQWVuVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU8sZ0JBQWdCLE1BQU07UUFDdEJyVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRU07SUFDM0M7SUFDQSxPQUFPTjtBQUNYO0FBQ0EsU0FBU2dkLGNBQWNqZCxVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNVSxvQkFBb0J2VCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSVcscUJBQXFCLE1BQU07UUFDM0J6VSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUU2Yyx1QkFBdUJuYztJQUN2RTtJQUNBLE1BQU1DLGNBQWN4VCxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSVksZUFBZSxNQUFNO1FBQ3JCMVUsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUVXO0lBQzFDO0lBQ0EsTUFBTUMsaUJBQWlCelQsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlhLGtCQUFrQixNQUFNO1FBQ3hCM1UsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUU4YyxjQUFjbGM7SUFDM0Q7SUFDQSxNQUFNQyxlQUFlMVQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUljLGdCQUFnQixNQUFNO1FBQ3RCNVUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUUrYyxrQkFBa0JsYztJQUM3RDtJQUNBLE1BQU1DLHVCQUF1QjNULGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJZSx3QkFBd0IsTUFBTTtRQUM5QjdVLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWM7SUFDbkQ7SUFDQSxNQUFNQywwQkFBMEI1VCxlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSWdCLDJCQUEyQixNQUFNO1FBQ2pDOVUsZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFZTtJQUN0RDtJQUNBLE1BQU1DLHFCQUFxQjdULGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJaUIsc0JBQXNCLE1BQU07UUFDNUIvVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVnQjtJQUNqRDtJQUNBLE1BQU1DLG1CQUFtQjlULGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJa0Isb0JBQW9CLE1BQU07UUFDMUJoVixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRWlCO0lBQy9DO0lBQ0EsTUFBTUMsdUJBQXVCL1QsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUltQix3QkFBd0IsTUFBTTtRQUM5QmpWLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWtCO0lBQ25EO0lBQ0EsTUFBTUMsV0FBV2hVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJb0IsWUFBWSxNQUFNO1FBQ2xCbFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVtQjtJQUN2QztJQUNBLE9BQU9uQjtBQUNYO0FBQ0EsU0FBU2lkLGlCQUFpQmxkLFVBQVU7SUFDaEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1xQixZQUFZbFUsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlzQixhQUFhLE1BQU07UUFDbkIsSUFBSUMsa0JBQWtCRDtRQUN0QixJQUFJNVUsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU9zakIsY0FBY3RqQjtZQUN6QjtRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRXNCO0lBQ3hDO0lBQ0EsTUFBTUMsV0FBV3BVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJd0IsWUFBWSxNQUFNO1FBQ2xCdFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV1QjtJQUN2QztJQUNBLE9BQU92QjtBQUNYO0FBQ0EsU0FBU2tkLDZCQUE2Qm5kLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1tRCxlQUFlaFcsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlvRCxnQkFBZ0IsTUFBTTtRQUN0QmxYLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFbUQ7SUFDM0M7SUFDQSxNQUFNeEIsa0JBQWtCeFUsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUk0QixtQkFBbUIsTUFBTTtRQUN6QjFWLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFMkI7SUFDOUM7SUFDQSxNQUFNcEUsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV6QztJQUN2QztJQUNBLE1BQU02RixpQkFBaUJqVyxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXFELGtCQUFrQixNQUFNO1FBQ3hCblgsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVvRDtJQUM3QztJQUNBLE1BQU1DLDJCQUEyQmxXLGVBQWU0UyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJc0QsNEJBQTRCLE1BQU07UUFDbENwWCxlQUFlK1QsVUFBVTtZQUFDO1NBQXVCLEVBQUVxRDtJQUN2RDtJQUNBLE1BQU1DLGVBQWVuVyxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXVELGdCQUFnQixNQUFNO1FBQ3RCclgsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVzRDtJQUMzQztJQUNBLE1BQU1DLHlCQUF5QnBXLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJd0QsMEJBQTBCLE1BQU07UUFDaEN0WCxlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUV1RDtJQUNyRDtJQUNBLE9BQU92RDtBQUNYO0FBQ0EsU0FBU21kLGtCQUFrQnBkLFVBQVU7SUFDakMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15RCxnQkFBZ0J0VyxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSTBELGlCQUFpQixNQUFNO1FBQ3ZCeFgsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUV5RDtJQUM1QztJQUNBLE1BQU1DLGNBQWN2VyxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSTJELGVBQWUsTUFBTTtRQUNyQnpYLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFMEQ7SUFDMUM7SUFDQSxPQUFPMUQ7QUFDWDtBQUNBLFNBQVNvZCxzQkFBc0JyZCxVQUFVO0lBQ3JDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNEQsc0JBQXNCelcsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUk2RCx1QkFBdUIsTUFBTTtRQUM3QjNYLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW1kLGtCQUFrQnZaO0lBQ3BFO0lBQ0EsSUFBSXpXLGVBQWU0UyxZQUFZO1FBQUM7S0FBaUIsTUFBTTdWLFdBQVc7UUFDOUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU9nVTtBQUNYO0FBQ0EsU0FBU3FkLGdDQUFnQ3RkLFVBQVU7SUFDL0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04RCxXQUFXM1csZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrRCxZQUFZLE1BQU07UUFDbEI3WCxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRThEO0lBQ3ZDO0lBQ0EsTUFBTUMsdUJBQXVCNVcsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlnRSx3QkFBd0IsTUFBTTtRQUM5QjlYLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRStEO0lBQ25EO0lBQ0EsT0FBTy9EO0FBQ1g7QUFDQSxTQUFTc2QsK0JBQStCdmQsVUFBVTtJQUM5QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWlFLDZCQUE2QjlXLGVBQWU0UyxZQUFZO1FBQzFEO0tBQ0g7SUFDRCxJQUFJa0UsOEJBQThCLE1BQU07UUFDcENoWSxlQUFlK1QsVUFBVTtZQUFDO1NBQXlCLEVBQUVxZCxnQ0FBZ0NwWjtJQUN6RjtJQUNBLE9BQU9qRTtBQUNYO0FBQ0EsU0FBU3VkO0lBQ0wsTUFBTXZkLFdBQVcsQ0FBQztJQUNsQixPQUFPQTtBQUNYO0FBQ0EsU0FBU3dkLHlCQUF5QnpkLFVBQVU7SUFDeEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vRSxrQkFBa0JqWCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXFFLG1CQUFtQixNQUFNO1FBQ3pCblksZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVvRTtJQUM5QztJQUNBLE9BQU9wRTtBQUNYO0FBQ0EsU0FBU3lkLGNBQWMxZCxVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNc0UsMkJBQTJCblgsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUl1RSw0QkFBNEIsTUFBTTtRQUNsQyxJQUFJaEQsa0JBQWtCZ0Q7UUFDdEIsSUFBSTdYLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPd2pCLDZCQUE2QnhqQjtZQUN4QztRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQXVCLEVBQUVzQjtJQUN2RDtJQUNBLElBQUluVSxlQUFlNFMsWUFBWTtRQUFDO0tBQVksTUFBTTdWLFdBQVc7UUFDekQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU11WSxtQkFBbUJwWCxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXdFLG9CQUFvQixNQUFNO1FBQzFCdFksZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVvZCxzQkFBc0I3WTtJQUNyRTtJQUNBLE1BQU1DLDRCQUE0QnJYLGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJeUUsNkJBQTZCLE1BQU07UUFDbkN2WSxlQUFlK1QsVUFBVTtZQUFDO1NBQXdCLEVBQUVzZCwrQkFBK0I5WTtJQUN2RjtJQUNBLElBQUlyWCxlQUFlNFMsWUFBWTtRQUFDO0tBQXNCLE1BQU03VixXQUFXO1FBQ25FLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJbUIsZUFBZTRTLFlBQVk7UUFBQztLQUFhLE1BQU03VixXQUFXO1FBQzFELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNeVksaUJBQWlCdFgsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkwRSxrQkFBa0IsTUFBTTtRQUN4QnhZLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFdWQ7SUFDN0M7SUFDQSxNQUFNN1ksa0JBQWtCdlgsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkyRSxtQkFBbUIsTUFBTTtRQUN6QnpZLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFd2QseUJBQXlCOVk7SUFDdkU7SUFDQSxNQUFNQyxvQkFBb0J4WCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSTRFLHFCQUFxQixNQUFNO1FBQzNCMVksZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFMkU7SUFDaEQ7SUFDQSxPQUFPM0U7QUFDWDtBQUNBLFNBQVMwZCxpQ0FBaUMzZCxVQUFVO0lBQ2hELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMmQsYUFBYXh3QixlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSTRkLGNBQWMsTUFBTTtRQUNwQjF4QixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRTJkO0lBQ3pDO0lBQ0EsSUFBSXh3QixlQUFlNFMsWUFBWTtRQUFDO0tBQWMsTUFBTTdWLFdBQVc7UUFDM0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU9nVTtBQUNYO0FBQ0EsU0FBUzRkO0lBQ0wsTUFBTTVkLFdBQVcsQ0FBQztJQUNsQixPQUFPQTtBQUNYO0FBQ0EsU0FBUzZkLG9DQUFvQzlkLFVBQVU7SUFDbkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04ZCxlQUFlM3dCLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK2QsZ0JBQWdCLE1BQU07UUFDdEI3eEIsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUU4ZDtJQUMzQztJQUNBLE1BQU1DLCtCQUErQjV3QixlQUFlNFMsWUFBWTtRQUM1RDtLQUNIO0lBQ0QsSUFBSWdlLGdDQUFnQyxNQUFNO1FBQ3RDOXhCLGVBQWUrVCxVQUFVO1lBQUM7U0FBMkIsRUFBRStkO0lBQzNEO0lBQ0EsTUFBTUMsNkJBQTZCN3dCLGVBQWU0UyxZQUFZO1FBQzFEO0tBQ0g7SUFDRCxJQUFJaWUsOEJBQThCLE1BQU07UUFDcEMveEIsZUFBZStULFVBQVU7WUFBQztTQUF5QixFQUFFZ2U7SUFDekQ7SUFDQSxNQUFNQyxzQkFBc0I5d0IsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlrZSx1QkFBdUIsTUFBTTtRQUM3Qmh5QixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVpZTtJQUNsRDtJQUNBLE1BQU1DLHdCQUF3Qi93QixlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSW1lLHlCQUF5QixNQUFNO1FBQy9CanlCLGVBQWUrVCxVQUFVO1lBQUM7U0FBb0IsRUFBRWtlO0lBQ3BEO0lBQ0EsT0FBT2xlO0FBQ1g7QUFDQSxTQUFTbWUsNkJBQTZCcGUsVUFBVTtJQUM1QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9lLGlDQUFpQ2p4QixlQUFlNFMsWUFBWTtRQUM5RDtLQUNIO0lBQ0QsSUFBSXFlLGtDQUFrQyxNQUFNO1FBQ3hDbnlCLGVBQWUrVCxVQUFVO1lBQUM7U0FBNkIsRUFBRTZkLG9DQUFvQ087SUFDakc7SUFDQSxNQUFNQyx1QkFBdUJseEIsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlzZSx3QkFBd0IsTUFBTTtRQUM5QnB5QixlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVxZTtJQUNuRDtJQUNBLE1BQU1DLG1CQUFtQm54QixlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXVlLG9CQUFvQixNQUFNO1FBQzFCcnlCLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFc2U7SUFDL0M7SUFDQSxPQUFPdGU7QUFDWDtBQUNBLFNBQVN1ZSx1QkFBdUJ4ZSxVQUFVO0lBQ3RDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNd2UsbUJBQW1CcnhCLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJeWUsb0JBQW9CLE1BQU07UUFDMUJ2eUIsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUV3ZTtJQUMvQztJQUNBLE9BQU94ZTtBQUNYO0FBQ0EsU0FBU3llLHdDQUF3QzFlLFVBQVU7SUFDdkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0wZSxvQkFBb0J2eEIsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUkyZSxxQkFBcUIsTUFBTTtRQUMzQnp5QixlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUUwZTtJQUNoRDtJQUNBLE1BQU1DLG9CQUFvQnh4QixlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSTRlLHFCQUFxQixNQUFNO1FBQzNCMXlCLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXVlLHVCQUF1Qkk7SUFDdkU7SUFDQSxPQUFPM2U7QUFDWDtBQUNBLFNBQVM0ZSwyQkFBMkI3ZSxVQUFVO0lBQzFDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNmUscUJBQXFCMXhCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJOGUsc0JBQXNCLE1BQU07UUFDNUI1eUIsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFNmU7SUFDakQ7SUFDQSxPQUFPN2U7QUFDWDtBQUNBLFNBQVM4ZSwyQkFBMkIvZSxVQUFVLEVBQUV1RyxZQUFZO0lBQ3hELE1BQU10RyxXQUFXLENBQUM7SUFDbEIsTUFBTStlLHVCQUF1QjV4QixlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWE2MEIsd0JBQXdCLE1BQU07UUFDNUQ5eUIsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1NBQW1CLEVBQUV5WTtJQUNoRTtJQUNBLE1BQU10WCx5QkFBeUJ0YSxlQUFlNFMsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWF1ZCwwQkFBMEIsTUFBTTtRQUM5RHhiLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFxQixFQUFFbUI7SUFDdEY7SUFDQSxNQUFNakIsa0JBQWtCclosZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUl1RyxpQkFBaUJwYyxhQUFhc2MsbUJBQW1CLE1BQU07UUFDdkR2YSxlQUFlcWEsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBYyxFQUFFRTtJQUMvRTtJQUNBLE1BQU1DLFdBQVd0WixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXVHLGlCQUFpQnBjLGFBQWF1YyxZQUFZLE1BQU07UUFDaER4YSxlQUFlcWEsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBTyxFQUFFRztJQUN4RTtJQUNBLE1BQU1DLFdBQVd2WixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXVHLGlCQUFpQnBjLGFBQWF3YyxZQUFZLE1BQU07UUFDaER6YSxlQUFlcWEsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBTyxFQUFFSTtJQUN4RTtJQUNBLE1BQU1FLHNCQUFzQnpaLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTBjLHVCQUF1QixNQUFNO1FBQzNEM2EsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQWtCLEVBQUVNO0lBQ25GO0lBQ0EsTUFBTWMsc0JBQXNCdmEsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhd2QsdUJBQXVCLE1BQU07UUFDM0R6YixlQUFlcWEsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBa0IsRUFBRW9CO0lBQ25GO0lBQ0EsTUFBTVIsV0FBVy9aLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWdkLFlBQVksTUFBTTtRQUNoRGpiLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFPLEVBQUVZO0lBQ3hFO0lBQ0EsTUFBTVMsbUJBQW1CeGEsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUl1RyxpQkFBaUJwYyxhQUFheWQsb0JBQW9CLE1BQU07UUFDeEQxYixlQUFlcWEsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBZSxFQUFFc1csc0JBQXNCN2dCLGtCQUFrQjRMO0lBQ3hIO0lBQ0EsTUFBTXFYLDRCQUE0Qjd4QixlQUFlNFMsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWE4MEIsNkJBQTZCLE1BQU07UUFDakUveUIsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQXdCLEVBQUUwWTtJQUN6RjtJQUNBLE1BQU16WSx3QkFBd0JwWixlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFxYyx5QkFBeUIsTUFBTTtRQUM3RHRhLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztTQUFvQixFQUFFMlcsaUJBQWlCbmpCLFNBQVN5TTtJQUMzRjtJQUNBLE1BQU1lLFlBQVluYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXVHLGlCQUFpQnBjLGFBQWFvZCxhQUFhLE1BQU07UUFDakQsSUFBSWhHLGtCQUFrQi9FLE9BQU8rSztRQUM3QixJQUFJN2EsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU8rakIsY0FBY3poQixNQUFNdEM7WUFDL0I7UUFDSjtRQUNBek4sZUFBZXFhLGNBQWM7WUFBQztZQUFTO1NBQVEsRUFBRWhGO0lBQ3JEO0lBQ0EsTUFBTTJkLHdCQUF3Qjl4QixlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWErMEIseUJBQXlCLE1BQU07UUFDN0RoekIsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1NBQW9CLEVBQUVvWCxpQ0FBaUN1QjtJQUNsRztJQUNBLE1BQU1DLDhCQUE4Qi94QixlQUFlNFMsWUFBWTtRQUMzRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFnMUIsK0JBQStCLE1BQU07UUFDbkVqekIsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1NBQTBCLEVBQUVzWDtJQUN2RTtJQUNBLE1BQU11QiwrQkFBK0JoeUIsZUFBZTRTLFlBQVk7UUFDNUQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhaTFCLGdDQUFnQyxNQUFNO1FBQ3BFbHpCLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztTQUEyQixFQUFFc1g7SUFDeEU7SUFDQSxNQUFNd0IsMEJBQTBCanlCLGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWsxQiwyQkFBMkIsTUFBTTtRQUMvRG56QixlQUFlcWEsY0FBYztZQUFDO1lBQVM7U0FBc0IsRUFBRTZYLDZCQUE2QmlCO0lBQ2hHO0lBQ0EsTUFBTUMsK0JBQStCbHlCLGVBQWU0UyxZQUFZO1FBQzVEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYW0xQixnQ0FBZ0MsTUFBTTtRQUNwRXB6QixlQUFlcWEsY0FBYztZQUFDO1lBQVM7U0FBMkIsRUFBRW1ZLHdDQUF3Q1k7SUFDaEg7SUFDQSxNQUFNQyxrQkFBa0JueUIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUl1RyxpQkFBaUJwYyxhQUFhbzFCLG1CQUFtQixNQUFNO1FBQ3ZEcnpCLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztTQUFjLEVBQUVzWSwyQkFBMkJVO0lBQ3RGO0lBQ0EsT0FBT3RmO0FBQ1g7QUFDQSxTQUFTdWYsNkJBQTZCaG5CLFNBQVMsRUFBRXdILFVBQVU7SUFDdkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04SCxZQUFZM2EsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrSCxhQUFhLE1BQU07UUFDbkI3YixlQUFlK1QsVUFBVTtZQUFDO1lBQVM7U0FBUSxFQUFFMUgsT0FBT0MsV0FBV3VQO0lBQ25FO0lBQ0EsTUFBTUUsYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUU4ZSwyQkFBMkI5VyxZQUFZaEk7SUFDaEY7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU3dmO0lBQ0wsTUFBTXhmLFdBQVcsQ0FBQztJQUNsQixPQUFPQTtBQUNYO0FBQ0EsU0FBU3lmO0lBQ0wsTUFBTXpmLFdBQVcsQ0FBQztJQUNsQixPQUFPQTtBQUNYO0FBQ0EsU0FBUzBmLHVDQUF1QzNmLFVBQVU7SUFDdEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0yZixZQUFZeHlCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJNGYsYUFBYSxNQUFNO1FBQ25CMXpCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFaEgsT0FBTzJtQjtJQUNyRDtJQUNBLE1BQU1DLFlBQVl6eUIsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk2ZixhQUFhLE1BQU07UUFDbkIzekIsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUUxRyxXQUFXc21CO0lBQ25EO0lBQ0EsTUFBTUMscUJBQXFCMXlCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJOGYsc0JBQXNCLE1BQU07UUFDNUI1ekIsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFNmY7SUFDakQ7SUFDQSxNQUFNQyxZQUFZM3lCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK2YsYUFBYSxNQUFNO1FBQ25CN3pCLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFNUcsV0FBVzBtQjtJQUNuRDtJQUNBLE1BQU0zZSxXQUFXaFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlvQixZQUFZLE1BQU07UUFDbEJsVixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRW1CO0lBQ3ZDO0lBQ0EsTUFBTTRlLG9CQUFvQjV5QixlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSWdnQixxQkFBcUIsTUFBTTtRQUMzQjl6QixlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUV3ZjtJQUNoRDtJQUNBLE1BQU1RLGtCQUFrQjd5QixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSWlnQixtQkFBbUIsTUFBTTtRQUN6Qi96QixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXlmO0lBQzlDO0lBQ0EsT0FBT3pmO0FBQ1g7QUFDQSxTQUFTaWdCLHNCQUFzQmxnQixVQUFVO0lBQ3JDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNbUIsV0FBV2hVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJb0IsWUFBWSxNQUFNO1FBQ2xCbFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVtQjtJQUN2QztJQUNBLE1BQU0rZSxhQUFhL3lCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJbWdCLGNBQWMsTUFBTTtRQUNwQmowQixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWtnQjtJQUN6QztJQUNBLE9BQU9sZ0I7QUFDWDtBQUNBLFNBQVNtZ0IsNkNBQTZDcGdCLFVBQVU7SUFDNUQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vZ0Isc0JBQXNCanpCLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcWdCLHVCQUF1QixNQUFNO1FBQzdCLElBQUk5ZSxrQkFBa0I4ZTtRQUN0QixJQUFJM3pCLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPdW1CLHNCQUFzQnZtQjtZQUNqQztRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVzQjtJQUNsRDtJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBU3FnQixpQ0FBaUN0Z0IsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXdHLGtCQUFrQnJaLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJeUcsbUJBQW1CLE1BQU07UUFDekJ2YSxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXdHO0lBQzlDO0lBQ0EsTUFBTUUsV0FBV3ZaLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJMkcsWUFBWSxNQUFNO1FBQ2xCemEsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUUwRztJQUN2QztJQUNBLE1BQU1RLFdBQVcvWixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSW1ILFlBQVksTUFBTTtRQUNsQmpiLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFa0g7SUFDdkM7SUFDQSxNQUFNb1osZUFBZW56QixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXVnQixnQkFBZ0IsTUFBTTtRQUN0QnIwQixlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRXNnQjtJQUMzQztJQUNBLE1BQU1DLFVBQVVwekIsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUl3Z0IsV0FBVyxNQUFNO1FBQ2pCdDBCLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFdWdCO0lBQ3RDO0lBQ0EsTUFBTUMsY0FBY3J6QixlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSXlnQixlQUFlLE1BQU07UUFDckJ2MEIsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUV3Z0I7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUJ0ekIsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkwZ0Isa0JBQWtCLE1BQU07UUFDeEJ4MEIsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUV5Z0I7SUFDN0M7SUFDQSxNQUFNQyxZQUFZdnpCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJMmdCLGFBQWEsTUFBTTtRQUNuQnowQixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRTBnQjtJQUN4QztJQUNBLE1BQU1DLGVBQWV4ekIsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUk0Z0IsZ0JBQWdCLE1BQU07UUFDdEIxMEIsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUUyZ0I7SUFDM0M7SUFDQSxNQUFNQyxnQkFBZ0J6ekIsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUk2Z0IsaUJBQWlCLE1BQU07UUFDdkIzMEIsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUU0Z0I7SUFDNUM7SUFDQSxNQUFNQyx1QkFBdUIxekIsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUk4Z0Isd0JBQXdCLE1BQU07UUFDOUI1MEIsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFNmdCO0lBQ25EO0lBQ0EsTUFBTUMsMEJBQTBCM3pCLGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJK2dCLDJCQUEyQixNQUFNO1FBQ2pDNzBCLGVBQWUrVCxVQUFVO1lBQUM7U0FBc0IsRUFBRThnQjtJQUN0RDtJQUNBLE9BQU85Z0I7QUFDWDtBQUNBLFNBQVMrZ0Isb0NBQW9DaGhCLFVBQVU7SUFDbkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1naEIsNEJBQTRCN3pCLGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJaWhCLDZCQUE2QixNQUFNO1FBQ25DLzBCLGVBQWUrVCxVQUFVO1lBQUM7U0FBd0IsRUFBRXFnQixpQ0FBaUNXO0lBQ3pGO0lBQ0EsT0FBT2hoQjtBQUNYO0FBQ0EsU0FBU2loQiw0QkFBNEJsaEIsVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFOEg7SUFDeEM7SUFDQSxPQUFPOUg7QUFDWDtBQUNBLFNBQVNraEIsOEJBQThCbmhCLFVBQVU7SUFDN0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vZ0Isc0JBQXNCanpCLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcWdCLHVCQUF1QixNQUFNO1FBQzdCLElBQUk5ZSxrQkFBa0I4ZTtRQUN0QixJQUFJM3pCLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPdW1CLHNCQUFzQnZtQjtZQUNqQztRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVzQjtJQUNsRDtJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBU21oQiw4QkFBOEJwaEIsVUFBVTtJQUM3QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9oQixZQUFZajBCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJcWhCLGFBQWEsTUFBTTtRQUNuQm4xQixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRWloQiw0QkFBNEJHO0lBQ3BFO0lBQ0EsTUFBTUMsb0JBQW9CbDBCLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJc2hCLHFCQUFxQixNQUFNO1FBQzNCcDFCLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRWtoQiw4QkFBOEJHO0lBQzlFO0lBQ0EsTUFBTUwsNEJBQTRCN3pCLGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJaWhCLDZCQUE2QixNQUFNO1FBQ25DLzBCLGVBQWUrVCxVQUFVO1lBQUM7U0FBd0IsRUFBRXFnQixpQ0FBaUNXO0lBQ3pGO0lBQ0EsTUFBTU0sc0JBQXNCbjBCLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJdWhCLHVCQUF1QixNQUFNO1FBQzdCcjFCLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRXNoQjtJQUNsRDtJQUNBLE9BQU90aEI7QUFDWDtBQUNBLFNBQVN1aEIsOEJBQThCeGhCLFVBQVU7SUFDN0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU13RixnQkFBZ0JyWSxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSXlGLGlCQUFpQixNQUFNO1FBQ3ZCdlosZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUV3RjtJQUM1QztJQUNBLE9BQU94RjtBQUNYO0FBQ0EsU0FBU3doQixzQkFBc0J6aEIsVUFBVTtJQUNyQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTBGLDBCQUEwQnZZLGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJMkYsMkJBQTJCLE1BQU07UUFDakN6WixlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUV1aEIsOEJBQThCN2I7SUFDcEY7SUFDQSxPQUFPMUY7QUFDWDtBQUNBLFNBQVN5aEIsdUJBQXVCMWhCLFVBQVU7SUFDdEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02RixrQkFBa0IxWSxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSThGLG1CQUFtQixNQUFNO1FBQ3pCNVosZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUV3aEIsc0JBQXNCM2I7SUFDcEU7SUFDQSxJQUFJMVksZUFBZTRTLFlBQVk7UUFBQztLQUEwQixNQUFNN1YsV0FBVztRQUN2RSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTW1aLG1CQUFtQmhZLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJb0Ysb0JBQW9CLE1BQU07UUFDMUJsWixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRW1GO0lBQy9DO0lBQ0EsT0FBT25GO0FBQ1g7QUFDQSxTQUFTMGhCLHdCQUF3QjNoQixVQUFVO0lBQ3ZDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNQyxVQUFVOVMsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUlFLFdBQVcsTUFBTTtRQUNqQmhVLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFQztJQUN0QztJQUNBLE1BQU1DLGdCQUFnQi9TLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJRyxpQkFBaUIsTUFBTTtRQUN2QmpVLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFRTtJQUM1QztJQUNBLE1BQU1DLGtCQUFrQmhULGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJSSxtQkFBbUIsTUFBTTtRQUN6QmxVLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFRztJQUM5QztJQUNBLE9BQU9IO0FBQ1g7QUFDQSxTQUFTMmhCLGVBQWU1aEIsVUFBVTtJQUM5QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFJLGtCQUFrQmxiLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJc0ksbUJBQW1CLE1BQU07UUFDekJwYyxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXFJO0lBQzlDO0lBQ0EsTUFBTWhJLFdBQVdsVCxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSU0sWUFBWSxNQUFNO1FBQ2xCcFUsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVLO0lBQ3ZDO0lBQ0EsTUFBTUMsZUFBZW5ULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJTyxnQkFBZ0IsTUFBTTtRQUN0QnJVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFTTtJQUMzQztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTNGhCLG1CQUFtQjdoQixVQUFVO0lBQ2xDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNcUksa0JBQWtCbGIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlzSSxtQkFBbUIsTUFBTTtRQUN6QnBjLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFcUk7SUFDOUM7SUFDQSxNQUFNN0gsY0FBY3JULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJUyxlQUFlLE1BQU07UUFDckJ2VSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVE7SUFDMUM7SUFDQSxNQUFNRixlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVM2aEIsZUFBZTloQixVQUFVO0lBQzlCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNVSxvQkFBb0J2VCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSVcscUJBQXFCLE1BQU07UUFDM0J6VSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUUwaEIsd0JBQXdCaGhCO0lBQ3hFO0lBQ0EsTUFBTUMsY0FBY3hULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJWSxlQUFlLE1BQU07UUFDckIxVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVc7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUJ6VCxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWEsa0JBQWtCLE1BQU07UUFDeEIzVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRTJoQixlQUFlL2dCO0lBQzVEO0lBQ0EsTUFBTUMsZUFBZTFULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJYyxnQkFBZ0IsTUFBTTtRQUN0QjVVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFNGhCLG1CQUFtQi9nQjtJQUM5RDtJQUNBLE1BQU1DLHVCQUF1QjNULGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJZSx3QkFBd0IsTUFBTTtRQUM5QjdVLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWM7SUFDbkQ7SUFDQSxNQUFNQywwQkFBMEI1VCxlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSWdCLDJCQUEyQixNQUFNO1FBQ2pDOVUsZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFZTtJQUN0RDtJQUNBLE1BQU1DLHFCQUFxQjdULGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJaUIsc0JBQXNCLE1BQU07UUFDNUIvVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVnQjtJQUNqRDtJQUNBLE1BQU1DLG1CQUFtQjlULGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJa0Isb0JBQW9CLE1BQU07UUFDMUJoVixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRWlCO0lBQy9DO0lBQ0EsTUFBTUMsdUJBQXVCL1QsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUltQix3QkFBd0IsTUFBTTtRQUM5QmpWLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWtCO0lBQ25EO0lBQ0EsTUFBTUMsV0FBV2hVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJb0IsWUFBWSxNQUFNO1FBQ2xCbFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVtQjtJQUN2QztJQUNBLE9BQU9uQjtBQUNYO0FBQ0EsU0FBUzhoQixrQkFBa0IvaEIsVUFBVTtJQUNqQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFCLFlBQVlsVSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXNCLGFBQWEsTUFBTTtRQUNuQixJQUFJQyxrQkFBa0JEO1FBQ3RCLElBQUk1VSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT21vQixlQUFlbm9CO1lBQzFCO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFc0I7SUFDeEM7SUFDQSxNQUFNQyxXQUFXcFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl3QixZQUFZLE1BQU07UUFDbEJ0VixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXVCO0lBQ3ZDO0lBQ0EsT0FBT3ZCO0FBQ1g7QUFDQSxTQUFTK2hCLDhCQUE4QmhpQixVQUFVO0lBQzdDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJN1MsZUFBZTRTLFlBQVk7UUFBQztLQUFXLE1BQU03VixXQUFXO1FBQ3hELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNMlYsa0JBQWtCeFUsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUk0QixtQkFBbUIsTUFBTTtRQUN6QjFWLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFMkI7SUFDOUM7SUFDQSxNQUFNcEUsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV6QztJQUN2QztJQUNBLE1BQU02RixpQkFBaUJqVyxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXFELGtCQUFrQixNQUFNO1FBQ3hCblgsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVvRDtJQUM3QztJQUNBLE1BQU1DLDJCQUEyQmxXLGVBQWU0UyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJc0QsNEJBQTRCLE1BQU07UUFDbENwWCxlQUFlK1QsVUFBVTtZQUFDO1NBQXVCLEVBQUVxRDtJQUN2RDtJQUNBLE1BQU1DLGVBQWVuVyxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXVELGdCQUFnQixNQUFNO1FBQ3RCclgsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVzRDtJQUMzQztJQUNBLE1BQU1DLHlCQUF5QnBXLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJd0QsMEJBQTBCLE1BQU07UUFDaEN0WCxlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUV1RDtJQUNyRDtJQUNBLE9BQU92RDtBQUNYO0FBQ0EsU0FBU2dpQixtQkFBbUJqaUIsVUFBVTtJQUNsQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlELGdCQUFnQnRXLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJMEQsaUJBQWlCLE1BQU07UUFDdkJ4WCxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRXlEO0lBQzVDO0lBQ0EsTUFBTUMsY0FBY3ZXLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJMkQsZUFBZSxNQUFNO1FBQ3JCelgsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUUwRDtJQUMxQztJQUNBLE9BQU8xRDtBQUNYO0FBQ0EsU0FBU2lpQix1QkFBdUJsaUIsVUFBVTtJQUN0QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTRELHNCQUFzQnpXLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJNkQsdUJBQXVCLE1BQU07UUFDN0IzWCxlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVnaUIsbUJBQW1CcGU7SUFDckU7SUFDQSxNQUFNc1AscUJBQXFCL2xCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJbVQsc0JBQXNCLE1BQU07UUFDNUJqbkIsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFa1Q7SUFDakQ7SUFDQSxPQUFPbFQ7QUFDWDtBQUNBLFNBQVNraUIsaUNBQWlDbmlCLFVBQVU7SUFDaEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04RCxXQUFXM1csZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrRCxZQUFZLE1BQU07UUFDbEI3WCxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRThEO0lBQ3ZDO0lBQ0EsTUFBTUMsdUJBQXVCNVcsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlnRSx3QkFBd0IsTUFBTTtRQUM5QjlYLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRStEO0lBQ25EO0lBQ0EsT0FBTy9EO0FBQ1g7QUFDQSxTQUFTbWlCLGdDQUFnQ3BpQixVQUFVO0lBQy9DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNaUUsNkJBQTZCOVcsZUFBZTRTLFlBQVk7UUFDMUQ7S0FDSDtJQUNELElBQUlrRSw4QkFBOEIsTUFBTTtRQUNwQ2hZLGVBQWUrVCxVQUFVO1lBQUM7U0FBeUIsRUFBRWtpQixpQ0FBaUNqZTtJQUMxRjtJQUNBLE9BQU9qRTtBQUNYO0FBQ0EsU0FBU29pQiw4QkFBOEJyaUIsVUFBVTtJQUM3QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWtULHFCQUFxQi9sQixlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSW1ULHNCQUFzQixNQUFNO1FBQzVCam5CLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRWtUO0lBQ2pEO0lBQ0EsT0FBT2xUO0FBQ1g7QUFDQSxTQUFTcWlCLHVCQUF1QnRpQixVQUFVO0lBQ3RDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNdVQsbUJBQW1CcG1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJd1Qsb0JBQW9CLE1BQU07UUFDMUJ0bkIsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUV1VDtJQUMvQztJQUNBLE9BQU92VDtBQUNYO0FBQ0EsU0FBU3NpQixxQkFBcUJ2aUIsVUFBVTtJQUNwQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlULG1CQUFtQnRtQixlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSTBULG9CQUFvQixNQUFNO1FBQzFCeG5CLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFcWlCLHVCQUF1QjVPO0lBQ3RFO0lBQ0EsTUFBTUMsZUFBZXZtQixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSTJULGdCQUFnQixNQUFNO1FBQ3RCem5CLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFMFQ7SUFDM0M7SUFDQSxNQUFNQyxpQ0FBaUN4bUIsZUFBZTRTLFlBQVk7UUFDOUQ7S0FDSDtJQUNELElBQUk0VCxrQ0FBa0MsTUFBTTtRQUN4QzFuQixlQUFlK1QsVUFBVTtZQUFDO1NBQTZCLEVBQUUyVDtJQUM3RDtJQUNBLE1BQU1DLDBCQUEwQnptQixlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSTZULDJCQUEyQixNQUFNO1FBQ2pDM25CLGVBQWUrVCxVQUFVO1lBQUM7U0FBc0IsRUFBRTRUO0lBQ3REO0lBQ0EsTUFBTUMsa0JBQWtCMW1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJOFQsbUJBQW1CLE1BQU07UUFDekI1bkIsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUU2VDtJQUM5QztJQUNBLE1BQU1DLGlCQUFpQjNtQixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSStULGtCQUFrQixNQUFNO1FBQ3hCN25CLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFOFQ7SUFDN0M7SUFDQSxPQUFPOVQ7QUFDWDtBQUNBLFNBQVN1aUIscUJBQXFCeGlCLFVBQVU7SUFDcEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1nVSxpQkFBaUI3bUIsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlpVSxrQkFBa0IsTUFBTTtRQUN4Qi9uQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXNpQixxQkFBcUJ0TztJQUNsRTtJQUNBLE9BQU9oVTtBQUNYO0FBQ0EsU0FBU3dpQjtJQUNMLE1BQU14aUIsV0FBVyxDQUFDO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQSxTQUFTeWlCLDBCQUEwQjFpQixVQUFVO0lBQ3pDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0Usa0JBQWtCalgsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlxRSxtQkFBbUIsTUFBTTtRQUN6Qm5ZLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFb0U7SUFDOUM7SUFDQSxPQUFPcEU7QUFDWDtBQUNBLFNBQVMwaUIsZUFBZTNpQixVQUFVO0lBQzlCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNc0UsMkJBQTJCblgsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUl1RSw0QkFBNEIsTUFBTTtRQUNsQyxJQUFJaEQsa0JBQWtCZ0Q7UUFDdEIsSUFBSTdYLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPcW9CLDhCQUE4QnJvQjtZQUN6QztRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQXVCLEVBQUVzQjtJQUN2RDtJQUNBLE1BQU04UyxnQkFBZ0JqbkIsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlxVSxpQkFBaUIsTUFBTTtRQUN2Qm5vQixlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRW9VO0lBQzVDO0lBQ0EsTUFBTTdQLG1CQUFtQnBYLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJd0Usb0JBQW9CLE1BQU07UUFDMUJ0WSxlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRWlpQix1QkFBdUIxZDtJQUN0RTtJQUNBLE1BQU1DLDRCQUE0QnJYLGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJeUUsNkJBQTZCLE1BQU07UUFDbkN2WSxlQUFlK1QsVUFBVTtZQUFDO1NBQXdCLEVBQUVtaUIsZ0NBQWdDM2Q7SUFDeEY7SUFDQSxNQUFNNlAsMEJBQTBCbG5CLGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJc1UsMkJBQTJCLE1BQU07UUFDakNwb0IsZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFb2lCLDhCQUE4Qi9OO0lBQ3BGO0lBQ0EsTUFBTUMsaUJBQWlCbm5CLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJdVUsa0JBQWtCLE1BQU07UUFDeEJyb0IsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUV1aUIscUJBQXFCak87SUFDbEU7SUFDQSxNQUFNN1AsaUJBQWlCdFgsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkwRSxrQkFBa0IsTUFBTTtRQUN4QnhZLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFd2lCO0lBQzdDO0lBQ0EsTUFBTTlkLGtCQUFrQnZYLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJMkUsbUJBQW1CLE1BQU07UUFDekJ6WSxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXlpQiwwQkFBMEIvZDtJQUN4RTtJQUNBLE1BQU1DLG9CQUFvQnhYLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJNEUscUJBQXFCLE1BQU07UUFDM0IxWSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUUyRTtJQUNoRDtJQUNBLE9BQU8zRTtBQUNYO0FBQ0EsU0FBUzJpQixnQ0FBZ0M1aUIsVUFBVTtJQUMvQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTJkLGFBQWF4d0IsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUk0ZCxjQUFjLE1BQU07UUFDcEIxeEIsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUUyZDtJQUN6QztJQUNBLE1BQU1pRixrQkFBa0J6MUIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUk2aUIsbUJBQW1CLE1BQU07UUFDekIzMkIsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUU0aUI7SUFDOUM7SUFDQSxPQUFPNWlCO0FBQ1g7QUFDQSxTQUFTNmlCO0lBQ0wsTUFBTTdpQixXQUFXLENBQUM7SUFDbEIsT0FBT0E7QUFDWDtBQUNBLFNBQVM4aUIsbUNBQW1DL2lCLFVBQVU7SUFDbEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04ZCxlQUFlM3dCLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK2QsZ0JBQWdCLE1BQU07UUFDdEI3eEIsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUU4ZDtJQUMzQztJQUNBLE1BQU1DLCtCQUErQjV3QixlQUFlNFMsWUFBWTtRQUM1RDtLQUNIO0lBQ0QsSUFBSWdlLGdDQUFnQyxNQUFNO1FBQ3RDOXhCLGVBQWUrVCxVQUFVO1lBQUM7U0FBMkIsRUFBRStkO0lBQzNEO0lBQ0EsTUFBTUMsNkJBQTZCN3dCLGVBQWU0UyxZQUFZO1FBQzFEO0tBQ0g7SUFDRCxJQUFJaWUsOEJBQThCLE1BQU07UUFDcEMveEIsZUFBZStULFVBQVU7WUFBQztTQUF5QixFQUFFZ2U7SUFDekQ7SUFDQSxNQUFNQyxzQkFBc0I5d0IsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlrZSx1QkFBdUIsTUFBTTtRQUM3Qmh5QixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVpZTtJQUNsRDtJQUNBLE1BQU1DLHdCQUF3Qi93QixlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSW1lLHlCQUF5QixNQUFNO1FBQy9CanlCLGVBQWUrVCxVQUFVO1lBQUM7U0FBb0IsRUFBRWtlO0lBQ3BEO0lBQ0EsT0FBT2xlO0FBQ1g7QUFDQSxTQUFTK2lCLDRCQUE0QmhqQixVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb2UsaUNBQWlDanhCLGVBQWU0UyxZQUFZO1FBQzlEO0tBQ0g7SUFDRCxJQUFJcWUsa0NBQWtDLE1BQU07UUFDeENueUIsZUFBZStULFVBQVU7WUFBQztTQUE2QixFQUFFOGlCLG1DQUFtQzFFO0lBQ2hHO0lBQ0EsTUFBTUMsdUJBQXVCbHhCLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJc2Usd0JBQXdCLE1BQU07UUFDOUJweUIsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFcWU7SUFDbkQ7SUFDQSxNQUFNQyxtQkFBbUJueEIsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUl1ZSxvQkFBb0IsTUFBTTtRQUMxQnJ5QixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRXNlO0lBQy9DO0lBQ0EsT0FBT3RlO0FBQ1g7QUFDQSxTQUFTZ2pCLHNCQUFzQmpqQixVQUFVO0lBQ3JDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNd2UsbUJBQW1CcnhCLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJeWUsb0JBQW9CLE1BQU07UUFDMUJ2eUIsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUV3ZTtJQUMvQztJQUNBLE9BQU94ZTtBQUNYO0FBQ0EsU0FBU2lqQix1Q0FBdUNsakIsVUFBVTtJQUN0RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTBlLG9CQUFvQnZ4QixlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSTJlLHFCQUFxQixNQUFNO1FBQzNCenlCLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRTBlO0lBQ2hEO0lBQ0EsTUFBTUMsb0JBQW9CeHhCLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJNGUscUJBQXFCLE1BQU07UUFDM0IxeUIsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFZ2pCLHNCQUFzQnJFO0lBQ3RFO0lBQ0EsT0FBTzNlO0FBQ1g7QUFDQSxTQUFTa2pCLDBCQUEwQm5qQixVQUFVO0lBQ3pDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNmUscUJBQXFCMXhCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJOGUsc0JBQXNCLE1BQU07UUFDNUI1eUIsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFNmU7SUFDakQ7SUFDQSxPQUFPN2U7QUFDWDtBQUNBLFNBQVNtakIsMEJBQTBCcGpCLFVBQVUsRUFBRXVHLFlBQVk7SUFDdkQsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNK2UsdUJBQXVCNXhCLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTYwQix3QkFBd0IsTUFBTTtRQUM1RDl5QixlQUFlcWEsY0FBYztZQUFDO1lBQVM7U0FBbUIsRUFBRXlZO0lBQ2hFO0lBQ0EsTUFBTXRYLHlCQUF5QnRhLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXVkLDBCQUEwQixNQUFNO1FBQzlEeGIsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQXFCLEVBQUVtQjtJQUN0RjtJQUNBLE1BQU1qQixrQkFBa0JyWixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXVHLGlCQUFpQnBjLGFBQWFzYyxtQkFBbUIsTUFBTTtRQUN2RHZhLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFjLEVBQUVFO0lBQy9FO0lBQ0EsTUFBTUMsV0FBV3RaLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXVjLFlBQVksTUFBTTtRQUNoRHhhLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFPLEVBQUVHO0lBQ3hFO0lBQ0EsTUFBTUMsV0FBV3ZaLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXdjLFlBQVksTUFBTTtRQUNoRHphLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFPLEVBQUVJO0lBQ3hFO0lBQ0EsTUFBTUUsc0JBQXNCelosZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhMGMsdUJBQXVCLE1BQU07UUFDM0QzYSxlQUFlcWEsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBa0IsRUFBRU07SUFDbkY7SUFDQSxNQUFNYyxzQkFBc0J2YSxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWF3ZCx1QkFBdUIsTUFBTTtRQUMzRHpiLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFrQixFQUFFb0I7SUFDbkY7SUFDQSxNQUFNUixXQUFXL1osZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl1RyxpQkFBaUJwYyxhQUFhZ2QsWUFBWSxNQUFNO1FBQ2hEamIsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQU8sRUFBRVk7SUFDeEU7SUFDQSxNQUFNUyxtQkFBbUJ4YSxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXVHLGlCQUFpQnBjLGFBQWF5ZCxvQkFBb0IsTUFBTTtRQUN4RDFiLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFlLEVBQUVtYix1QkFBdUIxbEIsa0JBQWtCNEw7SUFDekg7SUFDQSxNQUFNcVgsNEJBQTRCN3hCLGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTgwQiw2QkFBNkIsTUFBTTtRQUNqRS95QixlQUFlcWEsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBd0IsRUFBRTBZO0lBQ3pGO0lBQ0EsTUFBTXpZLHdCQUF3QnBaLGVBQWU0UyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXFjLHlCQUF5QixNQUFNO1FBQzdEdGEsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1NBQW9CLEVBQUV3YixrQkFBa0Job0IsU0FBU3lNO0lBQzVGO0lBQ0EsTUFBTWUsWUFBWW5hLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJdUcsaUJBQWlCcGMsYUFBYW9kLGFBQWEsTUFBTTtRQUNqRCxJQUFJaEcsa0JBQWtCL0UsT0FBTytLO1FBQzdCLElBQUk3YSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT2dwQixlQUFlMW1CLE1BQU10QztZQUNoQztRQUNKO1FBQ0F6TixlQUFlcWEsY0FBYztZQUFDO1lBQVM7U0FBUSxFQUFFaEY7SUFDckQ7SUFDQSxNQUFNMmQsd0JBQXdCOXhCLGVBQWU0UyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYSswQix5QkFBeUIsTUFBTTtRQUM3RGh6QixlQUFlcWEsY0FBYztZQUFDO1lBQVM7U0FBb0IsRUFBRXFjLGdDQUFnQzFEO0lBQ2pHO0lBQ0EsTUFBTUMsOEJBQThCL3hCLGVBQWU0UyxZQUFZO1FBQzNEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWcxQiwrQkFBK0IsTUFBTTtRQUNuRWp6QixlQUFlcWEsY0FBYztZQUFDO1lBQVM7U0FBMEIsRUFBRXVjO0lBQ3ZFO0lBQ0EsTUFBTTFELCtCQUErQmh5QixlQUFlNFMsWUFBWTtRQUM1RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFpMUIsZ0NBQWdDLE1BQU07UUFDcEVsekIsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1NBQTJCLEVBQUV1YztJQUN4RTtJQUNBLE1BQU16RCwwQkFBMEJqeUIsZUFBZTRTLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhazFCLDJCQUEyQixNQUFNO1FBQy9EbnpCLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztTQUFzQixFQUFFeWMsNEJBQTRCM0Q7SUFDL0Y7SUFDQSxNQUFNQywrQkFBK0JseUIsZUFBZTRTLFlBQVk7UUFDNUQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhbTFCLGdDQUFnQyxNQUFNO1FBQ3BFcHpCLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztTQUEyQixFQUFFMmMsdUNBQXVDNUQ7SUFDL0c7SUFDQSxNQUFNQyxrQkFBa0JueUIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUl1RyxpQkFBaUJwYyxhQUFhbzFCLG1CQUFtQixNQUFNO1FBQ3ZEcnpCLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztTQUFjLEVBQUU0YywwQkFBMEI1RDtJQUNyRjtJQUNBLE9BQU90ZjtBQUNYO0FBQ0EsU0FBU29qQiw4QkFBOEI3cUIsU0FBUyxFQUFFd0gsVUFBVTtJQUN4RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7WUFBUztTQUFRLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDbkU7SUFDQSxNQUFNRSxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRW1qQiwwQkFBMEJuYixZQUFZaEk7SUFDL0U7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU3FqQjtJQUNMLE1BQU1yakIsV0FBVyxDQUFDO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQSxTQUFTc2pCO0lBQ0wsTUFBTXRqQixXQUFXLENBQUM7SUFDbEIsT0FBT0E7QUFDWDtBQUNBLFNBQVN1akIsd0NBQXdDeGpCLFVBQVU7SUFDdkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0yZixZQUFZeHlCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJNGYsYUFBYSxNQUFNO1FBQ25CMXpCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFaEgsT0FBTzJtQjtJQUNyRDtJQUNBLE1BQU1DLFlBQVl6eUIsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk2ZixhQUFhLE1BQU07UUFDbkIzekIsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUUxRyxXQUFXc21CO0lBQ25EO0lBQ0EsTUFBTUMscUJBQXFCMXlCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJOGYsc0JBQXNCLE1BQU07UUFDNUI1ekIsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFNmY7SUFDakQ7SUFDQSxNQUFNQyxZQUFZM3lCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK2YsYUFBYSxNQUFNO1FBQ25CN3pCLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFNUcsV0FBVzBtQjtJQUNuRDtJQUNBLE1BQU0zZSxXQUFXaFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlvQixZQUFZLE1BQU07UUFDbEJsVixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRW1CO0lBQ3ZDO0lBQ0EsTUFBTTRlLG9CQUFvQjV5QixlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSWdnQixxQkFBcUIsTUFBTTtRQUMzQjl6QixlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVxakI7SUFDaEQ7SUFDQSxNQUFNckQsa0JBQWtCN3lCLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJaWdCLG1CQUFtQixNQUFNO1FBQ3pCL3pCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFc2pCO0lBQzlDO0lBQ0EsT0FBT3RqQjtBQUNYO0FBQ0EsU0FBU3dqQjtJQUNMLE1BQU14akIsV0FBVyxDQUFDO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQSxTQUFTeWpCLHlCQUF5QjFqQixVQUFVO0lBQ3hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNQyxVQUFVOVMsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUlFLFdBQVcsTUFBTTtRQUNqQmhVLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFQztJQUN0QztJQUNBLE1BQU1DLGdCQUFnQi9TLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJRyxpQkFBaUIsTUFBTTtRQUN2QmpVLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFRTtJQUM1QztJQUNBLE1BQU1DLGtCQUFrQmhULGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJSSxtQkFBbUIsTUFBTTtRQUN6QmxVLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFRztJQUM5QztJQUNBLE9BQU9IO0FBQ1g7QUFDQSxTQUFTMGpCLGdCQUFnQjNqQixVQUFVO0lBQy9CLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSyxXQUFXbFQsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlNLFlBQVksTUFBTTtRQUNsQnBVLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFSztJQUN2QztJQUNBLE1BQU1DLGVBQWVuVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU8sZ0JBQWdCLE1BQU07UUFDdEJyVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRU07SUFDM0M7SUFDQSxPQUFPTjtBQUNYO0FBQ0EsU0FBUzJqQixvQkFBb0I1akIsVUFBVTtJQUNuQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTVEsY0FBY3JULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJUyxlQUFlLE1BQU07UUFDckJ2VSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVE7SUFDMUM7SUFDQSxNQUFNRixlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVM0akIsZ0JBQWdCN2pCLFVBQVU7SUFDL0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1VLG9CQUFvQnZULGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJVyxxQkFBcUIsTUFBTTtRQUMzQnpVLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXlqQix5QkFBeUIvaUI7SUFDekU7SUFDQSxNQUFNQyxjQUFjeFQsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUlZLGVBQWUsTUFBTTtRQUNyQjFVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFVztJQUMxQztJQUNBLE1BQU1DLGlCQUFpQnpULGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJYSxrQkFBa0IsTUFBTTtRQUN4QjNVLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFMGpCLGdCQUFnQjlpQjtJQUM3RDtJQUNBLE1BQU1DLGVBQWUxVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWMsZ0JBQWdCLE1BQU07UUFDdEI1VSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRTJqQixvQkFBb0I5aUI7SUFDL0Q7SUFDQSxNQUFNQyx1QkFBdUIzVCxlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSWUsd0JBQXdCLE1BQU07UUFDOUI3VSxlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVjO0lBQ25EO0lBQ0EsTUFBTUMsMEJBQTBCNVQsZUFBZTRTLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUlnQiwyQkFBMkIsTUFBTTtRQUNqQzlVLGVBQWUrVCxVQUFVO1lBQUM7U0FBc0IsRUFBRWU7SUFDdEQ7SUFDQSxNQUFNQyxxQkFBcUI3VCxlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSWlCLHNCQUFzQixNQUFNO1FBQzVCL1UsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFZ0I7SUFDakQ7SUFDQSxNQUFNQyxtQkFBbUI5VCxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSWtCLG9CQUFvQixNQUFNO1FBQzFCaFYsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVpQjtJQUMvQztJQUNBLE1BQU1DLHVCQUF1Qi9ULGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJbUIsd0JBQXdCLE1BQU07UUFDOUJqVixlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVrQjtJQUNuRDtJQUNBLE1BQU1DLFdBQVdoVSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSW9CLFlBQVksTUFBTTtRQUNsQmxWLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFbUI7SUFDdkM7SUFDQSxPQUFPbkI7QUFDWDtBQUNBLFNBQVM2akIsbUJBQW1COWpCLFVBQVU7SUFDbEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1xQixZQUFZbFUsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlzQixhQUFhLE1BQU07UUFDbkIsSUFBSUMsa0JBQWtCRDtRQUN0QixJQUFJNVUsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU9rcUIsZ0JBQWdCbHFCO1lBQzNCO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFc0I7SUFDeEM7SUFDQSxNQUFNQyxXQUFXcFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl3QixZQUFZLE1BQU07UUFDbEJ0VixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXVCO0lBQ3ZDO0lBQ0EsT0FBT3ZCO0FBQ1g7QUFDQSxTQUFTOGpCLHVCQUF1Qi9qQixVQUFVO0lBQ3RDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNbUIsV0FBV2hVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJb0IsWUFBWSxNQUFNO1FBQ2xCbFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVtQjtJQUN2QztJQUNBLE1BQU00aUIsZUFBZTUyQixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWdrQixnQkFBZ0IsTUFBTTtRQUN0QjkzQixlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRStqQjtJQUMzQztJQUNBLE9BQU8vakI7QUFDWDtBQUNBLFNBQVNna0IsdUJBQXVCamtCLFVBQVU7SUFDdEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vSyxtQkFBbUJqZCxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXFLLG9CQUFvQixNQUFNO1FBQzFCbmUsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVvSztJQUMvQztJQUNBLE1BQU1DLHlCQUF5QmxkLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJc0ssMEJBQTBCLE1BQU07UUFDaENwZSxlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUVxSztJQUNyRDtJQUNBLE9BQU9ySztBQUNYO0FBQ0EsU0FBU2lrQiw4QkFBOEJsa0IsVUFBVTtJQUM3QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXVLLGtCQUFrQnBkLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJd0ssbUJBQW1CLE1BQU07UUFDekIsSUFBSWpKLGtCQUFrQmlKO1FBQ3RCLElBQUk5ZCxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3NxQix1QkFBdUJ0cUI7WUFDbEM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVzQjtJQUM5QztJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBU2trQiwyQkFBMkJua0IsVUFBVTtJQUMxQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW1rQixnQkFBZ0JoM0IsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlva0IsaUJBQWlCLE1BQU07UUFDdkJsNEIsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUU2akIsbUJBQW1CTTtJQUMvRDtJQUNBLE1BQU1DLG1CQUFtQmozQixlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXFrQixvQkFBb0IsTUFBTTtRQUMxQm40QixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRW9rQjtJQUMvQztJQUNBLE1BQU1DLGtCQUFrQmwzQixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXNrQixtQkFBbUIsTUFBTTtRQUN6QnA0QixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXFrQjtJQUM5QztJQUNBLE1BQU10Wix3QkFBd0I1ZCxlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSWdMLHlCQUF5QixNQUFNO1FBQy9COWUsZUFBZStULFVBQVU7WUFBQztTQUFvQixFQUFFK0s7SUFDcEQ7SUFDQSxNQUFNdVoseUJBQXlCbjNCLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJdWtCLDBCQUEwQixNQUFNO1FBQ2hDcjRCLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRXNrQjtJQUNyRDtJQUNBLE1BQU1DLHlCQUF5QnAzQixlQUFlNFMsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSXdrQiwwQkFBMEIsTUFBTTtRQUNoQ3Q0QixlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUU4akIsdUJBQXVCUztJQUM1RTtJQUNBLE1BQU1DLDBCQUEwQnIzQixlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSXlrQiwyQkFBMkIsTUFBTTtRQUNqQ3Y0QixlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUU4akIsdUJBQXVCVTtJQUM3RTtJQUNBLE1BQU0zWix5QkFBeUIxZCxlQUFlNFMsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSThLLDBCQUEwQixNQUFNO1FBQ2hDNWUsZUFBZStULFVBQVU7WUFBQztTQUFxQixFQUFFaWtCLDhCQUE4QnBaO0lBQ25GO0lBQ0EsT0FBTzdLO0FBQ1g7QUFDQSxTQUFTeWtCLHNCQUFzQjFrQixVQUFVO0lBQ3JDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMGtCLFNBQVN2M0IsZUFBZTRTLFlBQVk7UUFBQztLQUFLO0lBQ2hELElBQUkya0IsVUFBVSxNQUFNO1FBQ2hCejRCLGVBQWUrVCxVQUFVO1lBQUM7U0FBSyxFQUFFMGtCO0lBQ3JDO0lBQ0EsTUFBTUMsV0FBV3gzQixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTRrQixZQUFZLE1BQU07UUFDbEIxNEIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUUya0I7SUFDdkM7SUFDQSxNQUFNcG5CLFdBQVdwUSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXhDLFlBQVksTUFBTTtRQUNsQnRSLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFekM7SUFDdkM7SUFDQSxPQUFPeUM7QUFDWDtBQUNBLFNBQVM0a0IsNEJBQTRCN2tCLFVBQVU7SUFDM0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02a0Isb0JBQW9CMTNCLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJOGtCLHFCQUFxQixNQUFNO1FBQzNCLElBQUl2akIsa0JBQWtCdWpCO1FBQ3RCLElBQUlwNEIsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU8rcUIsc0JBQXNCL3FCO1lBQ2pDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXNCO0lBQ2hEO0lBQ0EsT0FBT3RCO0FBQ1g7QUFDQSxTQUFTOGtCLHdDQUF3Qy9rQixVQUFVO0lBQ3ZELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNK2tCLFVBQVU1M0IsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUlnbEIsV0FBVyxNQUFNO1FBQ2pCOTRCLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFK2tCO0lBQ3RDO0lBQ0EsT0FBTy9rQjtBQUNYO0FBQ0EsU0FBU2dsQiw0QkFBNEJqbEIsVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWlsQixlQUFlOTNCLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJa2xCLGdCQUFnQixNQUFNO1FBQ3RCaDVCLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFaWxCO0lBQzNDO0lBQ0EsTUFBTXRhLGlCQUFpQnhkLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJNEssa0JBQWtCLE1BQU07UUFDeEIxZSxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRTJLO0lBQzdDO0lBQ0EsT0FBTzNLO0FBQ1g7QUFDQSxTQUFTa2xCLHVCQUF1Qm5sQixVQUFVO0lBQ3RDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNbWxCLHVCQUF1Qmg0QixlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSW9sQix3QkFBd0IsTUFBTTtRQUM5Qmw1QixlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVtbEI7SUFDbkQ7SUFDQSxNQUFNQyw4QkFBOEJqNEIsZUFBZTRTLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUlxbEIsK0JBQStCLE1BQU07UUFDckNuNUIsZUFBZStULFVBQVU7WUFBQztTQUEwQixFQUFFb2xCO0lBQzFEO0lBQ0EsTUFBTUMseUJBQXlCbDRCLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJc2xCLDBCQUEwQixNQUFNO1FBQ2hDcDVCLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRXFsQjtJQUNyRDtJQUNBLE1BQU1DLDhCQUE4Qm40QixlQUFlNFMsWUFBWTtRQUMzRDtLQUNIO0lBQ0QsSUFBSXVsQiwrQkFBK0IsTUFBTTtRQUNyQ3I1QixlQUFlK1QsVUFBVTtZQUFDO1NBQTBCLEVBQUVzbEI7SUFDMUQ7SUFDQSxNQUFNQyx5QkFBeUJwNEIsZUFBZTRTLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUl3bEIsMEJBQTBCLE1BQU07UUFDaEN0NUIsZUFBZStULFVBQVU7WUFBQztTQUFxQixFQUFFdWxCO0lBQ3JEO0lBQ0EsTUFBTUMsc0JBQXNCcjRCLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJeWxCLHVCQUF1QixNQUFNO1FBQzdCdjVCLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRXdsQjtJQUNsRDtJQUNBLE1BQU1DLDBCQUEwQnQ0QixlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSTBsQiwyQkFBMkIsTUFBTTtRQUNqQyxJQUFJbmtCLGtCQUFrQm1rQjtRQUN0QixJQUFJaDVCLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPc3JCLDRCQUE0QnRyQjtZQUN2QztRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUVzQjtJQUN0RDtJQUNBLE1BQU1va0IseUJBQXlCdjRCLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJMmxCLDBCQUEwQixNQUFNO1FBQ2hDLElBQUlwa0Isa0JBQWtCb2tCO1FBQ3RCLElBQUlqNUIsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU9zckIsNEJBQTRCdHJCO1lBQ3ZDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRXNCO0lBQ3JEO0lBQ0EsTUFBTXFrQiw0QkFBNEJ4NEIsZUFBZTRTLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUk0bEIsNkJBQTZCLE1BQU07UUFDbkMsSUFBSXJrQixrQkFBa0Jxa0I7UUFDdEIsSUFBSWw1QixNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3NyQiw0QkFBNEJ0ckI7WUFDdkM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUF3QixFQUFFc0I7SUFDeEQ7SUFDQSxNQUFNc2tCLGlDQUFpQ3o0QixlQUFlNFMsWUFBWTtRQUM5RDtLQUNIO0lBQ0QsSUFBSTZsQixrQ0FBa0MsTUFBTTtRQUN4QyxJQUFJdGtCLGtCQUFrQnNrQjtRQUN0QixJQUFJbjVCLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPc3JCLDRCQUE0QnRyQjtZQUN2QztRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQTZCLEVBQUVzQjtJQUM3RDtJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBUzZsQiwwQkFBMEI5bEIsVUFBVTtJQUN6QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThsQixlQUFlMzRCLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK2xCLGdCQUFnQixNQUFNO1FBQ3RCNzVCLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFOGxCO0lBQzNDO0lBQ0EsT0FBTzlsQjtBQUNYO0FBQ0EsU0FBUytsQiwyQ0FBMkNobUIsVUFBVTtJQUMxRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWdtQixnQkFBZ0I3NEIsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlpbUIsaUJBQWlCLE1BQU07UUFDdkIvNUIsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVnbUI7SUFDNUM7SUFDQSxNQUFNQyxnQkFBZ0I5NEIsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlrbUIsaUJBQWlCLE1BQU07UUFDdkJoNkIsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVpbUI7SUFDNUM7SUFDQSxNQUFNQyxxQ0FBcUMvNEIsZUFBZTRTLFlBQVk7UUFDbEU7S0FDSDtJQUNELElBQUltbUIsc0NBQXNDLE1BQU07UUFDNUNqNkIsZUFBZStULFVBQVU7WUFBQztTQUFpQyxFQUFFa21CO0lBQ2pFO0lBQ0EsT0FBT2xtQjtBQUNYO0FBQ0EsU0FBU21tQiwyQkFBMkJwbUIsVUFBVTtJQUMxQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9tQixvQkFBb0JqNUIsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlxbUIscUJBQXFCLE1BQU07UUFDM0JuNkIsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFd2pCO0lBQ2hEO0lBQ0EsTUFBTTZDLG9CQUFvQmw1QixlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXNtQixxQkFBcUIsTUFBTTtRQUMzQnA2QixlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVra0IsMkJBQTJCbUM7SUFDM0U7SUFDQSxNQUFNQyxlQUFlbjVCLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJdW1CLGdCQUFnQixNQUFNO1FBQ3RCcjZCLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFNGtCLDRCQUE0QjBCO0lBQ3ZFO0lBQ0EsTUFBTUMsMkJBQTJCcDVCLGVBQWU0UyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJd21CLDRCQUE0QixNQUFNO1FBQ2xDdDZCLGVBQWUrVCxVQUFVO1lBQUM7U0FBdUIsRUFBRThrQix3Q0FBd0N5QjtJQUMvRjtJQUNBLE1BQU05YSxvQkFBb0J0ZSxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSTBMLHFCQUFxQixNQUFNO1FBQzNCeGYsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFa2xCLHVCQUF1QnpaO0lBQ3ZFO0lBQ0EsTUFBTSthLGFBQWFyNUIsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUl5bUIsY0FBYyxNQUFNO1FBQ3BCdjZCLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFNmxCLDBCQUEwQlc7SUFDbkU7SUFDQSxNQUFNQyw4QkFBOEJ0NUIsZUFBZTRTLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUkwbUIsK0JBQStCLE1BQU07UUFDckN4NkIsZUFBZStULFVBQVU7WUFBQztTQUEwQixFQUFFK2xCLDJDQUEyQ1U7SUFDckc7SUFDQSxPQUFPem1CO0FBQ1g7QUFDQSxTQUFTMG1CO0lBQ0wsTUFBTTFtQixXQUFXLENBQUM7SUFDbEIsT0FBT0E7QUFDWDtBQUNBLFNBQVMybUIsd0JBQXdCNW1CLFVBQVU7SUFDdkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1tQixXQUFXaFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlvQixZQUFZLE1BQU07UUFDbEJsVixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRW1CO0lBQ3ZDO0lBQ0EsTUFBTStlLGFBQWEveUIsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUltZ0IsY0FBYyxNQUFNO1FBQ3BCajBCLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFa2dCO0lBQ3pDO0lBQ0EsT0FBT2xnQjtBQUNYO0FBQ0EsU0FBUzRtQixnQ0FBZ0M3bUIsVUFBVTtJQUMvQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9nQixzQkFBc0JqekIsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxZ0IsdUJBQXVCLE1BQU07UUFDN0IsSUFBSTllLGtCQUFrQjhlO1FBQ3RCLElBQUkzekIsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU9pdEIsd0JBQXdCanRCO1lBQ25DO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRXNCO0lBQ2xEO0lBQ0EsT0FBT3RCO0FBQ1g7QUFDQSxTQUFTNm1CLG1DQUFtQzltQixVQUFVO0lBQ2xELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNd0csa0JBQWtCclosZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUl5RyxtQkFBbUIsTUFBTTtRQUN6QnZhLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFd0c7SUFDOUM7SUFDQSxNQUFNRSxXQUFXdlosZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkyRyxZQUFZLE1BQU07UUFDbEJ6YSxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRTBHO0lBQ3ZDO0lBQ0EsTUFBTVEsV0FBVy9aLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJbUgsWUFBWSxNQUFNO1FBQ2xCamIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVrSDtJQUN2QztJQUNBLE1BQU1vWixlQUFlbnpCLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJdWdCLGdCQUFnQixNQUFNO1FBQ3RCcjBCLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFc2dCO0lBQzNDO0lBQ0EsTUFBTUMsVUFBVXB6QixlQUFlNFMsWUFBWTtRQUFDO0tBQU07SUFDbEQsSUFBSXdnQixXQUFXLE1BQU07UUFDakJ0MEIsZUFBZStULFVBQVU7WUFBQztTQUFNLEVBQUV1Z0I7SUFDdEM7SUFDQSxNQUFNQyxjQUFjcnpCLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJeWdCLGVBQWUsTUFBTTtRQUNyQnYwQixlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRXdnQjtJQUMxQztJQUNBLE1BQU1DLGlCQUFpQnR6QixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSTBnQixrQkFBa0IsTUFBTTtRQUN4QngwQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXlnQjtJQUM3QztJQUNBLE1BQU1DLFlBQVl2ekIsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkyZ0IsYUFBYSxNQUFNO1FBQ25CejBCLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFMGdCO0lBQ3hDO0lBQ0EsTUFBTUMsZUFBZXh6QixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSTRnQixnQkFBZ0IsTUFBTTtRQUN0QjEwQixlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRTJnQjtJQUMzQztJQUNBLE1BQU1DLGdCQUFnQnp6QixlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSTZnQixpQkFBaUIsTUFBTTtRQUN2QjMwQixlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRTRnQjtJQUM1QztJQUNBLE1BQU1DLHVCQUF1QjF6QixlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSThnQix3QkFBd0IsTUFBTTtRQUM5QjUwQixlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUU2Z0I7SUFDbkQ7SUFDQSxNQUFNQywwQkFBMEIzekIsZUFBZTRTLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkrZ0IsMkJBQTJCLE1BQU07UUFDakM3MEIsZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFOGdCO0lBQ3REO0lBQ0EsT0FBTzlnQjtBQUNYO0FBQ0EsU0FBUzhtQixpQ0FBaUMvbUIsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFoQixvQkFBb0JsMEIsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlzaEIscUJBQXFCLE1BQU07UUFDM0JwMUIsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFNG1CLGdDQUFnQ3ZGO0lBQ2hGO0lBQ0EsTUFBTUwsNEJBQTRCN3pCLGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJaWhCLDZCQUE2QixNQUFNO1FBQ25DLzBCLGVBQWUrVCxVQUFVO1lBQUM7U0FBd0IsRUFBRTZtQixtQ0FBbUM3RjtJQUMzRjtJQUNBLE9BQU9oaEI7QUFDWDtBQUNBLFNBQVMrbUIsb0JBQW9CaG5CLFVBQVU7SUFDbkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1LLFdBQVdsVCxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSU0sWUFBWSxNQUFNO1FBQ2xCcFUsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVLO0lBQ3ZDO0lBQ0EsTUFBTUMsZUFBZW5ULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJTyxnQkFBZ0IsTUFBTTtRQUN0QnJVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFTTtJQUMzQztJQUNBLE1BQU0wbUIscUJBQXFCNzVCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJaW5CLHNCQUFzQixNQUFNO1FBQzVCLzZCLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRThtQixpQ0FBaUNFO0lBQ2xGO0lBQ0EsT0FBT2huQjtBQUNYO0FBQ0EsU0FBU2luQixnQ0FBZ0NsbkIsVUFBVTtJQUMvQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWtuQixrQkFBa0IvNUIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUltbkIsbUJBQW1CLE1BQU07UUFDekIsSUFBSTVsQixrQkFBa0I0bEI7UUFDdEIsSUFBSXo2QixNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3F0QixvQkFBb0JydEI7WUFDL0I7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVzQjtJQUM5QztJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBU21uQixpQ0FBaUNwbkIsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW1CLFdBQVdoVSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSW9CLFlBQVksTUFBTTtRQUNsQmxWLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFbUI7SUFDdkM7SUFDQSxNQUFNaW1CLHFCQUFxQmo2QixlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXFuQixzQkFBc0IsTUFBTTtRQUM1Qm43QixlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVvbkI7SUFDakQ7SUFDQSxPQUFPcG5CO0FBQ1g7QUFDQSxTQUFTcW5CLGdDQUFnQ3RuQixVQUFVO0lBQy9DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb21CLG9CQUFvQmo1QixlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXFtQixxQkFBcUIsTUFBTTtRQUMzQm42QixlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUUwbUI7SUFDaEQ7SUFDQSxNQUFNTCxvQkFBb0JsNUIsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlzbUIscUJBQXFCLE1BQU07UUFDM0JwNkIsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFaW5CLGdDQUFnQ1o7SUFDaEY7SUFDQSxNQUFNaUIscUJBQXFCbjZCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJdW5CLHNCQUFzQixNQUFNO1FBQzVCcjdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRW1uQixpQ0FBaUNHO0lBQ2xGO0lBQ0EsT0FBT3RuQjtBQUNYO0FBQ0EsU0FBU3VuQixrQ0FBa0N4bkIsVUFBVTtJQUNqRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXduQixnQkFBZ0JyNkIsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUl5bkIsaUJBQWlCLE1BQU07UUFDdkJ2N0IsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUV3bkI7SUFDNUM7SUFDQSxPQUFPeG5CO0FBQ1g7QUFDQSxTQUFTeW5CLDBCQUEwQjFuQixVQUFVO0lBQ3pDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNQyxVQUFVOVMsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUlFLFdBQVcsTUFBTTtRQUNqQmhVLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFQztJQUN0QztJQUNBLE1BQU1DLGdCQUFnQi9TLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJRyxpQkFBaUIsTUFBTTtRQUN2QmpVLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFRTtJQUM1QztJQUNBLE1BQU1DLGtCQUFrQmhULGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJSSxtQkFBbUIsTUFBTTtRQUN6QmxVLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFRztJQUM5QztJQUNBLE9BQU9IO0FBQ1g7QUFDQSxTQUFTMG5CLGlCQUFpQjNuQixVQUFVO0lBQ2hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNcUksa0JBQWtCbGIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlzSSxtQkFBbUIsTUFBTTtRQUN6QnBjLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFcUk7SUFDOUM7SUFDQSxNQUFNaEksV0FBV2xULGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJTSxZQUFZLE1BQU07UUFDbEJwVSxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRUs7SUFDdkM7SUFDQSxNQUFNQyxlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVMybkIscUJBQXFCNW5CLFVBQVU7SUFDcEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1xSSxrQkFBa0JsYixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXNJLG1CQUFtQixNQUFNO1FBQ3pCcGMsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVxSTtJQUM5QztJQUNBLE1BQU03SCxjQUFjclQsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUlTLGVBQWUsTUFBTTtRQUNyQnZVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFUTtJQUMxQztJQUNBLE1BQU1GLGVBQWVuVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU8sZ0JBQWdCLE1BQU07UUFDdEJyVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRU07SUFDM0M7SUFDQSxPQUFPTjtBQUNYO0FBQ0EsU0FBUzRuQixpQkFBaUI3bkIsVUFBVTtJQUNoQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTVUsb0JBQW9CdlQsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlXLHFCQUFxQixNQUFNO1FBQzNCelUsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFeW5CLDBCQUEwQi9tQjtJQUMxRTtJQUNBLE1BQU1DLGNBQWN4VCxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSVksZUFBZSxNQUFNO1FBQ3JCMVUsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUVXO0lBQzFDO0lBQ0EsTUFBTUMsaUJBQWlCelQsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlhLGtCQUFrQixNQUFNO1FBQ3hCM1UsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUUwbkIsaUJBQWlCOW1CO0lBQzlEO0lBQ0EsTUFBTUMsZUFBZTFULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJYyxnQkFBZ0IsTUFBTTtRQUN0QjVVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFMm5CLHFCQUFxQjltQjtJQUNoRTtJQUNBLE1BQU1DLHVCQUF1QjNULGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJZSx3QkFBd0IsTUFBTTtRQUM5QjdVLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWM7SUFDbkQ7SUFDQSxNQUFNQywwQkFBMEI1VCxlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSWdCLDJCQUEyQixNQUFNO1FBQ2pDOVUsZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFZTtJQUN0RDtJQUNBLE1BQU1DLHFCQUFxQjdULGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJaUIsc0JBQXNCLE1BQU07UUFDNUIvVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVnQjtJQUNqRDtJQUNBLE1BQU1DLG1CQUFtQjlULGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJa0Isb0JBQW9CLE1BQU07UUFDMUJoVixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRWlCO0lBQy9DO0lBQ0EsTUFBTUMsdUJBQXVCL1QsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUltQix3QkFBd0IsTUFBTTtRQUM5QmpWLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWtCO0lBQ25EO0lBQ0EsTUFBTUMsV0FBV2hVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJb0IsWUFBWSxNQUFNO1FBQ2xCbFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVtQjtJQUN2QztJQUNBLE9BQU9uQjtBQUNYO0FBQ0EsU0FBUzZuQixvQkFBb0I5bkIsVUFBVTtJQUNuQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFCLFlBQVlsVSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXNCLGFBQWEsTUFBTTtRQUNuQixJQUFJQyxrQkFBa0JEO1FBQ3RCLElBQUk1VSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT2t1QixpQkFBaUJsdUI7WUFDNUI7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUVzQjtJQUN4QztJQUNBLE1BQU1DLFdBQVdwVSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXdCLFlBQVksTUFBTTtRQUNsQnRWLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFdUI7SUFDdkM7SUFDQSxPQUFPdkI7QUFDWDtBQUNBLFNBQVM4bkIsd0JBQXdCL25CLFVBQVU7SUFDdkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1tQixXQUFXaFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlvQixZQUFZLE1BQU07UUFDbEJsVixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRW1CO0lBQ3ZDO0lBQ0EsTUFBTTRpQixlQUFlNTJCLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJZ2tCLGdCQUFnQixNQUFNO1FBQ3RCOTNCLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFK2pCO0lBQzNDO0lBQ0EsT0FBTy9qQjtBQUNYO0FBQ0EsU0FBUytuQiw0QkFBNEJob0IsVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW1rQixnQkFBZ0JoM0IsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlva0IsaUJBQWlCLE1BQU07UUFDdkJsNEIsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUU2bkIsb0JBQW9CMUQ7SUFDaEU7SUFDQSxNQUFNQyxtQkFBbUJqM0IsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlxa0Isb0JBQW9CLE1BQU07UUFDMUJuNEIsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVva0I7SUFDL0M7SUFDQSxNQUFNQyxrQkFBa0JsM0IsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlza0IsbUJBQW1CLE1BQU07UUFDekJwNEIsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVxa0I7SUFDOUM7SUFDQSxNQUFNdFosd0JBQXdCNWQsZUFBZTRTLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUlnTCx5QkFBeUIsTUFBTTtRQUMvQjllLGVBQWUrVCxVQUFVO1lBQUM7U0FBb0IsRUFBRStLO0lBQ3BEO0lBQ0EsTUFBTXVaLHlCQUF5Qm4zQixlQUFlNFMsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSXVrQiwwQkFBMEIsTUFBTTtRQUNoQ3I0QixlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUVza0I7SUFDckQ7SUFDQSxNQUFNQyx5QkFBeUJwM0IsZUFBZTRTLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUl3a0IsMEJBQTBCLE1BQU07UUFDaEN0NEIsZUFBZStULFVBQVU7WUFBQztTQUFxQixFQUFFOG5CLHdCQUF3QnZEO0lBQzdFO0lBQ0EsTUFBTUMsMEJBQTBCcjNCLGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJeWtCLDJCQUEyQixNQUFNO1FBQ2pDdjRCLGVBQWUrVCxVQUFVO1lBQUM7U0FBc0IsRUFBRThuQix3QkFBd0J0RDtJQUM5RTtJQUNBLE9BQU94a0I7QUFDWDtBQUNBLFNBQVNnb0IsdUJBQXVCam9CLFVBQVU7SUFDdEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0ya0IsV0FBV3gzQixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTRrQixZQUFZLE1BQU07UUFDbEIxNEIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUUya0I7SUFDdkM7SUFDQSxNQUFNcG5CLFdBQVdwUSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXhDLFlBQVksTUFBTTtRQUNsQnRSLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFekM7SUFDdkM7SUFDQSxPQUFPeUM7QUFDWDtBQUNBLFNBQVNpb0IsNkJBQTZCbG9CLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02a0Isb0JBQW9CMTNCLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJOGtCLHFCQUFxQixNQUFNO1FBQzNCLElBQUl2akIsa0JBQWtCdWpCO1FBQ3RCLElBQUlwNEIsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU9zdUIsdUJBQXVCdHVCO1lBQ2xDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXNCO0lBQ2hEO0lBQ0EsT0FBT3RCO0FBQ1g7QUFDQSxTQUFTa29CLHlDQUF5Q25vQixVQUFVO0lBQ3hELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNK2tCLFVBQVU1M0IsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUlnbEIsV0FBVyxNQUFNO1FBQ2pCOTRCLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFK2tCO0lBQ3RDO0lBQ0EsT0FBTy9rQjtBQUNYO0FBQ0EsU0FBU21vQiw2QkFBNkJwb0IsVUFBVTtJQUM1QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWlsQixlQUFlOTNCLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJa2xCLGdCQUFnQixNQUFNO1FBQ3RCaDVCLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFaWxCO0lBQzNDO0lBQ0EsTUFBTXRhLGlCQUFpQnhkLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJNEssa0JBQWtCLE1BQU07UUFDeEIxZSxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRTJLO0lBQzdDO0lBQ0EsT0FBTzNLO0FBQ1g7QUFDQSxTQUFTb29CLHdCQUF3QnJvQixVQUFVO0lBQ3ZDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNbWxCLHVCQUF1Qmg0QixlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSW9sQix3QkFBd0IsTUFBTTtRQUM5Qmw1QixlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVtbEI7SUFDbkQ7SUFDQSxNQUFNQyw4QkFBOEJqNEIsZUFBZTRTLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUlxbEIsK0JBQStCLE1BQU07UUFDckNuNUIsZUFBZStULFVBQVU7WUFBQztTQUEwQixFQUFFb2xCO0lBQzFEO0lBQ0EsTUFBTUMseUJBQXlCbDRCLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJc2xCLDBCQUEwQixNQUFNO1FBQ2hDcDVCLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRXFsQjtJQUNyRDtJQUNBLE1BQU1DLDhCQUE4Qm40QixlQUFlNFMsWUFBWTtRQUMzRDtLQUNIO0lBQ0QsSUFBSXVsQiwrQkFBK0IsTUFBTTtRQUNyQ3I1QixlQUFlK1QsVUFBVTtZQUFDO1NBQTBCLEVBQUVzbEI7SUFDMUQ7SUFDQSxNQUFNQyx5QkFBeUJwNEIsZUFBZTRTLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUl3bEIsMEJBQTBCLE1BQU07UUFDaEN0NUIsZUFBZStULFVBQVU7WUFBQztTQUFxQixFQUFFdWxCO0lBQ3JEO0lBQ0EsTUFBTUMsc0JBQXNCcjRCLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJeWxCLHVCQUF1QixNQUFNO1FBQzdCdjVCLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRXdsQjtJQUNsRDtJQUNBLE1BQU1DLDBCQUEwQnQ0QixlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSTBsQiwyQkFBMkIsTUFBTTtRQUNqQyxJQUFJbmtCLGtCQUFrQm1rQjtRQUN0QixJQUFJaDVCLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPeXVCLDZCQUE2Qnp1QjtZQUN4QztRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUVzQjtJQUN0RDtJQUNBLE1BQU1va0IseUJBQXlCdjRCLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJMmxCLDBCQUEwQixNQUFNO1FBQ2hDLElBQUlwa0Isa0JBQWtCb2tCO1FBQ3RCLElBQUlqNUIsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU95dUIsNkJBQTZCenVCO1lBQ3hDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRXNCO0lBQ3JEO0lBQ0EsTUFBTXFrQiw0QkFBNEJ4NEIsZUFBZTRTLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUk0bEIsNkJBQTZCLE1BQU07UUFDbkMsSUFBSXJrQixrQkFBa0Jxa0I7UUFDdEIsSUFBSWw1QixNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3l1Qiw2QkFBNkJ6dUI7WUFDeEM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUF3QixFQUFFc0I7SUFDeEQ7SUFDQSxNQUFNc2tCLGlDQUFpQ3o0QixlQUFlNFMsWUFBWTtRQUM5RDtLQUNIO0lBQ0QsSUFBSTZsQixrQ0FBa0MsTUFBTTtRQUN4QyxJQUFJdGtCLGtCQUFrQnNrQjtRQUN0QixJQUFJbjVCLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPeXVCLDZCQUE2Qnp1QjtZQUN4QztRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQTZCLEVBQUVzQjtJQUM3RDtJQUNBLE1BQU0rbUIsa0JBQWtCbDdCLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJc29CLG1CQUFtQixNQUFNO1FBQ3pCcDhCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFcW9CO0lBQzlDO0lBQ0EsT0FBT3JvQjtBQUNYO0FBQ0EsU0FBU3NvQiwyQkFBMkJ2b0IsVUFBVTtJQUMxQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThsQixlQUFlMzRCLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK2xCLGdCQUFnQixNQUFNO1FBQ3RCNzVCLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFOGxCO0lBQzNDO0lBQ0EsT0FBTzlsQjtBQUNYO0FBQ0EsU0FBU3VvQiw0Q0FBNEN4b0IsVUFBVTtJQUMzRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWdtQixnQkFBZ0I3NEIsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlpbUIsaUJBQWlCLE1BQU07UUFDdkIvNUIsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVnbUI7SUFDNUM7SUFDQSxNQUFNQyxnQkFBZ0I5NEIsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlrbUIsaUJBQWlCLE1BQU07UUFDdkJoNkIsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVpbUI7SUFDNUM7SUFDQSxNQUFNQyxxQ0FBcUMvNEIsZUFBZTRTLFlBQVk7UUFDbEU7S0FDSDtJQUNELElBQUltbUIsc0NBQXNDLE1BQU07UUFDNUNqNkIsZUFBZStULFVBQVU7WUFBQztTQUFpQyxFQUFFa21CO0lBQ2pFO0lBQ0EsT0FBT2xtQjtBQUNYO0FBQ0EsU0FBU3dvQiw0QkFBNEJ6b0IsVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9tQixvQkFBb0JqNUIsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlxbUIscUJBQXFCLE1BQU07UUFDM0JuNkIsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFdW5CLGtDQUFrQ25CO0lBQ2xGO0lBQ0EsTUFBTUMsb0JBQW9CbDVCLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJc21CLHFCQUFxQixNQUFNO1FBQzNCcDZCLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRStuQiw0QkFBNEIxQjtJQUM1RTtJQUNBLE1BQU1DLGVBQWVuNUIsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUl1bUIsZ0JBQWdCLE1BQU07UUFDdEJyNkIsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVpb0IsNkJBQTZCM0I7SUFDeEU7SUFDQSxNQUFNQywyQkFBMkJwNUIsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUl3bUIsNEJBQTRCLE1BQU07UUFDbEN0NkIsZUFBZStULFVBQVU7WUFBQztTQUF1QixFQUFFa29CLHlDQUF5QzNCO0lBQ2hHO0lBQ0EsTUFBTTlhLG9CQUFvQnRlLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJMEwscUJBQXFCLE1BQU07UUFDM0J4ZixlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVvb0Isd0JBQXdCM2M7SUFDeEU7SUFDQSxNQUFNK2EsYUFBYXI1QixlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSXltQixjQUFjLE1BQU07UUFDcEJ2NkIsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVzb0IsMkJBQTJCOUI7SUFDcEU7SUFDQSxNQUFNQyw4QkFBOEJ0NUIsZUFBZTRTLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUkwbUIsK0JBQStCLE1BQU07UUFDckN4NkIsZUFBZStULFVBQVU7WUFBQztTQUEwQixFQUFFdW9CLDRDQUE0QzlCO0lBQ3RHO0lBQ0EsT0FBT3ptQjtBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVN5b0IsdUJBQXVCMW9CLFVBQVU7SUFDdEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1DLFVBQVU5UyxlQUFlNFMsWUFBWTtRQUFDO0tBQU07SUFDbEQsSUFBSUUsV0FBVyxNQUFNO1FBQ2pCaFUsZUFBZStULFVBQVU7WUFBQztTQUFNLEVBQUVDO0lBQ3RDO0lBQ0EsTUFBTUMsZ0JBQWdCL1MsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlHLGlCQUFpQixNQUFNO1FBQ3ZCalUsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVFO0lBQzVDO0lBQ0EsTUFBTUMsa0JBQWtCaFQsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlJLG1CQUFtQixNQUFNO1FBQ3pCbFUsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVHO0lBQzlDO0lBQ0EsT0FBT0g7QUFDWDtBQUNBLFNBQVMwb0IsY0FBYzNvQixVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJN1MsZUFBZTRTLFlBQVk7UUFBQztLQUFjLE1BQU03VixXQUFXO1FBQzNELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNcVUsV0FBV2xULGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJTSxZQUFZLE1BQU07UUFDbEJwVSxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRUs7SUFDdkM7SUFDQSxNQUFNQyxlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVMyb0Isa0JBQWtCNW9CLFVBQVU7SUFDakMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLElBQUk3UyxlQUFlNFMsWUFBWTtRQUFDO0tBQWMsTUFBTTdWLFdBQVc7UUFDM0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU13VSxjQUFjclQsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUlTLGVBQWUsTUFBTTtRQUNyQnZVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFUTtJQUMxQztJQUNBLE1BQU1GLGVBQWVuVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU8sZ0JBQWdCLE1BQU07UUFDdEJyVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRU07SUFDM0M7SUFDQSxPQUFPTjtBQUNYO0FBQ0EsU0FBUzRvQixjQUFjN29CLFVBQVU7SUFDN0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1VLG9CQUFvQnZULGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJVyxxQkFBcUIsTUFBTTtRQUMzQnpVLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXlvQix1QkFBdUIvbkI7SUFDdkU7SUFDQSxNQUFNQyxjQUFjeFQsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUlZLGVBQWUsTUFBTTtRQUNyQjFVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFVztJQUMxQztJQUNBLE1BQU1DLGlCQUFpQnpULGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJYSxrQkFBa0IsTUFBTTtRQUN4QjNVLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFMG9CLGNBQWM5bkI7SUFDM0Q7SUFDQSxNQUFNQyxlQUFlMVQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUljLGdCQUFnQixNQUFNO1FBQ3RCNVUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUUyb0Isa0JBQWtCOW5CO0lBQzdEO0lBQ0EsTUFBTUMsdUJBQXVCM1QsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUllLHdCQUF3QixNQUFNO1FBQzlCN1UsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFYztJQUNuRDtJQUNBLE1BQU1DLDBCQUEwQjVULGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJZ0IsMkJBQTJCLE1BQU07UUFDakM5VSxlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUVlO0lBQ3REO0lBQ0EsTUFBTUMscUJBQXFCN1QsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUlpQixzQkFBc0IsTUFBTTtRQUM1Qi9VLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRWdCO0lBQ2pEO0lBQ0EsTUFBTUMsbUJBQW1COVQsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlrQixvQkFBb0IsTUFBTTtRQUMxQmhWLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFaUI7SUFDL0M7SUFDQSxNQUFNQyx1QkFBdUIvVCxlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSW1CLHdCQUF3QixNQUFNO1FBQzlCalYsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFa0I7SUFDbkQ7SUFDQSxNQUFNQyxXQUFXaFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlvQixZQUFZLE1BQU07UUFDbEJsVixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRW1CO0lBQ3ZDO0lBQ0EsT0FBT25CO0FBQ1g7QUFDQSxTQUFTNm9CLGlCQUFpQjlvQixVQUFVO0lBQ2hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNcUIsWUFBWWxVLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJc0IsYUFBYSxNQUFNO1FBQ25CLElBQUlDLGtCQUFrQkQ7UUFDdEIsSUFBSTVVLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPa3ZCLGNBQWNsdkI7WUFDekI7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUVzQjtJQUN4QztJQUNBLE1BQU1DLFdBQVdwVSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXdCLFlBQVksTUFBTTtRQUNsQnRWLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFdUI7SUFDdkM7SUFDQSxPQUFPdkI7QUFDWDtBQUNBLFNBQVM4b0IsY0FBYy9vQixVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUIsWUFBWXRVLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJMEIsYUFBYSxNQUFNO1FBQ25CeFYsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUV5QjtJQUN4QztJQUNBLE1BQU1DLGNBQWN2VSxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSTJCLGVBQWUsTUFBTTtRQUNyQnpWLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFMEI7SUFDMUM7SUFDQSxNQUFNQyxrQkFBa0J4VSxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTRCLG1CQUFtQixNQUFNO1FBQ3pCMVYsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUUyQjtJQUM5QztJQUNBLE1BQU1DLFdBQVd6VSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTZCLFlBQVksTUFBTTtRQUNsQjNWLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFNEI7SUFDdkM7SUFDQSxNQUFNQyxjQUFjMVUsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUk4QixlQUFlLE1BQU07UUFDckI1VixlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRTZCO0lBQzFDO0lBQ0EsTUFBTUMsYUFBYTNVLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJK0IsY0FBYyxNQUFNO1FBQ3BCN1YsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUU4QjtJQUN6QztJQUNBLE1BQU1DLFlBQVk1VSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSWdDLGFBQWEsTUFBTTtRQUNuQjlWLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFK0I7SUFDeEM7SUFDQSxNQUFNQyxlQUFlN1UsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlpQyxnQkFBZ0IsTUFBTTtRQUN0Qi9WLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFZ0M7SUFDM0M7SUFDQSxNQUFNQyxnQkFBZ0I5VSxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSWtDLGlCQUFpQixNQUFNO1FBQ3ZCaFcsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVpQztJQUM1QztJQUNBLE1BQU1DLG9CQUFvQi9VLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJbUMscUJBQXFCLE1BQU07UUFDM0JqVyxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVrQztJQUNoRDtJQUNBLE1BQU1DLGNBQWNoVixlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSW9DLGVBQWUsTUFBTTtRQUNyQmxXLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFbUM7SUFDMUM7SUFDQSxNQUFNQyxlQUFlalYsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlxQyxnQkFBZ0IsTUFBTTtRQUN0Qm5XLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFb0M7SUFDM0M7SUFDQSxNQUFNQyxnQkFBZ0JsVixlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSXNDLGlCQUFpQixNQUFNO1FBQ3ZCcFcsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVxQztJQUM1QztJQUNBLE1BQU1DLG9CQUFvQm5WLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJdUMscUJBQXFCLE1BQU07UUFDM0JyVyxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVzQztJQUNoRDtJQUNBLE1BQU1DLGNBQWNwVixlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSXdDLGVBQWUsTUFBTTtRQUNyQnRXLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFdUM7SUFDMUM7SUFDQSxNQUFNQyxlQUFlclYsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUl5QyxnQkFBZ0IsTUFBTTtRQUN0QnZXLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFd0M7SUFDM0M7SUFDQSxNQUFNQyxjQUFjdFYsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUkwQyxlQUFlLE1BQU07UUFDckJ4VyxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRXlDO0lBQzFDO0lBQ0EsTUFBTUMsaUJBQWlCdlYsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkyQyxrQkFBa0IsTUFBTTtRQUN4QnpXLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFMEM7SUFDN0M7SUFDQSxNQUFNQyx1QkFBdUJ4VixlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSTRDLHdCQUF3QixNQUFNO1FBQzlCMVcsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFMkM7SUFDbkQ7SUFDQSxNQUFNQyxlQUFlelYsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUk2QyxnQkFBZ0IsTUFBTTtRQUN0QjNXLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFNEM7SUFDM0M7SUFDQSxNQUFNQyxZQUFZMVYsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUk4QyxhQUFhLE1BQU07UUFDbkI1VyxlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRTZDO0lBQ3hDO0lBQ0EsTUFBTUMsV0FBVzNWLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJK0MsWUFBWSxNQUFNO1FBQ2xCN1csZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUU4QztJQUN2QztJQUNBLE9BQU85QztBQUNYO0FBQ0EsU0FBUytvQixxQkFBcUJocEIsVUFBVTtJQUNwQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSTdTLGVBQWU0UyxZQUFZO1FBQUM7S0FBUyxNQUFNN1YsV0FBVztRQUN0RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTWdYLGVBQWU3VixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWlELGdCQUFnQixNQUFNO1FBQ3RCL1csZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVnRDtJQUMzQztJQUNBLE1BQU1DLGdCQUFnQjlWLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJa0QsaUJBQWlCLE1BQU07UUFDdkJoWCxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRWlEO0lBQzVDO0lBQ0EsT0FBT2pEO0FBQ1g7QUFDQSxTQUFTZ3BCLDZCQUE2QmpwQixVQUFVO0lBQzVDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNbUQsZUFBZWhXLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJb0QsZ0JBQWdCLE1BQU07UUFDdEJsWCxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRW1EO0lBQzNDO0lBQ0EsTUFBTXhCLGtCQUFrQnhVLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJNEIsbUJBQW1CLE1BQU07UUFDekIxVixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRTJCO0lBQzlDO0lBQ0EsTUFBTXBFLFdBQVdwUSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXhDLFlBQVksTUFBTTtRQUNsQnRSLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFekM7SUFDdkM7SUFDQSxNQUFNNkYsaUJBQWlCalcsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlxRCxrQkFBa0IsTUFBTTtRQUN4Qm5YLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFb0Q7SUFDN0M7SUFDQSxNQUFNQywyQkFBMkJsVyxlQUFlNFMsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSXNELDRCQUE0QixNQUFNO1FBQ2xDcFgsZUFBZStULFVBQVU7WUFBQztTQUF1QixFQUFFcUQ7SUFDdkQ7SUFDQSxNQUFNQyxlQUFlblcsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUl1RCxnQkFBZ0IsTUFBTTtRQUN0QnJYLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFc0Q7SUFDM0M7SUFDQSxNQUFNQyx5QkFBeUJwVyxlQUFlNFMsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSXdELDBCQUEwQixNQUFNO1FBQ2hDdFgsZUFBZStULFVBQVU7WUFBQztTQUFxQixFQUFFdUQ7SUFDckQ7SUFDQSxPQUFPdkQ7QUFDWDtBQUNBLFNBQVNpcEIsa0JBQWtCbHBCLFVBQVU7SUFDakMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15RCxnQkFBZ0J0VyxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSTBELGlCQUFpQixNQUFNO1FBQ3ZCeFgsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUV5RDtJQUM1QztJQUNBLE1BQU1DLGNBQWN2VyxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSTJELGVBQWUsTUFBTTtRQUNyQnpYLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFMEQ7SUFDMUM7SUFDQSxPQUFPMUQ7QUFDWDtBQUNBLFNBQVNrcEIsc0JBQXNCbnBCLFVBQVU7SUFDckMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU00RCxzQkFBc0J6VyxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTZELHVCQUF1QixNQUFNO1FBQzdCM1gsZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFaXBCLGtCQUFrQnJsQjtJQUNwRTtJQUNBLElBQUl6VyxlQUFlNFMsWUFBWTtRQUFDO0tBQWlCLE1BQU03VixXQUFXO1FBQzlELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPZ1U7QUFDWDtBQUNBLFNBQVNtcEIsZ0NBQWdDcHBCLFVBQVU7SUFDL0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04RCxXQUFXM1csZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrRCxZQUFZLE1BQU07UUFDbEI3WCxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRThEO0lBQ3ZDO0lBQ0EsTUFBTUMsdUJBQXVCNVcsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlnRSx3QkFBd0IsTUFBTTtRQUM5QjlYLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRStEO0lBQ25EO0lBQ0EsT0FBTy9EO0FBQ1g7QUFDQSxTQUFTb3BCLCtCQUErQnJwQixVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNaUUsNkJBQTZCOVcsZUFBZTRTLFlBQVk7UUFDMUQ7S0FDSDtJQUNELElBQUlrRSw4QkFBOEIsTUFBTTtRQUNwQ2hZLGVBQWUrVCxVQUFVO1lBQUM7U0FBeUIsRUFBRW1wQixnQ0FBZ0NsbEI7SUFDekY7SUFDQSxPQUFPakU7QUFDWDtBQUNBLFNBQVNxcEI7SUFDTCxNQUFNcnBCLFdBQVcsQ0FBQztJQUNsQixPQUFPQTtBQUNYO0FBQ0EsU0FBU3NwQix5QkFBeUJ2cEIsVUFBVTtJQUN4QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9FLGtCQUFrQmpYLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJcUUsbUJBQW1CLE1BQU07UUFDekJuWSxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRW9FO0lBQzlDO0lBQ0EsT0FBT3BFO0FBQ1g7QUFDQSxTQUFTdXBCLGNBQWN4cEIsVUFBVTtJQUM3QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXNFLDJCQUEyQm5YLGVBQWU0UyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJdUUsNEJBQTRCLE1BQU07UUFDbEMsSUFBSWhELGtCQUFrQmdEO1FBQ3RCLElBQUk3WCxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3N2Qiw2QkFBNkJ0dkI7WUFDeEM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUF1QixFQUFFc0I7SUFDdkQ7SUFDQSxJQUFJblUsZUFBZTRTLFlBQVk7UUFBQztLQUFZLE1BQU03VixXQUFXO1FBQ3pELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNdVksbUJBQW1CcFgsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUl3RSxvQkFBb0IsTUFBTTtRQUMxQnRZLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFa3BCLHNCQUFzQjNrQjtJQUNyRTtJQUNBLE1BQU1DLDRCQUE0QnJYLGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJeUUsNkJBQTZCLE1BQU07UUFDbkN2WSxlQUFlK1QsVUFBVTtZQUFDO1NBQXdCLEVBQUVvcEIsK0JBQStCNWtCO0lBQ3ZGO0lBQ0EsSUFBSXJYLGVBQWU0UyxZQUFZO1FBQUM7S0FBc0IsTUFBTTdWLFdBQVc7UUFDbkUsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUltQixlQUFlNFMsWUFBWTtRQUFDO0tBQWEsTUFBTTdWLFdBQVc7UUFDMUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU15WSxpQkFBaUJ0WCxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSTBFLGtCQUFrQixNQUFNO1FBQ3hCeFksZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVxcEI7SUFDN0M7SUFDQSxNQUFNM2tCLGtCQUFrQnZYLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJMkUsbUJBQW1CLE1BQU07UUFDekJ6WSxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXNwQix5QkFBeUI1a0I7SUFDdkU7SUFDQSxNQUFNQyxvQkFBb0J4WCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSTRFLHFCQUFxQixNQUFNO1FBQzNCMVksZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFMkU7SUFDaEQ7SUFDQSxPQUFPM0U7QUFDWDtBQUNBLFNBQVN3cEIsNkJBQTZCenBCLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04RCxXQUFXM1csZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkrRCxZQUFZLE1BQU07UUFDbEI3WCxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRThEO0lBQ3ZDO0lBQ0EsTUFBTWUsMkJBQTJCMVgsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUk4RSw0QkFBNEIsTUFBTTtRQUNsQzVZLGVBQWUrVCxVQUFVO1lBQUM7U0FBdUIsRUFBRTZFO0lBQ3ZEO0lBQ0EsT0FBTzdFO0FBQ1g7QUFDQSxTQUFTeXBCLGNBQWMxcEIsVUFBVTtJQUM3QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTStFLGVBQWU1WCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWdGLGdCQUFnQixNQUFNO1FBQ3RCOVksZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUUrRTtJQUMzQztJQUNBLE1BQU1DLGdCQUFnQjdYLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJaUYsaUJBQWlCLE1BQU07UUFDdkIvWSxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRWdGO0lBQzVDO0lBQ0EsT0FBT2hGO0FBQ1g7QUFDQSxTQUFTMHBCLHVCQUF1QjNwQixVQUFVO0lBQ3RDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNa0YsYUFBYS9YLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJbUYsY0FBYyxNQUFNO1FBQ3BCalosZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUV5cEIsY0FBY3ZrQjtJQUN2RDtJQUNBLE1BQU1DLG1CQUFtQmhZLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJb0Ysb0JBQW9CLE1BQU07UUFDMUJsWixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRW1GO0lBQy9DO0lBQ0EsT0FBT25GO0FBQ1g7QUFDQSxTQUFTMnBCLGtCQUFrQjVwQixVQUFVO0lBQ2pDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNcUYsNEJBQTRCbFksZUFBZTRTLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUlzRiw2QkFBNkIsTUFBTTtRQUNuQ3BaLGVBQWUrVCxVQUFVO1lBQUM7U0FBd0IsRUFBRXdwQiw2QkFBNkJua0I7SUFDckY7SUFDQSxNQUFNQyxzQkFBc0JuWSxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSXVGLHVCQUF1QixNQUFNO1FBQzdCclosZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFMHBCLHVCQUF1QnBrQjtJQUN6RTtJQUNBLE9BQU90RjtBQUNYO0FBQ0EsU0FBUzRwQiw2QkFBNkI3cEIsVUFBVTtJQUM1QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXdGLGdCQUFnQnJZLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJeUYsaUJBQWlCLE1BQU07UUFDdkJ2WixlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRXdGO0lBQzVDO0lBQ0EsT0FBT3hGO0FBQ1g7QUFDQSxTQUFTNnBCLHFCQUFxQjlwQixVQUFVO0lBQ3BDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMEYsMEJBQTBCdlksZUFBZTRTLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUkyRiwyQkFBMkIsTUFBTTtRQUNqQ3paLGVBQWUrVCxVQUFVO1lBQUM7U0FBc0IsRUFBRTRwQiw2QkFBNkJsa0I7SUFDbkY7SUFDQSxPQUFPMUY7QUFDWDtBQUNBLFNBQVM4cEIsNEJBQTRCL3BCLFVBQVU7SUFDM0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU00RixjQUFjelksZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUk2RixlQUFlLE1BQU07UUFDckIzWixlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRTRGO0lBQzFDO0lBQ0EsTUFBTUMsa0JBQWtCMVksZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUk4RixtQkFBbUIsTUFBTTtRQUN6QjVaLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFNnBCLHFCQUFxQmhrQjtJQUNuRTtJQUNBLE9BQU83RjtBQUNYO0FBQ0EsU0FBUytwQixpQ0FBaUNocUIsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTStGLDBCQUEwQjVZLGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJZ0csMkJBQTJCLE1BQU07UUFDakMsSUFBSXpFLGtCQUFrQnlFO1FBQ3RCLElBQUl0WixNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT293Qiw0QkFBNEJwd0I7WUFDdkM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFc0I7SUFDdEQ7SUFDQSxPQUFPdEI7QUFDWDtBQUNBLFNBQVNncUIsc0JBQXNCanFCLFVBQVU7SUFDckMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02RixrQkFBa0IxWSxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSThGLG1CQUFtQixNQUFNO1FBQ3pCNVosZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUU2cEIscUJBQXFCaGtCO0lBQ25FO0lBQ0EsTUFBTUksOEJBQThCOVksZUFBZTRTLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUlrRywrQkFBK0IsTUFBTTtRQUNyQ2hhLGVBQWUrVCxVQUFVO1lBQUM7U0FBMEIsRUFBRStwQixpQ0FBaUM5akI7SUFDM0Y7SUFDQSxNQUFNZCxtQkFBbUJoWSxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSW9GLG9CQUFvQixNQUFNO1FBQzFCbFosZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVtRjtJQUMvQztJQUNBLE9BQU9uRjtBQUNYO0FBQ0EsU0FBU2lxQixzQkFBc0JscUIsVUFBVTtJQUNyQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW1HLHNCQUFzQmhaLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJb0csdUJBQXVCLE1BQU07UUFDN0JsYSxlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVtRztJQUNsRDtJQUNBLE1BQU1DLHFCQUFxQmpaLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJcUcsc0JBQXNCLE1BQU07UUFDNUJuYSxlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVvRztJQUNqRDtJQUNBLE9BQU9wRztBQUNYO0FBQ0EsU0FBU2txQiw2QkFBNkIzeEIsU0FBUyxFQUFFd0gsVUFBVSxFQUFFdUcsWUFBWTtJQUNyRSxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU11Ryx3QkFBd0JwWixlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFxYyx5QkFBeUIsTUFBTTtRQUM3RHRhLGVBQWVxYSxjQUFjO1lBQUM7U0FBb0IsRUFBRXVpQixpQkFBaUIvdUIsU0FBU3lNO0lBQ2xGO0lBQ0EsTUFBTUMsa0JBQWtCclosZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUl5RyxtQkFBbUIsTUFBTTtRQUN6QnZhLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFd0c7SUFDOUM7SUFDQSxNQUFNQyxXQUFXdFosZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkwRyxZQUFZLE1BQU07UUFDbEJ4YSxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXlHO0lBQ3ZDO0lBQ0EsTUFBTUMsV0FBV3ZaLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJMkcsWUFBWSxNQUFNO1FBQ2xCemEsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUUwRztJQUN2QztJQUNBLE1BQU1DLHFCQUFxQnhaLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJNEcsc0JBQXNCLE1BQU07UUFDNUIxYSxlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUUyRztJQUNqRDtJQUNBLE1BQU1DLHNCQUFzQnpaLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJNkcsdUJBQXVCLE1BQU07UUFDN0IzYSxlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUU0RztJQUNsRDtJQUNBLE1BQU1DLG9CQUFvQjFaLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJOEcscUJBQXFCLE1BQU07UUFDM0I1YSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUU2RztJQUNoRDtJQUNBLE1BQU1DLHVCQUF1QjNaLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJK0csd0JBQXdCLE1BQU07UUFDOUI3YSxlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUU4RztJQUNuRDtJQUNBLE1BQU1DLGVBQWU1WixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWdILGdCQUFnQixNQUFNO1FBQ3RCOWEsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUUrRztJQUMzQztJQUNBLE1BQU1DLHNCQUFzQjdaLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJaUgsdUJBQXVCLE1BQU07UUFDN0IvYSxlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVnSDtJQUNsRDtJQUNBLE1BQU1DLHVCQUF1QjlaLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJa0gsd0JBQXdCLE1BQU07UUFDOUJoYixlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVpSDtJQUNuRDtJQUNBLE1BQU1DLFdBQVcvWixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSW1ILFlBQVksTUFBTTtRQUNsQmpiLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFa0g7SUFDdkM7SUFDQSxNQUFNQyx1QkFBdUJoYSxlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSW9ILHdCQUF3QixNQUFNO1FBQzlCbGIsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFbUg7SUFDbkQ7SUFDQSxNQUFNQyxxQkFBcUJqYSxlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXFILHNCQUFzQixNQUFNO1FBQzVCbmIsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFOG9CLGNBQWN0dEIsUUFBUTRMO0lBQ3ZFO0lBQ0EsTUFBTTdELHlCQUF5QnBXLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJd0QsMEJBQTBCLE1BQU07UUFDaEN0WCxlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUV1RDtJQUNyRDtJQUNBLElBQUlwVyxlQUFlNFMsWUFBWTtRQUFDO0tBQWdCLE1BQU03VixXQUFXO1FBQzdELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJbUIsZUFBZTRTLFlBQVk7UUFBQztLQUF1QixNQUFNN1YsV0FBVztRQUNwRSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXFiLHFCQUFxQmxhLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYW1kLHNCQUFzQixNQUFNO1FBQzFELElBQUkvRixrQkFBa0IrRjtRQUN0QixJQUFJNWEsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU9xdkIscUJBQXFCcnZCO1lBQ2hDO1FBQ0o7UUFDQXpOLGVBQWVxYSxjQUFjO1lBQUM7U0FBaUIsRUFBRWhGO0lBQ3JEO0lBQ0EsTUFBTWdHLFlBQVluYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXVHLGlCQUFpQnBjLGFBQWFvZCxhQUFhLE1BQU07UUFDakQsSUFBSWhHLGtCQUFrQi9FLE9BQU8rSztRQUM3QixJQUFJN2EsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU82dkIsY0FBY3Z0QixNQUFNdEM7WUFDL0I7UUFDSjtRQUNBek4sZUFBZXFhLGNBQWM7WUFBQztTQUFRLEVBQUVoRjtJQUM1QztJQUNBLE1BQU1pRyxpQkFBaUJwYSxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXVHLGlCQUFpQnBjLGFBQWFxZCxrQkFBa0IsTUFBTTtRQUN0RHRiLGVBQWVxYSxjQUFjO1lBQUM7U0FBYSxFQUFFcWpCLGtCQUFrQnBpQjtJQUNuRTtJQUNBLElBQUlwYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVMsTUFBTTdWLFdBQVc7UUFDdEQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU13YixvQkFBb0JyYSxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFzZCxxQkFBcUIsTUFBTTtRQUN6RHZiLGVBQWVxYSxjQUFjO1lBQUM7U0FBZ0IsRUFBRXhKLG1CQUFtQnZFLFdBQVdpUDtJQUNsRjtJQUNBLE1BQU1DLHlCQUF5QnRhLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJMEgsMEJBQTBCLE1BQU07UUFDaEN4YixlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUV5SDtJQUNyRDtJQUNBLE1BQU1DLHNCQUFzQnZhLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJMkgsdUJBQXVCLE1BQU07UUFDN0J6YixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUUwSDtJQUNsRDtJQUNBLE1BQU1DLG1CQUFtQnhhLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJNEgsb0JBQW9CLE1BQU07UUFDMUIxYixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRWdxQixzQkFBc0J0dUIsY0FBY2lNO0lBQ25GO0lBQ0EsSUFBSXhhLGVBQWU0UyxZQUFZO1FBQUM7S0FBaUIsTUFBTTdWLFdBQVc7UUFDOUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU00YixxQkFBcUJ6YSxlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSTZILHNCQUFzQixNQUFNO1FBQzVCM2IsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFaXFCLHNCQUFzQnJpQjtJQUN2RTtJQUNBLE9BQU81SDtBQUNYO0FBQ0EsU0FBU21xQixpQ0FBaUM1eEIsU0FBUyxFQUFFd0gsVUFBVTtJQUMzRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFRLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDbEU7SUFDQSxNQUFNQyxlQUFlNWEsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlnSSxnQkFBZ0IsTUFBTTtRQUN0QixJQUFJekcsa0JBQWtCckgsVUFBVThOO1FBQ2hDLElBQUl0YixNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT212QixpQkFBaUJudkI7WUFDNUI7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVzQjtJQUMzQztJQUNBLE1BQU0wRyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVrcUIsNkJBQTZCM3hCLFdBQVd5UCxZQUFZaEk7SUFDdkc7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU29xQiwwQkFBMEJycUIsVUFBVSxFQUFFdUcsWUFBWTtJQUN2RCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU1xcUIsZUFBZWw5QixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXVHLGlCQUFpQnBjLGFBQWFtZ0MsZ0JBQWdCLE1BQU07UUFDcERwK0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQVcsRUFBRStqQjtJQUM3RDtJQUNBLE1BQU14bkIsWUFBWTFWLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJdUcsaUJBQWlCcGMsYUFBYTJZLGFBQWEsTUFBTTtRQUNqRDVXLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFRLEVBQUV6RDtJQUMxRDtJQUNBLE1BQU15bkIsMkJBQTJCbjlCLGVBQWU0UyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYW9nQyw0QkFBNEIsTUFBTTtRQUNoRXIrQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBdUIsRUFBRWdrQjtJQUN6RTtJQUNBLElBQUluOUIsZUFBZTRTLFlBQVk7UUFBQztLQUFXLE1BQU03VixXQUFXO1FBQ3hELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJbUIsZUFBZTRTLFlBQVk7UUFBQztLQUFlLE1BQU03VixXQUFXO1FBQzVELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPZ1U7QUFDWDtBQUNBLFNBQVN1cUIsOEJBQThCaHlCLFNBQVMsRUFBRXdILFVBQVU7SUFDeEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04SCxZQUFZM2EsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrSCxhQUFhLE1BQU07UUFDbkI3YixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFMUgsT0FBT0MsV0FBV3VQO0lBQ2xFO0lBQ0EsTUFBTUMsZUFBZTVhLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJZ0ksZ0JBQWdCLE1BQU07UUFDdEI5YixlQUFlK1QsVUFBVTtZQUFDO1lBQWM7U0FBVSxFQUFFakcsa0JBQWtCeEIsV0FBV3dQO0lBQ3JGO0lBQ0EsTUFBTUMsYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVvcUIsMEJBQTBCcGlCLFlBQVloSTtJQUMvRTtJQUNBLE1BQU13cUIsMkJBQTJCcjlCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUNyRSxJQUFJeXFCLDZCQUE2QnRnQyxXQUFXO1FBQ3hDK0IsZUFBZStULFVBQVU7WUFBQztZQUFjO1NBQVEsRUFBRTFILE9BQU9DLFdBQVdpeUI7SUFDeEU7SUFDQSxPQUFPeHFCO0FBQ1g7QUFDQSxTQUFTeXFCLDRCQUE0QjFxQixVQUFVLEVBQUV1RyxZQUFZO0lBQ3pELE1BQU10RyxXQUFXLENBQUM7SUFDbEIsSUFBSTdTLGVBQWU0UyxZQUFZO1FBQUM7S0FBZSxNQUFNN1YsV0FBVztRQUM1RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBaUIsTUFBTTdWLFdBQVc7UUFDOUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU0wK0IscUJBQXFCdjlCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXdnQyxzQkFBc0IsTUFBTTtRQUMxRHorQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBYyxFQUFFb2tCO0lBQ2hFO0lBQ0EsTUFBTUMsa0JBQWtCeDlCLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJdUcsaUJBQWlCcGMsYUFBYXlnQyxtQkFBbUIsTUFBTTtRQUN2RDErQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBYyxFQUFFcWtCO0lBQ2hFO0lBQ0EsTUFBTUMsb0JBQW9CejlCLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTBnQyxxQkFBcUIsTUFBTTtRQUN6RDMrQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBZ0IsRUFBRXNrQjtJQUNsRTtJQUNBLElBQUl6OUIsZUFBZTRTLFlBQVk7UUFBQztLQUFPLE1BQU03VixXQUFXO1FBQ3BELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNNitCLHdCQUF3QjE5QixlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWEyZ0MseUJBQXlCLE1BQU07UUFDN0Q1K0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWdCLEVBQUV1a0I7SUFDbEU7SUFDQSxNQUFNQyx1QkFBdUIzOUIsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhNGdDLHdCQUF3QixNQUFNO1FBQzVENytCLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFtQixFQUFFd2tCO0lBQ3JFO0lBQ0EsTUFBTUMsOEJBQThCNTlCLGVBQWU0UyxZQUFZO1FBQzNEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTZnQywrQkFBK0IsTUFBTTtRQUNuRTkrQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBMEIsRUFBRXlrQjtJQUM1RTtJQUNBLE1BQU1DLHVCQUF1Qjc5QixlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWE4Z0Msd0JBQXdCLE1BQU07UUFDNUQvK0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQW1CLEVBQUUwa0I7SUFDckU7SUFDQSxNQUFNQyxlQUFlOTlCLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJdUcsaUJBQWlCcGMsYUFBYStnQyxnQkFBZ0IsTUFBTTtRQUNwRGgvQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBVyxFQUFFMmtCO0lBQzdEO0lBQ0EsTUFBTUMscUJBQXFCLzlCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWdoQyxzQkFBc0IsTUFBTTtRQUMxRGovQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7WUFBaUI7U0FBVyxFQUFFNGtCO0lBQzlFO0lBQ0EsTUFBTUMsK0JBQStCaCtCLGVBQWU0UyxZQUFZO1FBQzVEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWloQyxnQ0FBZ0MsTUFBTTtRQUNwRWwvQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7WUFBaUI7U0FBcUIsRUFBRTZrQjtJQUN4RjtJQUNBLElBQUloK0IsZUFBZTRTLFlBQVk7UUFBQztLQUFlLE1BQU03VixXQUFXO1FBQzVELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNby9CLGdCQUFnQmorQixlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSXVHLGlCQUFpQnBjLGFBQWFraEMsaUJBQWlCLE1BQU07UUFDckRuL0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWtCLEVBQUU4a0I7SUFDcEU7SUFDQSxJQUFJaitCLGVBQWU0UyxZQUFZO1FBQUM7S0FBZ0IsTUFBTTdWLFdBQVc7UUFDN0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU9nVTtBQUNYO0FBQ0EsU0FBU3FyQixnQ0FBZ0M5eUIsU0FBUyxFQUFFd0gsVUFBVTtJQUMxRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFRLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDbEU7SUFDQSxNQUFNd2pCLGFBQWFuK0IsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUl1ckIsY0FBYyxNQUFNO1FBQ3BCci9CLGVBQWUrVCxVQUFVO1lBQUM7WUFBZ0I7U0FBUyxFQUFFc3JCO0lBQ3pEO0lBQ0EsTUFBTXRqQixhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRXlxQiw0QkFBNEJ6aUIsWUFBWWhJO0lBQ2pGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVN1ckIsMEJBQTBCaHpCLFNBQVMsRUFBRXdILFVBQVU7SUFDcEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04SCxZQUFZM2EsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrSCxhQUFhLE1BQU07UUFDbkI3YixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFMUgsT0FBT0MsV0FBV3VQO0lBQ2pFO0lBQ0EsTUFBTUUsYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVnSTtJQUN6QztJQUNBLE9BQU9oSTtBQUNYO0FBQ0EsU0FBU3dyQix3QkFBd0JqekIsU0FBUyxFQUFFd0gsVUFBVSxFQUFFdUcsWUFBWTtJQUNoRSxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU0ySSxlQUFleGIsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUl1RyxpQkFBaUJwYyxhQUFheWUsZ0JBQWdCLE1BQU07UUFDcEQxYyxlQUFlcWEsY0FBYztZQUFDO1lBQVU7U0FBVyxFQUFFcUM7SUFDekQ7SUFDQSxNQUFNQyxnQkFBZ0J6YixlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSXVHLGlCQUFpQnBjLGFBQWEwZSxpQkFBaUIsTUFBTTtRQUNyRDNjLGVBQWVxYSxjQUFjO1lBQUM7WUFBVTtTQUFZLEVBQUVzQztJQUMxRDtJQUNBLE1BQU1hLGFBQWF0YyxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSXVHLGlCQUFpQnBjLGFBQWF1ZixjQUFjLE1BQU07UUFDbER4ZCxlQUFlcWEsY0FBYztZQUFDO1lBQVU7U0FBUyxFQUFFbUQ7SUFDdkQ7SUFDQSxNQUFNZ2lCLGdCQUFnQnQrQixlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSXVHLGlCQUFpQnBjLGFBQWF1aEMsaUJBQWlCLE1BQU07UUFDckR4L0IsZUFBZXFhLGNBQWM7WUFBQztZQUFRO1NBQWEsRUFBRTdJLFdBQVdsRixXQUFXa3pCO0lBQy9FO0lBQ0EsT0FBT3pyQjtBQUNYO0FBQ0EsU0FBUzByQiw0QkFBNEJuekIsU0FBUyxFQUFFd0gsVUFBVTtJQUN0RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWdJLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFd3JCLHdCQUF3Qmp6QixXQUFXeVAsWUFBWWhJO0lBQ3hGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVMyckIseUJBQXlCNXJCLFVBQVUsRUFBRXVHLFlBQVk7SUFDdEQsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNcUksa0JBQWtCbGIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUl1RyxpQkFBaUJwYyxhQUFhbWUsbUJBQW1CLE1BQU07UUFDdkRwYyxlQUFlcWEsY0FBYztZQUFDO1NBQWMsRUFBRStCO0lBQ2xEO0lBQ0EsTUFBTTFHLGtCQUFrQnhVLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJdUcsaUJBQWlCcGMsYUFBYXlYLG1CQUFtQixNQUFNO1FBQ3ZEMVYsZUFBZXFhLGNBQWM7WUFBQztTQUFjLEVBQUUzRTtJQUNsRDtJQUNBLE1BQU1pcUIsMEJBQTBCeitCLGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTBoQywyQkFBMkIsTUFBTTtRQUMvRDMvQixlQUFlcWEsY0FBYztZQUFDO1NBQXNCLEVBQUVzbEI7SUFDMUQ7SUFDQSxPQUFPNXJCO0FBQ1g7QUFDQSxTQUFTNnJCLDZCQUE2QnR6QixTQUFTLEVBQUV3SCxVQUFVO0lBQ3ZELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEgsWUFBWTNhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK0gsYUFBYSxNQUFNO1FBQ25CN2IsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRTFILE9BQU9DLFdBQVd1UDtJQUNqRTtJQUNBLE1BQU1FLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFMnJCLHlCQUF5QjNqQixZQUFZaEk7SUFDOUU7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBUzhyQiw2QkFBNkJ2ekIsU0FBUyxFQUFFd0gsVUFBVTtJQUN2RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFPLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDakU7SUFDQSxNQUFNRSxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWdJO0lBQ3pDO0lBQ0EsT0FBT2hJO0FBQ1g7QUFDQSxTQUFTK3JCLHlCQUF5QmhzQixVQUFVO0lBQ3hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJN1MsZUFBZTRTLFlBQVk7UUFBQztLQUFvQixNQUFNN1YsV0FBVztRQUNqRSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBUSxNQUFNN1YsV0FBVztRQUNyRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBbUIsTUFBTTdWLFdBQVc7UUFDaEUsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU9nVTtBQUNYO0FBQ0EsU0FBU2dzQiw2QkFBNkJ6ekIsU0FBUyxFQUFFd0gsVUFBVTtJQUN2RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFRLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDbEU7SUFDQSxNQUFNQyxlQUFlNWEsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlnSSxnQkFBZ0IsTUFBTTtRQUN0QixJQUFJekcsa0JBQWtCckgsVUFBVThOO1FBQ2hDLElBQUl0YixNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT212QixpQkFBaUJudkI7WUFDNUI7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVzQjtJQUMzQztJQUNBLE1BQU0wRyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRStyQix5QkFBeUIvakI7SUFDbEU7SUFDQSxPQUFPaEk7QUFDWDtBQUNBLFNBQVNpc0IsYUFBYWxzQixVQUFVO0lBQzVCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJN1MsZUFBZTRTLFlBQVk7UUFBQztLQUFTLE1BQU03VixXQUFXO1FBQ3RELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNa1IsaUJBQWlCL1AsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUk3QyxrQkFBa0IsTUFBTTtRQUN4QmpSLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRS9DLE9BQU9DO0lBQzVEO0lBQ0EsTUFBTW9ELGVBQWVuVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU8sZ0JBQWdCLE1BQU07UUFDdEJyVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRU07SUFDM0M7SUFDQSxPQUFPTjtBQUNYO0FBQ0EsU0FBU2tzQiw0QkFBNEJuc0IsVUFBVSxFQUFFdUcsWUFBWTtJQUN6RCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU1tc0IscUJBQXFCaC9CLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWlpQyxzQkFBc0IsTUFBTTtRQUMxRGxnQyxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBYyxFQUFFNmxCO0lBQ2hFO0lBQ0EsSUFBSWgvQixlQUFlNFMsWUFBWTtRQUFDO0tBQWUsTUFBTTdWLFdBQVc7UUFDNUQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUltQixlQUFlNFMsWUFBWTtRQUFDO0tBQU0sTUFBTTdWLFdBQVc7UUFDbkQsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE1BQU1vZ0Msc0JBQXNCai9CLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWtpQyx1QkFBdUIsTUFBTTtRQUMzRG5nQyxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBa0IsRUFBRThsQjtJQUNwRTtJQUNBLElBQUlqL0IsZUFBZTRTLFlBQVk7UUFBQztLQUFPLE1BQU03VixXQUFXO1FBQ3BELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNMitCLGtCQUFrQng5QixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXVHLGlCQUFpQnBjLGFBQWF5Z0MsbUJBQW1CLE1BQU07UUFDdkQxK0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWMsRUFBRXFrQjtJQUNoRTtJQUNBLElBQUl4OUIsZUFBZTRTLFlBQVk7UUFBQztLQUFhLE1BQU03VixXQUFXO1FBQzFELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNOCtCLHVCQUF1QjM5QixlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWE0Z0Msd0JBQXdCLE1BQU07UUFDNUQ3K0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQW1CLEVBQUV3a0I7SUFDckU7SUFDQSxJQUFJMzlCLGVBQWU0UyxZQUFZO1FBQUM7S0FBYyxNQUFNN1YsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXFnQyxxQkFBcUJsL0IsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhbWlDLHNCQUFzQixNQUFNO1FBQzFEcGdDLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFpQixFQUFFK2xCO0lBQ25FO0lBQ0EsTUFBTUMsb0JBQW9Cbi9CLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYW9pQyxxQkFBcUIsTUFBTTtRQUN6RHJnQyxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBZ0IsRUFBRWdtQjtJQUNsRTtJQUNBLElBQUluL0IsZUFBZTRTLFlBQVk7UUFBQztLQUFnQixNQUFNN1YsV0FBVztRQUM3RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBWSxNQUFNN1YsV0FBVztRQUN6RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsSUFBSW1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBa0IsTUFBTTdWLFdBQVc7UUFDL0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUltQixlQUFlNFMsWUFBWTtRQUFDO0tBQXFCLE1BQU03VixXQUFXO1FBQ2xFLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPZ1U7QUFDWDtBQUNBLFNBQVN1c0IsZ0NBQWdDaDBCLFNBQVMsRUFBRXdILFVBQVU7SUFDMUQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04SCxZQUFZM2EsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrSCxhQUFhLE1BQU07UUFDbkI3YixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFMUgsT0FBT0MsV0FBV3VQO0lBQ2xFO0lBQ0EsTUFBTXdqQixhQUFhbitCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJdXJCLGNBQWMsTUFBTTtRQUNwQnIvQixlQUFlK1QsVUFBVTtZQUFDO1lBQWdCO1NBQVMsRUFBRXNyQjtJQUN6RDtJQUNBLE1BQU1rQixZQUFZci9CLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJeXNCLGFBQWEsTUFBTTtRQUNuQnZnQyxlQUFlK1QsVUFBVTtZQUFDO1lBQWdCO1NBQVEsRUFBRWlzQixhQUFhTztJQUNyRTtJQUNBLElBQUlyL0IsZUFBZTRTLFlBQVk7UUFBQztLQUFRLE1BQU03VixXQUFXO1FBQ3JELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNZ2MsYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVrc0IsNEJBQTRCbGtCLFlBQVloSTtJQUNqRjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTeXNCLHNCQUFzQjFzQixVQUFVO0lBQ3JDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNQyxVQUFVOVMsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUlFLFdBQVcsTUFBTTtRQUNqQmhVLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFQztJQUN0QztJQUNBLE1BQU1DLGdCQUFnQi9TLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJRyxpQkFBaUIsTUFBTTtRQUN2QmpVLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFRTtJQUM1QztJQUNBLE1BQU1DLGtCQUFrQmhULGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJSSxtQkFBbUIsTUFBTTtRQUN6QmxVLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFRztJQUM5QztJQUNBLE9BQU9IO0FBQ1g7QUFDQSxTQUFTMHNCLGFBQWEzc0IsVUFBVTtJQUM1QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFJLGtCQUFrQmxiLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJc0ksbUJBQW1CLE1BQU07UUFDekJwYyxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXFJO0lBQzlDO0lBQ0EsTUFBTWhJLFdBQVdsVCxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSU0sWUFBWSxNQUFNO1FBQ2xCcFUsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVLO0lBQ3ZDO0lBQ0EsTUFBTUMsZUFBZW5ULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJTyxnQkFBZ0IsTUFBTTtRQUN0QnJVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFTTtJQUMzQztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTMnNCLGlCQUFpQjVzQixVQUFVO0lBQ2hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNcUksa0JBQWtCbGIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlzSSxtQkFBbUIsTUFBTTtRQUN6QnBjLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFcUk7SUFDOUM7SUFDQSxNQUFNN0gsY0FBY3JULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJUyxlQUFlLE1BQU07UUFDckJ2VSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVE7SUFDMUM7SUFDQSxNQUFNRixlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVM0c0IsYUFBYTdzQixVQUFVO0lBQzVCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNVSxvQkFBb0J2VCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSVcscUJBQXFCLE1BQU07UUFDM0J6VSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUV5c0Isc0JBQXNCL3JCO0lBQ3RFO0lBQ0EsTUFBTUMsY0FBY3hULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJWSxlQUFlLE1BQU07UUFDckIxVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVc7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUJ6VCxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWEsa0JBQWtCLE1BQU07UUFDeEIzVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRTBzQixhQUFhOXJCO0lBQzFEO0lBQ0EsTUFBTUMsZUFBZTFULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJYyxnQkFBZ0IsTUFBTTtRQUN0QjVVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFMnNCLGlCQUFpQjlyQjtJQUM1RDtJQUNBLE1BQU1DLHVCQUF1QjNULGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJZSx3QkFBd0IsTUFBTTtRQUM5QjdVLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWM7SUFDbkQ7SUFDQSxNQUFNQywwQkFBMEI1VCxlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSWdCLDJCQUEyQixNQUFNO1FBQ2pDOVUsZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFZTtJQUN0RDtJQUNBLE1BQU1DLHFCQUFxQjdULGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJaUIsc0JBQXNCLE1BQU07UUFDNUIvVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVnQjtJQUNqRDtJQUNBLE1BQU1DLG1CQUFtQjlULGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJa0Isb0JBQW9CLE1BQU07UUFDMUJoVixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRWlCO0lBQy9DO0lBQ0EsTUFBTUMsdUJBQXVCL1QsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUltQix3QkFBd0IsTUFBTTtRQUM5QmpWLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWtCO0lBQ25EO0lBQ0EsTUFBTUMsV0FBV2hVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJb0IsWUFBWSxNQUFNO1FBQ2xCbFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVtQjtJQUN2QztJQUNBLE9BQU9uQjtBQUNYO0FBQ0EsU0FBUzZzQixnQkFBZ0I5c0IsVUFBVTtJQUMvQixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFCLFlBQVlsVSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXNCLGFBQWEsTUFBTTtRQUNuQixJQUFJQyxrQkFBa0JEO1FBQ3RCLElBQUk1VSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT2t6QixhQUFhbHpCO1lBQ3hCO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFc0I7SUFDeEM7SUFDQSxNQUFNQyxXQUFXcFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl3QixZQUFZLE1BQU07UUFDbEJ0VixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXVCO0lBQ3ZDO0lBQ0EsT0FBT3ZCO0FBQ1g7QUFDQSxTQUFTOHNCLGVBQWUvc0IsVUFBVTtJQUM5QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlCLFlBQVl0VSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSTBCLGFBQWEsTUFBTTtRQUNuQnhWLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFeUI7SUFDeEM7SUFDQSxNQUFNQyxjQUFjdlUsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUkyQixlQUFlLE1BQU07UUFDckJ6VixlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRTBCO0lBQzFDO0lBQ0EsTUFBTUMsa0JBQWtCeFUsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUk0QixtQkFBbUIsTUFBTTtRQUN6QjFWLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFMkI7SUFDOUM7SUFDQSxNQUFNQyxXQUFXelUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUk2QixZQUFZLE1BQU07UUFDbEIzVixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRTRCO0lBQ3ZDO0lBQ0EsTUFBTUMsY0FBYzFVLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJOEIsZUFBZSxNQUFNO1FBQ3JCNVYsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUU2QjtJQUMxQztJQUNBLE1BQU1DLGFBQWEzVSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSStCLGNBQWMsTUFBTTtRQUNwQjdWLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFOEI7SUFDekM7SUFDQSxNQUFNQyxZQUFZNVUsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlnQyxhQUFhLE1BQU07UUFDbkI5VixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRStCO0lBQ3hDO0lBQ0EsTUFBTUMsZUFBZTdVLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJaUMsZ0JBQWdCLE1BQU07UUFDdEIvVixlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRWdDO0lBQzNDO0lBQ0EsTUFBTUMsZ0JBQWdCOVUsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlrQyxpQkFBaUIsTUFBTTtRQUN2QmhXLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFaUM7SUFDNUM7SUFDQSxNQUFNQyxvQkFBb0IvVSxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSW1DLHFCQUFxQixNQUFNO1FBQzNCalcsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFa0M7SUFDaEQ7SUFDQSxNQUFNQyxjQUFjaFYsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUlvQyxlQUFlLE1BQU07UUFDckJsVyxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRW1DO0lBQzFDO0lBQ0EsTUFBTUMsZUFBZWpWLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJcUMsZ0JBQWdCLE1BQU07UUFDdEJuVyxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRW9DO0lBQzNDO0lBQ0EsTUFBTUMsZ0JBQWdCbFYsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlzQyxpQkFBaUIsTUFBTTtRQUN2QnBXLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFcUM7SUFDNUM7SUFDQSxNQUFNQyxvQkFBb0JuVixlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXVDLHFCQUFxQixNQUFNO1FBQzNCclcsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFc0M7SUFDaEQ7SUFDQSxNQUFNQyxjQUFjcFYsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUl3QyxlQUFlLE1BQU07UUFDckJ0VyxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRXVDO0lBQzFDO0lBQ0EsTUFBTUMsZUFBZXJWLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJeUMsZ0JBQWdCLE1BQU07UUFDdEJ2VyxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRXdDO0lBQzNDO0lBQ0EsTUFBTUMsY0FBY3RWLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJMEMsZUFBZSxNQUFNO1FBQ3JCeFcsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUV5QztJQUMxQztJQUNBLE1BQU1DLGlCQUFpQnZWLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJMkMsa0JBQWtCLE1BQU07UUFDeEJ6VyxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRTBDO0lBQzdDO0lBQ0EsTUFBTUMsdUJBQXVCeFYsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUk0Qyx3QkFBd0IsTUFBTTtRQUM5QjFXLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRTJDO0lBQ25EO0lBQ0EsTUFBTUMsZUFBZXpWLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJNkMsZ0JBQWdCLE1BQU07UUFDdEIzVyxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRTRDO0lBQzNDO0lBQ0EsTUFBTUMsWUFBWTFWLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJOEMsYUFBYSxNQUFNO1FBQ25CNVcsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUU2QztJQUN4QztJQUNBLE1BQU1DLFdBQVczVixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSStDLFlBQVksTUFBTTtRQUNsQjdXLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFOEM7SUFDdkM7SUFDQSxPQUFPOUM7QUFDWDtBQUNBLFNBQVMrc0IsNkJBQTZCaHRCLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1ndEIsaUNBQWlDNy9CLGVBQWU0UyxZQUFZO1FBQzlEO0tBQ0g7SUFDRCxJQUFJaXRCLGtDQUFrQyxNQUFNO1FBQ3hDL2dDLGVBQWUrVCxVQUFVO1lBQUM7U0FBNkIsRUFBRWd0QjtJQUM3RDtJQUNBLE9BQU9odEI7QUFDWDtBQUNBLFNBQVNpdEIsc0JBQXNCbHRCLFVBQVU7SUFDckMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1rdEIsYUFBYS8vQixlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSW10QixjQUFjLE1BQU07UUFDcEJqaEMsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVrdEI7SUFDekM7SUFDQSxNQUFNbHFCLGVBQWU3VixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWlELGdCQUFnQixNQUFNO1FBQ3RCL1csZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVnRDtJQUMzQztJQUNBLE1BQU1DLGdCQUFnQjlWLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJa0QsaUJBQWlCLE1BQU07UUFDdkJoWCxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRWlEO0lBQzVDO0lBQ0EsT0FBT2pEO0FBQ1g7QUFDQSxTQUFTbXRCLDRCQUE0QnB0QixVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJN1MsZUFBZTRTLFlBQVk7UUFBQztLQUFXLE1BQU03VixXQUFXO1FBQ3hELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNMlYsa0JBQWtCeFUsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUk0QixtQkFBbUIsTUFBTTtRQUN6QjFWLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFMkI7SUFDOUM7SUFDQSxNQUFNcEUsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV6QztJQUN2QztJQUNBLE1BQU02RixpQkFBaUJqVyxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXFELGtCQUFrQixNQUFNO1FBQ3hCblgsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVvRDtJQUM3QztJQUNBLE1BQU1DLDJCQUEyQmxXLGVBQWU0UyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJc0QsNEJBQTRCLE1BQU07UUFDbENwWCxlQUFlK1QsVUFBVTtZQUFDO1NBQXVCLEVBQUVxRDtJQUN2RDtJQUNBLE1BQU1DLGVBQWVuVyxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXVELGdCQUFnQixNQUFNO1FBQ3RCclgsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVzRDtJQUMzQztJQUNBLE1BQU1DLHlCQUF5QnBXLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJd0QsMEJBQTBCLE1BQU07UUFDaEN0WCxlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUV1RDtJQUNyRDtJQUNBLE9BQU92RDtBQUNYO0FBQ0EsU0FBU290QixpQkFBaUJydEIsVUFBVTtJQUNoQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlELGdCQUFnQnRXLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJMEQsaUJBQWlCLE1BQU07UUFDdkJ4WCxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRXlEO0lBQzVDO0lBQ0EsTUFBTUMsY0FBY3ZXLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJMkQsZUFBZSxNQUFNO1FBQ3JCelgsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUUwRDtJQUMxQztJQUNBLE9BQU8xRDtBQUNYO0FBQ0EsU0FBU3F0QixxQkFBcUJ0dEIsVUFBVTtJQUNwQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTRELHNCQUFzQnpXLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJNkQsdUJBQXVCLE1BQU07UUFDN0IzWCxlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVvdEIsaUJBQWlCeHBCO0lBQ25FO0lBQ0EsTUFBTXNQLHFCQUFxQi9sQixlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSW1ULHNCQUFzQixNQUFNO1FBQzVCam5CLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRWtUO0lBQ2pEO0lBQ0EsT0FBT2xUO0FBQ1g7QUFDQSxTQUFTc3RCLCtCQUErQnZ0QixVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEQsV0FBVzNXLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJK0QsWUFBWSxNQUFNO1FBQ2xCN1gsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUU4RDtJQUN2QztJQUNBLE1BQU1DLHVCQUF1QjVXLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJZ0Usd0JBQXdCLE1BQU07UUFDOUI5WCxlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUUrRDtJQUNuRDtJQUNBLE9BQU8vRDtBQUNYO0FBQ0EsU0FBU3V0Qiw4QkFBOEJ4dEIsVUFBVTtJQUM3QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWlFLDZCQUE2QjlXLGVBQWU0UyxZQUFZO1FBQzFEO0tBQ0g7SUFDRCxJQUFJa0UsOEJBQThCLE1BQU07UUFDcENoWSxlQUFlK1QsVUFBVTtZQUFDO1NBQXlCLEVBQUVzdEIsK0JBQStCcnBCO0lBQ3hGO0lBQ0EsT0FBT2pFO0FBQ1g7QUFDQSxTQUFTd3RCLDRCQUE0Qnp0QixVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNa1QscUJBQXFCL2xCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJbVQsc0JBQXNCLE1BQU07UUFDNUJqbkIsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFa1Q7SUFDakQ7SUFDQSxPQUFPbFQ7QUFDWDtBQUNBLFNBQVN5dEIscUJBQXFCMXRCLFVBQVU7SUFDcEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU11VCxtQkFBbUJwbUIsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUl3VCxvQkFBb0IsTUFBTTtRQUMxQnRuQixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRXVUO0lBQy9DO0lBQ0EsT0FBT3ZUO0FBQ1g7QUFDQSxTQUFTMHRCLG1CQUFtQjN0QixVQUFVO0lBQ2xDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeVQsbUJBQW1CdG1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJMFQsb0JBQW9CLE1BQU07UUFDMUJ4bkIsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUV5dEIscUJBQXFCaGE7SUFDcEU7SUFDQSxNQUFNQyxlQUFldm1CLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJMlQsZ0JBQWdCLE1BQU07UUFDdEJ6bkIsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUUwVDtJQUMzQztJQUNBLE1BQU1DLGlDQUFpQ3htQixlQUFlNFMsWUFBWTtRQUM5RDtLQUNIO0lBQ0QsSUFBSTRULGtDQUFrQyxNQUFNO1FBQ3hDMW5CLGVBQWUrVCxVQUFVO1lBQUM7U0FBNkIsRUFBRTJUO0lBQzdEO0lBQ0EsTUFBTUMsMEJBQTBCem1CLGVBQWU0UyxZQUFZO1FBQ3ZEO0tBQ0g7SUFDRCxJQUFJNlQsMkJBQTJCLE1BQU07UUFDakMzbkIsZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFNFQ7SUFDdEQ7SUFDQSxNQUFNQyxrQkFBa0IxbUIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUk4VCxtQkFBbUIsTUFBTTtRQUN6QjVuQixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRTZUO0lBQzlDO0lBQ0EsTUFBTUMsaUJBQWlCM21CLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJK1Qsa0JBQWtCLE1BQU07UUFDeEI3bkIsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUU4VDtJQUM3QztJQUNBLE9BQU85VDtBQUNYO0FBQ0EsU0FBUzJ0QixtQkFBbUI1dEIsVUFBVTtJQUNsQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWdVLGlCQUFpQjdtQixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWlVLGtCQUFrQixNQUFNO1FBQ3hCL25CLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFMHRCLG1CQUFtQjFaO0lBQ2hFO0lBQ0EsT0FBT2hVO0FBQ1g7QUFDQSxTQUFTNHRCO0lBQ0wsTUFBTTV0QixXQUFXLENBQUM7SUFDbEIsT0FBT0E7QUFDWDtBQUNBLFNBQVM2dEIsd0JBQXdCOXRCLFVBQVU7SUFDdkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vRSxrQkFBa0JqWCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXFFLG1CQUFtQixNQUFNO1FBQ3pCblksZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVvRTtJQUM5QztJQUNBLE9BQU9wRTtBQUNYO0FBQ0EsU0FBUzh0QixhQUFhL3RCLFVBQVU7SUFDNUIsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1zRSwyQkFBMkJuWCxlQUFlNFMsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSXVFLDRCQUE0QixNQUFNO1FBQ2xDLElBQUloRCxrQkFBa0JnRDtRQUN0QixJQUFJN1gsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU95ekIsNEJBQTRCenpCO1lBQ3ZDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBdUIsRUFBRXNCO0lBQ3ZEO0lBQ0EsTUFBTThTLGdCQUFnQmpuQixlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSXFVLGlCQUFpQixNQUFNO1FBQ3ZCbm9CLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFb1U7SUFDNUM7SUFDQSxNQUFNN1AsbUJBQW1CcFgsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUl3RSxvQkFBb0IsTUFBTTtRQUMxQnRZLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFcXRCLHFCQUFxQjlvQjtJQUNwRTtJQUNBLE1BQU1DLDRCQUE0QnJYLGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJeUUsNkJBQTZCLE1BQU07UUFDbkN2WSxlQUFlK1QsVUFBVTtZQUFDO1NBQXdCLEVBQUV1dEIsOEJBQThCL29CO0lBQ3RGO0lBQ0EsTUFBTTZQLDBCQUEwQmxuQixlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSXNVLDJCQUEyQixNQUFNO1FBQ2pDcG9CLGVBQWUrVCxVQUFVO1lBQUM7U0FBc0IsRUFBRXd0Qiw0QkFBNEJuWjtJQUNsRjtJQUNBLE1BQU1DLGlCQUFpQm5uQixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXVVLGtCQUFrQixNQUFNO1FBQ3hCcm9CLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFMnRCLG1CQUFtQnJaO0lBQ2hFO0lBQ0EsTUFBTTdQLGlCQUFpQnRYLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJMEUsa0JBQWtCLE1BQU07UUFDeEJ4WSxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRTR0QjtJQUM3QztJQUNBLE1BQU1scEIsa0JBQWtCdlgsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkyRSxtQkFBbUIsTUFBTTtRQUN6QnpZLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFNnRCLHdCQUF3Qm5wQjtJQUN0RTtJQUNBLE1BQU1DLG9CQUFvQnhYLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJNEUscUJBQXFCLE1BQU07UUFDM0IxWSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUUyRTtJQUNoRDtJQUNBLE9BQU8zRTtBQUNYO0FBQ0EsU0FBUyt0Qiw4QkFBOEJodUIsVUFBVTtJQUM3QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThELFdBQVczVyxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSStELFlBQVksTUFBTTtRQUNsQjdYLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFOEQ7SUFDdkM7SUFDQSxNQUFNZSwyQkFBMkIxWCxlQUFlNFMsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSThFLDRCQUE0QixNQUFNO1FBQ2xDNVksZUFBZStULFVBQVU7WUFBQztTQUF1QixFQUFFNkU7SUFDdkQ7SUFDQSxPQUFPN0U7QUFDWDtBQUNBLFNBQVNndUIsZUFBZWp1QixVQUFVO0lBQzlCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNK0UsZUFBZTVYLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJZ0YsZ0JBQWdCLE1BQU07UUFDdEI5WSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRStFO0lBQzNDO0lBQ0EsTUFBTUMsZ0JBQWdCN1gsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlpRixpQkFBaUIsTUFBTTtRQUN2Qi9ZLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFZ0Y7SUFDNUM7SUFDQSxPQUFPaEY7QUFDWDtBQUNBLFNBQVNpdUIsd0JBQXdCbHVCLFVBQVU7SUFDdkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1rRixhQUFhL1gsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUltRixjQUFjLE1BQU07UUFDcEJqWixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWd1QixlQUFlOW9CO0lBQ3hEO0lBQ0EsTUFBTUMsbUJBQW1CaFksZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlvRixvQkFBb0IsTUFBTTtRQUMxQmxaLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFbUY7SUFDL0M7SUFDQSxPQUFPbkY7QUFDWDtBQUNBLFNBQVNrdUIsbUJBQW1CbnVCLFVBQVU7SUFDbEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1xRiw0QkFBNEJsWSxlQUFlNFMsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSXNGLDZCQUE2QixNQUFNO1FBQ25DcFosZUFBZStULFVBQVU7WUFBQztTQUF3QixFQUFFK3RCLDhCQUE4QjFvQjtJQUN0RjtJQUNBLE1BQU1DLHNCQUFzQm5ZLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJdUYsdUJBQXVCLE1BQU07UUFDN0JyWixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVpdUIsd0JBQXdCM29CO0lBQzFFO0lBQ0EsT0FBT3RGO0FBQ1g7QUFDQSxTQUFTbXVCLDRCQUE0QnB1QixVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNd0YsZ0JBQWdCclksZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUl5RixpQkFBaUIsTUFBTTtRQUN2QnZaLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFd0Y7SUFDNUM7SUFDQSxPQUFPeEY7QUFDWDtBQUNBLFNBQVNvdUIsb0JBQW9CcnVCLFVBQVU7SUFDbkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0wRiwwQkFBMEJ2WSxlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSTJGLDJCQUEyQixNQUFNO1FBQ2pDelosZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFbXVCLDRCQUE0QnpvQjtJQUNsRjtJQUNBLE9BQU8xRjtBQUNYO0FBQ0EsU0FBU3F1QixxQkFBcUJ0dUIsVUFBVTtJQUNwQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZGLGtCQUFrQjFZLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJOEYsbUJBQW1CLE1BQU07UUFDekI1WixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRW91QixvQkFBb0J2b0I7SUFDbEU7SUFDQSxJQUFJMVksZUFBZTRTLFlBQVk7UUFBQztLQUEwQixNQUFNN1YsV0FBVztRQUN2RSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTW1aLG1CQUFtQmhZLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJb0Ysb0JBQW9CLE1BQU07UUFDMUJsWixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRW1GO0lBQy9DO0lBQ0EsT0FBT25GO0FBQ1g7QUFDQSxTQUFTc3VCLHVCQUF1QnZ1QixVQUFVO0lBQ3RDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNbUcsc0JBQXNCaFosZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlvRyx1QkFBdUIsTUFBTTtRQUM3QmxhLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW1HO0lBQ2xEO0lBQ0EsTUFBTUMscUJBQXFCalosZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUlxRyxzQkFBc0IsTUFBTTtRQUM1Qm5hLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRW9HO0lBQ2pEO0lBQ0EsT0FBT3BHO0FBQ1g7QUFDQSxTQUFTdXVCLDhCQUE4QmgyQixTQUFTLEVBQUV3SCxVQUFVLEVBQUV1RyxZQUFZO0lBQ3RFLE1BQU10RyxXQUFXLENBQUM7SUFDbEIsTUFBTXVHLHdCQUF3QnBaLGVBQWU0UyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXFjLHlCQUF5QixNQUFNO1FBQzdEdGEsZUFBZXFhLGNBQWM7WUFBQztTQUFvQixFQUFFdW1CLGdCQUFnQi95QixTQUFTeU07SUFDakY7SUFDQSxNQUFNQyxrQkFBa0JyWixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXlHLG1CQUFtQixNQUFNO1FBQ3pCdmEsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUV3RztJQUM5QztJQUNBLE1BQU1DLFdBQVd0WixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTBHLFlBQVksTUFBTTtRQUNsQnhhLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFeUc7SUFDdkM7SUFDQSxNQUFNQyxXQUFXdlosZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUkyRyxZQUFZLE1BQU07UUFDbEJ6YSxlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRTBHO0lBQ3ZDO0lBQ0EsTUFBTUMscUJBQXFCeFosZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUk0RyxzQkFBc0IsTUFBTTtRQUM1QjFhLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRTJHO0lBQ2pEO0lBQ0EsTUFBTUMsc0JBQXNCelosZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUk2Ryx1QkFBdUIsTUFBTTtRQUM3QjNhLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRTRHO0lBQ2xEO0lBQ0EsTUFBTUMsb0JBQW9CMVosZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUk4RyxxQkFBcUIsTUFBTTtRQUMzQjVhLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRTZHO0lBQ2hEO0lBQ0EsTUFBTUMsdUJBQXVCM1osZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUkrRyx3QkFBd0IsTUFBTTtRQUM5QjdhLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRThHO0lBQ25EO0lBQ0EsTUFBTUMsZUFBZTVaLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJZ0gsZ0JBQWdCLE1BQU07UUFDdEI5YSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRStHO0lBQzNDO0lBQ0EsTUFBTUMsc0JBQXNCN1osZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlpSCx1QkFBdUIsTUFBTTtRQUM3Qi9hLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRWdIO0lBQ2xEO0lBQ0EsTUFBTUMsdUJBQXVCOVosZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlrSCx3QkFBd0IsTUFBTTtRQUM5QmhiLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWlIO0lBQ25EO0lBQ0EsTUFBTUMsV0FBVy9aLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJbUgsWUFBWSxNQUFNO1FBQ2xCamIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVrSDtJQUN2QztJQUNBLE1BQU1DLHVCQUF1QmhhLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJb0gsd0JBQXdCLE1BQU07UUFDOUJsYixlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVtSDtJQUNuRDtJQUNBLE1BQU1DLHFCQUFxQmphLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJcUgsc0JBQXNCLE1BQU07UUFDNUJuYixlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUU4c0IsZUFBZXR4QixRQUFRNEw7SUFDeEU7SUFDQSxNQUFNN0QseUJBQXlCcFcsZUFBZTRTLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUl3RCwwQkFBMEIsTUFBTTtRQUNoQ3RYLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRXVEO0lBQ3JEO0lBQ0EsTUFBTWlyQixvQkFBb0JyaEMsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUl5dUIscUJBQXFCLE1BQU07UUFDM0J2aUMsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFd3VCO0lBQ2hEO0lBQ0EsTUFBTUMsMkJBQTJCdGhDLGVBQWU0UyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJMHVCLDRCQUE0QixNQUFNO1FBQ2xDeGlDLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFK3NCLDZCQUE2QjBCO0lBQzNFO0lBQ0EsTUFBTXBuQixxQkFBcUJsYSxlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFtZCxzQkFBc0IsTUFBTTtRQUMxRCxJQUFJL0Ysa0JBQWtCK0Y7UUFDdEIsSUFBSTVhLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPdXpCLHNCQUFzQnZ6QjtZQUNqQztRQUNKO1FBQ0F6TixlQUFlcWEsY0FBYztZQUFDO1NBQWlCLEVBQUVoRjtJQUNyRDtJQUNBLE1BQU1nRyxZQUFZbmEsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUl1RyxpQkFBaUJwYyxhQUFhb2QsYUFBYSxNQUFNO1FBQ2pELElBQUloRyxrQkFBa0IvRSxPQUFPK0s7UUFDN0IsSUFBSTdhLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPbzBCLGFBQWE5eEIsTUFBTXRDO1lBQzlCO1FBQ0o7UUFDQXpOLGVBQWVxYSxjQUFjO1lBQUM7U0FBUSxFQUFFaEY7SUFDNUM7SUFDQSxNQUFNaUcsaUJBQWlCcGEsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUl1RyxpQkFBaUJwYyxhQUFhcWQsa0JBQWtCLE1BQU07UUFDdER0YixlQUFlcWEsY0FBYztZQUFDO1NBQWEsRUFBRTRuQixtQkFBbUIzbUI7SUFDcEU7SUFDQSxNQUFNbW5CLGFBQWF2aEMsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUl1RyxpQkFBaUJwYyxhQUFhd2tDLGNBQWMsTUFBTTtRQUNsRHppQyxlQUFlcWEsY0FBYztZQUFDO1NBQVMsRUFBRW9vQjtJQUM3QztJQUNBLE1BQU1sbkIsb0JBQW9CcmEsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhc2QscUJBQXFCLE1BQU07UUFDekR2YixlQUFlcWEsY0FBYztZQUFDO1NBQWdCLEVBQUV4SixtQkFBbUJ2RSxXQUFXaVA7SUFDbEY7SUFDQSxNQUFNQyx5QkFBeUJ0YSxlQUFlNFMsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSTBILDBCQUEwQixNQUFNO1FBQ2hDeGIsZUFBZStULFVBQVU7WUFBQztTQUFxQixFQUFFeUg7SUFDckQ7SUFDQSxNQUFNQyxzQkFBc0J2YSxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSTJILHVCQUF1QixNQUFNO1FBQzdCemIsZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFMEg7SUFDbEQ7SUFDQSxNQUFNQyxtQkFBbUJ4YSxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSTRILG9CQUFvQixNQUFNO1FBQzFCMWIsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVxdUIscUJBQXFCM3lCLGNBQWNpTTtJQUNsRjtJQUNBLE1BQU1nbkIscUJBQXFCeGhDLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJNHVCLHNCQUFzQixNQUFNO1FBQzVCMWlDLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRTJ1QjtJQUNqRDtJQUNBLE1BQU0vbUIscUJBQXFCemEsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUk2SCxzQkFBc0IsTUFBTTtRQUM1QjNiLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRXN1Qix1QkFBdUIxbUI7SUFDeEU7SUFDQSxPQUFPNUg7QUFDWDtBQUNBLFNBQVM0dUIsa0NBQWtDcjJCLFNBQVMsRUFBRXdILFVBQVU7SUFDNUQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04SCxZQUFZM2EsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrSCxhQUFhLE1BQU07UUFDbkI3YixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFMUgsT0FBT0MsV0FBV3VQO0lBQ2xFO0lBQ0EsTUFBTUMsZUFBZTVhLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJZ0ksZ0JBQWdCLE1BQU07UUFDdEIsSUFBSXpHLGtCQUFrQnJILFVBQVU4TjtRQUNoQyxJQUFJdGIsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU9tekIsZ0JBQWdCbnpCO1lBQzNCO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFc0I7SUFDM0M7SUFDQSxNQUFNMEcsYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFdXVCLDhCQUE4QmgyQixXQUFXeVAsWUFBWWhJO0lBQ3hHO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVM2dUIsMkJBQTJCOXVCLFVBQVUsRUFBRXVHLFlBQVk7SUFDeEQsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNcXFCLGVBQWVsOUIsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUl1RyxpQkFBaUJwYyxhQUFhbWdDLGdCQUFnQixNQUFNO1FBQ3BEcCtCLGVBQWVxYSxjQUFjO1lBQUM7WUFBZTtTQUFZLEVBQUUrakI7SUFDL0Q7SUFDQSxNQUFNeG5CLFlBQVkxVixlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXVHLGlCQUFpQnBjLGFBQWEyWSxhQUFhLE1BQU07UUFDakQ1VyxlQUFlcWEsY0FBYztZQUFDO1lBQWU7U0FBUSxFQUFFekQ7SUFDM0Q7SUFDQSxNQUFNeW5CLDJCQUEyQm45QixlQUFlNFMsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFvZ0MsNEJBQTRCLE1BQU07UUFDaEVyK0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQXVCLEVBQUVna0I7SUFDekU7SUFDQSxNQUFNaHFCLGVBQWVuVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXVHLGlCQUFpQnBjLGFBQWFvVyxnQkFBZ0IsTUFBTTtRQUNwRHJVLGVBQWVxYSxjQUFjO1lBQUM7WUFBZTtTQUFXLEVBQUVoRztJQUM5RDtJQUNBLE1BQU13dUIsbUJBQW1CM2hDLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJdUcsaUJBQWlCcGMsYUFBYTRrQyxvQkFBb0IsTUFBTTtRQUN4RDdpQyxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBZSxFQUFFd29CO0lBQ2pFO0lBQ0EsT0FBTzl1QjtBQUNYO0FBQ0EsU0FBUyt1QiwrQkFBK0J4MkIsU0FBUyxFQUFFd0gsVUFBVTtJQUN6RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFRLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDbEU7SUFDQSxNQUFNQyxlQUFlNWEsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlnSSxnQkFBZ0IsTUFBTTtRQUN0QjliLGVBQWUrVCxVQUFVO1lBQUM7WUFBZTtTQUFVLEVBQUVqRyxrQkFBa0J4QixXQUFXd1A7SUFDdEY7SUFDQSxNQUFNQyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRTZ1QiwyQkFBMkI3bUIsWUFBWWhJO0lBQ2hGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNndkIsNkJBQTZCanZCLFVBQVUsRUFBRXVHLFlBQVk7SUFDMUQsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNaXZCLG1CQUFtQjloQyxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXVHLGlCQUFpQnBjLGFBQWEra0Msb0JBQW9CLE1BQU07UUFDeERoakMsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWEsRUFBRTJvQjtJQUMvRDtJQUNBLE1BQU01QyxxQkFBcUJsL0IsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhbWlDLHNCQUFzQixNQUFNO1FBQzFEcGdDLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFpQixFQUFFK2xCO0lBQ25FO0lBQ0EsTUFBTTNCLHFCQUFxQnY5QixlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWF3Z0Msc0JBQXNCLE1BQU07UUFDMUR6K0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWMsRUFBRW9rQjtJQUNoRTtJQUNBLE1BQU1DLGtCQUFrQng5QixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXVHLGlCQUFpQnBjLGFBQWF5Z0MsbUJBQW1CLE1BQU07UUFDdkQxK0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWMsRUFBRXFrQjtJQUNoRTtJQUNBLE1BQU1DLG9CQUFvQno5QixlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWEwZ0MscUJBQXFCLE1BQU07UUFDekQzK0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWdCLEVBQUVza0I7SUFDbEU7SUFDQSxNQUFNMWpCLFdBQVcvWixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXVHLGlCQUFpQnBjLGFBQWFnZCxZQUFZLE1BQU07UUFDaERqYixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBTyxFQUFFWTtJQUN6RDtJQUNBLE1BQU0yakIsd0JBQXdCMTlCLGVBQWU0UyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTJnQyx5QkFBeUIsTUFBTTtRQUM3RDUrQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBZ0IsRUFBRXVrQjtJQUNsRTtJQUNBLE1BQU1DLHVCQUF1QjM5QixlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWE0Z0Msd0JBQXdCLE1BQU07UUFDNUQ3K0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQW1CLEVBQUV3a0I7SUFDckU7SUFDQSxNQUFNQyw4QkFBOEI1OUIsZUFBZTRTLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhNmdDLCtCQUErQixNQUFNO1FBQ25FOStCLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUEwQixFQUFFeWtCO0lBQzVFO0lBQ0EsTUFBTUMsdUJBQXVCNzlCLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYThnQyx3QkFBd0IsTUFBTTtRQUM1RC8rQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBbUIsRUFBRTBrQjtJQUNyRTtJQUNBLE1BQU1DLGVBQWU5OUIsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUl1RyxpQkFBaUJwYyxhQUFhK2dDLGdCQUFnQixNQUFNO1FBQ3BEaC9CLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFXLEVBQUUya0I7SUFDN0Q7SUFDQSxNQUFNQyxxQkFBcUIvOUIsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhZ2hDLHNCQUFzQixNQUFNO1FBQzFEai9CLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztZQUFpQjtTQUFXLEVBQUU0a0I7SUFDOUU7SUFDQSxNQUFNQywrQkFBK0JoK0IsZUFBZTRTLFlBQVk7UUFDNUQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhaWhDLGdDQUFnQyxNQUFNO1FBQ3BFbC9CLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztZQUFpQjtTQUFxQixFQUFFNmtCO0lBQ3hGO0lBQ0EsTUFBTStELG1CQUFtQi9oQyxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXVHLGlCQUFpQnBjLGFBQWFnbEMsb0JBQW9CLE1BQU07UUFDeERqakMsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWUsRUFBRTRvQjtJQUNqRTtJQUNBLE1BQU05RCxnQkFBZ0JqK0IsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUl1RyxpQkFBaUJwYyxhQUFha2hDLGlCQUFpQixNQUFNO1FBQ3JEbi9CLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFrQixFQUFFOGtCO0lBQ3BFO0lBQ0EsTUFBTWtCLG9CQUFvQm4vQixlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFvaUMscUJBQXFCLE1BQU07UUFDekRyZ0MsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWdCLEVBQUVnbUI7SUFDbEU7SUFDQSxPQUFPdHNCO0FBQ1g7QUFDQSxTQUFTbXZCLGlDQUFpQzUyQixTQUFTLEVBQUV3SCxVQUFVO0lBQzNELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEgsWUFBWTNhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK0gsYUFBYSxNQUFNO1FBQ25CN2IsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQVEsRUFBRTFILE9BQU9DLFdBQVd1UDtJQUNsRTtJQUNBLE1BQU13akIsYUFBYW4rQixlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSXVyQixjQUFjLE1BQU07UUFDcEJyL0IsZUFBZStULFVBQVU7WUFBQztZQUFnQjtTQUFTLEVBQUVzckI7SUFDekQ7SUFDQSxNQUFNdGpCLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFZ3ZCLDZCQUE2QmhuQixZQUFZaEk7SUFDbEY7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU292QixjQUFjcnZCLFVBQVU7SUFDN0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1nSixhQUFhN2IsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSixjQUFjLE1BQU07UUFDcEIvYyxlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWdKO0lBQ3pDO0lBQ0EsTUFBTTlMLGlCQUFpQi9QLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJN0Msa0JBQWtCLE1BQU07UUFDeEJqUixlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUUvQyxPQUFPQztJQUM1RDtJQUNBLE1BQU1vRCxlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVNxdkIsNEJBQTRCdHZCLFVBQVU7SUFDM0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1zdkIsZUFBZW5pQyxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXV2QixnQkFBZ0IsTUFBTTtRQUN0QnJqQyxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRXN2QjtJQUMzQztJQUNBLE1BQU1DLDBCQUEwQnBpQyxlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSXd2QiwyQkFBMkIsTUFBTTtRQUNqQ3RqQyxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXV2QjtJQUM5QztJQUNBLE1BQU1DLG1CQUFtQnJpQyxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXl2QixvQkFBb0IsTUFBTTtRQUMxQnZqQyxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRXd2QjtJQUMzQztJQUNBLE9BQU94dkI7QUFDWDtBQUNBLFNBQVN5dkIsK0JBQStCMXZCLFVBQVU7SUFDOUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0wdkIsa0JBQWtCdmlDLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJMnZCLG1CQUFtQixNQUFNO1FBQ3pCempDLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFMHZCO0lBQzlDO0lBQ0EsTUFBTUMsb0NBQW9DeGlDLGVBQWU0UyxZQUFZO1FBQ2pFO0tBQ0g7SUFDRCxJQUFJNHZCLHFDQUFxQyxNQUFNO1FBQzNDMWpDLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRTJ2QjtJQUNqRDtJQUNBLE9BQU8zdkI7QUFDWDtBQUNBLFNBQVM0dkIsNkJBQTZCN3ZCLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU02dkIsdUJBQXVCMWlDLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJOHZCLHdCQUF3QixNQUFNO1FBQzlCNWpDLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRTZ2QjtJQUNuRDtJQUNBLE9BQU83dkI7QUFDWDtBQUNBLFNBQVM4dkIsK0JBQStCL3ZCLFVBQVU7SUFDOUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0rdkIsa0JBQWtCNWlDLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJZ3dCLG1CQUFtQixNQUFNO1FBQ3pCOWpDLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFK3ZCO0lBQzlDO0lBQ0EsTUFBTUMseUJBQXlCN2lDLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJaXdCLDBCQUEwQixNQUFNO1FBQ2hDL2pDLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRWd3QjtJQUNyRDtJQUNBLE9BQU9od0I7QUFDWDtBQUNBLFNBQVNpd0Isa0NBQWtDbHdCLFVBQVU7SUFDakQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1rd0IscUJBQXFCL2lDLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJbXdCLHNCQUFzQixNQUFNO1FBQzVCamtDLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRW92QixjQUFjYztJQUMvRDtJQUNBLE1BQU1DLGtCQUFrQmhqQyxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSW93QixtQkFBbUIsTUFBTTtRQUN6QmxrQyxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRW13QjtJQUM5QztJQUNBLE1BQU1DLG9CQUFvQmpqQyxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXF3QixxQkFBcUIsTUFBTTtRQUMzQm5rQyxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVvd0I7SUFDaEQ7SUFDQSxNQUFNQyxzQkFBc0JsakMsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlzd0IsdUJBQXVCLE1BQU07UUFDN0Jwa0MsZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFcXZCLDRCQUE0QmdCO0lBQzlFO0lBQ0EsTUFBTUMseUJBQXlCbmpDLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJdXdCLDBCQUEwQixNQUFNO1FBQ2hDcmtDLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRXl2QiwrQkFBK0JhO0lBQ3BGO0lBQ0EsTUFBTUMsdUJBQXVCcGpDLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJd3dCLHdCQUF3QixNQUFNO1FBQzlCdGtDLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRTR2Qiw2QkFBNkJXO0lBQ2hGO0lBQ0EsTUFBTUMseUJBQXlCcmpDLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJeXdCLDBCQUEwQixNQUFNO1FBQ2hDdmtDLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRTh2QiwrQkFBK0JVO0lBQ3BGO0lBQ0EsT0FBT3h3QjtBQUNYO0FBQ0EsU0FBU3l3Qix3QkFBd0Ixd0IsVUFBVSxFQUFFdUcsWUFBWTtJQUNyRCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pdkIsbUJBQW1COWhDLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJdUcsaUJBQWlCcGMsYUFBYStrQyxvQkFBb0IsTUFBTTtRQUN4RGhqQyxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBYSxFQUFFMm9CO0lBQy9EO0lBQ0EsTUFBTTVDLHFCQUFxQmwvQixlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFtaUMsc0JBQXNCLE1BQU07UUFDMURwZ0MsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWlCLEVBQUUrbEI7SUFDbkU7SUFDQSxNQUFNM0IscUJBQXFCdjlCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXdnQyxzQkFBc0IsTUFBTTtRQUMxRHorQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBYyxFQUFFb2tCO0lBQ2hFO0lBQ0EsTUFBTUMsa0JBQWtCeDlCLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJdUcsaUJBQWlCcGMsYUFBYXlnQyxtQkFBbUIsTUFBTTtRQUN2RDErQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBYyxFQUFFcWtCO0lBQ2hFO0lBQ0EsTUFBTUMsb0JBQW9CejlCLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTBnQyxxQkFBcUIsTUFBTTtRQUN6RDMrQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBZ0IsRUFBRXNrQjtJQUNsRTtJQUNBLE1BQU0xakIsV0FBVy9aLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWdkLFlBQVksTUFBTTtRQUNoRGpiLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFPLEVBQUVZO0lBQ3pEO0lBQ0EsTUFBTTJqQix3QkFBd0IxOUIsZUFBZTRTLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhMmdDLHlCQUF5QixNQUFNO1FBQzdENStCLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFnQixFQUFFdWtCO0lBQ2xFO0lBQ0EsTUFBTUMsdUJBQXVCMzlCLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTRnQyx3QkFBd0IsTUFBTTtRQUM1RDcrQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBbUIsRUFBRXdrQjtJQUNyRTtJQUNBLE1BQU1DLDhCQUE4QjU5QixlQUFlNFMsWUFBWTtRQUMzRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWE2Z0MsK0JBQStCLE1BQU07UUFDbkU5K0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQTBCLEVBQUV5a0I7SUFDNUU7SUFDQSxNQUFNQyx1QkFBdUI3OUIsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhOGdDLHdCQUF3QixNQUFNO1FBQzVELytCLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFtQixFQUFFMGtCO0lBQ3JFO0lBQ0EsTUFBTUMsZUFBZTk5QixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXVHLGlCQUFpQnBjLGFBQWErZ0MsZ0JBQWdCLE1BQU07UUFDcERoL0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQVcsRUFBRTJrQjtJQUM3RDtJQUNBLE1BQU1DLHFCQUFxQi85QixlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFnaEMsc0JBQXNCLE1BQU07UUFDMURqL0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1lBQWlCO1NBQVcsRUFBRTRrQjtJQUM5RTtJQUNBLE1BQU1DLCtCQUErQmgrQixlQUFlNFMsWUFBWTtRQUM1RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFpaEMsZ0NBQWdDLE1BQU07UUFDcEVsL0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1lBQWlCO1NBQXFCLEVBQUU2a0I7SUFDeEY7SUFDQSxNQUFNK0QsbUJBQW1CL2hDLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJdUcsaUJBQWlCcGMsYUFBYWdsQyxvQkFBb0IsTUFBTTtRQUN4RGpqQyxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBZSxFQUFFNG9CO0lBQ2pFO0lBQ0EsTUFBTXdCLGVBQWV2akMsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUl1RyxpQkFBaUJwYyxhQUFhd21DLGdCQUFnQixNQUFNO1FBQ3BEemtDLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFXLEVBQUVvcUI7SUFDN0Q7SUFDQSxNQUFNQyxnQkFBZ0J4akMsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUl1RyxpQkFBaUJwYyxhQUFheW1DLGlCQUFpQixNQUFNO1FBQ3JEMWtDLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztZQUFjO1NBQVksRUFBRXFxQjtJQUM1RTtJQUNBLE9BQU8zd0I7QUFDWDtBQUNBLFNBQVM0d0Isb0NBQW9DcjRCLFNBQVMsRUFBRXdILFVBQVU7SUFDOUQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04SCxZQUFZM2EsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrSCxhQUFhLE1BQU07UUFDbkI3YixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFMUgsT0FBT0MsV0FBV3VQO0lBQ2xFO0lBQ0EsTUFBTXdqQixhQUFhbitCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJdXJCLGNBQWMsTUFBTTtRQUNwQnIvQixlQUFlK1QsVUFBVTtZQUFDO1lBQWdCO1NBQVMsRUFBRXNyQjtJQUN6RDtJQUNBLE1BQU11RixzQkFBc0IxakMsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUk4d0IsdUJBQXVCLE1BQU07UUFDN0IsSUFBSXZ2QixrQkFBa0J1dkI7UUFDdEIsSUFBSXBrQyxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3UyQixrQ0FBa0N2MkI7WUFDN0M7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztZQUFnQjtTQUFrQixFQUFFc0I7SUFDbEU7SUFDQSxNQUFNMEcsYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUV5d0Isd0JBQXdCem9CLFlBQVloSTtJQUM3RTtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTOHdCLHNDQUFzQy93QixVQUFVLEVBQUV1RyxZQUFZO0lBQ25FLE1BQU10RyxXQUFXLENBQUM7SUFDbEIsTUFBTWdyQix1QkFBdUI3OUIsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhOGdDLHdCQUF3QixNQUFNO1FBQzVELytCLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFtQixFQUFFMGtCO0lBQ3JFO0lBQ0EsTUFBTUUscUJBQXFCLzlCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWdoQyxzQkFBc0IsTUFBTTtRQUMxRGovQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7WUFBaUI7U0FBVyxFQUFFNGtCO0lBQzlFO0lBQ0EsTUFBTUMsK0JBQStCaCtCLGVBQWU0UyxZQUFZO1FBQzVEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWloQyxnQ0FBZ0MsTUFBTTtRQUNwRWwvQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7WUFBaUI7U0FBcUIsRUFBRTZrQjtJQUN4RjtJQUNBLE1BQU00Rix3QkFBd0I1akMsZUFBZTRTLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhNm1DLHlCQUF5QixNQUFNO1FBQzdEOWtDLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztZQUFpQjtTQUFvQixFQUFFeXFCO0lBQ3ZGO0lBQ0EsTUFBTUMsOEJBQThCN2pDLGVBQWU0UyxZQUFZO1FBQzNEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYThtQywrQkFBK0IsTUFBTTtRQUNuRS9rQyxlQUFlcWEsY0FBYztZQUFDO1lBQWM7WUFBaUI7U0FBMEIsRUFBRTBxQjtJQUM3RjtJQUNBLE1BQU10RyxxQkFBcUJ2OUIsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhd2dDLHNCQUFzQixNQUFNO1FBQzFEeitCLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFjLEVBQUVva0I7SUFDaEU7SUFDQSxNQUFNNW1CLFdBQVczVyxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXVHLGlCQUFpQnBjLGFBQWE0WixZQUFZLE1BQU07UUFDaEQ3WCxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBTyxFQUFFeEM7SUFDekQ7SUFDQSxPQUFPOUQ7QUFDWDtBQUNBLFNBQVNpeEIsMENBQTBDMTRCLFNBQVMsRUFBRXdILFVBQVU7SUFDcEUsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04SCxZQUFZM2EsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrSCxhQUFhLE1BQU07UUFDbkI3YixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFMUgsT0FBT0MsV0FBV3VQO0lBQ2xFO0lBQ0EsTUFBTTBrQixZQUFZci9CLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJeXNCLGFBQWEsTUFBTTtRQUNuQnZnQyxlQUFlK1QsVUFBVTtZQUFDO1lBQWdCO1NBQVEsRUFBRW92QixjQUFjNUM7SUFDdEU7SUFDQSxNQUFNMEUsb0JBQW9CL2pDLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJbXhCLHFCQUFxQixNQUFNO1FBQzNCamxDLGVBQWUrVCxVQUFVO1lBQUM7WUFBYztZQUFpQjtTQUFnQixFQUFFa3hCO0lBQy9FO0lBQ0EsTUFBTWxwQixhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRTh3QixzQ0FBc0M5b0IsWUFBWWhJO0lBQzNGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNteEIscUJBQXFCcHhCLFVBQVU7SUFDcEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1veEIsbUJBQW1CamtDLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJcXhCLG9CQUFvQixNQUFNO1FBQzFCbmxDLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFb3ZCLGNBQWNnQztJQUN0RDtJQUNBLE9BQU9weEI7QUFDWDtBQUNBLFNBQVNxeEIsNkJBQTZCdHhCLFVBQVUsRUFBRXVHLFlBQVk7SUFDMUQsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNc3JCLGFBQWFuK0IsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUl1RyxpQkFBaUJwYyxhQUFhb2hDLGNBQWMsTUFBTTtRQUNsRHIvQixlQUFlcWEsY0FBYztZQUFDO1lBQWdCO1NBQVMsRUFBRWdsQjtJQUM3RDtJQUNBLE1BQU1nRyxrQkFBa0Jua0MsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUl1RyxpQkFBaUJwYyxhQUFhb25DLG1CQUFtQixNQUFNO1FBQ3ZEcmxDLGVBQWVxYSxjQUFjO1lBQUM7WUFBZ0I7WUFBZTtTQUFRLEVBQUU4b0IsY0FBY2tDO0lBQ3pGO0lBQ0EsTUFBTUMsb0JBQW9CcGtDLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXFuQyxxQkFBcUIsTUFBTTtRQUN6RCxJQUFJandCLGtCQUFrQml3QjtRQUN0QixJQUFJOWtDLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPeTNCLHFCQUFxQnozQjtZQUNoQztRQUNKO1FBQ0F6TixlQUFlcWEsY0FBYztZQUFDO1lBQWdCO1NBQWdCLEVBQUVoRjtJQUNwRTtJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBU3d4Qiw2QkFBNkJ6eEIsVUFBVSxFQUFFdUcsWUFBWTtJQUMxRCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU0wcUIscUJBQXFCdjlCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXdnQyxzQkFBc0IsTUFBTTtRQUMxRHorQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBYyxFQUFFb2tCO0lBQ2hFO0lBQ0EsTUFBTWlHLGdCQUFnQnhqQyxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSXVHLGlCQUFpQnBjLGFBQWF5bUMsaUJBQWlCLE1BQU07UUFDckQxa0MsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1lBQWM7U0FBWSxFQUFFcXFCO0lBQzVFO0lBQ0EsTUFBTTFCLG1CQUFtQjloQyxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXVHLGlCQUFpQnBjLGFBQWEra0Msb0JBQW9CLE1BQU07UUFDeERoakMsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWEsRUFBRTJvQjtJQUMvRDtJQUNBLE1BQU0vbkIsV0FBVy9aLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWdkLFlBQVksTUFBTTtRQUNoRGpiLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFPLEVBQUVZO0lBQ3pEO0lBQ0EsTUFBTTJqQix3QkFBd0IxOUIsZUFBZTRTLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhMmdDLHlCQUF5QixNQUFNO1FBQzdENStCLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFnQixFQUFFdWtCO0lBQ2xFO0lBQ0EsTUFBTUMsdUJBQXVCMzlCLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTRnQyx3QkFBd0IsTUFBTTtRQUM1RDcrQixlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBbUIsRUFBRXdrQjtJQUNyRTtJQUNBLE1BQU1JLHFCQUFxQi85QixlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFnaEMsc0JBQXNCLE1BQU07UUFDMURqL0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1lBQWlCO1NBQVcsRUFBRTRrQjtJQUM5RTtJQUNBLE1BQU1DLCtCQUErQmgrQixlQUFlNFMsWUFBWTtRQUM1RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFpaEMsZ0NBQWdDLE1BQU07UUFDcEVsL0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1lBQWlCO1NBQXFCLEVBQUU2a0I7SUFDeEY7SUFDQSxNQUFNbUIsb0JBQW9Cbi9CLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYW9pQyxxQkFBcUIsTUFBTTtRQUN6RHJnQyxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBZ0IsRUFBRWdtQjtJQUNsRTtJQUNBLE9BQU90c0I7QUFDWDtBQUNBLFNBQVN5eEIsaUNBQWlDbDVCLFNBQVMsRUFBRXdILFVBQVU7SUFDM0QsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04SCxZQUFZM2EsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrSCxhQUFhLE1BQU07UUFDbkI3YixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBUSxFQUFFMUgsT0FBT0MsV0FBV3VQO0lBQ2xFO0lBQ0EsTUFBTXdULGFBQWFudUIsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUl1YixjQUFjLE1BQU07UUFDcEJydkIsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVxeEIsNkJBQTZCL1YsWUFBWXRiO0lBQ2xGO0lBQ0EsTUFBTWdJLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFd3hCLDZCQUE2QnhwQixZQUFZaEk7SUFDbEY7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBUzB4QixzQkFBc0IzeEIsVUFBVTtJQUNyQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXdzQixZQUFZci9CLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJeXNCLGFBQWEsTUFBTTtRQUNuQnZnQyxlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRW92QixjQUFjNUM7SUFDdEQ7SUFDQSxPQUFPeHNCO0FBQ1g7QUFDQSxTQUFTMnhCLDJCQUEyQjV4QixVQUFVLEVBQUV1RyxZQUFZO0lBQ3hELE1BQU10RyxXQUFXLENBQUM7SUFDbEIsTUFBTXNyQixhQUFhbitCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJdUcsaUJBQWlCcGMsYUFBYW9oQyxjQUFjLE1BQU07UUFDbERyL0IsZUFBZXFhLGNBQWM7WUFBQztZQUFnQjtTQUFTLEVBQUVnbEI7SUFDN0Q7SUFDQSxNQUFNa0IsWUFBWXIvQixlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXVHLGlCQUFpQnBjLGFBQWFzaUMsYUFBYSxNQUFNO1FBQ2pEdmdDLGVBQWVxYSxjQUFjO1lBQUM7WUFBZ0I7U0FBUSxFQUFFOG9CLGNBQWM1QztJQUMxRTtJQUNBLE1BQU1vRixvQkFBb0J6a0MsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhMG5DLHFCQUFxQixNQUFNO1FBQ3pEM2xDLGVBQWVxYSxjQUFjO1lBQUM7WUFBZ0I7U0FBVyxFQUFFb3JCLHNCQUFzQkU7SUFDckY7SUFDQSxPQUFPNXhCO0FBQ1g7QUFDQSxTQUFTNnhCLDJCQUEyQjl4QixVQUFVLEVBQUV1RyxZQUFZO0lBQ3hELE1BQU10RyxXQUFXLENBQUM7SUFDbEIsTUFBTThELFdBQVczVyxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXVHLGlCQUFpQnBjLGFBQWE0WixZQUFZLE1BQU07UUFDaEQ3WCxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBTyxFQUFFeEM7SUFDekQ7SUFDQSxNQUFNZ3VCLHFCQUFxQjNrQyxlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWE0bkMsc0JBQXNCLE1BQU07UUFDMUQ3bEMsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWlCLEVBQUV3ckI7SUFDbkU7SUFDQSxNQUFNQywwQkFBMEI1a0MsZUFBZTRTLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhNm5DLDJCQUEyQixNQUFNO1FBQy9EOWxDLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFzQixFQUFFeXJCO0lBQ3hFO0lBQ0EsTUFBTXZDLG1CQUFtQnJpQyxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXVHLGlCQUFpQnBjLGFBQWFzbEMsb0JBQW9CLE1BQU07UUFDeER2akMsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWUsRUFBRWtwQjtJQUNqRTtJQUNBLE1BQU13QywyQkFBMkI3a0MsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhOG5DLDRCQUE0QixNQUFNO1FBQ2hFL2xDLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUF1QixFQUFFMHJCO0lBQ3pFO0lBQ0EsT0FBT2h5QjtBQUNYO0FBQ0EsU0FBU2l5QiwrQkFBK0IxNUIsU0FBUyxFQUFFd0gsVUFBVTtJQUN6RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFRLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDbEU7SUFDQSxNQUFNd1QsYUFBYW51QixlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSXViLGNBQWMsTUFBTTtRQUNwQnJ2QixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRTJ4QiwyQkFBMkJyVyxZQUFZdGI7SUFDaEY7SUFDQSxNQUFNZ0ksYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUU2eEIsMkJBQTJCN3BCLFlBQVloSTtJQUNoRjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTa3lCLDJCQUEyQjM1QixTQUFTLEVBQUV3SCxVQUFVO0lBQ3JELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEgsWUFBWTNhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK0gsYUFBYSxNQUFNO1FBQ25CN2IsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQU8sRUFBRTFILE9BQU9DLFdBQVd1UDtJQUNqRTtJQUNBLE1BQU1FLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFZ0k7SUFDekM7SUFDQSxPQUFPaEk7QUFDWDtBQUNBLFNBQVNteUIseUJBQXlCNTVCLFNBQVMsRUFBRXdILFVBQVUsRUFBRXVHLFlBQVk7SUFDakUsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNMkksZUFBZXhiLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJdUcsaUJBQWlCcGMsYUFBYXllLGdCQUFnQixNQUFNO1FBQ3BEMWMsZUFBZXFhLGNBQWM7WUFBQztZQUFVO1NBQVcsRUFBRXFDO0lBQ3pEO0lBQ0EsTUFBTUMsZ0JBQWdCemIsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUl1RyxpQkFBaUJwYyxhQUFhMGUsaUJBQWlCLE1BQU07UUFDckQzYyxlQUFlcWEsY0FBYztZQUFDO1lBQVU7U0FBWSxFQUFFc0M7SUFDMUQ7SUFDQSxNQUFNYSxhQUFhdGMsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUl1RyxpQkFBaUJwYyxhQUFhdWYsY0FBYyxNQUFNO1FBQ2xEeGQsZUFBZXFhLGNBQWM7WUFBQztZQUFVO1NBQVMsRUFBRW1EO0lBQ3ZEO0lBQ0EsTUFBTWdpQixnQkFBZ0J0K0IsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUl1RyxpQkFBaUJwYyxhQUFhdWhDLGlCQUFpQixNQUFNO1FBQ3JEeC9CLGVBQWVxYSxjQUFjO1lBQUM7WUFBUTtTQUFhLEVBQUU3SSxXQUFXbEYsV0FBV2t6QjtJQUMvRTtJQUNBLE9BQU96ckI7QUFDWDtBQUNBLFNBQVNveUIsNkJBQTZCNzVCLFNBQVMsRUFBRXdILFVBQVU7SUFDdkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1nSSxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRW15Qix5QkFBeUI1NUIsV0FBV3lQLFlBQVloSTtJQUN6RjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTcXlCLDBCQUEwQnR5QixVQUFVLEVBQUV1RyxZQUFZO0lBQ3ZELE1BQU10RyxXQUFXLENBQUM7SUFDbEIsTUFBTXFJLGtCQUFrQmxiLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJdUcsaUJBQWlCcGMsYUFBYW1lLG1CQUFtQixNQUFNO1FBQ3ZEcGMsZUFBZXFhLGNBQWM7WUFBQztTQUFjLEVBQUUrQjtJQUNsRDtJQUNBLE1BQU0xRyxrQkFBa0J4VSxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXVHLGlCQUFpQnBjLGFBQWF5WCxtQkFBbUIsTUFBTTtRQUN2RDFWLGVBQWVxYSxjQUFjO1lBQUM7U0FBYyxFQUFFM0U7SUFDbEQ7SUFDQSxNQUFNaXFCLDBCQUEwQnorQixlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWEwaEMsMkJBQTJCLE1BQU07UUFDL0QzL0IsZUFBZXFhLGNBQWM7WUFBQztTQUFzQixFQUFFc2xCO0lBQzFEO0lBQ0EsT0FBTzVyQjtBQUNYO0FBQ0EsU0FBU3N5Qiw4QkFBOEIvNUIsU0FBUyxFQUFFd0gsVUFBVTtJQUN4RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFRLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDbEU7SUFDQSxNQUFNRSxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRXF5QiwwQkFBMEJycUIsWUFBWWhJO0lBQy9FO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVN1eUIsOEJBQThCaDZCLFNBQVMsRUFBRXdILFVBQVU7SUFDeEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04SCxZQUFZM2EsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkrSCxhQUFhLE1BQU07UUFDbkI3YixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFMUgsT0FBT0MsV0FBV3VQO0lBQ2pFO0lBQ0EsTUFBTUUsYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVnSTtJQUN6QztJQUNBLE9BQU9oSTtBQUNYO0FBQ0EsU0FBU3d5QiwwQkFBMEJ6eUIsVUFBVSxFQUFFdUcsWUFBWTtJQUN2RCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU11Ryx3QkFBd0JwWixlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFxYyx5QkFBeUIsTUFBTTtRQUM3RHRhLGVBQWVxYSxjQUFjO1lBQUM7U0FBb0IsRUFBRXVtQixnQkFBZ0IveUIsU0FBU3lNO0lBQ2pGO0lBQ0EsTUFBTWUsWUFBWW5hLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJdUcsaUJBQWlCcGMsYUFBYW9kLGFBQWEsTUFBTTtRQUNqRCxJQUFJaEcsa0JBQWtCZ0c7UUFDdEIsSUFBSTdhLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPbzBCLGFBQWFwMEI7WUFDeEI7UUFDSjtRQUNBek4sZUFBZXFhLGNBQWM7WUFBQztTQUFRLEVBQUVoRjtJQUM1QztJQUNBLE1BQU15ZCx1QkFBdUI1eEIsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhNjBCLHdCQUF3QixNQUFNO1FBQzVEOXlCLGVBQWVxYSxjQUFjO1lBQUM7U0FBbUIsRUFBRXlZO0lBQ3ZEO0lBQ0EsT0FBTy9lO0FBQ1g7QUFDQSxTQUFTeXlCLDhCQUE4Qmw2QixTQUFTLEVBQUV3SCxVQUFVO0lBQ3hELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEgsWUFBWTNhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK0gsYUFBYSxNQUFNO1FBQ25CN2IsZUFBZStULFVBQVU7WUFBQztZQUFRO1NBQVEsRUFBRTFILE9BQU9DLFdBQVd1UDtJQUNsRTtJQUNBLE1BQU1DLGVBQWU1YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSWdJLGdCQUFnQixNQUFNO1FBQ3RCLElBQUl6RyxrQkFBa0JySCxVQUFVOE47UUFDaEMsSUFBSXRiLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPbXpCLGdCQUFnQm56QjtZQUMzQjtRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRXNCO0lBQzNDO0lBQ0EsTUFBTTBHLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFd3lCLDBCQUEwQnhxQixZQUFZaEk7SUFDL0U7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBUzB5QixnQ0FBZ0NuNkIsU0FBUyxFQUFFd0gsVUFBVTtJQUMxRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFRLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDbEU7SUFDQSxNQUFNQyxlQUFlNWEsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlnSSxnQkFBZ0IsTUFBTTtRQUN0QixJQUFJekcsa0JBQWtCckgsVUFBVThOO1FBQ2hDLElBQUl0YixNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT216QixnQkFBZ0JuekI7WUFDM0I7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVzQjtJQUMzQztJQUNBLE1BQU0wRyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWdJO0lBQ3pDO0lBQ0EsT0FBT2hJO0FBQ1g7QUFDQSxTQUFTMnlCLGNBQWM1eUIsVUFBVTtJQUM3QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9iLFVBQVVqdUIsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUlxYixXQUFXLE1BQU07UUFDakJudkIsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVvYjtJQUN6QztJQUNBLE1BQU13WCxpQkFBaUJ6bEMsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUk2eUIsa0JBQWtCLE1BQU07UUFDeEIzbUMsZUFBZStULFVBQVU7WUFBQztTQUFxQixFQUFFL0MsT0FBTzIxQjtJQUM1RDtJQUNBLE1BQU10eUIsZUFBZW5ULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJTyxnQkFBZ0IsTUFBTTtRQUN0QnJVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFTTtJQUMzQztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTNnlCLHNDQUFzQzl5QixVQUFVO0lBQ3JELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNd3NCLFlBQVlyL0IsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUl5c0IsYUFBYSxNQUFNO1FBQ25CdmdDLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFb3ZCLGNBQWM1QztJQUN0RDtJQUNBLE1BQU00RCxvQkFBb0JqakMsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlxd0IscUJBQXFCLE1BQU07UUFDM0Jua0MsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFb3dCO0lBQ2hEO0lBQ0EsT0FBT3B3QjtBQUNYO0FBQ0EsU0FBUzh5Qiw2QkFBNkIveUIsVUFBVSxFQUFFdUcsWUFBWTtJQUMxRCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU1tc0IscUJBQXFCaC9CLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWlpQyxzQkFBc0IsTUFBTTtRQUMxRGxnQyxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBYyxFQUFFNmxCO0lBQ2hFO0lBQ0EsTUFBTThDLG1CQUFtQjloQyxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXVHLGlCQUFpQnBjLGFBQWEra0Msb0JBQW9CLE1BQU07UUFDeERoakMsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWEsRUFBRTJvQjtJQUMvRDtJQUNBLE1BQU1odkIsVUFBVTlTLGVBQWU0UyxZQUFZO1FBQUM7S0FBTTtJQUNsRCxJQUFJdUcsaUJBQWlCcGMsYUFBYStWLFdBQVcsTUFBTTtRQUMvQ2hVLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFNLEVBQUVyRztJQUN4RDtJQUNBLE1BQU1tc0Isc0JBQXNCai9CLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWtpQyx1QkFBdUIsTUFBTTtRQUMzRG5nQyxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBa0IsRUFBRThsQjtJQUNwRTtJQUNBLE1BQU1sbEIsV0FBVy9aLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJdUcsaUJBQWlCcGMsYUFBYWdkLFlBQVksTUFBTTtRQUNoRGpiLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFPLEVBQUVZO0lBQ3pEO0lBQ0EsTUFBTXlqQixrQkFBa0J4OUIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUl1RyxpQkFBaUJwYyxhQUFheWdDLG1CQUFtQixNQUFNO1FBQ3ZEMStCLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFjLEVBQUVxa0I7SUFDaEU7SUFDQSxNQUFNb0ksaUJBQWlCNWxDLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJdUcsaUJBQWlCcGMsYUFBYTZvQyxrQkFBa0IsTUFBTTtRQUN0RDltQyxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBYSxFQUFFeXNCO0lBQy9EO0lBQ0EsTUFBTWpJLHVCQUF1QjM5QixlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWE0Z0Msd0JBQXdCLE1BQU07UUFDNUQ3K0IsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQW1CLEVBQUV3a0I7SUFDckU7SUFDQSxNQUFNa0ksa0JBQWtCN2xDLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJdUcsaUJBQWlCcGMsYUFBYThvQyxtQkFBbUIsTUFBTTtRQUN2RC9tQyxlQUFlcWEsY0FBYztZQUFDO1lBQWM7U0FBYyxFQUFFMHNCO0lBQ2hFO0lBQ0EsTUFBTTNHLHFCQUFxQmwvQixlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFtaUMsc0JBQXNCLE1BQU07UUFDMURwZ0MsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWlCLEVBQUUrbEI7SUFDbkU7SUFDQSxNQUFNQyxvQkFBb0JuL0IsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhb2lDLHFCQUFxQixNQUFNO1FBQ3pEcmdDLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFnQixFQUFFZ21CO0lBQ2xFO0lBQ0EsTUFBTTJHLG9CQUFvQjlsQyxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWErb0MscUJBQXFCLE1BQU07UUFDekRobkMsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1NBQWdCLEVBQUUyc0I7SUFDbEU7SUFDQSxNQUFNQyxnQkFBZ0IvbEMsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUl1RyxpQkFBaUJwYyxhQUFhZ3BDLGlCQUFpQixNQUFNO1FBQ3JEam5DLGVBQWVxYSxjQUFjO1lBQUM7WUFBZ0I7U0FBWSxFQUFFOG9CLGNBQWM4RDtJQUM5RTtJQUNBLE1BQU1yQyxzQkFBc0IxakMsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhMm1DLHVCQUF1QixNQUFNO1FBQzNELElBQUl2dkIsa0JBQWtCdXZCO1FBQ3RCLElBQUlwa0MsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU9tNUIsc0NBQXNDbjVCO1lBQ2pEO1FBQ0o7UUFDQXpOLGVBQWVxYSxjQUFjO1lBQUM7WUFBZ0I7U0FBa0IsRUFBRWhGO0lBQ3RFO0lBQ0EsTUFBTTZ4Qix5QkFBeUJobUMsZUFBZTRTLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhaXBDLDBCQUEwQixNQUFNO1FBQzlEbG5DLGVBQWVxYSxjQUFjO1lBQUM7WUFBYztTQUFxQixFQUFFNnNCO0lBQ3ZFO0lBQ0EsT0FBT256QjtBQUNYO0FBQ0EsU0FBU296QixpQ0FBaUM3NkIsU0FBUyxFQUFFd0gsVUFBVTtJQUMzRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFRLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDbEU7SUFDQSxNQUFNd2pCLGFBQWFuK0IsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUl1ckIsY0FBYyxNQUFNO1FBQ3BCci9CLGVBQWUrVCxVQUFVO1lBQUM7WUFBZ0I7U0FBUyxFQUFFc3JCO0lBQ3pEO0lBQ0EsTUFBTWtCLFlBQVlyL0IsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUl5c0IsYUFBYSxNQUFNO1FBQ25CdmdDLGVBQWUrVCxVQUFVO1lBQUM7WUFBZ0I7U0FBUSxFQUFFb3ZCLGNBQWM1QztJQUN0RTtJQUNBLE1BQU0xTSxZQUFZM3lCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK2YsYUFBYSxNQUFNO1FBQ25CN3pCLGVBQWUrVCxVQUFVO1lBQUM7WUFBZ0I7U0FBUSxFQUFFMnlCLGNBQWM3UztJQUN0RTtJQUNBLE1BQU05WCxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRTh5Qiw2QkFBNkI5cUIsWUFBWWhJO0lBQ2xGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVNxekIsdUJBQXVCdHpCLFVBQVU7SUFDdEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1DLFVBQVU5UyxlQUFlNFMsWUFBWTtRQUFDO0tBQU07SUFDbEQsSUFBSUUsV0FBVyxNQUFNO1FBQ2pCaFUsZUFBZStULFVBQVU7WUFBQztTQUFNLEVBQUVDO0lBQ3RDO0lBQ0EsTUFBTUMsZ0JBQWdCL1MsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlHLGlCQUFpQixNQUFNO1FBQ3ZCalUsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVFO0lBQzVDO0lBQ0EsTUFBTUMsa0JBQWtCaFQsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlJLG1CQUFtQixNQUFNO1FBQ3pCbFUsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVHO0lBQzlDO0lBQ0EsT0FBT0g7QUFDWDtBQUNBLFNBQVNzekIsY0FBY3Z6QixVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNSyxXQUFXbFQsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUlNLFlBQVksTUFBTTtRQUNsQnBVLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFSztJQUN2QztJQUNBLE1BQU1DLGVBQWVuVCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSU8sZ0JBQWdCLE1BQU07UUFDdEJyVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRU07SUFDM0M7SUFDQSxPQUFPTjtBQUNYO0FBQ0EsU0FBU3V6QixrQkFBa0J4ekIsVUFBVTtJQUNqQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTVEsY0FBY3JULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJUyxlQUFlLE1BQU07UUFDckJ2VSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVE7SUFDMUM7SUFDQSxNQUFNRixlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVN3ekIsY0FBY3p6QixVQUFVO0lBQzdCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNVSxvQkFBb0J2VCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSVcscUJBQXFCLE1BQU07UUFDM0J6VSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVxekIsdUJBQXVCM3lCO0lBQ3ZFO0lBQ0EsTUFBTUMsY0FBY3hULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJWSxlQUFlLE1BQU07UUFDckIxVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVc7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUJ6VCxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWEsa0JBQWtCLE1BQU07UUFDeEIzVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXN6QixjQUFjMXlCO0lBQzNEO0lBQ0EsTUFBTUMsZUFBZTFULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJYyxnQkFBZ0IsTUFBTTtRQUN0QjVVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFdXpCLGtCQUFrQjF5QjtJQUM3RDtJQUNBLE1BQU1DLHVCQUF1QjNULGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJZSx3QkFBd0IsTUFBTTtRQUM5QjdVLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWM7SUFDbkQ7SUFDQSxNQUFNQywwQkFBMEI1VCxlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSWdCLDJCQUEyQixNQUFNO1FBQ2pDOVUsZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFZTtJQUN0RDtJQUNBLE1BQU1DLHFCQUFxQjdULGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJaUIsc0JBQXNCLE1BQU07UUFDNUIvVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVnQjtJQUNqRDtJQUNBLE1BQU1DLG1CQUFtQjlULGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJa0Isb0JBQW9CLE1BQU07UUFDMUJoVixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRWlCO0lBQy9DO0lBQ0EsTUFBTUMsdUJBQXVCL1QsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUltQix3QkFBd0IsTUFBTTtRQUM5QmpWLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWtCO0lBQ25EO0lBQ0EsTUFBTUMsV0FBV2hVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJb0IsWUFBWSxNQUFNO1FBQ2xCbFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVtQjtJQUN2QztJQUNBLE9BQU9uQjtBQUNYO0FBQ0EsU0FBU3l6QixpQkFBaUIxekIsVUFBVTtJQUNoQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFCLFlBQVlsVSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXNCLGFBQWEsTUFBTTtRQUNuQixJQUFJQyxrQkFBa0JEO1FBQ3RCLElBQUk1VSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBTzg1QixjQUFjOTVCO1lBQ3pCO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFc0I7SUFDeEM7SUFDQSxNQUFNQyxXQUFXcFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl3QixZQUFZLE1BQU07UUFDbEJ0VixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXVCO0lBQ3ZDO0lBQ0EsT0FBT3ZCO0FBQ1g7QUFDQSxTQUFTMHpCLDBCQUEwQjN6QixVQUFVO0lBQ3pDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNa0ssZ0JBQWdCL2MsZUFBZTRTLFlBQVk7UUFBQztLQUFrQjtJQUNwRSxJQUFJbUssaUJBQWlCLE1BQU07UUFDdkJqZSxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRWtLO0lBQzVDO0lBQ0EsT0FBT2xLO0FBQ1g7QUFDQSxTQUFTMnpCLHFCQUFxQjV6QixVQUFVO0lBQ3BDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0ssbUJBQW1CamQsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUlxSyxvQkFBb0IsTUFBTTtRQUMxQm5lLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFb0s7SUFDL0M7SUFDQSxNQUFNQyx5QkFBeUJsZCxlQUFlNFMsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSXNLLDBCQUEwQixNQUFNO1FBQ2hDcGUsZUFBZStULFVBQVU7WUFBQztTQUFxQixFQUFFcUs7SUFDckQ7SUFDQSxPQUFPcks7QUFDWDtBQUNBLFNBQVM0ekIsNEJBQTRCN3pCLFVBQVU7SUFDM0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU11SyxrQkFBa0JwZCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXdLLG1CQUFtQixNQUFNO1FBQ3pCLElBQUlqSixrQkFBa0JpSjtRQUN0QixJQUFJOWQsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU9pNkIscUJBQXFCajZCO1lBQ2hDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFc0I7SUFDOUM7SUFDQSxPQUFPdEI7QUFDWDtBQUNBLFNBQVM2ekIsbUJBQW1COXpCLFVBQVU7SUFDbEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU15SyxjQUFjdGQsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUkwSyxlQUFlLE1BQU07UUFDckJ4ZSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRXl6QixpQkFBaUJocEI7SUFDM0Q7SUFDQSxNQUFNQyx1QkFBdUJ2ZCxlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSTJLLHdCQUF3QixNQUFNO1FBQzlCemUsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFMHpCLDBCQUEwQmhwQjtJQUM3RTtJQUNBLE1BQU1DLGlCQUFpQnhkLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJNEssa0JBQWtCLE1BQU07UUFDeEIxZSxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRTJLO0lBQzdDO0lBQ0EsTUFBTUMsbUJBQW1CemQsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUk2SyxvQkFBb0IsTUFBTTtRQUMxQjNlLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFNEs7SUFDL0M7SUFDQSxNQUFNQyx5QkFBeUIxZCxlQUFlNFMsWUFBWTtRQUN0RDtLQUNIO0lBQ0QsSUFBSThLLDBCQUEwQixNQUFNO1FBQ2hDNWUsZUFBZStULFVBQVU7WUFBQztTQUFxQixFQUFFNHpCLDRCQUE0Qi9vQjtJQUNqRjtJQUNBLE1BQU1DLGtCQUFrQjNkLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJK0ssbUJBQW1CLE1BQU07UUFDekI3ZSxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRThLO0lBQzlDO0lBQ0EsTUFBTUMsd0JBQXdCNWQsZUFBZTRTLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUlnTCx5QkFBeUIsTUFBTTtRQUMvQjllLGVBQWUrVCxVQUFVO1lBQUM7U0FBb0IsRUFBRStLO0lBQ3BEO0lBQ0EsTUFBTUMsWUFBWTdkLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJaUwsYUFBYSxNQUFNO1FBQ25CL2UsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUVnTDtJQUN4QztJQUNBLE1BQU1DLHFCQUFxQjlkLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJa0wsc0JBQXNCLE1BQU07UUFDNUJoZixlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVpTDtJQUNqRDtJQUNBLE1BQU1DLG9CQUFvQi9kLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJbUwscUJBQXFCLE1BQU07UUFDM0JqZixlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVrTDtJQUNoRDtJQUNBLE9BQU9sTDtBQUNYO0FBQ0EsU0FBUzh6QixpQ0FBaUMvekIsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9MLHNCQUFzQmplLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcUwsdUJBQXVCLE1BQU07UUFDN0JuZixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVvTDtJQUNsRDtJQUNBLE1BQU1DLGlCQUFpQmxlLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJc0wsa0JBQWtCLE1BQU07UUFDeEIsSUFBSS9KLGtCQUFrQitKO1FBQ3RCLElBQUk1ZSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT202QixtQkFBbUJuNkI7WUFDOUI7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVzQjtJQUM3QztJQUNBLE1BQU1nSyxtQkFBbUJuZSxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXVMLG9CQUFvQixNQUFNO1FBQzFCcmYsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVzTDtJQUMvQztJQUNBLE1BQU1DLHFCQUFxQnBlLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJd0wsc0JBQXNCLE1BQU07UUFDNUJ0ZixlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUV1TDtJQUNqRDtJQUNBLE1BQU1DLGlCQUFpQnJlLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJeUwsa0JBQWtCLE1BQU07UUFDeEJ2ZixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXdMO0lBQzdDO0lBQ0EsTUFBTUMsb0JBQW9CdGUsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUkwTCxxQkFBcUIsTUFBTTtRQUMzQnhmLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXlMO0lBQ2hEO0lBQ0EsT0FBT3pMO0FBQ1g7QUFDQSxTQUFTK3pCLDBCQUEwQmgwQixVQUFVO0lBQ3pDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNZzBCLGFBQWE3bUMsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpMEIsY0FBYyxNQUFNO1FBQ3BCL25DLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFZzBCO0lBQ3pDO0lBQ0EsT0FBT2gwQjtBQUNYO0FBQ0EsU0FBU2kwQjtJQUNMLE1BQU1qMEIsV0FBVyxDQUFDO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQSxTQUFTazBCLDhCQUE4Qm4wQixVQUFVO0lBQzdDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0wsc0JBQXNCamUsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxTCx1QkFBdUIsTUFBTTtRQUM3Qm5mLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW9MO0lBQ2xEO0lBQ0EsTUFBTStvQixpQkFBaUJobkMsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlvMEIsa0JBQWtCLE1BQU07UUFDeEIsSUFBSTd5QixrQkFBa0I2eUI7UUFDdEIsSUFBSTFuQyxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3E2QiwwQkFBMEJyNkI7WUFDckM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVzQjtJQUM3QztJQUNBLE1BQU04eUIsZUFBZWpuQyxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXEwQixnQkFBZ0IsTUFBTTtRQUN0Qm5vQyxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRWkwQjtJQUMzQztJQUNBLE9BQU9qMEI7QUFDWDtBQUNBLFNBQVNxMEIsZUFBZXQwQixVQUFVO0lBQzlCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOUMsaUJBQWlCL1AsZUFBZTRTLFlBQVk7UUFDOUM7S0FDSDtJQUNELElBQUk3QyxrQkFBa0IsTUFBTTtRQUN4QmpSLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFL0MsT0FBT0M7SUFDcEQ7SUFDQSxNQUFNb0QsZUFBZW5ULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJTyxnQkFBZ0IsTUFBTTtRQUN0QnJVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFTTtJQUMzQztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTczBCLDBCQUEwQnYwQixVQUFVO0lBQ3pDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNdTBCLGlCQUFpQnBuQyxlQUFlNFMsWUFBWTtRQUM5QztRQUNBO0tBQ0g7SUFDRCxJQUFJdzBCLGtCQUFrQixNQUFNO1FBQ3hCdG9DLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFdTBCO0lBQzdDO0lBQ0EsTUFBTUMsYUFBYXJuQyxlQUFlNFMsWUFBWTtRQUMxQztRQUNBO0tBQ0g7SUFDRCxJQUFJeTBCLGNBQWMsTUFBTTtRQUNwQnZvQyxlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRXcwQjtJQUN6QztJQUNBLE1BQU1DLGtCQUFrQnRuQyxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTAwQixtQkFBbUIsTUFBTTtRQUN6QnhvQyxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXkwQjtJQUM5QztJQUNBLE9BQU96MEI7QUFDWDtBQUNBLFNBQVMwMEIsd0JBQXdCMzBCLFVBQVU7SUFDdkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU13c0IsWUFBWXIvQixlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXlzQixhQUFhLE1BQU07UUFDbkJ2Z0MsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUVxMEIsZUFBZTdIO0lBQ3ZEO0lBQ0EsTUFBTW1JLHdCQUF3QnhuQyxlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSTQwQix5QkFBeUIsTUFBTTtRQUMvQjFvQyxlQUFlK1QsVUFBVTtZQUFDO1NBQW9CLEVBQUUyMEI7SUFDcEQ7SUFDQSxNQUFNQyx1QkFBdUJ6bkMsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ2pFLElBQUk2MEIsd0JBQXdCLE1BQU07UUFDOUIzb0MsZUFBZStULFVBQVU7WUFBQztTQUFtQixFQUFFczBCLDBCQUEwQk07SUFDN0U7SUFDQSxPQUFPNTBCO0FBQ1g7QUFDQSxTQUFTNjBCLGdDQUFnQzkwQixVQUFVO0lBQy9DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0wsc0JBQXNCamUsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxTCx1QkFBdUIsTUFBTTtRQUM3Qm5mLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW9MO0lBQ2xEO0lBQ0EsTUFBTTBwQixzQkFBc0IzbkMsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkrMEIsdUJBQXVCLE1BQU07UUFDN0IsSUFBSXh6QixrQkFBa0J3ekI7UUFDdEIsSUFBSXJvQyxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT2c3Qix3QkFBd0JoN0I7WUFDbkM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFc0I7SUFDbEQ7SUFDQSxNQUFNeXpCLHFDQUFxQzVuQyxlQUFlNFMsWUFBWTtRQUNsRTtLQUNIO0lBQ0QsSUFBSWcxQixzQ0FBc0MsTUFBTTtRQUM1QzlvQyxlQUFlK1QsVUFBVTtZQUFDO1NBQWlDLEVBQUVzMEIsMEJBQTBCUztJQUMzRjtJQUNBLE9BQU8vMEI7QUFDWDtBQUNBLFNBQVNnMUIsd0JBQXdCajFCLFVBQVU7SUFDdkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pMUIsZ0JBQWdCOW5DLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJazFCLGlCQUFpQixNQUFNO1FBQ3ZCaHBDLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFaTFCO0lBQzVDO0lBQ0EsTUFBTTdvQixpQkFBaUJqZixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXFNLGtCQUFrQixNQUFNO1FBQ3hCbmdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFb007SUFDN0M7SUFDQSxNQUFNQyxpQkFBaUJsZixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXNNLGtCQUFrQixNQUFNO1FBQ3hCcGdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFcU07SUFDN0M7SUFDQSxPQUFPck07QUFDWDtBQUNBLFNBQVNrMUIsZUFBZW4xQixVQUFVO0lBQzlCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV6QztJQUN2QztJQUNBLE1BQU04SyxrQkFBa0JsYixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXNJLG1CQUFtQixNQUFNO1FBQ3pCcGMsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVxSTtJQUM5QztJQUNBLE1BQU0xRyxrQkFBa0J4VSxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTRCLG1CQUFtQixNQUFNO1FBQ3pCMVYsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUUyQjtJQUM5QztJQUNBLE1BQU13ekIsY0FBY2hvQyxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSW8xQixlQUFlLE1BQU07UUFDckJscEMsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUVtMUI7SUFDMUM7SUFDQSxNQUFNQyxxQkFBcUJqb0MsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQy9ELElBQUlxMUIsc0JBQXNCLE1BQU07UUFDNUJucEMsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFZzFCLHdCQUF3Qkk7SUFDekU7SUFDQSxNQUFNQyxzQkFBc0Jsb0MsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlzMUIsdUJBQXVCLE1BQU07UUFDN0JwcEMsZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFcTFCO0lBQ2xEO0lBQ0EsTUFBTUMsdUJBQXVCbm9DLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJdTFCLHdCQUF3QixNQUFNO1FBQzlCcnBDLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRXMxQjtJQUNuRDtJQUNBLE1BQU1DLHVCQUF1QnBvQyxlQUFlNFMsWUFBWTtRQUNwRDtLQUNIO0lBQ0QsSUFBSXcxQix3QkFBd0IsTUFBTTtRQUM5QnRwQyxlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUV1MUI7SUFDbkQ7SUFDQSxPQUFPdjFCO0FBQ1g7QUFDQSxTQUFTdzFCLDRCQUE0QnoxQixVQUFVO0lBQzNDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0wsc0JBQXNCamUsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxTCx1QkFBdUIsTUFBTTtRQUM3Qm5mLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW9MO0lBQ2xEO0lBQ0EsTUFBTW1CLG9CQUFvQnBmLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJd00scUJBQXFCLE1BQU07UUFDM0J0Z0IsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFdU07SUFDaEQ7SUFDQSxNQUFNa3BCLGFBQWF0b0MsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3ZELElBQUkwMUIsY0FBYyxNQUFNO1FBQ3BCLElBQUluMEIsa0JBQWtCMUQsZUFBZTYzQjtRQUNyQyxJQUFJaHBDLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPdzdCLGVBQWV4N0I7WUFDMUI7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVzQjtJQUN6QztJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBUzAxQjtJQUNMLE1BQU0xMUIsV0FBVyxDQUFDO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQSxTQUFTMjFCLDZCQUE2QjUxQixVQUFVO0lBQzVDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0wsc0JBQXNCamUsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxTCx1QkFBdUIsTUFBTTtRQUM3Qm5mLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW9MO0lBQ2xEO0lBQ0EsTUFBTXdxQixrQkFBa0J6b0MsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUk2MUIsbUJBQW1CLE1BQU07UUFDekIzcEMsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUU0MUI7SUFDOUM7SUFDQSxNQUFNeFEsOEJBQThCajRCLGVBQWU0UyxZQUFZO1FBQzNEO0tBQ0g7SUFDRCxJQUFJcWxCLCtCQUErQixNQUFNO1FBQ3JDbjVCLGVBQWUrVCxVQUFVO1lBQUM7U0FBMEIsRUFBRW9sQjtJQUMxRDtJQUNBLE9BQU9wbEI7QUFDWDtBQUNBLFNBQVM2MUIsZUFBZTkxQixVQUFVO0lBQzlCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb2IsVUFBVWp1QixlQUFlNFMsWUFBWTtRQUFDO1FBQVM7S0FBTTtJQUMzRCxJQUFJcWIsV0FBVyxNQUFNO1FBQ2pCbnZCLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFb2I7SUFDdEM7SUFDQSxNQUFNd1gsaUJBQWlCemxDLGVBQWU0UyxZQUFZO1FBQzlDO1FBQ0E7S0FDSDtJQUNELElBQUk2eUIsa0JBQWtCLE1BQU07UUFDeEIzbUMsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUUvQyxPQUFPMjFCO0lBQ3BEO0lBQ0EsTUFBTXR5QixlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVM4MUIsd0JBQXdCLzFCLFVBQVU7SUFDdkMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04ZixZQUFZM3lCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK2YsYUFBYSxNQUFNO1FBQ25CN3pCLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFNjFCLGVBQWUvVjtJQUN2RDtJQUNBLE9BQU85ZjtBQUNYO0FBQ0EsU0FBUysxQixnQ0FBZ0NoMkIsVUFBVTtJQUMvQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWcyQixzQkFBc0I3b0MsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlpMkIsdUJBQXVCLE1BQU07UUFDN0IsSUFBSTEwQixrQkFBa0IwMEI7UUFDdEIsSUFBSXZwQyxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT284Qix3QkFBd0JwOEI7WUFDbkM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFc0I7SUFDbEQ7SUFDQSxNQUFNMjBCLDRCQUE0QjlvQyxlQUFlNFMsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSWsyQiw2QkFBNkIsTUFBTTtRQUNuQ2hxQyxlQUFlK1QsVUFBVTtZQUFDO1NBQXdCLEVBQUVpMkI7SUFDeEQ7SUFDQSxNQUFNQyw4QkFBOEIvb0MsZUFBZTRTLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUltMkIsK0JBQStCLE1BQU07UUFDckNqcUMsZUFBZStULFVBQVU7WUFBQztTQUEwQixFQUFFazJCO0lBQzFEO0lBQ0EsT0FBT2wyQjtBQUNYO0FBQ0EsU0FBU20yQixpQ0FBaUNwMkIsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXpDLFdBQVdwUSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXhDLFlBQVksTUFBTTtRQUNsQnRSLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFekM7SUFDdkM7SUFDQSxNQUFNNjJCLGVBQWVqbkMsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlxMEIsZ0JBQWdCLE1BQU07UUFDdEJub0MsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVvMEI7SUFDM0M7SUFDQSxNQUFNMW5CLFdBQVd2ZixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTJNLFlBQVksTUFBTTtRQUNsQnpnQixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRTBNO0lBQ3ZDO0lBQ0EsTUFBTVgsWUFBWTVlLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJZ00sYUFBYSxNQUFNO1FBQ25COWYsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUUrTDtJQUN4QztJQUNBLE1BQU16SSxlQUFlblcsZUFBZTRTLFlBQVk7UUFDNUM7UUFDQTtLQUNIO0lBQ0QsSUFBSXVELGdCQUFnQixNQUFNO1FBQ3RCclgsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUUrMUIsZ0NBQWdDenlCO0lBQzNFO0lBQ0EsT0FBT3REO0FBQ1g7QUFDQSxTQUFTbzJCLHdCQUF3QnIyQixVQUFVO0lBQ3ZDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNQyxVQUFVOVMsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUlFLFdBQVcsTUFBTTtRQUNqQmhVLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFQztJQUN0QztJQUNBLE1BQU1DLGdCQUFnQi9TLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJRyxpQkFBaUIsTUFBTTtRQUN2QmpVLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFRTtJQUM1QztJQUNBLE1BQU1DLGtCQUFrQmhULGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJSSxtQkFBbUIsTUFBTTtRQUN6QmxVLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFRztJQUM5QztJQUNBLE9BQU9IO0FBQ1g7QUFDQSxTQUFTcTJCLGVBQWV0MkIsVUFBVTtJQUM5QixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFJLGtCQUFrQmxiLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJc0ksbUJBQW1CLE1BQU07UUFDekJwYyxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRXFJO0lBQzlDO0lBQ0EsTUFBTWhJLFdBQVdsVCxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSU0sWUFBWSxNQUFNO1FBQ2xCcFUsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVLO0lBQ3ZDO0lBQ0EsTUFBTUMsZUFBZW5ULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJTyxnQkFBZ0IsTUFBTTtRQUN0QnJVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFTTtJQUMzQztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTczJCLG1CQUFtQnYyQixVQUFVO0lBQ2xDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNcUksa0JBQWtCbGIsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUlzSSxtQkFBbUIsTUFBTTtRQUN6QnBjLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFcUk7SUFDOUM7SUFDQSxNQUFNN0gsY0FBY3JULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJUyxlQUFlLE1BQU07UUFDckJ2VSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVE7SUFDMUM7SUFDQSxNQUFNRixlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVN1MkIsZUFBZXgyQixVQUFVO0lBQzlCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNVSxvQkFBb0J2VCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSVcscUJBQXFCLE1BQU07UUFDM0J6VSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVvMkIsd0JBQXdCMTFCO0lBQ3hFO0lBQ0EsTUFBTUMsY0FBY3hULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJWSxlQUFlLE1BQU07UUFDckIxVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVc7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUJ6VCxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWEsa0JBQWtCLE1BQU07UUFDeEIzVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXEyQixlQUFlejFCO0lBQzVEO0lBQ0EsTUFBTUMsZUFBZTFULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJYyxnQkFBZ0IsTUFBTTtRQUN0QjVVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFczJCLG1CQUFtQnoxQjtJQUM5RDtJQUNBLE1BQU1DLHVCQUF1QjNULGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJZSx3QkFBd0IsTUFBTTtRQUM5QjdVLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWM7SUFDbkQ7SUFDQSxNQUFNQywwQkFBMEI1VCxlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSWdCLDJCQUEyQixNQUFNO1FBQ2pDOVUsZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFZTtJQUN0RDtJQUNBLE1BQU1DLHFCQUFxQjdULGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJaUIsc0JBQXNCLE1BQU07UUFDNUIvVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVnQjtJQUNqRDtJQUNBLE1BQU1DLG1CQUFtQjlULGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJa0Isb0JBQW9CLE1BQU07UUFDMUJoVixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRWlCO0lBQy9DO0lBQ0EsTUFBTUMsdUJBQXVCL1QsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUltQix3QkFBd0IsTUFBTTtRQUM5QmpWLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWtCO0lBQ25EO0lBQ0EsTUFBTUMsV0FBV2hVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJb0IsWUFBWSxNQUFNO1FBQ2xCbFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVtQjtJQUN2QztJQUNBLE9BQU9uQjtBQUNYO0FBQ0EsU0FBU3cyQixrQkFBa0J6MkIsVUFBVTtJQUNqQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXFCLFlBQVlsVSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSXNCLGFBQWEsTUFBTTtRQUNuQixJQUFJQyxrQkFBa0JEO1FBQ3RCLElBQUk1VSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBTzY4QixlQUFlNzhCO1lBQzFCO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFc0I7SUFDeEM7SUFDQSxNQUFNQyxXQUFXcFUsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl3QixZQUFZLE1BQU07UUFDbEJ0VixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXVCO0lBQ3ZDO0lBQ0EsT0FBT3ZCO0FBQ1g7QUFDQSxTQUFTeTJCLDJCQUEyQjEyQixVQUFVO0lBQzFDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNa0ssZ0JBQWdCL2MsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUltSyxpQkFBaUIsTUFBTTtRQUN2QmplLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFa0s7SUFDNUM7SUFDQSxPQUFPbEs7QUFDWDtBQUNBLFNBQVMwMkIsc0JBQXNCMzJCLFVBQVU7SUFDckMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vSyxtQkFBbUJqZCxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXFLLG9CQUFvQixNQUFNO1FBQzFCbmUsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUVvSztJQUMvQztJQUNBLE1BQU1DLHlCQUF5QmxkLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJc0ssMEJBQTBCLE1BQU07UUFDaENwZSxlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUVxSztJQUNyRDtJQUNBLE9BQU9ySztBQUNYO0FBQ0EsU0FBUzIyQiw2QkFBNkI1MkIsVUFBVTtJQUM1QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXVLLGtCQUFrQnBkLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJd0ssbUJBQW1CLE1BQU07UUFDekIsSUFBSWpKLGtCQUFrQmlKO1FBQ3RCLElBQUk5ZCxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT2c5QixzQkFBc0JoOUI7WUFDakM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVzQjtJQUM5QztJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBUzQyQixvQkFBb0I3MkIsVUFBVTtJQUNuQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXlLLGNBQWN0ZCxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSTBLLGVBQWUsTUFBTTtRQUNyQnhlLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFdzJCLGtCQUFrQi9yQjtJQUM1RDtJQUNBLE1BQU1DLHVCQUF1QnZkLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJMkssd0JBQXdCLE1BQU07UUFDOUJ6ZSxlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUV5MkIsMkJBQTJCL3JCO0lBQzlFO0lBQ0EsTUFBTW1zQixvQkFBb0IxcEMsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUk4MkIscUJBQXFCLE1BQU07UUFDM0I1cUMsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFNjJCO0lBQ2hEO0lBQ0EsTUFBTWpzQixtQkFBbUJ6ZCxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSTZLLG9CQUFvQixNQUFNO1FBQzFCM2UsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUU0SztJQUMvQztJQUNBLE1BQU1DLHlCQUF5QjFkLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJOEssMEJBQTBCLE1BQU07UUFDaEM1ZSxlQUFlK1QsVUFBVTtZQUFDO1NBQXFCLEVBQUUyMkIsNkJBQTZCOXJCO0lBQ2xGO0lBQ0EsTUFBTUMsa0JBQWtCM2QsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrSyxtQkFBbUIsTUFBTTtRQUN6QjdlLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFOEs7SUFDOUM7SUFDQSxNQUFNQyx3QkFBd0I1ZCxlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSWdMLHlCQUF5QixNQUFNO1FBQy9COWUsZUFBZStULFVBQVU7WUFBQztTQUFvQixFQUFFK0s7SUFDcEQ7SUFDQSxNQUFNQyxZQUFZN2QsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlpTCxhQUFhLE1BQU07UUFDbkIvZSxlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRWdMO0lBQ3hDO0lBQ0EsTUFBTUMscUJBQXFCOWQsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUlrTCxzQkFBc0IsTUFBTTtRQUM1QmhmLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRWlMO0lBQ2pEO0lBQ0EsTUFBTUMsb0JBQW9CL2QsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUltTCxxQkFBcUIsTUFBTTtRQUMzQmpmLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRWtMO0lBQ2hEO0lBQ0EsT0FBT2xMO0FBQ1g7QUFDQSxTQUFTODJCLGtDQUFrQy8yQixVQUFVO0lBQ2pELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0wsc0JBQXNCamUsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxTCx1QkFBdUIsTUFBTTtRQUM3Qm5mLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW9MO0lBQ2xEO0lBQ0EsTUFBTUMsaUJBQWlCbGUsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlzTCxrQkFBa0IsTUFBTTtRQUN4QixJQUFJL0osa0JBQWtCK0o7UUFDdEIsSUFBSTVlLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPazlCLG9CQUFvQmw5QjtZQUMvQjtRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXNCO0lBQzdDO0lBQ0EsTUFBTThLLGlCQUFpQmpmLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJcU0sa0JBQWtCLE1BQU07UUFDeEJuZ0IsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVvTTtJQUM3QztJQUNBLE1BQU1kLG1CQUFtQm5lLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJdUwsb0JBQW9CLE1BQU07UUFDMUJyZixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRXNMO0lBQy9DO0lBQ0EsTUFBTUMscUJBQXFCcGUsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUl3TCxzQkFBc0IsTUFBTTtRQUM1QnRmLGVBQWUrVCxVQUFVO1lBQUM7U0FBaUIsRUFBRXVMO0lBQ2pEO0lBQ0EsTUFBTUMsaUJBQWlCcmUsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUl5TCxrQkFBa0IsTUFBTTtRQUN4QnZmLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFd0w7SUFDN0M7SUFDQSxNQUFNQyxvQkFBb0J0ZSxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSTBMLHFCQUFxQixNQUFNO1FBQzNCeGYsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFeUw7SUFDaEQ7SUFDQSxPQUFPekw7QUFDWDtBQUNBLFNBQVMrMkIscUNBQXFDaDNCLFVBQVU7SUFDcEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1nM0IsZ0JBQWdCN3BDLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJaTNCLGlCQUFpQixNQUFNO1FBQ3ZCL3FDLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFZzNCO0lBQzVDO0lBQ0EsTUFBTXJzQixpQkFBaUJ4ZCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDakUsSUFBSTRLLGtCQUFrQixNQUFNO1FBQ3hCMWUsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUUySztJQUM3QztJQUNBLE9BQU8zSztBQUNYO0FBQ0EsU0FBU2kzQiwyQkFBMkJsM0IsVUFBVTtJQUMxQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWcwQixhQUFhN21DLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaTBCLGNBQWMsTUFBTTtRQUNwQi9uQyxlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWcwQjtJQUN6QztJQUNBLE1BQU1rRCxpQkFBaUIvcEMsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUltM0Isa0JBQWtCLE1BQU07UUFDeEJqckMsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUUrMkIscUNBQXFDRztJQUNsRjtJQUNBLE9BQU9sM0I7QUFDWDtBQUNBLFNBQVNtM0IsK0JBQStCcDNCLFVBQVU7SUFDOUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vM0IsNkJBQTZCanFDLGVBQWU0UyxZQUFZO1FBQzFEO0tBQ0g7SUFDRCxJQUFJcTNCLDhCQUE4QixNQUFNO1FBQ3BDbnJDLGVBQWUrVCxVQUFVO1lBQUM7U0FBeUIsRUFBRW8zQjtJQUN6RDtJQUNBLE9BQU9wM0I7QUFDWDtBQUNBLFNBQVNxM0IsK0JBQStCdDNCLFVBQVU7SUFDOUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vTCxzQkFBc0JqZSxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSXFMLHVCQUF1QixNQUFNO1FBQzdCbmYsZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFb0w7SUFDbEQ7SUFDQSxNQUFNK29CLGlCQUFpQmhuQyxlQUFlNFMsWUFBWTtRQUM5QztRQUNBO0tBQ0g7SUFDRCxJQUFJbzBCLGtCQUFrQixNQUFNO1FBQ3hCLElBQUk3eUIsa0JBQWtCNnlCO1FBQ3RCLElBQUkxbkMsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU91OUIsMkJBQTJCdjlCO1lBQ3RDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFc0I7SUFDN0M7SUFDQSxNQUFNOHlCLGVBQWVqbkMsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlxMEIsZ0JBQWdCLE1BQU07UUFDdEJub0MsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVtM0IsK0JBQStCL0M7SUFDMUU7SUFDQSxPQUFPcDBCO0FBQ1g7QUFDQSxTQUFTczNCLGdCQUFnQnYzQixVQUFVO0lBQy9CLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNZ0osYUFBYTdiLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUosY0FBYyxNQUFNO1FBQ3BCL2MsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVnSjtJQUN6QztJQUNBLE1BQU05TCxpQkFBaUIvUCxlQUFlNFMsWUFBWTtRQUM5QztLQUNIO0lBQ0QsSUFBSTdDLGtCQUFrQixNQUFNO1FBQ3hCalIsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUUvQyxPQUFPQztJQUNwRDtJQUNBLE1BQU1vRCxlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVN1M0IsMkJBQTJCeDNCLFVBQVU7SUFDMUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU11MEIsaUJBQWlCcG5DLGVBQWU0UyxZQUFZO1FBQzlDO1FBQ0E7S0FDSDtJQUNELElBQUl3MEIsa0JBQWtCLE1BQU07UUFDeEJ0b0MsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUV1MEI7SUFDN0M7SUFDQSxNQUFNQyxhQUFhcm5DLGVBQWU0UyxZQUFZO1FBQzFDO1FBQ0E7S0FDSDtJQUNELElBQUl5MEIsY0FBYyxNQUFNO1FBQ3BCdm9DLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFdzBCO0lBQ3pDO0lBQ0EsTUFBTUMsa0JBQWtCdG5DLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJMDBCLG1CQUFtQixNQUFNO1FBQ3pCeG9DLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFeTBCO0lBQzlDO0lBQ0EsT0FBT3owQjtBQUNYO0FBQ0EsU0FBU3czQix5QkFBeUJ6M0IsVUFBVTtJQUN4QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXdzQixZQUFZci9CLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJeXNCLGFBQWEsTUFBTTtRQUNuQnZnQyxlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRXMzQixnQkFBZ0I5SztJQUN4RDtJQUNBLE1BQU1tSSx3QkFBd0J4bkMsZUFBZTRTLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUk0MEIseUJBQXlCLE1BQU07UUFDL0Ixb0MsZUFBZStULFVBQVU7WUFBQztTQUFvQixFQUFFMjBCO0lBQ3BEO0lBQ0EsTUFBTUMsdUJBQXVCem5DLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUNqRSxJQUFJNjBCLHdCQUF3QixNQUFNO1FBQzlCM29DLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRXUzQiwyQkFBMkIzQztJQUM5RTtJQUNBLE1BQU02QyxxQkFBcUJ0cUMsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ2hFLElBQUkwM0Isc0JBQXNCLE1BQU07UUFDNUJ4ckMsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFeTNCO0lBQ2pEO0lBQ0EsT0FBT3ozQjtBQUNYO0FBQ0EsU0FBUzAzQixpQ0FBaUMzM0IsVUFBVTtJQUNoRCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9MLHNCQUFzQmplLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcUwsdUJBQXVCLE1BQU07UUFDN0JuZixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVvTDtJQUNsRDtJQUNBLE1BQU0wcEIsc0JBQXNCM25DLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJKzBCLHVCQUF1QixNQUFNO1FBQzdCLElBQUl4ekIsa0JBQWtCd3pCO1FBQ3RCLElBQUlyb0MsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU84OUIseUJBQXlCOTlCO1lBQ3BDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRXNCO0lBQ2xEO0lBQ0EsTUFBTXl6QixxQ0FBcUM1bkMsZUFBZTRTLFlBQVk7UUFDbEU7S0FDSDtJQUNELElBQUlnMUIsc0NBQXNDLE1BQU07UUFDNUM5b0MsZUFBZStULFVBQVU7WUFBQztTQUFpQyxFQUFFdTNCLDJCQUEyQnhDO0lBQzVGO0lBQ0EsT0FBTy8wQjtBQUNYO0FBQ0EsU0FBUzIzQiw0QkFBNEI1M0IsVUFBVTtJQUMzQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9MLHNCQUFzQmplLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcUwsdUJBQXVCLE1BQU07UUFDN0JuZixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVvTDtJQUNsRDtJQUNBLE1BQU0wcEIsc0JBQXNCM25DLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJKzBCLHVCQUF1QixNQUFNO1FBQzdCLElBQUl4ekIsa0JBQWtCd3pCO1FBQ3RCLElBQUlyb0MsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU84OUIseUJBQXlCOTlCO1lBQ3BDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRXNCO0lBQ2xEO0lBQ0EsT0FBT3RCO0FBQ1g7QUFDQSxTQUFTNDNCLCtCQUErQjczQixVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0wsc0JBQXNCamUsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxTCx1QkFBdUIsTUFBTTtRQUM3Qm5mLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW9MO0lBQ2xEO0lBQ0EsTUFBTTBwQixzQkFBc0IzbkMsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUkrMEIsdUJBQXVCLE1BQU07UUFDN0IsSUFBSXh6QixrQkFBa0J3ekI7UUFDdEIsSUFBSXJvQyxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBTzg5Qix5QkFBeUI5OUI7WUFDcEM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFc0I7SUFDbEQ7SUFDQSxPQUFPdEI7QUFDWDtBQUNBLFNBQVM2M0IsaUNBQWlDOTNCLFVBQVU7SUFDaEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04MEIsc0JBQXNCM25DLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJKzBCLHVCQUF1QixNQUFNO1FBQzdCLElBQUl4ekIsa0JBQWtCd3pCO1FBQ3RCLElBQUlyb0MsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU84OUIseUJBQXlCOTlCO1lBQ3BDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRXNCO0lBQ2xEO0lBQ0EsT0FBT3RCO0FBQ1g7QUFDQSxTQUFTODNCLHNCQUFzQi8zQixVQUFVO0lBQ3JDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNKzNCLFlBQVk1cUMsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlnNEIsYUFBYSxNQUFNO1FBQ25COXJDLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFKzNCO0lBQ3hDO0lBQ0EsTUFBTUMsWUFBWTdxQyxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSWk0QixhQUFhLE1BQU07UUFDbkIvckMsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUVnNEI7SUFDeEM7SUFDQSxPQUFPaDRCO0FBQ1g7QUFDQSxTQUFTaTRCLDZCQUE2Qmw0QixVQUFVO0lBQzVDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNazRCLFdBQVcvcUMsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3JELElBQUltNEIsWUFBWSxNQUFNO1FBQ2xCanNDLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFczNCLGdCQUFnQlk7SUFDdkQ7SUFDQSxNQUFNeEosYUFBYXZoQyxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSTJ1QixjQUFjLE1BQU07UUFDcEIsSUFBSXB0QixrQkFBa0JvdEI7UUFDdEIsSUFBSWppQyxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT28rQixzQkFBc0JwK0I7WUFDakM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVzQjtJQUN6QztJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBU200QiwrQkFBK0JwNEIsVUFBVTtJQUM5QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW80QixxQkFBcUJqckMsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ3JFLElBQUlxNEIsc0JBQXNCLE1BQU07UUFDNUIsSUFBSTkyQixrQkFBa0I4MkI7UUFDdEIsSUFBSTNyQyxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3UrQiw2QkFBNkJ2K0I7WUFDeEM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFc0I7SUFDakQ7SUFDQSxPQUFPdEI7QUFDWDtBQUNBLFNBQVNxNEIsbUJBQW1CdDRCLFVBQVU7SUFDbEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU16QyxXQUFXcFEsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQ3hELElBQUl4QyxZQUFZLE1BQU07UUFDbEJ0UixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXpDO0lBQ3ZDO0lBQ0EsTUFBTSs2QixzQkFBc0JuckMsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUl1NEIsdUJBQXVCLE1BQU07UUFDN0Jyc0MsZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFczRCO0lBQ2xEO0lBQ0EsT0FBT3Q0QjtBQUNYO0FBQ0EsU0FBU3U0Qix5QkFBeUJ4NEIsVUFBVTtJQUN4QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWkxQixnQkFBZ0I5bkMsZUFBZTRTLFlBQVk7UUFDN0M7UUFDQTtLQUNIO0lBQ0QsSUFBSWsxQixpQkFBaUIsTUFBTTtRQUN2QmhwQyxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRWkxQjtJQUM1QztJQUNBLE1BQU03b0IsaUJBQWlCamYsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlxTSxrQkFBa0IsTUFBTTtRQUN4Qm5nQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRW9NO0lBQzdDO0lBQ0EsTUFBTUMsaUJBQWlCbGYsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlzTSxrQkFBa0IsTUFBTTtRQUN4QnBnQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXFNO0lBQzdDO0lBQ0EsT0FBT3JNO0FBQ1g7QUFDQSxTQUFTdzRCLHFCQUFxQno0QixVQUFVO0lBQ3BDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeTRCLG1CQUFtQnRyQyxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSTA0QixvQkFBb0IsTUFBTTtRQUMxQnhzQyxlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRXk0QjtJQUMvQztJQUNBLE1BQU1DLFlBQVl2ckMsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUkyNEIsYUFBYSxNQUFNO1FBQ25CenNDLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFMDRCO0lBQ3hDO0lBQ0EsTUFBTUMsV0FBV3hyQyxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTQ0QixZQUFZLE1BQU07UUFDbEIxc0MsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUUyNEI7SUFDdkM7SUFDQSxPQUFPMzRCO0FBQ1g7QUFDQSxTQUFTNDRCLGdCQUFnQjc0QixVQUFVO0lBQy9CLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV6QztJQUN2QztJQUNBLE1BQU04SyxrQkFBa0JsYixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXNJLG1CQUFtQixNQUFNO1FBQ3pCcGMsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVxSTtJQUM5QztJQUNBLE1BQU0xRyxrQkFBa0J4VSxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTRCLG1CQUFtQixNQUFNO1FBQ3pCMVYsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUUyQjtJQUM5QztJQUNBLE1BQU13ekIsY0FBY2hvQyxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDNUQsSUFBSW8xQixlQUFlLE1BQU07UUFDckJscEMsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUVtMUI7SUFDMUM7SUFDQSxNQUFNMEQsZ0JBQWdCMXJDLGVBQWU0UyxZQUFZO1FBQUM7S0FBaUI7SUFDbkUsSUFBSTg0QixpQkFBaUIsTUFBTTtRQUN2QixJQUFJdjNCLGtCQUFrQnUzQjtRQUN0QixJQUFJcHNDLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPMitCLG1CQUFtQjMrQjtZQUM5QjtRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRXNCO0lBQzVDO0lBQ0EsTUFBTW90QixhQUFhdmhDLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJMnVCLGNBQWMsTUFBTTtRQUNwQnppQyxlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRTB1QjtJQUN6QztJQUNBLE1BQU0wRyxxQkFBcUJqb0MsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQy9ELElBQUlxMUIsc0JBQXNCLE1BQU07UUFDNUJucEMsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFdTRCLHlCQUF5Qm5EO0lBQzFFO0lBQ0EsTUFBTXhKLDBCQUEwQnorQixlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSTZyQiwyQkFBMkIsTUFBTTtRQUNqQzMvQixlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUU0ckI7SUFDdEQ7SUFDQSxNQUFNa04sa0JBQWtCM3JDLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJKzRCLG1CQUFtQixNQUFNO1FBQ3pCLElBQUl4M0Isa0JBQWtCdzNCO1FBQ3RCLElBQUlyc0MsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU84K0IscUJBQXFCOStCO1lBQ2hDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFc0I7SUFDOUM7SUFDQSxPQUFPdEI7QUFDWDtBQUNBLFNBQVMrNEIsNkJBQTZCaDVCLFVBQVU7SUFDNUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vTCxzQkFBc0JqZSxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSXFMLHVCQUF1QixNQUFNO1FBQzdCbmYsZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFb0w7SUFDbEQ7SUFDQSxNQUFNbUIsb0JBQW9CcGYsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUl3TSxxQkFBcUIsTUFBTTtRQUMzQnRnQixlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUV1TTtJQUNoRDtJQUNBLE1BQU1rcEIsYUFBYXRvQyxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdkQsSUFBSTAxQixjQUFjLE1BQU07UUFDcEIsSUFBSW4wQixrQkFBa0IxRCxlQUFlNjNCO1FBQ3JDLElBQUlocEMsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU9rL0IsZ0JBQWdCbC9CO1lBQzNCO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFc0I7SUFDekM7SUFDQSxPQUFPdEI7QUFDWDtBQUNBLFNBQVNnNUI7SUFDTCxNQUFNaDVCLFdBQVcsQ0FBQztJQUNsQixPQUFPQTtBQUNYO0FBQ0EsU0FBU2k1Qiw4QkFBOEJsNUIsVUFBVTtJQUM3QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9MLHNCQUFzQmplLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcUwsdUJBQXVCLE1BQU07UUFDN0JuZixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVvTDtJQUNsRDtJQUNBLE1BQU13cUIsa0JBQWtCem9DLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJNjFCLG1CQUFtQixNQUFNO1FBQ3pCM3BDLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFNDFCO0lBQzlDO0lBQ0EsT0FBTzUxQjtBQUNYO0FBQ0EsU0FBU2s1QixnQ0FBZ0NuNUIsVUFBVTtJQUMvQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9MLHNCQUFzQmplLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcUwsdUJBQXVCLE1BQU07UUFDN0JuZixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVvTDtJQUNsRDtJQUNBLE1BQU0rdEIsaUJBQWlCaHNDLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJbzVCLGtCQUFrQixNQUFNO1FBQ3hCbHRDLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFbTVCO0lBQzdDO0lBQ0EsT0FBT241QjtBQUNYO0FBQ0EsU0FBU281QixnQkFBZ0JyNUIsVUFBVTtJQUMvQixNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9iLFVBQVVqdUIsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3JELElBQUlxYixXQUFXLE1BQU07UUFDakJudkIsZUFBZStULFVBQVU7WUFBQztTQUFNLEVBQUVvYjtJQUN0QztJQUNBLE1BQU13WCxpQkFBaUJ6bEMsZUFBZTRTLFlBQVk7UUFDOUM7S0FDSDtJQUNELElBQUk2eUIsa0JBQWtCLE1BQU07UUFDeEIzbUMsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUUvQyxPQUFPMjFCO0lBQ3BEO0lBQ0EsTUFBTXR5QixlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVNxNUIseUJBQXlCdDVCLFVBQVU7SUFDeEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU04ZixZQUFZM3lCLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK2YsYUFBYSxNQUFNO1FBQ25CN3pCLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFbzVCLGdCQUFnQnRaO0lBQ3hEO0lBQ0EsT0FBTzlmO0FBQ1g7QUFDQSxTQUFTczVCLGlDQUFpQ3Y1QixVQUFVO0lBQ2hELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNZzJCLHNCQUFzQjdvQyxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDakUsSUFBSWkyQix1QkFBdUIsTUFBTTtRQUM3QixJQUFJMTBCLGtCQUFrQjAwQjtRQUN0QixJQUFJdnBDLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPMi9CLHlCQUF5QjMvQjtZQUNwQztRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVzQjtJQUNsRDtJQUNBLE1BQU0yMEIsNEJBQTRCOW9DLGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJazJCLDZCQUE2QixNQUFNO1FBQ25DaHFDLGVBQWUrVCxVQUFVO1lBQUM7U0FBd0IsRUFBRWkyQjtJQUN4RDtJQUNBLE1BQU1DLDhCQUE4Qi9vQyxlQUFlNFMsWUFBWTtRQUMzRDtLQUNIO0lBQ0QsSUFBSW0yQiwrQkFBK0IsTUFBTTtRQUNyQ2pxQyxlQUFlK1QsVUFBVTtZQUFDO1NBQTBCLEVBQUVrMkI7SUFDMUQ7SUFDQSxPQUFPbDJCO0FBQ1g7QUFDQSxTQUFTdTVCLGtDQUFrQ3g1QixVQUFVO0lBQ2pELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV6QztJQUN2QztJQUNBLE1BQU02MkIsZUFBZWpuQyxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXEwQixnQkFBZ0IsTUFBTTtRQUN0Qm5vQyxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRW8wQjtJQUMzQztJQUNBLE1BQU0xbkIsV0FBV3ZmLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJMk0sWUFBWSxNQUFNO1FBQ2xCemdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFME07SUFDdkM7SUFDQSxNQUFNWCxZQUFZNWUsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlnTSxhQUFhLE1BQU07UUFDbkI5ZixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRStMO0lBQ3hDO0lBQ0EsTUFBTXpJLGVBQWVuVyxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXVELGdCQUFnQixNQUFNO1FBQ3RCclgsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVzNUIsaUNBQWlDaDJCO0lBQzVFO0lBQ0EsT0FBT3REO0FBQ1g7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTXc1QixzQkFBc0I7QUFDNUIsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLG9CQUFvQjtBQUMxQixNQUFNQywyQkFBMkI7QUFDakMsTUFBTUMsY0FBYyxVQUFVLDJCQUEyQjtBQUN6RCxNQUFNQyxnQkFBZ0IsQ0FBQyxpQkFBaUIsRUFBRUQsWUFBWSxDQUFDO0FBQ3ZELE1BQU1FLGdDQUFnQztBQUN0QyxNQUFNQyxnQ0FBZ0M7QUFDdEMsTUFBTUMsaUJBQWlCO0FBQ3ZCOzs7Q0FHQyxHQUNELE1BQU1DO0lBQ0Z0bkMsWUFBWXVuQyxJQUFJLENBQUU7UUFDZCxJQUFJcHZDLElBQUlDO1FBQ1IsSUFBSSxDQUFDb3ZDLGFBQWEsR0FBR3p1QyxPQUFPd0IsTUFBTSxDQUFDeEIsT0FBT3dCLE1BQU0sQ0FBQyxDQUFDLEdBQUdndEMsT0FBTztZQUFFRSxTQUFTRixLQUFLRSxPQUFPO1lBQUVDLFVBQVVILEtBQUtHLFFBQVE7WUFBRUMsUUFBUUosS0FBS0ksTUFBTTtZQUFFM3ZDLFVBQVV1dkMsS0FBS3Z2QyxRQUFRO1FBQUM7UUFDM0osTUFBTTR2QyxrQkFBa0IsQ0FBQztRQUN6QixJQUFJLElBQUksQ0FBQ0osYUFBYSxDQUFDeHZDLFFBQVEsRUFBRTtZQUM3QjR2QyxnQkFBZ0JDLFVBQVUsR0FDdEIsQ0FBQzF2QyxLQUFLLElBQUksQ0FBQ3F2QyxhQUFhLENBQUNLLFVBQVUsTUFBTSxRQUFRMXZDLE9BQU8sS0FBSyxJQUFJQSxLQUFLZ3ZDO1lBQzFFUyxnQkFBZ0J2dkMsT0FBTyxHQUFHLElBQUksQ0FBQ3l2QywwQkFBMEI7WUFDekQsSUFBSSxDQUFDQyx1QkFBdUI7UUFDaEMsT0FDSztZQUNELGFBQWE7WUFDYkgsZ0JBQWdCQyxVQUFVLEdBQ3RCLENBQUN6dkMsS0FBSyxJQUFJLENBQUNvdkMsYUFBYSxDQUFDSyxVQUFVLE1BQU0sUUFBUXp2QyxPQUFPLEtBQUssSUFBSUEsS0FBS2d2QztZQUMxRVEsZ0JBQWdCdnZDLE9BQU8sR0FBRyxDQUFDLDBDQUEwQyxDQUFDO1FBQzFFO1FBQ0F1dkMsZ0JBQWdCM25DLE9BQU8sR0FBRyxJQUFJLENBQUMrbkMsaUJBQWlCO1FBQ2hELElBQUksQ0FBQ1IsYUFBYSxDQUFDenZDLFdBQVcsR0FBRzZ2QztRQUNqQyxJQUFJTCxLQUFLeHZDLFdBQVcsRUFBRTtZQUNsQixJQUFJLENBQUN5dkMsYUFBYSxDQUFDenZDLFdBQVcsR0FBRyxJQUFJLENBQUNrd0MsZ0JBQWdCLENBQUNMLGlCQUFpQkwsS0FBS3h2QyxXQUFXO1FBQzVGO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEK3ZDLDZCQUE2QjtRQUN6QixJQUFJLElBQUksQ0FBQ04sYUFBYSxDQUFDQyxPQUFPLElBQzFCLElBQUksQ0FBQ0QsYUFBYSxDQUFDRSxRQUFRLElBQzNCLElBQUksQ0FBQ0YsYUFBYSxDQUFDRSxRQUFRLEtBQUssVUFBVTtZQUMxQyxvQkFBb0I7WUFDcEIsT0FBTyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUNGLGFBQWEsQ0FBQ0UsUUFBUSxDQUFDLDJCQUEyQixDQUFDO1FBQzlFO1FBQ0EsK0RBQStEO1FBQy9ELE9BQU8sQ0FBQyxrQ0FBa0MsQ0FBQztJQUMvQztJQUNBOzs7Ozs7S0FNQyxHQUNESywwQkFBMEI7UUFDdEIsSUFBSSxJQUFJLENBQUNQLGFBQWEsQ0FBQ0MsT0FBTyxJQUFJLElBQUksQ0FBQ0QsYUFBYSxDQUFDRSxRQUFRLEVBQUU7WUFDM0QsMkRBQTJEO1lBQzNELElBQUksQ0FBQ0YsYUFBYSxDQUFDRyxNQUFNLEdBQUdwd0M7WUFDNUI7UUFDSjtRQUNBLDJFQUEyRTtRQUMzRSxJQUFJLENBQUNpd0MsYUFBYSxDQUFDQyxPQUFPLEdBQUdsd0M7UUFDN0IsSUFBSSxDQUFDaXdDLGFBQWEsQ0FBQ0UsUUFBUSxHQUFHbndDO0lBQ2xDO0lBQ0FpTixhQUFhO1FBQ1QsSUFBSXJNO1FBQ0osT0FBTyxDQUFDQSxLQUFLLElBQUksQ0FBQ3F2QyxhQUFhLENBQUN4dkMsUUFBUSxNQUFNLFFBQVFHLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0lBQy9FO0lBQ0FnTyxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUNxaEMsYUFBYSxDQUFDQyxPQUFPO0lBQ3JDO0lBQ0FyaEMsY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDb2hDLGFBQWEsQ0FBQ0UsUUFBUTtJQUN0QztJQUNBUSxnQkFBZ0I7UUFDWixJQUFJLElBQUksQ0FBQ1YsYUFBYSxDQUFDenZDLFdBQVcsSUFDOUIsSUFBSSxDQUFDeXZDLGFBQWEsQ0FBQ3p2QyxXQUFXLENBQUM4dkMsVUFBVSxLQUFLdHdDLFdBQVc7WUFDekQsT0FBTyxJQUFJLENBQUNpd0MsYUFBYSxDQUFDenZDLFdBQVcsQ0FBQzh2QyxVQUFVO1FBQ3BEO1FBQ0EsTUFBTSxJQUFJeHVDLE1BQU07SUFDcEI7SUFDQXZCLGFBQWE7UUFDVCxJQUFJLElBQUksQ0FBQzB2QyxhQUFhLENBQUN6dkMsV0FBVyxJQUM5QixJQUFJLENBQUN5dkMsYUFBYSxDQUFDenZDLFdBQVcsQ0FBQ00sT0FBTyxLQUFLZCxXQUFXO1lBQ3RELE9BQU8sSUFBSSxDQUFDaXdDLGFBQWEsQ0FBQ3p2QyxXQUFXLENBQUNNLE9BQU87UUFDakQ7UUFDQSxNQUFNLElBQUlnQixNQUFNO0lBQ3BCO0lBQ0E4dUMsZ0JBQWdCO1FBQ1osT0FBTyxJQUFJLENBQUNDLHFCQUFxQixDQUFDLElBQUksQ0FBQ1osYUFBYSxDQUFDenZDLFdBQVc7SUFDcEU7SUFDQXN3QyxhQUFhO1FBQ1QsSUFBSSxJQUFJLENBQUNiLGFBQWEsQ0FBQ3p2QyxXQUFXLElBQzlCLElBQUksQ0FBQ3l2QyxhQUFhLENBQUN6dkMsV0FBVyxDQUFDa0ksT0FBTyxLQUFLMUksV0FBVztZQUN0RCxPQUFPLElBQUksQ0FBQ2l3QyxhQUFhLENBQUN6dkMsV0FBVyxDQUFDa0ksT0FBTztRQUNqRCxPQUNLO1lBQ0QsTUFBTSxJQUFJNUcsTUFBTTtRQUNwQjtJQUNKO0lBQ0ErdUMsc0JBQXNCcndDLFdBQVcsRUFBRTtRQUMvQixJQUFJLENBQUNBLGVBQ0RBLFlBQVlNLE9BQU8sS0FBS2QsYUFDeEJRLFlBQVk4dkMsVUFBVSxLQUFLdHdDLFdBQVc7WUFDdEMsTUFBTSxJQUFJOEIsTUFBTTtRQUNwQjtRQUNBLE1BQU1oQixVQUFVTixZQUFZTSxPQUFPLENBQUNzQixRQUFRLENBQUMsT0FDdkM1QixZQUFZTSxPQUFPLENBQUN3QixLQUFLLENBQUMsR0FBRyxDQUFDLEtBQzlCOUIsWUFBWU0sT0FBTztRQUN6QixNQUFNaXdDLGFBQWE7WUFBQ2p3QztTQUFRO1FBQzVCLElBQUlOLFlBQVk4dkMsVUFBVSxJQUFJOXZDLFlBQVk4dkMsVUFBVSxLQUFLLElBQUk7WUFDekRTLFdBQVc1b0MsSUFBSSxDQUFDM0gsWUFBWTh2QyxVQUFVO1FBQzFDO1FBQ0EsT0FBT1MsV0FBV0MsSUFBSSxDQUFDO0lBQzNCO0lBQ0FDLHNCQUFzQjtRQUNsQixPQUFPLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQ2hCLGFBQWEsQ0FBQ0MsT0FBTyxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUNELGFBQWEsQ0FBQ0UsUUFBUSxDQUFDLENBQUM7SUFDNUY7SUFDQWUsWUFBWTtRQUNSLE9BQU8sSUFBSSxDQUFDakIsYUFBYSxDQUFDRyxNQUFNO0lBQ3BDO0lBQ0FlLHNCQUFzQjtRQUNsQixNQUFNcndDLFVBQVUsSUFBSSxDQUFDUCxVQUFVO1FBQy9CLE1BQU02d0MsV0FBVyxJQUFJQyxJQUFJdndDO1FBQ3pCc3dDLFNBQVNFLFFBQVEsR0FBR0YsU0FBU0UsUUFBUSxJQUFJLFVBQVUsT0FBTztRQUMxRCxPQUFPRixTQUFTcnNCLFFBQVE7SUFDNUI7SUFDQXdzQixXQUFXQyxHQUFHLEVBQUU7UUFDWixJQUFJLElBQUksQ0FBQ3ZCLGFBQWEsQ0FBQ3p2QyxXQUFXLEVBQUU7WUFDaEMsSUFBSSxDQUFDeXZDLGFBQWEsQ0FBQ3p2QyxXQUFXLENBQUNNLE9BQU8sR0FBRzB3QztRQUM3QyxPQUNLO1lBQ0QsTUFBTSxJQUFJMXZDLE1BQU07UUFDcEI7SUFDSjtJQUNBMnZDLGFBQWF4c0IsSUFBSSxFQUFFemtCLFdBQVcsRUFBRWt4QyxzQkFBc0IsRUFBRTtRQUNwRCxNQUFNWCxhQUFhO1lBQUMsSUFBSSxDQUFDRixxQkFBcUIsQ0FBQ3J3QztTQUFhO1FBQzVELElBQUlreEMsd0JBQXdCO1lBQ3hCWCxXQUFXNW9DLElBQUksQ0FBQyxJQUFJLENBQUM4b0MsbUJBQW1CO1FBQzVDO1FBQ0EsSUFBSWhzQixTQUFTLElBQUk7WUFDYjhyQixXQUFXNW9DLElBQUksQ0FBQzhjO1FBQ3BCO1FBQ0EsTUFBTXVzQixNQUFNLElBQUlILElBQUksQ0FBQyxFQUFFTixXQUFXQyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQzdDLE9BQU9RO0lBQ1g7SUFDQUcsK0JBQStCMXVCLE9BQU8sRUFBRTtRQUNwQyxJQUFJLElBQUksQ0FBQ2d0QixhQUFhLENBQUNHLE1BQU0sRUFBRTtZQUMzQixPQUFPO1FBQ1g7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDSCxhQUFhLENBQUN4dkMsUUFBUSxFQUFFO1lBQzlCLE9BQU87UUFDWDtRQUNBLElBQUl3aUIsUUFBUWdDLElBQUksQ0FBQzFXLFVBQVUsQ0FBQyxjQUFjO1lBQ3RDLHNDQUFzQztZQUN0Qyw0Q0FBNEM7WUFDNUMsT0FBTztRQUNYO1FBQ0EsSUFBSTBVLFFBQVE2QyxVQUFVLEtBQUssU0FDdkI3QyxRQUFRZ0MsSUFBSSxDQUFDMVcsVUFBVSxDQUFDLDZCQUE2QjtZQUNyRCw4REFBOEQ7WUFDOUQsbUVBQW1FO1lBQ25FLG1EQUFtRDtZQUNuRCxPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQSxNQUFNMFUsUUFBUUEsT0FBTyxFQUFFO1FBQ25CLElBQUkydUIscUJBQXFCLElBQUksQ0FBQzNCLGFBQWEsQ0FBQ3p2QyxXQUFXO1FBQ3ZELElBQUl5aUIsUUFBUXppQixXQUFXLEVBQUU7WUFDckJveEMscUJBQXFCLElBQUksQ0FBQ2xCLGdCQUFnQixDQUFDLElBQUksQ0FBQ1QsYUFBYSxDQUFDenZDLFdBQVcsRUFBRXlpQixRQUFRemlCLFdBQVc7UUFDbEc7UUFDQSxNQUFNa3hDLHlCQUF5QixJQUFJLENBQUNDLDhCQUE4QixDQUFDMXVCO1FBQ25FLE1BQU11dUIsTUFBTSxJQUFJLENBQUNDLFlBQVksQ0FBQ3h1QixRQUFRZ0MsSUFBSSxFQUFFMnNCLG9CQUFvQkY7UUFDaEUsSUFBSXp1QixRQUFRaUMsV0FBVyxFQUFFO1lBQ3JCLEtBQUssTUFBTSxDQUFDM2pCLEtBQUtLLE1BQU0sSUFBSUosT0FBT29ILE9BQU8sQ0FBQ3FhLFFBQVFpQyxXQUFXLEVBQUc7Z0JBQzVEc3NCLElBQUlLLFlBQVksQ0FBQ0MsTUFBTSxDQUFDdndDLEtBQUtNLE9BQU9EO1lBQ3hDO1FBQ0o7UUFDQSxJQUFJbXdDLGNBQWMsQ0FBQztRQUNuQixJQUFJOXVCLFFBQVE2QyxVQUFVLEtBQUssT0FBTztZQUM5QixJQUFJN0MsUUFBUWtDLElBQUksSUFBSWxDLFFBQVFrQyxJQUFJLEtBQUssTUFBTTtnQkFDdkMsTUFBTSxJQUFJcmpCLE1BQU07WUFDcEI7UUFDSixPQUNLO1lBQ0Rpd0MsWUFBWTVzQixJQUFJLEdBQUdsQyxRQUFRa0MsSUFBSTtRQUNuQztRQUNBNHNCLGNBQWMsTUFBTSxJQUFJLENBQUNDLG9DQUFvQyxDQUFDRCxhQUFhSCxvQkFBb0IzdUIsUUFBUThDLFdBQVc7UUFDbEgsT0FBTyxJQUFJLENBQUNrc0IsWUFBWSxDQUFDVCxLQUFLTyxhQUFhOXVCLFFBQVE2QyxVQUFVO0lBQ2pFO0lBQ0E0cUIsaUJBQWlCd0IsZUFBZSxFQUFFQyxrQkFBa0IsRUFBRTtRQUNsRCxNQUFNUCxxQkFBcUJoc0IsS0FBS3dzQixLQUFLLENBQUN4c0IsS0FBS0MsU0FBUyxDQUFDcXNCO1FBQ3JELEtBQUssTUFBTSxDQUFDM3dDLEtBQUtLLE1BQU0sSUFBSUosT0FBT29ILE9BQU8sQ0FBQ3VwQyxvQkFBcUI7WUFDM0QsOEJBQThCO1lBQzlCLElBQUksT0FBT3Z3QyxVQUFVLFVBQVU7Z0JBQzNCLHNFQUFzRTtnQkFDdEUsa0VBQWtFO2dCQUNsRSxpQkFBaUI7Z0JBQ2pCZ3dDLGtCQUFrQixDQUFDcndDLElBQUksR0FBR0MsT0FBT3dCLE1BQU0sQ0FBQ3hCLE9BQU93QixNQUFNLENBQUMsQ0FBQyxHQUFHNHVDLGtCQUFrQixDQUFDcndDLElBQUksR0FBR0s7WUFDeEYsT0FDSyxJQUFJQSxVQUFVNUIsV0FBVztnQkFDMUIsc0VBQXNFO2dCQUN0RSxrRUFBa0U7Z0JBQ2xFLGlCQUFpQjtnQkFDakI0eEMsa0JBQWtCLENBQUNyd0MsSUFBSSxHQUFHSztZQUM5QjtRQUNKO1FBQ0EsT0FBT2d3QztJQUNYO0lBQ0EsTUFBTVMsY0FBY3B2QixPQUFPLEVBQUU7UUFDekIsSUFBSTJ1QixxQkFBcUIsSUFBSSxDQUFDM0IsYUFBYSxDQUFDenZDLFdBQVc7UUFDdkQsSUFBSXlpQixRQUFRemlCLFdBQVcsRUFBRTtZQUNyQm94QyxxQkFBcUIsSUFBSSxDQUFDbEIsZ0JBQWdCLENBQUMsSUFBSSxDQUFDVCxhQUFhLENBQUN6dkMsV0FBVyxFQUFFeWlCLFFBQVF6aUIsV0FBVztRQUNsRztRQUNBLE1BQU1reEMseUJBQXlCLElBQUksQ0FBQ0MsOEJBQThCLENBQUMxdUI7UUFDbkUsTUFBTXV1QixNQUFNLElBQUksQ0FBQ0MsWUFBWSxDQUFDeHVCLFFBQVFnQyxJQUFJLEVBQUUyc0Isb0JBQW9CRjtRQUNoRSxJQUFJLENBQUNGLElBQUlLLFlBQVksQ0FBQ3Q5QixHQUFHLENBQUMsVUFBVWk5QixJQUFJSyxZQUFZLENBQUNyckIsR0FBRyxDQUFDLFdBQVcsT0FBTztZQUN2RWdyQixJQUFJSyxZQUFZLENBQUNTLEdBQUcsQ0FBQyxPQUFPO1FBQ2hDO1FBQ0EsSUFBSVAsY0FBYyxDQUFDO1FBQ25CQSxZQUFZNXNCLElBQUksR0FBR2xDLFFBQVFrQyxJQUFJO1FBQy9CNHNCLGNBQWMsTUFBTSxJQUFJLENBQUNDLG9DQUFvQyxDQUFDRCxhQUFhSCxvQkFBb0IzdUIsUUFBUThDLFdBQVc7UUFDbEgsT0FBTyxJQUFJLENBQUN3c0IsYUFBYSxDQUFDZixLQUFLTyxhQUFhOXVCLFFBQVE2QyxVQUFVO0lBQ2xFO0lBQ0EsTUFBTWtzQixxQ0FBcUNELFdBQVcsRUFBRXZ4QyxXQUFXLEVBQUV1bEIsV0FBVyxFQUFFO1FBQzlFLElBQUksZUFBZ0J2bEIsWUFBWWd5QyxPQUFPLElBQUt6c0IsYUFBYTtZQUNyRCxNQUFNMHNCLGtCQUFrQixJQUFJQztZQUM1QixNQUFNQyxTQUFTRixnQkFBZ0JFLE1BQU07WUFDckMsSUFBSW55QyxZQUFZZ3lDLE9BQU8sSUFBSSxDQUFDaHlDLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsWUFBWWd5QyxPQUFPLElBQUksR0FBRztnQkFDNUcsTUFBTUksZ0JBQWdCQyxXQUFXLElBQU1KLGdCQUFnQkssS0FBSyxJQUFJdHlDLFlBQVlneUMsT0FBTztnQkFDbkYsSUFBSUksaUJBQ0EsT0FBT0EsY0FBY0csS0FBSyxLQUN0QixZQUFZO29CQUNoQix5REFBeUQ7b0JBQ3pELGtEQUFrRDtvQkFDbERILGNBQWNHLEtBQUs7Z0JBQ3ZCO1lBQ0o7WUFDQSxJQUFJaHRCLGFBQWE7Z0JBQ2JBLFlBQVlpdEIsZ0JBQWdCLENBQUMsU0FBUztvQkFDbENQLGdCQUFnQkssS0FBSztnQkFDekI7WUFDSjtZQUNBZixZQUFZWSxNQUFNLEdBQUdBO1FBQ3pCO1FBQ0EsSUFBSW55QyxlQUFlQSxZQUFZeXlDLFNBQVMsS0FBSyxNQUFNO1lBQy9DQyw4QkFBOEJuQixhQUFhdnhDLFlBQVl5eUMsU0FBUztRQUNwRTtRQUNBbEIsWUFBWXJwQyxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUN5cUMsa0JBQWtCLENBQUMzeUM7UUFDcEQsT0FBT3V4QztJQUNYO0lBQ0EsTUFBTUUsYUFBYVQsR0FBRyxFQUFFTyxXQUFXLEVBQUVqc0IsVUFBVSxFQUFFO1FBQzdDLE9BQU8sSUFBSSxDQUFDc3RCLE9BQU8sQ0FBQzVCLElBQUl6c0IsUUFBUSxJQUFJdmpCLE9BQU93QixNQUFNLENBQUN4QixPQUFPd0IsTUFBTSxDQUFDLENBQUMsR0FBRyt1QyxjQUFjO1lBQUVzQixRQUFRdnRCO1FBQVcsSUFDbEdFLElBQUksQ0FBQyxPQUFPOWU7WUFDYixNQUFNb3NDLGtCQUFrQnBzQztZQUN4QixPQUFPLElBQUlzQixhQUFhdEI7UUFDNUIsR0FDS3NvQixLQUFLLENBQUMsQ0FBQ2xDO1lBQ1IsSUFBSUEsYUFBYXhyQixPQUFPO2dCQUNwQixNQUFNd3JCO1lBQ1YsT0FDSztnQkFDRCxNQUFNLElBQUl4ckIsTUFBTThqQixLQUFLQyxTQUFTLENBQUN5SDtZQUNuQztRQUNKO0lBQ0o7SUFDQSxNQUFNaWxCLGNBQWNmLEdBQUcsRUFBRU8sV0FBVyxFQUFFanNCLFVBQVUsRUFBRTtRQUM5QyxPQUFPLElBQUksQ0FBQ3N0QixPQUFPLENBQUM1QixJQUFJenNCLFFBQVEsSUFBSXZqQixPQUFPd0IsTUFBTSxDQUFDeEIsT0FBT3dCLE1BQU0sQ0FBQyxDQUFDLEdBQUcrdUMsY0FBYztZQUFFc0IsUUFBUXZ0QjtRQUFXLElBQ2xHRSxJQUFJLENBQUMsT0FBTzllO1lBQ2IsTUFBTW9zQyxrQkFBa0Jwc0M7WUFDeEIsT0FBTyxJQUFJLENBQUMwb0IscUJBQXFCLENBQUMxb0I7UUFDdEMsR0FDS3NvQixLQUFLLENBQUMsQ0FBQ2xDO1lBQ1IsSUFBSUEsYUFBYXhyQixPQUFPO2dCQUNwQixNQUFNd3JCO1lBQ1YsT0FDSztnQkFDRCxNQUFNLElBQUl4ckIsTUFBTThqQixLQUFLQyxTQUFTLENBQUN5SDtZQUNuQztRQUNKO0lBQ0o7SUFDQXNDLHNCQUFzQjFvQixRQUFRLEVBQUU7UUFDNUIsSUFBSXRHO1FBQ0osT0FBT3VyQixpQkFBaUIsSUFBSSxFQUFFMkQsV0FBVyxVQUFVQztZQUMvQyxNQUFNd2pCLFNBQVMsQ0FBQzN5QyxLQUFLc0csYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVNpZSxJQUFJLE1BQU0sUUFBUXZrQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc0eUMsU0FBUztZQUN6SSxNQUFNQyxVQUFVLElBQUlDLFlBQVk7WUFDaEMsSUFBSSxDQUFDSCxRQUFRO2dCQUNULE1BQU0sSUFBSXp4QyxNQUFNO1lBQ3BCO1lBQ0EsSUFBSTtnQkFDQSxJQUFJNnhDLFNBQVM7Z0JBQ2IsTUFBTyxLQUFNO29CQUNULE1BQU0sRUFBRXZtQyxJQUFJLEVBQUV4TCxLQUFLLEVBQUUsR0FBRyxNQUFNcXFCLFFBQVFzbkIsT0FBT0ssSUFBSTtvQkFDakQsSUFBSXhtQyxNQUFNO3dCQUNOLElBQUl1bUMsT0FBT0UsSUFBSSxHQUFHMXhDLE1BQU0sR0FBRyxHQUFHOzRCQUMxQixNQUFNLElBQUlMLE1BQU07d0JBQ3BCO3dCQUNBO29CQUNKO29CQUNBLE1BQU1neUMsY0FBY0wsUUFBUU0sTUFBTSxDQUFDbnlDLE9BQU87d0JBQUVveUMsUUFBUTtvQkFBSztvQkFDekQsMkRBQTJEO29CQUMzRCxJQUFJO3dCQUNBLE1BQU1DLFlBQVlydUIsS0FBS3dzQixLQUFLLENBQUMwQjt3QkFDN0IsSUFBSSxXQUFXRyxXQUFXOzRCQUN0QixNQUFNQyxZQUFZdHVCLEtBQUt3c0IsS0FBSyxDQUFDeHNCLEtBQUtDLFNBQVMsQ0FBQ291QixTQUFTLENBQUMsUUFBUTs0QkFDOUQsTUFBTW5oQyxTQUFTb2hDLFNBQVMsQ0FBQyxTQUFTOzRCQUNsQyxNQUFNdnNDLE9BQU91c0MsU0FBUyxDQUFDLE9BQU87NEJBQzlCLE1BQU1DLGVBQWUsQ0FBQyxZQUFZLEVBQUVyaEMsT0FBTyxFQUFFLEVBQUU4UyxLQUFLQyxTQUFTLENBQUNvdUIsV0FBVyxDQUFDOzRCQUMxRSxJQUFJdHNDLFFBQVEsT0FBT0EsT0FBTyxLQUFLO2dDQUMzQixNQUFNeXNDLFdBQVcsSUFBSTVqQixTQUFTO29DQUMxQjFDLFNBQVNxbUI7b0NBQ1RyaEMsUUFBUW5MO2dDQUNaO2dDQUNBLE1BQU15c0M7NEJBQ1Y7d0JBQ0o7b0JBQ0osRUFDQSxPQUFPOW1CLEdBQUc7d0JBQ04sTUFBTW5xQixRQUFRbXFCO3dCQUNkLElBQUlucUIsTUFBTTBELElBQUksS0FBSyxZQUFZOzRCQUMzQixNQUFNeW1CO3dCQUNWO29CQUNKO29CQUNBcW1CLFVBQVVHO29CQUNWLElBQUl4eUMsUUFBUXF5QyxPQUFPcnlDLEtBQUssQ0FBQ3d1QztvQkFDekIsTUFBT3h1QyxNQUFPO3dCQUNWLE1BQU0reUMsdUJBQXVCL3lDLEtBQUssQ0FBQyxFQUFFO3dCQUNyQyxJQUFJOzRCQUNBLE1BQU1nekMsa0JBQWtCLElBQUlDLFNBQVNGLHNCQUFzQjtnQ0FDdkQzckMsU0FBU3hCLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTd0IsT0FBTztnQ0FDN0VvSyxRQUFRNUwsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVM0TCxNQUFNO2dDQUMzRTBoQyxZQUFZdHRDLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTc3RDLFVBQVU7NEJBQ3ZGOzRCQUNBLE1BQU0sTUFBTXZvQixRQUFRLElBQUl6akIsYUFBYThyQzs0QkFDckNYLFNBQVNBLE9BQU9yeEMsS0FBSyxDQUFDaEIsS0FBSyxDQUFDLEVBQUUsQ0FBQ2EsTUFBTTs0QkFDckNiLFFBQVFxeUMsT0FBT3J5QyxLQUFLLENBQUN3dUM7d0JBQ3pCLEVBQ0EsT0FBT3hpQixHQUFHOzRCQUNOLE1BQU0sSUFBSXhyQixNQUFNLENBQUMsK0JBQStCLEVBQUV1eUMscUJBQXFCLEVBQUUsRUFBRS9tQixFQUFFLENBQUM7d0JBQ2xGO29CQUNKO2dCQUNKO1lBQ0osU0FDUTtnQkFDSmltQixPQUFPa0IsV0FBVztZQUN0QjtRQUNKO0lBQ0o7SUFDQSxNQUFNckIsUUFBUTVCLEdBQUcsRUFBRU8sV0FBVyxFQUFFO1FBQzVCLE9BQU8yQyxNQUFNbEQsS0FBS08sYUFBYXZpQixLQUFLLENBQUMsQ0FBQ2xDO1lBQ2xDLE1BQU0sSUFBSXhyQixNQUFNLENBQUMsVUFBVSxFQUFFd3JCLEVBQUUsZ0JBQWdCLENBQUM7UUFDcEQ7SUFDSjtJQUNBbWpCLG9CQUFvQjtRQUNoQixNQUFNL25DLFVBQVUsQ0FBQztRQUNqQixNQUFNaXNDLHFCQUFxQmhGLGdCQUFnQixNQUFNLElBQUksQ0FBQ00sYUFBYSxDQUFDMkUsY0FBYztRQUNsRmxzQyxPQUFPLENBQUM4bUMsa0JBQWtCLEdBQUdtRjtRQUM3QmpzQyxPQUFPLENBQUMrbUMseUJBQXlCLEdBQUdrRjtRQUNwQ2pzQyxPQUFPLENBQUM0bUMsb0JBQW9CLEdBQUc7UUFDL0IsT0FBTzVtQztJQUNYO0lBQ0EsTUFBTXlxQyxtQkFBbUIzeUMsV0FBVyxFQUFFO1FBQ2xDLE1BQU1rSSxVQUFVLElBQUltc0M7UUFDcEIsSUFBSXIwQyxlQUFlQSxZQUFZa0ksT0FBTyxFQUFFO1lBQ3BDLEtBQUssTUFBTSxDQUFDbkgsS0FBS0ssTUFBTSxJQUFJSixPQUFPb0gsT0FBTyxDQUFDcEksWUFBWWtJLE9BQU8sRUFBRztnQkFDNURBLFFBQVFvcEMsTUFBTSxDQUFDdndDLEtBQUtLO1lBQ3hCO1lBQ0Esd0VBQXdFO1lBQ3hFLGdEQUFnRDtZQUNoRCxJQUFJcEIsWUFBWWd5QyxPQUFPLElBQUloeUMsWUFBWWd5QyxPQUFPLEdBQUcsR0FBRztnQkFDaEQ5cEMsUUFBUW9wQyxNQUFNLENBQUN2Qyx1QkFBdUIxdEMsT0FBT2l6QyxLQUFLQyxJQUFJLENBQUN2MEMsWUFBWWd5QyxPQUFPLEdBQUc7WUFDakY7UUFDSjtRQUNBLE1BQU0sSUFBSSxDQUFDdkMsYUFBYSxDQUFDK0UsSUFBSSxDQUFDQyxjQUFjLENBQUN2c0M7UUFDN0MsT0FBT0E7SUFDWDtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNd3BCLFdBQVdDLElBQUksRUFBRWhtQixNQUFNLEVBQUU7UUFDM0IsSUFBSXZMO1FBQ0osTUFBTXMwQyxlQUFlLENBQUM7UUFDdEIsSUFBSS9vQyxVQUFVLE1BQU07WUFDaEIrb0MsYUFBYTN1QyxRQUFRLEdBQUc0RixPQUFPNUYsUUFBUTtZQUN2QzJ1QyxhQUFhcnVDLElBQUksR0FBR3NGLE9BQU90RixJQUFJO1lBQy9CcXVDLGFBQWFsd0IsV0FBVyxHQUFHN1ksT0FBTzZZLFdBQVc7UUFDakQ7UUFDQSxJQUFJa3dCLGFBQWFydUMsSUFBSSxJQUFJLENBQUNxdUMsYUFBYXJ1QyxJQUFJLENBQUMwSCxVQUFVLENBQUMsV0FBVztZQUM5RDJtQyxhQUFhcnVDLElBQUksR0FBRyxDQUFDLE1BQU0sRUFBRXF1QyxhQUFhcnVDLElBQUksQ0FBQyxDQUFDO1FBQ3BEO1FBQ0EsTUFBTXN1QyxXQUFXLElBQUksQ0FBQ2xGLGFBQWEsQ0FBQ2tGLFFBQVE7UUFDNUMsTUFBTUMsV0FBVyxNQUFNRCxTQUFTRSxJQUFJLENBQUNsakI7UUFDckMraUIsYUFBYUksU0FBUyxHQUFHenpDLE9BQU91ekMsU0FBU0csSUFBSTtRQUM3QyxNQUFNaHZDLFdBQVcsQ0FBQzNGLEtBQUt1TCxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBTzVGLFFBQVEsTUFBTSxRQUFRM0YsT0FBTyxLQUFLLElBQUlBLEtBQUt3MEMsU0FBUzNrQyxJQUFJO1FBQ3RJLElBQUlsSyxhQUFhdkcsYUFBYXVHLGFBQWEsSUFBSTtZQUMzQyxNQUFNLElBQUl6RSxNQUFNO1FBQ3BCO1FBQ0FvekMsYUFBYTN1QyxRQUFRLEdBQUdBO1FBQ3hCLE1BQU1pdkMsWUFBWSxNQUFNLElBQUksQ0FBQ0MsY0FBYyxDQUFDUCxjQUFjL29DO1FBQzFELE9BQU9ncEMsU0FBU2xqQixNQUFNLENBQUNFLE1BQU1xakIsV0FBVyxJQUFJO0lBQ2hEO0lBQ0E7Ozs7O0tBS0MsR0FDRCxNQUFNbmpCLGFBQWFuUCxNQUFNLEVBQUU7UUFDdkIsTUFBTXd5QixhQUFhLElBQUksQ0FBQ3pGLGFBQWEsQ0FBQ3lGLFVBQVU7UUFDaEQsTUFBTUEsV0FBV3RqQixRQUFRLENBQUNsUCxRQUFRLElBQUk7SUFDMUM7SUFDQSxNQUFNdXlCLGVBQWV0akIsSUFBSSxFQUFFaG1CLE1BQU0sRUFBRTtRQUMvQixJQUFJdkw7UUFDSixJQUFJSixjQUFjLENBQUM7UUFDbkIsSUFBSTJMLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPM0wsV0FBVyxFQUFFO1lBQ3BFQSxjQUFjMkwsT0FBTzNMLFdBQVc7UUFDcEMsT0FDSztZQUNEQSxjQUFjO2dCQUNWOHZDLFlBQVk7Z0JBQ1o1bkMsU0FBUztvQkFDTCxnQkFBZ0I7b0JBQ2hCLDBCQUEwQjtvQkFDMUIseUJBQXlCO29CQUN6Qix1Q0FBdUMsQ0FBQyxFQUFFeXBCLEtBQUttakIsU0FBUyxDQUFDLENBQUM7b0JBQzFELHFDQUFxQyxDQUFDLEVBQUVuakIsS0FBSzVyQixRQUFRLENBQUMsQ0FBQztnQkFDM0Q7WUFDSjtRQUNKO1FBQ0EsTUFBTTRlLE9BQU87WUFDVCxRQUFRZ047UUFDWjtRQUNBLE1BQU1sTSxlQUFlLE1BQU0sSUFBSSxDQUFDaEQsT0FBTyxDQUFDO1lBQ3BDZ0MsTUFBTWhrQixVQUFVLHVCQUF1QmtrQixJQUFJLENBQUMsT0FBTztZQUNuREEsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtZQUNyQlcsWUFBWTtZQUNadGxCO1FBQ0o7UUFDQSxJQUFJLENBQUN5bEIsZ0JBQWdCLENBQUVBLENBQUFBLGlCQUFpQixRQUFRQSxpQkFBaUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsYUFBYXZkLE9BQU8sR0FBRztZQUN0RyxNQUFNLElBQUk1RyxNQUFNO1FBQ3BCO1FBQ0EsTUFBTTB6QyxZQUFZLENBQUM1MEMsS0FBS3FsQixpQkFBaUIsUUFBUUEsaUJBQWlCLEtBQUssSUFBSSxLQUFLLElBQUlBLGFBQWF2ZCxPQUFPLE1BQU0sUUFBUTlILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLG9CQUFvQjtRQUN0SyxJQUFJNDBDLGNBQWN4MUMsV0FBVztZQUN6QixNQUFNLElBQUk4QixNQUFNO1FBQ3BCO1FBQ0EsT0FBTzB6QztJQUNYO0FBQ0o7QUFDQSxlQUFlbEMsa0JBQWtCcHNDLFFBQVE7SUFDckMsSUFBSXRHO0lBQ0osSUFBSXNHLGFBQWFsSCxXQUFXO1FBQ3hCLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJLENBQUNvRixTQUFTeXVDLEVBQUUsRUFBRTtRQUNkLE1BQU03aUMsU0FBUzVMLFNBQVM0TCxNQUFNO1FBQzlCLElBQUk4aUM7UUFDSixJQUFJLENBQUNoMUMsS0FBS3NHLFNBQVN3QixPQUFPLENBQUM4ZCxHQUFHLENBQUMsZUFBYyxNQUFPLFFBQVE1bEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMlAsUUFBUSxDQUFDLHFCQUFxQjtZQUNsSHFsQyxZQUFZLE1BQU0xdUMsU0FBUzRCLElBQUk7UUFDbkMsT0FDSztZQUNEOHNDLFlBQVk7Z0JBQ1J6eUMsT0FBTztvQkFDSDJxQixTQUFTLE1BQU01bUIsU0FBU1AsSUFBSTtvQkFDNUJnQixNQUFNVCxTQUFTNEwsTUFBTTtvQkFDckJBLFFBQVE1TCxTQUFTc3RDLFVBQVU7Z0JBQy9CO1lBQ0o7UUFDSjtRQUNBLE1BQU1MLGVBQWV2dUIsS0FBS0MsU0FBUyxDQUFDK3ZCO1FBQ3BDLElBQUk5aUMsVUFBVSxPQUFPQSxTQUFTLEtBQUs7WUFDL0IsTUFBTXNoQyxXQUFXLElBQUk1akIsU0FBUztnQkFDMUIxQyxTQUFTcW1CO2dCQUNUcmhDLFFBQVFBO1lBQ1o7WUFDQSxNQUFNc2hDO1FBQ1Y7UUFDQSxNQUFNLElBQUl0eUMsTUFBTXF5QztJQUNwQjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0QsU0FBU2pCLDhCQUE4Qm5CLFdBQVcsRUFBRWtCLFNBQVM7SUFDekQsSUFBSSxDQUFDQSxhQUFhenhDLE9BQU9TLElBQUksQ0FBQ2d4QyxXQUFXOXdDLE1BQU0sS0FBSyxHQUFHO1FBQ25EO0lBQ0o7SUFDQSxJQUFJNHZDLFlBQVk1c0IsSUFBSSxZQUFZMHdCLE1BQU07UUFDbENuc0MsUUFBUUMsSUFBSSxDQUFDO1FBQ2I7SUFDSjtJQUNBLElBQUltc0Msb0JBQW9CLENBQUM7SUFDekIseUVBQXlFO0lBQ3pFLHNDQUFzQztJQUN0QyxJQUFJLE9BQU8vRCxZQUFZNXNCLElBQUksS0FBSyxZQUFZNHNCLFlBQVk1c0IsSUFBSSxDQUFDaGpCLE1BQU0sR0FBRyxHQUFHO1FBQ3JFLElBQUk7WUFDQSxNQUFNNHpDLGFBQWFud0IsS0FBS3dzQixLQUFLLENBQUNMLFlBQVk1c0IsSUFBSTtZQUM5QyxJQUFJLE9BQU80d0IsZUFBZSxZQUN0QkEsZUFBZSxRQUNmLENBQUN4ekMsTUFBTUMsT0FBTyxDQUFDdXpDLGFBQWE7Z0JBQzVCRCxvQkFBb0JDO1lBQ3hCLE9BQ0s7Z0JBQ0Ryc0MsUUFBUUMsSUFBSSxDQUFDO2dCQUNiO1lBQ0o7UUFDQSwrREFBK0QsR0FDbkUsRUFDQSxPQUFPMmpCLEdBQUc7WUFDTjVqQixRQUFRQyxJQUFJLENBQUM7WUFDYjtRQUNKO0lBQ0o7SUFDQSxTQUFTcXNDLFVBQVVDLE1BQU0sRUFBRUMsTUFBTTtRQUM3QixNQUFNMXVDLFNBQVNoRyxPQUFPd0IsTUFBTSxDQUFDLENBQUMsR0FBR2l6QztRQUNqQyxJQUFLLE1BQU0xMEMsT0FBTzIwQyxPQUFRO1lBQ3RCLElBQUkxMEMsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ3UwQyxRQUFRMzBDLE1BQU07Z0JBQ25ELE1BQU00MEMsY0FBY0QsTUFBTSxDQUFDMzBDLElBQUk7Z0JBQy9CLE1BQU02MEMsY0FBYzV1QyxNQUFNLENBQUNqRyxJQUFJO2dCQUMvQixJQUFJNDBDLGVBQ0EsT0FBT0EsZ0JBQWdCLFlBQ3ZCLENBQUM1ekMsTUFBTUMsT0FBTyxDQUFDMnpDLGdCQUNmQyxlQUNBLE9BQU9BLGdCQUFnQixZQUN2QixDQUFDN3pDLE1BQU1DLE9BQU8sQ0FBQzR6QyxjQUFjO29CQUM3QjV1QyxNQUFNLENBQUNqRyxJQUFJLEdBQUd5MEMsVUFBVUksYUFBYUQ7Z0JBQ3pDLE9BQ0s7b0JBQ0QsSUFBSUMsZUFDQUQsZUFDQSxPQUFPQyxnQkFBZ0IsT0FBT0QsYUFBYTt3QkFDM0N6c0MsUUFBUUMsSUFBSSxDQUFDLENBQUMsZ0VBQWdFLEVBQUVwSSxJQUFJLGtCQUFrQixFQUFFLE9BQU82MEMsWUFBWSxZQUFZLEVBQUUsT0FBT0QsWUFBWSxjQUFjLENBQUM7b0JBQy9LO29CQUNBM3VDLE1BQU0sQ0FBQ2pHLElBQUksR0FBRzQwQztnQkFDbEI7WUFDSjtRQUNKO1FBQ0EsT0FBTzN1QztJQUNYO0lBQ0EsTUFBTTZ1QyxhQUFhTCxVQUFVRixtQkFBbUI3QztJQUNoRGxCLFlBQVk1c0IsSUFBSSxHQUFHUyxLQUFLQyxTQUFTLENBQUN3d0I7QUFDdEM7QUFFQTs7OztDQUlDLEdBQ0QseUVBQXlFO0FBQ3pFLE1BQU1DLFlBQVk7QUFDbEIsc0VBQXNFO0FBQ3RFLGFBQWE7QUFDYixJQUFJQywrQkFBK0I7QUFDbkMsMkRBQTJEO0FBQzNELFNBQVNDLGdCQUFnQmxrQyxLQUFLO0lBQzFCLEtBQUssTUFBTVAsUUFBUU8sTUFBTztRQUN0QixJQUFJbWtDLGtCQUFrQjFrQyxPQUFPO1lBQ3pCLE9BQU87UUFDWDtRQUNBLElBQUksT0FBT0EsU0FBUyxZQUFZLGlCQUFpQkEsTUFBTTtZQUNuRCxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU93a0M7QUFDWDtBQUNBLDhEQUE4RDtBQUM5RCxTQUFTRyxrQkFBa0JodUMsT0FBTztJQUM5QixJQUFJOUg7SUFDSixNQUFNKzFDLGlCQUFpQixDQUFDLzFDLEtBQUs4SCxPQUFPLENBQUMrbUMseUJBQXlCLE1BQU0sUUFBUTd1QyxPQUFPLEtBQUssSUFBSUEsS0FBSztJQUNqRzhILE9BQU8sQ0FBQyttQyx5QkFBeUIsR0FBRyxDQUFDa0gsaUJBQWlCLENBQUMsQ0FBQyxFQUFFTCxVQUFVLENBQUMsRUFBRU0sU0FBUztBQUNwRjtBQUNBLHFFQUFxRTtBQUNyRSxTQUFTSCxrQkFBa0JJLE1BQU07SUFDN0IsT0FBUUEsV0FBVyxRQUNmLE9BQU9BLFdBQVcsWUFDbEJBLGtCQUFrQkM7QUFDMUI7QUFDQSxzQ0FBc0M7QUFDdEMsU0FBU0MsYUFBYUMsU0FBUyxFQUFFQyxXQUFXLEdBQUc7SUFDM0MsT0FBTzlxQixpQkFBaUIsSUFBSSxFQUFFMkQsV0FBVyxVQUFVb25CO1FBQy9DLElBQUlDLFNBQVNuM0M7UUFDYixJQUFJbzNDLFdBQVc7UUFDZixNQUFPQSxXQUFXSCxTQUFVO1lBQ3hCLE1BQU1JLElBQUksTUFBTXByQixRQUFRK3FCLFVBQVVNLFNBQVMsQ0FBQztnQkFBRUg7WUFBTztZQUNyRCxLQUFLLE1BQU1wbEMsUUFBUXNsQyxFQUFFL2tDLEtBQUssQ0FBRTtnQkFDeEIsTUFBTSxNQUFNMlosUUFBUWxhO2dCQUNwQnFsQztZQUNKO1lBQ0EsSUFBSSxDQUFDQyxFQUFFRSxVQUFVLEVBQUU7Z0JBQ2Y7WUFDSjtZQUNBSixTQUFTRSxFQUFFRSxVQUFVO1FBQ3pCO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Q0FNQyxHQUNELE1BQU1UO0lBQ0ZydUMsWUFBWSt1QyxhQUFhLEVBQUUsRUFBRXJyQyxNQUFNLENBQUU7UUFDakMsSUFBSSxDQUFDZ0ksUUFBUSxHQUFHLEVBQUU7UUFDbEIsSUFBSSxDQUFDc2pDLHVCQUF1QixHQUFHLENBQUM7UUFDaEMsSUFBSSxDQUFDRCxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ3JyQyxNQUFNLEdBQUdBO0lBQ2xCO0lBQ0E7O0tBRUMsR0FDRCxPQUFPdVksT0FBTzh5QixVQUFVLEVBQUVyckMsTUFBTSxFQUFFO1FBQzlCLE9BQU8sSUFBSTJxQyxnQkFBZ0JVLFlBQVlyckM7SUFDM0M7SUFDQTs7Ozs7O0tBTUMsR0FDRCxNQUFNdXJDLGFBQWE7UUFDZixJQUFJOTJDLElBQUlvdkIsS0FBS252QixJQUFJcUk7UUFDakIsSUFBSSxJQUFJLENBQUNpTCxRQUFRLENBQUNoUyxNQUFNLEdBQUcsR0FBRztZQUMxQjtRQUNKO1FBQ0EsTUFBTXcxQyxjQUFjLENBQUM7UUFDckIsTUFBTXhqQyxXQUFXLEVBQUU7UUFDbkIsS0FBSyxNQUFNNmlDLGFBQWEsSUFBSSxDQUFDUSxVQUFVLENBQUU7WUFDckMsSUFBSTtnQkFDQSxJQUFLLElBQUlydUMsS0FBSyxNQUFNQyxLQUFNNG1CLENBQUFBLE1BQU0sS0FBSyxHQUFHckMsY0FBY29wQixhQUFhQyxXQUFVLEdBQUkzdEMsSUFBSUEsS0FBSyxNQUFNRCxHQUFHaWIsSUFBSSxJQUFJempCLEtBQUt5SSxHQUFHK0QsSUFBSSxFQUFFLENBQUN4TSxJQUFJdUksS0FBSyxLQUFNO29CQUNySUQsS0FBS0csR0FBR3pILEtBQUs7b0JBQ2J1SCxLQUFLO29CQUNMLE1BQU0wSyxVQUFVM0s7b0JBQ2hCaUwsU0FBU2hNLElBQUksQ0FBQzBMO29CQUNkLE1BQU1TLGNBQWNULFFBQVFoTixJQUFJO29CQUNoQyxJQUFJOHdDLFdBQVcsQ0FBQ3JqQyxZQUFZLEVBQUU7d0JBQzFCLE1BQU0sSUFBSXhTLE1BQU0sQ0FBQyx3QkFBd0IsRUFBRXdTLFlBQVksNkRBQTZELENBQUM7b0JBQ3pIO29CQUNBcWpDLFdBQVcsQ0FBQ3JqQyxZQUFZLEdBQUcwaUM7Z0JBQy9CO1lBQ0osRUFDQSxPQUFPNW1CLE9BQU87Z0JBQUVKLE1BQU07b0JBQUU3c0IsT0FBT2l0QjtnQkFBTTtZQUFHLFNBQ2hDO2dCQUNKLElBQUk7b0JBQ0EsSUFBSSxDQUFDam5CLE1BQU0sQ0FBQ3ZJLE1BQU9DLENBQUFBLEtBQUt1SSxHQUFHb2IsTUFBTSxHQUFHLE1BQU0zakIsR0FBR2MsSUFBSSxDQUFDeUg7Z0JBQ3RELFNBQ1E7b0JBQUUsSUFBSTRtQixLQUFLLE1BQU1BLElBQUk3c0IsS0FBSztnQkFBRTtZQUN4QztRQUNKO1FBQ0EsSUFBSSxDQUFDZ1IsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNzakMsdUJBQXVCLEdBQUdFO0lBQ25DO0lBQ0EsTUFBTTVsQyxPQUFPO1FBQ1QsTUFBTSxJQUFJLENBQUMybEMsVUFBVTtRQUNyQixPQUFPeGpDLHFCQUFxQixJQUFJLENBQUNDLFFBQVEsRUFBRSxJQUFJLENBQUNoSSxNQUFNO0lBQzFEO0lBQ0EsTUFBTXlyQyxTQUFTeHRDLGFBQWEsRUFBRTtRQUMxQixNQUFNLElBQUksQ0FBQ3N0QyxVQUFVO1FBQ3JCLE1BQU1HLDRCQUE0QixFQUFFO1FBQ3BDLEtBQUssTUFBTTl3QyxnQkFBZ0JxRCxjQUFlO1lBQ3RDLElBQUlyRCxhQUFhRixJQUFJLElBQUksSUFBSSxDQUFDNHdDLHVCQUF1QixFQUFFO2dCQUNuRCxNQUFNVCxZQUFZLElBQUksQ0FBQ1MsdUJBQXVCLENBQUMxd0MsYUFBYUYsSUFBSSxDQUFDO2dCQUNqRSxJQUFJaXhDLGlCQUFpQjkzQztnQkFDckIscUVBQXFFO2dCQUNyRSxJQUFJLElBQUksQ0FBQ21NLE1BQU0sQ0FBQ3FtQyxPQUFPLEVBQUU7b0JBQ3JCc0YsaUJBQWlCO3dCQUNidEYsU0FBUyxJQUFJLENBQUNybUMsTUFBTSxDQUFDcW1DLE9BQU87b0JBQ2hDO2dCQUNKO2dCQUNBLE1BQU11RixtQkFBbUIsTUFBTWYsVUFBVVksUUFBUSxDQUFDO29CQUM5Qy93QyxNQUFNRSxhQUFhRixJQUFJO29CQUN2QmlwQixXQUFXL29CLGFBQWFELElBQUk7Z0JBQ2hDLEdBQ0EsaUVBQWlFO2dCQUNqRSxrQkFBa0I7Z0JBQ2xCOUcsV0FBVzgzQztnQkFDWEQsMEJBQTBCMXZDLElBQUksQ0FBQztvQkFDM0JoQixrQkFBa0I7d0JBQ2ROLE1BQU1FLGFBQWFGLElBQUk7d0JBQ3ZCSyxVQUFVNndDLGlCQUFpQkMsT0FBTyxHQUM1Qjs0QkFBRTcwQyxPQUFPNDBDO3dCQUFpQixJQUMxQkE7b0JBQ1Y7Z0JBQ0o7WUFDSjtRQUNKO1FBQ0EsT0FBT0Y7SUFDWDtBQUNKO0FBQ0EsU0FBU0ksWUFBWXpsQyxNQUFNO0lBQ3ZCLE9BQVFBLFdBQVcsUUFDZixPQUFPQSxXQUFXLFlBQ2xCLGVBQWVBLFVBQ2YsT0FBT0EsT0FBTzhrQyxTQUFTLEtBQUs7QUFDcEM7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTWSxVQUFVLEdBQUdweEMsSUFBSTtJQUN0QiwrQkFBK0I7SUFDL0J5dkMsK0JBQStCO0lBQy9CLElBQUl6dkMsS0FBSzNFLE1BQU0sS0FBSyxHQUFHO1FBQ25CLE1BQU0sSUFBSUwsTUFBTTtJQUNwQjtJQUNBLE1BQU1xMkMsY0FBY3J4QyxJQUFJLENBQUNBLEtBQUszRSxNQUFNLEdBQUcsRUFBRTtJQUN6QyxJQUFJODFDLFlBQVlFLGNBQWM7UUFDMUIsT0FBT3JCLGdCQUFnQnB5QixNQUFNLENBQUM1ZCxNQUFNLENBQUM7SUFDekM7SUFDQSxPQUFPZ3dDLGdCQUFnQnB5QixNQUFNLENBQUM1ZCxLQUFLeEUsS0FBSyxDQUFDLEdBQUd3RSxLQUFLM0UsTUFBTSxHQUFHLElBQUlnMkM7QUFDbEU7QUFFQTs7OztDQUlDLEdBQ0Q7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsZUFBZUMseUJBQXlCL3BDLFNBQVMsRUFBRWdxQyxTQUFTLEVBQUVDLEtBQUs7SUFDL0QsTUFBTUMsZ0JBQWdCLElBQUl0cUM7SUFDMUIsSUFBSWpNO0lBQ0osSUFBSXMyQyxNQUFNdDJDLElBQUksWUFBWTZ6QyxNQUFNO1FBQzVCN3pDLE9BQU80akIsS0FBS3dzQixLQUFLLENBQUMsTUFBTWtHLE1BQU10MkMsSUFBSSxDQUFDMkUsSUFBSTtJQUMzQyxPQUNLO1FBQ0QzRSxPQUFPNGpCLEtBQUt3c0IsS0FBSyxDQUFDa0csTUFBTXQyQyxJQUFJO0lBQ2hDO0lBQ0EsTUFBTWtGLFdBQVdpMkIsZ0NBQWdDbjdCO0lBQ2pEUixPQUFPd0IsTUFBTSxDQUFDdTFDLGVBQWVyeEM7SUFDN0JteEMsVUFBVUU7QUFDZDtBQUNBOzs7OztFQUtFLEdBQ0YsTUFBTUM7SUFDRi92QyxZQUFZNEYsU0FBUyxFQUFFMm1DLElBQUksRUFBRXlELGdCQUFnQixDQUFFO1FBQzNDLElBQUksQ0FBQ3BxQyxTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQzJtQyxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDeUQsZ0JBQWdCLEdBQUdBO0lBQzVCO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BNkJFLEdBQ0YsTUFBTUMsUUFBUXgxQixNQUFNLEVBQUU7UUFDbEIsSUFBSXRpQixJQUFJQztRQUNSLElBQUksSUFBSSxDQUFDd04sU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCLE1BQU0sSUFBSW5MLE1BQU07UUFDcEI7UUFDQTRILFFBQVFDLElBQUksQ0FBQztRQUNiLE1BQU1ndkMsbUJBQW1CLElBQUksQ0FBQ3RxQyxTQUFTLENBQUM4aUMsbUJBQW1CO1FBQzNELE1BQU1iLGFBQWEsSUFBSSxDQUFDamlDLFNBQVMsQ0FBQ3NpQyxhQUFhO1FBQy9DLE1BQU1qb0MsVUFBVWt3QyxlQUFlLElBQUksQ0FBQ3ZxQyxTQUFTLENBQUNvaUMsaUJBQWlCO1FBQy9ELE1BQU1MLFNBQVMsSUFBSSxDQUFDL2hDLFNBQVMsQ0FBQzZpQyxTQUFTO1FBQ3ZDLE1BQU1NLE1BQU0sQ0FBQyxFQUFFbUgsaUJBQWlCLGlDQUFpQyxFQUFFckksV0FBVyx5Q0FBeUMsRUFBRUYsT0FBTyxDQUFDO1FBQ2pJLElBQUl5SSxnQkFBZ0IsS0FBUTtRQUM1QixNQUFNQyxnQkFBZ0IsSUFBSWhzQixRQUFRLENBQUNDO1lBQy9COHJCLGdCQUFnQjlyQjtRQUNwQjtRQUNBLE1BQU1nc0IsWUFBWTcxQixPQUFPNjFCLFNBQVM7UUFDbEMsTUFBTUMsd0JBQXdCO1lBQzFCSCxjQUFjLENBQUM7UUFDbkI7UUFDQSxNQUFNeHFDLFlBQVksSUFBSSxDQUFDQSxTQUFTO1FBQ2hDLE1BQU00cUMscUJBQXFCO1lBQ3ZCQyxRQUFRRjtZQUNSWCxXQUFXLENBQUNDO2dCQUNSLEtBQUtGLHlCQUF5Qi9wQyxXQUFXMHFDLFVBQVVWLFNBQVMsRUFBRUM7WUFDbEU7WUFDQWEsU0FBUyxDQUFDdjRDLEtBQUttNEMsY0FBYyxRQUFRQSxjQUFjLEtBQUssSUFBSSxLQUFLLElBQUlBLFVBQVVJLE9BQU8sTUFBTSxRQUFRdjRDLE9BQU8sS0FBSyxJQUFJQSxLQUFLLFNBQVUwc0IsQ0FBQyxHQUNwSTtZQUNBOHJCLFNBQVMsQ0FBQ3Y0QyxLQUFLazRDLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVSyxPQUFPLE1BQU0sUUFBUXY0QyxPQUFPLEtBQUssSUFBSUEsS0FBSyxTQUFVeXNCLENBQUMsR0FDcEk7UUFDSjtRQUNBLE1BQU0rckIsT0FBTyxJQUFJLENBQUNaLGdCQUFnQixDQUFDL3pCLE1BQU0sQ0FBQzhzQixLQUFLOEgsZUFBZTV3QyxVQUFVdXdDO1FBQ3hFSSxLQUFLWCxPQUFPO1FBQ1osMERBQTBEO1FBQzFELE1BQU1JO1FBQ04sTUFBTXhxQyxRQUFRRixPQUFPLElBQUksQ0FBQ0MsU0FBUyxFQUFFNlUsT0FBTzVVLEtBQUs7UUFDakQsTUFBTWlyQyxRQUFReGlCLDRCQUE0QjtZQUN0Q3pvQjtRQUNKO1FBQ0EsTUFBTWtyQyxnQkFBZ0J2aUIsOEJBQThCO1lBQUVzaUI7UUFBTTtRQUM1REYsS0FBS0ksSUFBSSxDQUFDN3pCLEtBQUtDLFNBQVMsQ0FBQzJ6QjtRQUN6QixPQUFPLElBQUlFLGlCQUFpQkwsTUFBTSxJQUFJLENBQUNockMsU0FBUztJQUNwRDtBQUNKO0FBQ0E7Ozs7RUFJRSxHQUNGLE1BQU1xckM7SUFDRmp4QyxZQUFZNHdDLElBQUksRUFBRWhyQyxTQUFTLENBQUU7UUFDekIsSUFBSSxDQUFDZ3JDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNockMsU0FBUyxHQUFHQTtJQUNyQjtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNc3JDLG1CQUFtQnoyQixNQUFNLEVBQUU7UUFDN0IsSUFBSSxDQUFDQSxPQUFPMDJCLGVBQWUsSUFDdkJwNEMsT0FBT1MsSUFBSSxDQUFDaWhCLE9BQU8wMkIsZUFBZSxFQUFFejNDLE1BQU0sS0FBSyxHQUFHO1lBQ2xELE1BQU0sSUFBSUwsTUFBTTtRQUNwQjtRQUNBLE1BQU0rM0MsK0JBQStCNWpCLDZDQUE2Qy9TO1FBQ2xGLE1BQU00MkIsZ0JBQWdCOWlCLDhCQUE4QjZpQjtRQUNwRCxJQUFJLENBQUNSLElBQUksQ0FBQ0ksSUFBSSxDQUFDN3pCLEtBQUtDLFNBQVMsQ0FBQztZQUFFaTBCO1FBQWM7SUFDbEQ7SUFDQTs7Ozs7Ozs7OztLQVVDLEdBQ0QsTUFBTUMseUJBQXlCNzJCLE1BQU0sRUFBRTtRQUNuQyxJQUFJLENBQUNBLE9BQU84MkIscUJBQXFCLEVBQUU7WUFDL0I5MkIsT0FBTzgyQixxQkFBcUIsR0FBRyxDQUFDO1FBQ3BDO1FBQ0EsTUFBTUMsc0JBQXNCcGpCLG9DQUFvQzNUO1FBQ2hFLE1BQU1zMkIsZ0JBQWdCdmlCLDhCQUE4QmdqQjtRQUNwRCxJQUFJLENBQUNaLElBQUksQ0FBQ0ksSUFBSSxDQUFDN3pCLEtBQUtDLFNBQVMsQ0FBQzJ6QjtJQUNsQztJQUNBVSxvQkFBb0JDLGVBQWUsRUFBRTtRQUNqQyxNQUFNWCxnQkFBZ0J2aUIsOEJBQThCO1lBQ2hEa2pCO1FBQ0o7UUFDQSxJQUFJLENBQUNkLElBQUksQ0FBQ0ksSUFBSSxDQUFDN3pCLEtBQUtDLFNBQVMsQ0FBQzJ6QjtJQUNsQztJQUNBOzs7O0tBSUMsR0FDRFksT0FBTztRQUNILElBQUksQ0FBQ0YsbUJBQW1CLENBQUMvekMseUJBQXlCazBDLElBQUk7SUFDMUQ7SUFDQTs7Ozs7S0FLQyxHQUNEQyxRQUFRO1FBQ0osSUFBSSxDQUFDSixtQkFBbUIsQ0FBQy96Qyx5QkFBeUJvMEMsS0FBSztJQUMzRDtJQUNBOzs7OztLQUtDLEdBQ0RDLE9BQU87UUFDSCxJQUFJLENBQUNOLG1CQUFtQixDQUFDL3pDLHlCQUF5QnMwQyxJQUFJO0lBQzFEO0lBQ0E7Ozs7O0tBS0MsR0FDREMsZUFBZTtRQUNYLElBQUksQ0FBQ1IsbUJBQW1CLENBQUMvekMseUJBQXlCdzBDLGFBQWE7SUFDbkU7SUFDQTs7OztLQUlDLEdBQ0RDLFFBQVE7UUFDSixJQUFJLENBQUN2QixJQUFJLENBQUN1QixLQUFLO0lBQ25CO0FBQ0o7QUFDQSw0RUFBNEU7QUFDNUUsNEVBQTRFO0FBQzVFLCtDQUErQztBQUMvQyxTQUFTdEIsZUFBZTV3QyxPQUFPO0lBQzNCLE1BQU1teUMsWUFBWSxDQUFDO0lBQ25CbnlDLFFBQVFveUMsT0FBTyxDQUFDLENBQUNsNUMsT0FBT0w7UUFDcEJzNUMsU0FBUyxDQUFDdDVDLElBQUksR0FBR0s7SUFDckI7SUFDQSxPQUFPaTVDO0FBQ1g7QUFDQSx1RUFBdUU7QUFDdkUsNEVBQTRFO0FBQzVFLGlCQUFpQjtBQUNqQixTQUFTakMsZUFBZTExQyxHQUFHO0lBQ3ZCLE1BQU13RixVQUFVLElBQUltc0M7SUFDcEIsS0FBSyxNQUFNLENBQUN0ekMsS0FBS0ssTUFBTSxJQUFJSixPQUFPb0gsT0FBTyxDQUFDMUYsS0FBTTtRQUM1Q3dGLFFBQVFvcEMsTUFBTSxDQUFDdndDLEtBQUtLO0lBQ3hCO0lBQ0EsT0FBTzhHO0FBQ1g7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTXF5QyxnQ0FBZ0M7QUFDdEM7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsZUFBZUMsdUJBQXVCM3NDLFNBQVMsRUFBRWdxQyxTQUFTLEVBQUVDLEtBQUs7SUFDN0QsTUFBTUMsZ0JBQWdCLElBQUk3ckM7SUFDMUIsSUFBSXV1QztJQUNKLElBQUkzQyxNQUFNdDJDLElBQUksWUFBWTZ6QyxNQUFNO1FBQzVCb0YsV0FBVyxNQUFNM0MsTUFBTXQyQyxJQUFJLENBQUMyRSxJQUFJO0lBQ3BDLE9BQ0ssSUFBSTJ4QyxNQUFNdDJDLElBQUksWUFBWWs1QyxhQUFhO1FBQ3hDRCxXQUFXLElBQUl2SCxjQUFjSyxNQUFNLENBQUN1RSxNQUFNdDJDLElBQUk7SUFDbEQsT0FDSztRQUNEaTVDLFdBQVczQyxNQUFNdDJDLElBQUk7SUFDekI7SUFDQSxNQUFNQSxPQUFPNGpCLEtBQUt3c0IsS0FBSyxDQUFDNkk7SUFDeEIsSUFBSTVzQyxVQUFVcEIsVUFBVSxJQUFJO1FBQ3hCLE1BQU1pWixPQUFPb1ksNEJBQTRCdDhCO1FBQ3pDUixPQUFPd0IsTUFBTSxDQUFDdTFDLGVBQWVyeUI7SUFDakMsT0FDSztRQUNELE1BQU1BLE9BQU8rViwyQkFBMkJqNkI7UUFDeENSLE9BQU93QixNQUFNLENBQUN1MUMsZUFBZXJ5QjtJQUNqQztJQUNBbXlCLFVBQVVFO0FBQ2Q7QUFDQTs7Ozs7RUFLRSxHQUNGLE1BQU00QztJQUNGMXlDLFlBQVk0RixTQUFTLEVBQUUybUMsSUFBSSxFQUFFeUQsZ0JBQWdCLENBQUU7UUFDM0MsSUFBSSxDQUFDcHFDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDMm1DLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUN5RCxnQkFBZ0IsR0FBR0E7UUFDeEIsSUFBSSxDQUFDMkMsS0FBSyxHQUFHLElBQUk1QyxVQUFVLElBQUksQ0FBQ25xQyxTQUFTLEVBQUUsSUFBSSxDQUFDMm1DLElBQUksRUFBRSxJQUFJLENBQUN5RCxnQkFBZ0I7SUFDL0U7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUF5Q0UsR0FDRixNQUFNQyxRQUFReDFCLE1BQU0sRUFBRTtRQUNsQixJQUFJdGlCLElBQUlDLElBQUlxSSxJQUFJQyxJQUFJQyxJQUFJQztRQUN4Qix3REFBd0Q7UUFDeEQsSUFBSTZaLE9BQU8vVyxNQUFNLElBQUkrVyxPQUFPL1csTUFBTSxDQUFDM0wsV0FBVyxFQUFFO1lBQzVDLE1BQU0sSUFBSXNCLE1BQU0scUVBQ1osb0VBQ0E7UUFDUjtRQUNBLE1BQU02MkMsbUJBQW1CLElBQUksQ0FBQ3RxQyxTQUFTLENBQUM4aUMsbUJBQW1CO1FBQzNELE1BQU1iLGFBQWEsSUFBSSxDQUFDamlDLFNBQVMsQ0FBQ3NpQyxhQUFhO1FBQy9DLElBQUlhO1FBQ0osTUFBTTZKLGdCQUFnQixJQUFJLENBQUNodEMsU0FBUyxDQUFDeWlDLFVBQVU7UUFDL0MsSUFBSTV0QixPQUFPL1csTUFBTSxJQUNiK1csT0FBTy9XLE1BQU0sQ0FBQ21HLEtBQUssSUFDbkJra0MsZ0JBQWdCdHpCLE9BQU8vVyxNQUFNLENBQUNtRyxLQUFLLEdBQUc7WUFDdENva0Msa0JBQWtCMkU7UUFDdEI7UUFDQSxNQUFNM3lDLFVBQVU0eUMsYUFBYUQ7UUFDN0IsSUFBSSxJQUFJLENBQUNodEMsU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCdWtDLE1BQU0sQ0FBQyxFQUFFbUgsaUJBQWlCLDRCQUE0QixFQUFFckksV0FBVyxtQ0FBbUMsQ0FBQztZQUN2RyxNQUFNLElBQUksQ0FBQzBFLElBQUksQ0FBQ0MsY0FBYyxDQUFDdnNDO1FBQ25DLE9BQ0s7WUFDRCxNQUFNMG5DLFNBQVMsSUFBSSxDQUFDL2hDLFNBQVMsQ0FBQzZpQyxTQUFTO1lBQ3ZDLElBQUltQyxTQUFTO1lBQ2IsSUFBSWh4QyxVQUFVO1lBQ2QsSUFBSSt0QyxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBTzdoQyxVQUFVLENBQUMsaUJBQWlCO2dCQUNuRjdFLFFBQVFDLElBQUksQ0FBQztnQkFDYixJQUFJMm1DLGVBQWUsV0FBVztvQkFDMUI1bUMsUUFBUUMsSUFBSSxDQUFDO2dCQUNqQjtnQkFDQTBwQyxTQUFTO2dCQUNUaHhDLFVBQVU7WUFDZDtZQUNBbXZDLE1BQU0sQ0FBQyxFQUFFbUgsaUJBQWlCLGlDQUFpQyxFQUFFckksV0FBVyxtQkFBbUIsRUFBRStDLE9BQU8sQ0FBQyxFQUFFaHhDLFFBQVEsQ0FBQyxFQUFFK3RDLE9BQU8sQ0FBQztRQUM5SDtRQUNBLElBQUl5SSxnQkFBZ0IsS0FBUTtRQUM1QixNQUFNQyxnQkFBZ0IsSUFBSWhzQixRQUFRLENBQUNDO1lBQy9COHJCLGdCQUFnQjlyQjtRQUNwQjtRQUNBLE1BQU1nc0IsWUFBWTcxQixPQUFPNjFCLFNBQVM7UUFDbEMsTUFBTUMsd0JBQXdCO1lBQzFCLElBQUlwNEM7WUFDSEEsQ0FBQUEsS0FBS200QyxjQUFjLFFBQVFBLGNBQWMsS0FBSyxJQUFJLEtBQUssSUFBSUEsVUFBVUcsTUFBTSxNQUFNLFFBQVF0NEMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHZSxJQUFJLENBQUNvM0M7WUFDM0hGLGNBQWMsQ0FBQztRQUNuQjtRQUNBLE1BQU14cUMsWUFBWSxJQUFJLENBQUNBLFNBQVM7UUFDaEMsTUFBTTRxQyxxQkFBcUI7WUFDdkJDLFFBQVFGO1lBQ1JYLFdBQVcsQ0FBQ0M7Z0JBQ1IsS0FBSzBDLHVCQUF1QjNzQyxXQUFXMHFDLFVBQVVWLFNBQVMsRUFBRUM7WUFDaEU7WUFDQWEsU0FBUyxDQUFDdjRDLEtBQUttNEMsY0FBYyxRQUFRQSxjQUFjLEtBQUssSUFBSSxLQUFLLElBQUlBLFVBQVVJLE9BQU8sTUFBTSxRQUFRdjRDLE9BQU8sS0FBSyxJQUFJQSxLQUFLLFNBQVUwc0IsQ0FBQyxHQUNwSTtZQUNBOHJCLFNBQVMsQ0FBQ3Y0QyxLQUFLazRDLGNBQWMsUUFBUUEsY0FBYyxLQUFLLElBQUksS0FBSyxJQUFJQSxVQUFVSyxPQUFPLE1BQU0sUUFBUXY0QyxPQUFPLEtBQUssSUFBSUEsS0FBSyxTQUFVeXNCLENBQUMsR0FDcEk7UUFDSjtRQUNBLE1BQU0rckIsT0FBTyxJQUFJLENBQUNaLGdCQUFnQixDQUFDL3pCLE1BQU0sQ0FBQzhzQixLQUFLK0osYUFBYTd5QyxVQUFVdXdDO1FBQ3RFSSxLQUFLWCxPQUFPO1FBQ1osMERBQTBEO1FBQzFELE1BQU1JO1FBQ04sSUFBSW5xQyxtQkFBbUJQLE9BQU8sSUFBSSxDQUFDQyxTQUFTLEVBQUU2VSxPQUFPNVUsS0FBSztRQUMxRCxJQUFJLElBQUksQ0FBQ0QsU0FBUyxDQUFDcEIsVUFBVSxNQUN6QjBCLGlCQUFpQkosVUFBVSxDQUFDLGdCQUFnQjtZQUM1QyxNQUFNMmhDLFVBQVUsSUFBSSxDQUFDN2hDLFNBQVMsQ0FBQ08sVUFBVTtZQUN6QyxNQUFNdWhDLFdBQVcsSUFBSSxDQUFDOWhDLFNBQVMsQ0FBQ1EsV0FBVztZQUMzQ0YsbUJBQ0ksQ0FBQyxTQUFTLEVBQUV1aEMsUUFBUSxXQUFXLEVBQUVDLFNBQVMsQ0FBQyxDQUFDLEdBQUd4aEM7UUFDdkQ7UUFDQSxJQUFJNnFDLGdCQUFnQixDQUFDO1FBQ3JCLElBQUksSUFBSSxDQUFDbnJDLFNBQVMsQ0FBQ3BCLFVBQVUsTUFDekIsQ0FBQyxDQUFDL0QsS0FBS2dhLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWpELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3N5QyxrQkFBa0IsTUFBTXg3QyxXQUFXO1lBQ2pHLGdEQUFnRDtZQUNoRCxJQUFJa2pCLE9BQU8vVyxNQUFNLEtBQUtuTSxXQUFXO2dCQUM3QmtqQixPQUFPL1csTUFBTSxHQUFHO29CQUFFcXZDLG9CQUFvQjt3QkFBQ2wzQyxTQUFTbTNDLEtBQUs7cUJBQUM7Z0JBQUM7WUFDM0QsT0FDSztnQkFDRHY0QixPQUFPL1csTUFBTSxDQUFDcXZDLGtCQUFrQixHQUFHO29CQUFDbDNDLFNBQVNtM0MsS0FBSztpQkFBQztZQUN2RDtRQUNKO1FBQ0EsSUFBSSxDQUFDdHlDLEtBQUsrWixPQUFPL1csTUFBTSxNQUFNLFFBQVFoRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd1eUMsZ0JBQWdCLEVBQUU7WUFDL0Usa0RBQWtEO1lBQ2xEaHlDLFFBQVFDLElBQUksQ0FBQztRQUNqQjtRQUNBLE1BQU1neUMsYUFBYSxDQUFDdHlDLEtBQUssQ0FBQ0QsS0FBSzhaLE9BQU8vVyxNQUFNLE1BQU0sUUFBUS9DLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tKLEtBQUssTUFBTSxRQUFRakosT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtRQUNoSSxNQUFNdXlDLGlCQUFpQixFQUFFO1FBQ3pCLEtBQUssTUFBTTdwQyxRQUFRNHBDLFdBQVk7WUFDM0IsSUFBSSxJQUFJLENBQUNFLGNBQWMsQ0FBQzlwQyxPQUFPO2dCQUMzQixNQUFNK3BDLGVBQWUvcEM7Z0JBQ3JCNnBDLGVBQWV6ekMsSUFBSSxDQUFDLE1BQU0yekMsYUFBYS9wQyxJQUFJO1lBQy9DLE9BQ0s7Z0JBQ0Q2cEMsZUFBZXp6QyxJQUFJLENBQUM0SjtZQUN4QjtRQUNKO1FBQ0EsSUFBSTZwQyxlQUFlejVDLE1BQU0sR0FBRyxHQUFHO1lBQzNCK2dCLE9BQU8vVyxNQUFNLENBQUNtRyxLQUFLLEdBQUdzcEM7UUFDMUI7UUFDQSxNQUFNRyx3QkFBd0I7WUFDMUJ6dEMsT0FBT0s7WUFDUHhDLFFBQVErVyxPQUFPL1csTUFBTTtZQUNyQjRzQyxXQUFXNzFCLE9BQU82MUIsU0FBUztRQUMvQjtRQUNBLElBQUksSUFBSSxDQUFDMXFDLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QnVzQyxnQkFBZ0J0Z0IsOEJBQThCLElBQUksQ0FBQzdxQixTQUFTLEVBQUUwdEM7UUFDbEUsT0FDSztZQUNEdkMsZ0JBQWdCbmtCLDZCQUE2QixJQUFJLENBQUNobkIsU0FBUyxFQUFFMHRDO1FBQ2pFO1FBQ0EsT0FBT3ZDLGFBQWEsQ0FBQyxTQUFTO1FBQzlCSCxLQUFLSSxJQUFJLENBQUM3ekIsS0FBS0MsU0FBUyxDQUFDMnpCO1FBQ3pCLE9BQU8sSUFBSXdDLFFBQVEzQyxNQUFNLElBQUksQ0FBQ2hyQyxTQUFTO0lBQzNDO0lBQ0EsOERBQThEO0lBQzlEd3RDLGVBQWU5cEMsSUFBSSxFQUFFO1FBQ2pCLE9BQU8sY0FBY0EsUUFBUSxPQUFPQSxLQUFLNmxDLFFBQVEsS0FBSztJQUMxRDtBQUNKO0FBQ0EsTUFBTXFFLDBDQUEwQztJQUM1Q0MsY0FBYztBQUNsQjtBQUNBOzs7O0VBSUUsR0FDRixNQUFNRjtJQUNGdnpDLFlBQVk0d0MsSUFBSSxFQUFFaHJDLFNBQVMsQ0FBRTtRQUN6QixJQUFJLENBQUNnckMsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2hyQyxTQUFTLEdBQUdBO0lBQ3JCO0lBQ0E4dEMsbUJBQW1COXRDLFNBQVMsRUFBRTZVLE1BQU0sRUFBRTtRQUNsQyxJQUFJQSxPQUFPazVCLEtBQUssS0FBSyxRQUFRbDVCLE9BQU9rNUIsS0FBSyxLQUFLcDhDLFdBQVc7WUFDckQsSUFBSWl2QixXQUFXLEVBQUU7WUFDakIsSUFBSTtnQkFDQUEsV0FBV2xmLFVBQVVtVCxPQUFPazVCLEtBQUs7Z0JBQ2pDLElBQUkvdEMsVUFBVXBCLFVBQVUsSUFBSTtvQkFDeEJnaUIsV0FBV0EsU0FBUy9yQixHQUFHLENBQUMsQ0FBQ3NNLE9BQVNtekIsZ0JBQWdCbnpCO2dCQUN0RCxPQUNLO29CQUNEeWYsV0FBV0EsU0FBUy9yQixHQUFHLENBQUMsQ0FBQ3NNLE9BQVNtdkIsaUJBQWlCbnZCO2dCQUN2RDtZQUNKLEVBQ0EsT0FBTzVPLElBQUk7Z0JBQ1AsTUFBTSxJQUFJa0IsTUFBTSxDQUFDLCtDQUErQyxFQUFFLE9BQU9vaEIsT0FBT2s1QixLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzVGO1lBQ0EsT0FBTztnQkFDSHRDLGVBQWU7b0JBQUVzQyxPQUFPbnRCO29CQUFVaXRCLGNBQWNoNUIsT0FBT2c1QixZQUFZO2dCQUFDO1lBQ3hFO1FBQ0o7UUFDQSxPQUFPO1lBQ0hwQyxlQUFlO2dCQUFFb0MsY0FBY2g1QixPQUFPZzVCLFlBQVk7WUFBQztRQUN2RDtJQUNKO0lBQ0FHLHlCQUF5Qmh1QyxTQUFTLEVBQUU2VSxNQUFNLEVBQUU7UUFDeEMsSUFBSWxWLG9CQUFvQixFQUFFO1FBQzFCLElBQUlrVixPQUFPbFYsaUJBQWlCLElBQUksTUFBTTtZQUNsQyxNQUFNLElBQUlsTSxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDUyxNQUFNQyxPQUFPLENBQUMwZ0IsT0FBT2xWLGlCQUFpQixHQUFHO1lBQzFDQSxvQkFBb0I7Z0JBQUNrVixPQUFPbFYsaUJBQWlCO2FBQUM7UUFDbEQsT0FDSztZQUNEQSxvQkFBb0JrVixPQUFPbFYsaUJBQWlCO1FBQ2hEO1FBQ0EsSUFBSUEsa0JBQWtCN0wsTUFBTSxLQUFLLEdBQUc7WUFDaEMsTUFBTSxJQUFJTCxNQUFNO1FBQ3BCO1FBQ0EsS0FBSyxNQUFNcUYsb0JBQW9CNkcsa0JBQW1CO1lBQzlDLElBQUksT0FBTzdHLHFCQUFxQixZQUM1QkEscUJBQXFCLFFBQ3JCLENBQUUsV0FBVUEsZ0JBQWUsS0FDM0IsQ0FBRSxlQUFjQSxnQkFBZSxHQUFJO2dCQUNuQyxNQUFNLElBQUlyRixNQUFNLENBQUMseUNBQXlDLEVBQUUsT0FBT3FGLGlCQUFpQixFQUFFLENBQUM7WUFDM0Y7WUFDQSxJQUFJLENBQUNrSCxVQUFVcEIsVUFBVSxNQUFNLENBQUUsU0FBUTlGLGdCQUFlLEdBQUk7Z0JBQ3hELE1BQU0sSUFBSXJGLE1BQU1pNUM7WUFDcEI7UUFDSjtRQUNBLE1BQU12QixnQkFBZ0I7WUFDbEI4QyxjQUFjO2dCQUFFdHVDLG1CQUFtQkE7WUFBa0I7UUFDekQ7UUFDQSxPQUFPd3JDO0lBQ1g7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBZ0RDLEdBQ0QrQyxrQkFBa0JyNUIsTUFBTSxFQUFFO1FBQ3RCQSxTQUFTMWhCLE9BQU93QixNQUFNLENBQUN4QixPQUFPd0IsTUFBTSxDQUFDLENBQUMsR0FBR2k1QywwQ0FBMEMvNEI7UUFDbkYsTUFBTXMyQixnQkFBZ0IsSUFBSSxDQUFDMkMsa0JBQWtCLENBQUMsSUFBSSxDQUFDOXRDLFNBQVMsRUFBRTZVO1FBQzlELElBQUksQ0FBQ20yQixJQUFJLENBQUNJLElBQUksQ0FBQzd6QixLQUFLQyxTQUFTLENBQUMyekI7SUFDbEM7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBcUJDLEdBQ0RnRCxrQkFBa0J0NUIsTUFBTSxFQUFFO1FBQ3RCLElBQUlzMkIsZ0JBQWdCLENBQUM7UUFDckIsSUFBSSxJQUFJLENBQUNuckMsU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCdXNDLGdCQUFnQjtnQkFDWixpQkFBaUJuZ0Isd0NBQXdDblc7WUFDN0Q7UUFDSixPQUNLO1lBQ0RzMkIsZ0JBQWdCO2dCQUNaLGlCQUFpQmhrQix1Q0FBdUN0UztZQUM1RDtRQUNKO1FBQ0EsSUFBSSxDQUFDbTJCLElBQUksQ0FBQ0ksSUFBSSxDQUFDN3pCLEtBQUtDLFNBQVMsQ0FBQzJ6QjtJQUNsQztJQUNBOzs7Ozs7Ozs7Ozs7O0tBYUMsR0FDRGlELGlCQUFpQnY1QixNQUFNLEVBQUU7UUFDckIsSUFBSUEsT0FBT2xWLGlCQUFpQixJQUFJLE1BQU07WUFDbEMsTUFBTSxJQUFJbE0sTUFBTTtRQUNwQjtRQUNBLE1BQU0wM0MsZ0JBQWdCLElBQUksQ0FBQzZDLHdCQUF3QixDQUFDLElBQUksQ0FBQ2h1QyxTQUFTLEVBQUU2VTtRQUNwRSxJQUFJLENBQUNtMkIsSUFBSSxDQUFDSSxJQUFJLENBQUM3ekIsS0FBS0MsU0FBUyxDQUFDMnpCO0lBQ2xDO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FzQkMsR0FDRG9CLFFBQVE7UUFDSixJQUFJLENBQUN2QixJQUFJLENBQUN1QixLQUFLO0lBQ25CO0FBQ0o7QUFDQSw0RUFBNEU7QUFDNUUsNEVBQTRFO0FBQzVFLCtDQUErQztBQUMvQyxTQUFTVyxhQUFhN3lDLE9BQU87SUFDekIsTUFBTW15QyxZQUFZLENBQUM7SUFDbkJueUMsUUFBUW95QyxPQUFPLENBQUMsQ0FBQ2w1QyxPQUFPTDtRQUNwQnM1QyxTQUFTLENBQUN0NUMsSUFBSSxHQUFHSztJQUNyQjtJQUNBLE9BQU9pNUM7QUFDWDtBQUNBLHVFQUF1RTtBQUN2RSw0RUFBNEU7QUFDNUUsaUJBQWlCO0FBQ2pCLFNBQVNTLGFBQWFwNEMsR0FBRztJQUNyQixNQUFNd0YsVUFBVSxJQUFJbXNDO0lBQ3BCLEtBQUssTUFBTSxDQUFDdHpDLEtBQUtLLE1BQU0sSUFBSUosT0FBT29ILE9BQU8sQ0FBQzFGLEtBQU07UUFDNUN3RixRQUFRb3BDLE1BQU0sQ0FBQ3Z3QyxLQUFLSztJQUN4QjtJQUNBLE9BQU84RztBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1nMEMsMkJBQTJCO0FBQ2pDLDREQUE0RCxHQUM1RCxTQUFTQyxpQkFBaUJ4d0MsTUFBTTtJQUM1QixJQUFJdkwsSUFBSUMsSUFBSXFJO0lBQ1osSUFBSSxDQUFDdEksS0FBS3VMLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPeXdDLHdCQUF3QixNQUFNLFFBQVFoOEMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaThDLE9BQU8sRUFBRTtRQUN4SSxPQUFPO0lBQ1g7SUFDQSxJQUFJQyx1QkFBdUI7SUFDM0IsS0FBSyxNQUFNL3FDLFFBQVEsQ0FBQ2xSLEtBQUtzTCxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT21HLEtBQUssTUFBTSxRQUFRelIsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRSxDQUFFO1FBQ3hILElBQUlnN0MsZUFBZTlwQyxPQUFPO1lBQ3RCK3FDLHVCQUF1QjtZQUN2QjtRQUNKO0lBQ0o7SUFDQSxJQUFJLENBQUNBLHNCQUFzQjtRQUN2QixPQUFPO0lBQ1g7SUFDQSxNQUFNQyxXQUFXLENBQUM3ekMsS0FBS2lELFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPeXdDLHdCQUF3QixNQUFNLFFBQVExekMsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHOHpDLGtCQUFrQjtJQUNsSyxJQUFJLFlBQWNELENBQUFBLFdBQVcsS0FBSyxDQUFDRSxPQUFPQyxTQUFTLENBQUNILFNBQVEsS0FDeERBLFlBQVksR0FBRztRQUNmcnpDLFFBQVFDLElBQUksQ0FBQyxvTUFBb01vekM7UUFDak4sT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBU2xCLGVBQWU5cEMsSUFBSTtJQUN4QixPQUFPLGNBQWNBLFFBQVEsT0FBT0EsS0FBSzZsQyxRQUFRLEtBQUs7QUFDMUQ7QUFDQSxnRkFBZ0Y7QUFDaEYseUNBQXlDO0FBQ3pDLFNBQVN1RixpQkFBaUJqNkIsTUFBTTtJQUM1QixJQUFJdGlCLElBQUlDLElBQUlxSTtJQUNaLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDckksS0FBSyxDQUFDRCxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzBSLEtBQUssTUFBTSxRQUFRelIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHdThDLElBQUksQ0FBQyxDQUFDcnJDLE9BQVM4cEMsZUFBZTlwQyxNQUFLLE1BQU8sUUFBUTdJLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0FBQzFNO0FBQ0EsZ0ZBQWdGO0FBQ2hGLG1EQUFtRDtBQUNuRCxTQUFTbTBDLG9CQUFvQm42QixNQUFNO0lBQy9CLElBQUl0aUIsSUFBSUMsSUFBSXFJO0lBQ1osT0FBTyxDQUFDQSxLQUFLLENBQUNySSxLQUFLLENBQUNELEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMFIsS0FBSyxNQUFNLFFBQVF6UixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd1OEMsSUFBSSxDQUFDLENBQUNyckMsT0FBUyxDQUFDOHBDLGVBQWU5cEMsTUFBSyxNQUFPLFFBQVE3SSxPQUFPLEtBQUssSUFBSUEsS0FBSztBQUMzTTtBQUNBOzs7Q0FHQyxHQUNELFNBQVNvMEMsdUJBQXVCbnhDLE1BQU07SUFDbEMsSUFBSXZMO0lBQ0osT0FBTyxDQUFFLEVBQUNBLEtBQUt1TCxXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT3l3Qyx3QkFBd0IsTUFBTSxRQUFRaDhDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzI4QyxpQkFBaUI7QUFDN0o7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUMsZUFBZXg4QztJQUNqQnlILFlBQVk0RixTQUFTLENBQUU7UUFDbkIsS0FBSztRQUNMLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtRQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQXFDQyxHQUNELElBQUksQ0FBQzJnQixlQUFlLEdBQUcsT0FBTzlMO1lBQzFCLElBQUl0aUIsSUFBSUMsSUFBSXFJLElBQUlDLElBQUlDO1lBQ3BCLE1BQU1xMEMsb0JBQW9CLE1BQU0sSUFBSSxDQUFDQyw2QkFBNkIsQ0FBQ3g2QjtZQUNuRSxJQUFJLENBQUN5NkIsNEJBQTRCLENBQUN6NkI7WUFDbEMsSUFBSSxDQUFDaTZCLGlCQUFpQmo2QixXQUFXeTVCLGlCQUFpQno1QixPQUFPL1csTUFBTSxHQUFHO2dCQUM5RCxPQUFPLE1BQU0sSUFBSSxDQUFDeXhDLHVCQUF1QixDQUFDSDtZQUM5QztZQUNBLElBQUlKLG9CQUFvQm42QixTQUFTO2dCQUM3QixNQUFNLElBQUlwaEIsTUFBTTtZQUNwQjtZQUNBLElBQUlvRjtZQUNKLElBQUkyMkM7WUFDSixNQUFNdnVCLGtDQUFrQ3ZmLFVBQVUwdEMsa0JBQWtCeHVCLFFBQVE7WUFDNUUsTUFBTTZ1QixpQkFBaUIsQ0FBQzUwQyxLQUFLLENBQUNySSxLQUFLLENBQUNELEtBQUs2OEMsa0JBQWtCdHhDLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHZzhDLHdCQUF3QixNQUFNLFFBQVEvN0MsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHbThDLGtCQUFrQixNQUFNLFFBQVE5ekMsT0FBTyxLQUFLLElBQUlBLEtBQUt3ekM7WUFDbE8sSUFBSXFCLGNBQWM7WUFDbEIsTUFBT0EsY0FBY0QsZUFBZ0I7Z0JBQ2pDNTJDLFdBQVcsTUFBTSxJQUFJLENBQUMwMkMsdUJBQXVCLENBQUNIO2dCQUM5QyxJQUFJLENBQUN2MkMsU0FBU2tELGFBQWEsSUFBSWxELFNBQVNrRCxhQUFhLENBQUNqSSxNQUFNLEtBQUssR0FBRztvQkFDaEU7Z0JBQ0o7Z0JBQ0EsTUFBTTY3QyxrQkFBa0I5MkMsU0FBU3NDLFVBQVUsQ0FBQyxFQUFFLENBQUNDLE9BQU87Z0JBQ3RELE1BQU13MEMsd0JBQXdCLEVBQUU7Z0JBQ2hDLEtBQUssTUFBTWxzQyxRQUFRLENBQUMzSSxLQUFLLENBQUNELEtBQUsrWixPQUFPL1csTUFBTSxNQUFNLFFBQVFoRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdtSixLQUFLLE1BQU0sUUFBUWxKLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsQ0FBRTtvQkFDOUgsSUFBSXl5QyxlQUFlOXBDLE9BQU87d0JBQ3RCLE1BQU0rcEMsZUFBZS9wQzt3QkFDckIsTUFBTTdKLFFBQVEsTUFBTTR6QyxhQUFhbEUsUUFBUSxDQUFDMXdDLFNBQVNrRCxhQUFhO3dCQUNoRTZ6QyxzQkFBc0I5MUMsSUFBSSxJQUFJRDtvQkFDbEM7Z0JBQ0o7Z0JBQ0E2MUM7Z0JBQ0FGLDBCQUEwQjtvQkFDdEJ2MUMsTUFBTTtvQkFDTkosT0FBTysxQztnQkFDWDtnQkFDQVIsa0JBQWtCeHVCLFFBQVEsR0FBR2xmLFVBQVUwdEMsa0JBQWtCeHVCLFFBQVE7Z0JBQ2pFd3VCLGtCQUFrQnh1QixRQUFRLENBQUM5bUIsSUFBSSxDQUFDNjFDO2dCQUNoQ1Asa0JBQWtCeHVCLFFBQVEsQ0FBQzltQixJQUFJLENBQUMwMUM7Z0JBQ2hDLElBQUlQLHVCQUF1Qkcsa0JBQWtCdHhDLE1BQU0sR0FBRztvQkFDbERtakIsZ0NBQWdDbm5CLElBQUksQ0FBQzYxQztvQkFDckMxdUIsZ0NBQWdDbm5CLElBQUksQ0FBQzAxQztnQkFDekM7WUFDSjtZQUNBLElBQUlQLHVCQUF1Qkcsa0JBQWtCdHhDLE1BQU0sR0FBRztnQkFDbERqRixTQUFTb29CLCtCQUErQixHQUNwQ0E7WUFDUjtZQUNBLE9BQU9wb0I7UUFDWDtRQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBd0NDLEdBQ0QsSUFBSSxDQUFDeW9CLHFCQUFxQixHQUFHLE9BQU96TTtZQUNoQyxJQUFJLENBQUN5NkIsNEJBQTRCLENBQUN6NkI7WUFDbEMsSUFBSXk1QixpQkFBaUJ6NUIsT0FBTy9XLE1BQU0sR0FBRztnQkFDakMsTUFBTXN4QyxvQkFBb0IsTUFBTSxJQUFJLENBQUNDLDZCQUE2QixDQUFDeDZCO2dCQUNuRSxPQUFPLE1BQU0sSUFBSSxDQUFDZzdCLDZCQUE2QixDQUFDVDtZQUNwRCxPQUNLO2dCQUNELE9BQU8sTUFBTSxJQUFJLENBQUNVLGdCQUFnQixDQUFDajdCO1lBQ3ZDO1FBQ0o7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBa0JDLEdBQ0QsSUFBSSxDQUFDazdCLGNBQWMsR0FBRyxPQUFPbDdCO1lBQ3pCLE9BQU8sTUFBTSxJQUFJLENBQUNtN0Isc0JBQXNCLENBQUNuN0IsUUFBUThDLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ25ELElBQUlwTTtnQkFDSixJQUFJMDlDO2dCQUNKLE1BQU1DLGtCQUFrQixFQUFFO2dCQUMxQixJQUFJdnhDLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsWUFBWXV4QyxlQUFlLEVBQUU7b0JBQ3ZGLEtBQUssTUFBTUMsa0JBQWtCeHhDLFlBQVl1eEMsZUFBZSxDQUFFO3dCQUN0RCxJQUFJQyxrQkFDQ0EsQ0FBQUEsbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUksS0FBSyxJQUFJQSxlQUFlQyxnQkFBZ0IsS0FDaEcsQ0FBQyxDQUFDNzlDLEtBQUs0OUMsbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUksS0FBSyxJQUFJQSxlQUFlQyxnQkFBZ0IsTUFBTSxRQUFRNzlDLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzg5QyxXQUFXLE1BQU0sbUJBQW1COzRCQUNwTEosaUNBQWlDRSxtQkFBbUIsUUFBUUEsbUJBQW1CLEtBQUssSUFBSSxLQUFLLElBQUlBLGVBQWVDLGdCQUFnQjt3QkFDcEksT0FDSzs0QkFDREYsZ0JBQWdCcDJDLElBQUksQ0FBQ3EyQzt3QkFDekI7b0JBQ0o7Z0JBQ0o7Z0JBQ0EsSUFBSXQzQztnQkFDSixJQUFJbzNDLGdDQUFnQztvQkFDaENwM0MsV0FBVzt3QkFDUHEzQyxpQkFBaUJBO3dCQUNqQkQsZ0NBQWdDQTt3QkFDaEM3NkIsaUJBQWlCelcsWUFBWXlXLGVBQWU7b0JBQ2hEO2dCQUNKLE9BQ0s7b0JBQ0R2YyxXQUFXO3dCQUNQcTNDLGlCQUFpQkE7d0JBQ2pCOTZCLGlCQUFpQnpXLFlBQVl5VyxlQUFlO29CQUNoRDtnQkFDSjtnQkFDQSxPQUFPdmM7WUFDWDtRQUNKO1FBQ0EsSUFBSSxDQUFDa2YsSUFBSSxHQUFHLE9BQU9sRDtZQUNmLElBQUl0aUI7WUFDSixNQUFNKzlDLGdCQUFnQjtnQkFDbEJDLFdBQVc7WUFDZjtZQUNBLE1BQU1DLGVBQWVyOUMsT0FBT3dCLE1BQU0sQ0FBQ3hCLE9BQU93QixNQUFNLENBQUMsQ0FBQyxHQUFHMjdDLGdCQUFnQno3QixXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBTy9XLE1BQU07WUFDbEksTUFBTTJ5QyxlQUFlO2dCQUNqQjN5QyxRQUFRMHlDO1lBQ1o7WUFDQSxJQUFJLElBQUksQ0FBQ3h3QyxTQUFTLENBQUNwQixVQUFVLElBQUk7Z0JBQzdCLElBQUksQ0FBQzZ4QyxhQUFhM3lDLE1BQU0sQ0FBQ3l5QyxTQUFTLEVBQUU7b0JBQ2hDLElBQUksQ0FBQ2grQyxLQUFLaytDLGFBQWEzeUMsTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUd5SixNQUFNLEVBQUU7d0JBQzNFLE1BQU0sSUFBSXZJLE1BQU07b0JBQ3BCLE9BQ0s7d0JBQ0RnOUMsYUFBYTN5QyxNQUFNLENBQUM5QixNQUFNLEdBQUc7b0JBQ2pDO2dCQUNKO1lBQ0o7WUFDQSxPQUFPLElBQUkyWSxNQUFNRCxVQUFVZzhCLGlCQUFpQixFQUFFLENBQUN6NEIsSUFBTSxJQUFJLENBQUNDLFlBQVksQ0FBQ0QsSUFBSSxNQUFNLElBQUksQ0FBQ0MsWUFBWSxDQUFDdTRCLGVBQWVBO1FBQ3RIO1FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FtQkMsR0FDRCxJQUFJLENBQUNFLFNBQVMsR0FBRyxPQUFPOTdCO1lBQ3BCLE1BQU1FLGlCQUFpQjtnQkFDbkI5VSxPQUFPNFUsT0FBTzVVLEtBQUs7Z0JBQ25CMndDLFFBQVEvN0IsT0FBTys3QixNQUFNO2dCQUNyQkMsaUJBQWlCLEVBQUU7Z0JBQ25CL3lDLFFBQVErVyxPQUFPL1csTUFBTTtZQUN6QjtZQUNBLElBQUkrVyxPQUFPZzhCLGVBQWUsRUFBRTtnQkFDeEIsSUFBSWg4QixPQUFPZzhCLGVBQWUsRUFBRTtvQkFDeEI5N0IsZUFBZTg3QixlQUFlLEdBQUdoOEIsT0FBT2c4QixlQUFlLENBQUNoOEMsR0FBRyxDQUFDLENBQUNpOEMsTUFBUUEsSUFBSXZ6QyxtQkFBbUI7Z0JBQ2hHO1lBQ0o7WUFDQSxPQUFPLE1BQU0sSUFBSSxDQUFDd3pDLGlCQUFpQixDQUFDaDhCO1FBQ3hDO1FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0FtQkMsR0FDRCxJQUFJLENBQUNpOEIsWUFBWSxHQUFHLE9BQU9uOEI7WUFDdkIsSUFBSW84QixZQUFZO2dCQUNaQyxnQkFBZ0I7Z0JBQ2hCQyxNQUFNO1lBQ1Y7WUFDQSxJQUFJdDhCLE9BQU8vVyxNQUFNLEVBQUU7Z0JBQ2ZtekMsWUFBWTk5QyxPQUFPd0IsTUFBTSxDQUFDeEIsT0FBT3dCLE1BQU0sQ0FBQyxDQUFDLEdBQUdzOEMsWUFBWXA4QixPQUFPL1csTUFBTTtZQUN6RTtZQUNBLE1BQU1zekMsWUFBWTtnQkFDZG54QyxPQUFPNFUsT0FBTzVVLEtBQUs7Z0JBQ25Cb3hDLE9BQU94OEIsT0FBT3c4QixLQUFLO2dCQUNuQkMsZUFBZXo4QixPQUFPeThCLGFBQWE7Z0JBQ25DeHpDLFFBQVFtekM7WUFDWjtZQUNBLE9BQU8sTUFBTSxJQUFJLENBQUNNLG9CQUFvQixDQUFDSDtRQUMzQztRQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBc0JDLEdBQ0QsSUFBSSxDQUFDSSxjQUFjLEdBQUcsT0FBTzM4QjtZQUN6QixPQUFPLE1BQU0sSUFBSSxDQUFDNDhCLHNCQUFzQixDQUFDNThCO1FBQzdDO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRHk2Qiw2QkFBNkJ6NkIsTUFBTSxFQUFFO1FBQ2pDLElBQUlBLE9BQU8vVyxNQUFNLElBQUkrVyxPQUFPL1csTUFBTSxDQUFDNHpDLGNBQWMsRUFBRTtZQUMvQyxJQUFJLENBQUM3OEIsT0FBTy9XLE1BQU0sQ0FBQ2lHLGtCQUFrQixFQUFFO2dCQUNuQyxJQUFJNVEsT0FBT1MsSUFBSSxDQUFDaWhCLE9BQU8vVyxNQUFNLENBQUM0ekMsY0FBYyxFQUFFeHZDLFFBQVEsQ0FBQyxZQUFZO29CQUMvRDJTLE9BQU8vVyxNQUFNLENBQUNpRyxrQkFBa0IsR0FBRzhRLE9BQU8vVyxNQUFNLENBQUM0ekMsY0FBYztvQkFDL0QsT0FBTzc4QixPQUFPL1csTUFBTSxDQUFDNHpDLGNBQWM7Z0JBQ3ZDO1lBQ0o7UUFDSjtRQUNBO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNELE1BQU1yQyw4QkFBOEJ4NkIsTUFBTSxFQUFFO1FBQ3hDLElBQUl0aUIsSUFBSUMsSUFBSXFJO1FBQ1osTUFBTW9KLFFBQVEsQ0FBQzFSLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMFIsS0FBSztRQUNoRixJQUFJLENBQUNBLE9BQU87WUFDUixPQUFPNFE7UUFDWDtRQUNBLE1BQU04OEIsbUJBQW1CLE1BQU1sekIsUUFBUW16QixHQUFHLENBQUMzdEMsTUFBTXBQLEdBQUcsQ0FBQyxPQUFPNk87WUFDeEQsSUFBSThwQyxlQUFlOXBDLE9BQU87Z0JBQ3RCLE1BQU0rcEMsZUFBZS9wQztnQkFDckIsT0FBTyxNQUFNK3BDLGFBQWEvcEMsSUFBSTtZQUNsQztZQUNBLE9BQU9BO1FBQ1g7UUFDQSxNQUFNbXVDLFlBQVk7WUFDZDV4QyxPQUFPNFUsT0FBTzVVLEtBQUs7WUFDbkIyZ0IsVUFBVS9MLE9BQU8rTCxRQUFRO1lBQ3pCOWlCLFFBQVEzSyxPQUFPd0IsTUFBTSxDQUFDeEIsT0FBT3dCLE1BQU0sQ0FBQyxDQUFDLEdBQUdrZ0IsT0FBTy9XLE1BQU0sR0FBRztnQkFBRW1HLE9BQU8wdEM7WUFBaUI7UUFDdEY7UUFDQUUsVUFBVS96QyxNQUFNLENBQUNtRyxLQUFLLEdBQUcwdEM7UUFDekIsSUFBSTk4QixPQUFPL1csTUFBTSxJQUNiK1csT0FBTy9XLE1BQU0sQ0FBQ21HLEtBQUssSUFDbkJra0MsZ0JBQWdCdHpCLE9BQU8vVyxNQUFNLENBQUNtRyxLQUFLLEdBQUc7WUFDdEMsTUFBTTVKLFVBQVUsQ0FBQ1EsS0FBSyxDQUFDckksS0FBS3FpQixPQUFPL1csTUFBTSxDQUFDM0wsV0FBVyxNQUFNLFFBQVFLLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzZILE9BQU8sTUFBTSxRQUFRUSxPQUFPLEtBQUssSUFBSUEsS0FBSyxDQUFDO1lBQzFJLElBQUlpM0MsYUFBYTMrQyxPQUFPd0IsTUFBTSxDQUFDLENBQUMsR0FBRzBGO1lBQ25DLElBQUlsSCxPQUFPUyxJQUFJLENBQUNrK0MsWUFBWWgrQyxNQUFNLEtBQUssR0FBRztnQkFDdENnK0MsYUFBYSxJQUFJLENBQUM5eEMsU0FBUyxDQUFDb2lDLGlCQUFpQjtZQUNqRDtZQUNBaUcsa0JBQWtCeUo7WUFDbEJELFVBQVUvekMsTUFBTSxDQUFDM0wsV0FBVyxHQUFHZ0IsT0FBT3dCLE1BQU0sQ0FBQ3hCLE9BQU93QixNQUFNLENBQUMsQ0FBQyxHQUFHa2dCLE9BQU8vVyxNQUFNLENBQUMzTCxXQUFXLEdBQUc7Z0JBQUVrSSxTQUFTeTNDO1lBQVc7UUFDckg7UUFDQSxPQUFPRDtJQUNYO0lBQ0EsTUFBTUUsZ0JBQWdCbDlCLE1BQU0sRUFBRTtRQUMxQixJQUFJdGlCLElBQUlDLElBQUlxSTtRQUNaLE1BQU1tM0MsV0FBVyxJQUFJQztRQUNyQixLQUFLLE1BQU12dUMsUUFBUSxDQUFDbFIsS0FBSyxDQUFDRCxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzBSLEtBQUssTUFBTSxRQUFRelIsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRSxDQUFFO1lBQzlILElBQUlnN0MsZUFBZTlwQyxPQUFPO2dCQUN0QixNQUFNK3BDLGVBQWUvcEM7Z0JBQ3JCLE1BQU13dUMsa0JBQWtCLE1BQU16RSxhQUFhL3BDLElBQUk7Z0JBQy9DLEtBQUssTUFBTXl1QyxlQUFlLENBQUN0M0MsS0FBS3EzQyxnQkFBZ0J2dUMsb0JBQW9CLE1BQU0sUUFBUTlJLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsQ0FBRTtvQkFDdkcsSUFBSSxDQUFDczNDLFlBQVkzNUMsSUFBSSxFQUFFO3dCQUNuQixNQUFNLElBQUkvRSxNQUFNO29CQUNwQjtvQkFDQSxJQUFJdStDLFNBQVM5ckMsR0FBRyxDQUFDaXNDLFlBQVkzNUMsSUFBSSxHQUFHO3dCQUNoQyxNQUFNLElBQUkvRSxNQUFNLENBQUMsaUNBQWlDLEVBQUUwK0MsWUFBWTM1QyxJQUFJLENBQUMsQ0FBQztvQkFDMUU7b0JBQ0F3NUMsU0FBUy9OLEdBQUcsQ0FBQ2tPLFlBQVkzNUMsSUFBSSxFQUFFaTFDO2dCQUNuQztZQUNKO1FBQ0o7UUFDQSxPQUFPdUU7SUFDWDtJQUNBLE1BQU1sQyxpQkFBaUJqN0IsTUFBTSxFQUFFO1FBQzNCLElBQUl0aUIsSUFBSUMsSUFBSXFJO1FBQ1osTUFBTTQwQyxpQkFBaUIsQ0FBQzUwQyxLQUFLLENBQUNySSxLQUFLLENBQUNELEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHZzhDLHdCQUF3QixNQUFNLFFBQVEvN0MsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHbThDLGtCQUFrQixNQUFNLFFBQVE5ekMsT0FBTyxLQUFLLElBQUlBLEtBQUt3ekM7UUFDdk4sSUFBSStELHNCQUFzQjtRQUMxQixJQUFJQyxrQkFBa0I7UUFDdEIsTUFBTUMsY0FBYyxNQUFNLElBQUksQ0FBQ1AsZUFBZSxDQUFDbDlCO1FBQy9DLE9BQU8sU0FBVzA5QixNQUFNLEVBQUVQLFFBQVEsRUFBRW45QixNQUFNO1lBQ3RDLElBQUl0aUIsSUFBSUM7WUFDUixPQUFPc3JCLGlCQUFpQixJQUFJLEVBQUUyRCxXQUFXO2dCQUNyQyxJQUFJNW1CLElBQUk4bUIsS0FBSzdtQixJQUFJQztnQkFDakIsTUFBT3MzQyxrQkFBa0I1QyxlQUFnQjtvQkFDckMsSUFBSTJDLHFCQUFxQjt3QkFDckJDO3dCQUNBRCxzQkFBc0I7b0JBQzFCO29CQUNBLE1BQU1oRCxvQkFBb0IsTUFBTXh4QixRQUFRMjBCLE9BQU9sRCw2QkFBNkIsQ0FBQ3g2QjtvQkFDN0UsTUFBTWhjLFdBQVcsTUFBTStrQixRQUFRMjBCLE9BQU8xQyw2QkFBNkIsQ0FBQ1Q7b0JBQ3BFLE1BQU16dkMsb0JBQW9CLEVBQUU7b0JBQzVCLE1BQU02eUMsbUJBQW1CLEVBQUU7b0JBQzNCLElBQUk7d0JBQ0EsSUFBSyxJQUFJeDNDLEtBQUssTUFBTXkzQyxhQUFjOXdCLENBQUFBLE1BQU0sS0FBSyxHQUFHckMsY0FBY3ptQixTQUFRLEdBQUk2NUMsY0FBY0EsZUFBZSxNQUFNOTBCLFFBQVE2MEIsV0FBV3o4QixJQUFJLEtBQUtuYixLQUFLNjNDLGFBQWEzekMsSUFBSSxFQUFFLENBQUNsRSxJQUFJRyxLQUFLLEtBQU07NEJBQzdLRCxLQUFLMjNDLGFBQWFuL0MsS0FBSzs0QkFDdkJ5SCxLQUFLOzRCQUNMLE1BQU04bUIsUUFBUS9tQjs0QkFDZCxNQUFNLE1BQU02aUIsUUFBUWtFOzRCQUNwQixJQUFJQSxNQUFNM21CLFVBQVUsSUFBSyxFQUFDNUksS0FBS3V2QixNQUFNM21CLFVBQVUsQ0FBQyxFQUFFLE1BQU0sUUFBUTVJLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzZJLE9BQU8sR0FBRztnQ0FDbEdvM0MsaUJBQWlCMTRDLElBQUksQ0FBQ2dvQixNQUFNM21CLFVBQVUsQ0FBQyxFQUFFLENBQUNDLE9BQU87Z0NBQ2pELEtBQUssTUFBTXJCLFFBQVEsQ0FBQ3ZILEtBQUtzdkIsTUFBTTNtQixVQUFVLENBQUMsRUFBRSxDQUFDQyxPQUFPLENBQUN2QixLQUFLLE1BQU0sUUFBUXJILE9BQU8sS0FBSyxJQUFJQSxLQUFLLEVBQUUsQ0FBRTtvQ0FDN0YsSUFBSTYvQyxrQkFBa0I1QyxrQkFBa0IxMUMsS0FBS3JCLFlBQVksRUFBRTt3Q0FDdkQsSUFBSSxDQUFDcUIsS0FBS3JCLFlBQVksQ0FBQ0YsSUFBSSxFQUFFOzRDQUN6QixNQUFNLElBQUkvRSxNQUFNO3dDQUNwQjt3Q0FDQSxJQUFJLENBQUN1K0MsU0FBUzlyQyxHQUFHLENBQUNuTSxLQUFLckIsWUFBWSxDQUFDRixJQUFJLEdBQUc7NENBQ3ZDLE1BQU0sSUFBSS9FLE1BQU0sQ0FBQyxzSUFBc0ksRUFBRXUrQyxTQUFTcCtDLElBQUksR0FBRyxlQUFlLEVBQUVtRyxLQUFLckIsWUFBWSxDQUFDRixJQUFJLENBQUMsQ0FBQzt3Q0FDdE4sT0FDSzs0Q0FDRCxNQUFNbTZDLGdCQUFnQixNQUFNLzBCLFFBQVFvMEIsU0FDL0I3NUIsR0FBRyxDQUFDcGUsS0FBS3JCLFlBQVksQ0FBQ0YsSUFBSSxFQUMxQit3QyxRQUFRLENBQUM7Z0RBQUN4dkMsS0FBS3JCLFlBQVk7NkNBQUM7NENBQ2pDaUgsa0JBQWtCN0YsSUFBSSxJQUFJNjRDO3dDQUM5QjtvQ0FDSjtnQ0FDSjs0QkFDSjt3QkFDSjtvQkFDSixFQUNBLE9BQU81d0IsT0FBTzt3QkFBRUosTUFBTTs0QkFBRTdzQixPQUFPaXRCO3dCQUFNO29CQUFHLFNBQ2hDO3dCQUNKLElBQUk7NEJBQ0EsSUFBSSxDQUFDL21CLE1BQU0sQ0FBQ0gsTUFBT0MsQ0FBQUEsS0FBSzIzQyxXQUFXdDhCLE1BQU0sR0FBRyxNQUFNeUgsUUFBUTlpQixHQUFHeEgsSUFBSSxDQUFDbS9DO3dCQUN0RSxTQUNROzRCQUFFLElBQUk5d0IsS0FBSyxNQUFNQSxJQUFJN3NCLEtBQUs7d0JBQUU7b0JBQ3hDO29CQUNBLElBQUk2SyxrQkFBa0I3TCxNQUFNLEdBQUcsR0FBRzt3QkFDOUJzK0Msc0JBQXNCO3dCQUN0QixNQUFNUSxxQkFBcUIsSUFBSWg0Qzt3QkFDL0JnNEMsbUJBQW1CejNDLFVBQVUsR0FBRzs0QkFDNUI7Z0NBQ0lDLFNBQVM7b0NBQ0xuQixNQUFNO29DQUNOSixPQUFPOEY7Z0NBQ1g7NEJBQ0o7eUJBQ0g7d0JBQ0QsTUFBTSxNQUFNaWUsUUFBUWcxQjt3QkFDcEIsTUFBTUMsY0FBYyxFQUFFO3dCQUN0QkEsWUFBWS80QyxJQUFJLElBQUkwNEM7d0JBQ3BCSyxZQUFZLzRDLElBQUksQ0FBQzs0QkFDYkcsTUFBTTs0QkFDTkosT0FBTzhGO3dCQUNYO3dCQUNBLE1BQU1tekMsa0JBQWtCcHhDLFVBQVVtVCxPQUFPK0wsUUFBUSxFQUFFRSxNQUFNLENBQUMreEI7d0JBQzFEaCtCLE9BQU8rTCxRQUFRLEdBQUdreUI7b0JBQ3RCLE9BQ0s7d0JBQ0Q7b0JBQ0o7Z0JBQ0o7WUFDSjtRQUNKLEVBQUcsSUFBSSxFQUFFUixhQUFhejlCO0lBQzFCO0lBQ0EsTUFBTTA2Qix3QkFBd0IxNkIsTUFBTSxFQUFFO1FBQ2xDLElBQUl0aUIsSUFBSUMsSUFBSXFJLElBQUlDO1FBQ2hCLElBQUlqQztRQUNKLElBQUkrZCxPQUFPO1FBQ1gsSUFBSUMsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDN1csU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCLE1BQU1rWSxPQUFPdWYsa0NBQWtDLElBQUksQ0FBQ3IyQixTQUFTLEVBQUU2VTtZQUMvRCtCLE9BQU9oa0IsVUFBVSwyQkFBMkJra0IsSUFBSSxDQUFDLE9BQU87WUFDeERELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUNJLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVsQixhQUFhLENBQUNsbEIsS0FBS3FpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF0TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbEIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUksR0FBR2tkLElBQUksQ0FBQyxDQUFDVTtvQkFDN0IsTUFBTXhmLFdBQVd3ZjtvQkFDakJ4ZixTQUFTdWMsZUFBZSxHQUFHO3dCQUN2Qi9hLFNBQVN1ZCxhQUFhdmQsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU8wbUIsa0NBQWtDNS9CO2dCQUMvQyxNQUFNMlosWUFBWSxJQUFJMWQ7Z0JBQ3RCekgsT0FBT3dCLE1BQU0sQ0FBQzJqQixXQUFXVDtnQkFDekIsT0FBT1M7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNeEIsT0FBTzhhLGlDQUFpQyxJQUFJLENBQUM1eEIsU0FBUyxFQUFFNlU7WUFDOUQrQixPQUFPaGtCLFVBQVUsMkJBQTJCa2tCLElBQUksQ0FBQyxPQUFPO1lBQ3hERCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDMEksS0FBS2dhLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWpELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzFJLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQzVjLEtBQUsrWixPQUFPL1csTUFBTSxNQUFNLFFBQVFoRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc0YyxXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSSxHQUFHa2QsSUFBSSxDQUFDLENBQUNVO29CQUM3QixNQUFNeGYsV0FBV3dmO29CQUNqQnhmLFNBQVN1YyxlQUFlLEdBQUc7d0JBQ3ZCL2EsU0FBU3VkLGFBQWF2ZCxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBTzBqQixpQ0FBaUM1OEI7Z0JBQzlDLE1BQU0yWixZQUFZLElBQUkxZDtnQkFDdEJ6SCxPQUFPd0IsTUFBTSxDQUFDMmpCLFdBQVdUO2dCQUN6QixPQUFPUztZQUNYO1FBQ0o7SUFDSjtJQUNBLE1BQU11M0IsOEJBQThCaDdCLE1BQU0sRUFBRTtRQUN4QyxJQUFJdGlCLElBQUlDLElBQUlxSSxJQUFJQztRQUNoQixJQUFJakM7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNa1ksT0FBT3VmLGtDQUFrQyxJQUFJLENBQUNyMkIsU0FBUyxFQUFFNlU7WUFDL0QrQixPQUFPaGtCLFVBQVUseUNBQXlDa2tCLElBQUksQ0FBQyxPQUFPO1lBQ3RFRCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixNQUFNOVcsWUFBWSxJQUFJLENBQUNBLFNBQVM7WUFDaENuSCxXQUFXbUgsVUFBVWdrQyxhQUFhLENBQUM7Z0JBQy9CcHRCLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDSSxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDbGxCLEtBQUtxaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdEwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2xCLFdBQVc7WUFDekY7WUFDQSxPQUFPN2UsU0FBUzhlLElBQUksQ0FBQyxTQUFVaFosV0FBVztnQkFDdEMsT0FBT21mLGlCQUFpQixJQUFJLEVBQUUyRCxXQUFXO29CQUNyQyxJQUFJbHZCLElBQUl3Z0QsS0FBS3ZnRCxJQUFJcUk7b0JBQ2pCLElBQUk7d0JBQ0EsSUFBSyxJQUFJQyxLQUFLLE1BQU1rNEMsZ0JBQWdCMXpCLGNBQWMzZ0IsY0FBY3MwQyxpQkFBaUJBLGtCQUFrQixNQUFNcjFCLFFBQVFvMUIsY0FBY2g5QixJQUFJLEtBQUt6akIsS0FBSzBnRCxnQkFBZ0JsMEMsSUFBSSxFQUFFLENBQUN4TSxJQUFJdUksS0FBSyxLQUFNOzRCQUMvS0QsS0FBS280QyxnQkFBZ0IxL0MsS0FBSzs0QkFDMUJ1SCxLQUFLOzRCQUNMLE1BQU1nbkIsUUFBUWpuQjs0QkFDZCxNQUFNZ2QsT0FBTzBtQixrQ0FBbUMsT0FBTTNnQixRQUFRa0UsTUFBTXJuQixJQUFJLEdBQUU7NEJBQzFFb2QsSUFBSSxDQUFDLGtCQUFrQixHQUFHO2dDQUN0QnhkLFNBQVN5bkIsTUFBTXpuQixPQUFPOzRCQUMxQjs0QkFDQSxNQUFNaWUsWUFBWSxJQUFJMWQ7NEJBQ3RCekgsT0FBT3dCLE1BQU0sQ0FBQzJqQixXQUFXVDs0QkFDekIsTUFBTSxNQUFNK0YsUUFBUXRGO3dCQUN4QjtvQkFDSixFQUNBLE9BQU80NkIsT0FBTzt3QkFBRUgsTUFBTTs0QkFBRWorQyxPQUFPbytDO3dCQUFNO29CQUFHLFNBQ2hDO3dCQUNKLElBQUk7NEJBQ0EsSUFBSSxDQUFDcDRDLE1BQU0sQ0FBQ3ZJLE1BQU9DLENBQUFBLEtBQUt3Z0QsY0FBYzc4QixNQUFNLEdBQUcsTUFBTXlILFFBQVFwckIsR0FBR2MsSUFBSSxDQUFDMC9DO3dCQUN6RSxTQUNROzRCQUFFLElBQUlELEtBQUssTUFBTUEsSUFBSWorQyxLQUFLO3dCQUFFO29CQUN4QztnQkFDSjtZQUNKO1FBQ0osT0FDSztZQUNELE1BQU1naUIsT0FBTzhhLGlDQUFpQyxJQUFJLENBQUM1eEIsU0FBUyxFQUFFNlU7WUFDOUQrQixPQUFPaGtCLFVBQVUseUNBQXlDa2tCLElBQUksQ0FBQyxPQUFPO1lBQ3RFRCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixNQUFNOVcsWUFBWSxJQUFJLENBQUNBLFNBQVM7WUFDaENuSCxXQUFXbUgsVUFBVWdrQyxhQUFhLENBQUM7Z0JBQy9CcHRCLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDMEksS0FBS2dhLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWpELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzFJLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQzVjLEtBQUsrWixPQUFPL1csTUFBTSxNQUFNLFFBQVFoRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc0YyxXQUFXO1lBQ3pGO1lBQ0EsT0FBTzdlLFNBQVM4ZSxJQUFJLENBQUMsU0FBVWhaLFdBQVc7Z0JBQ3RDLE9BQU9tZixpQkFBaUIsSUFBSSxFQUFFMkQsV0FBVztvQkFDckMsSUFBSWx2QixJQUFJNGdELEtBQUszZ0QsSUFBSXFJO29CQUNqQixJQUFJO3dCQUNBLElBQUssSUFBSUMsS0FBSyxNQUFNczRDLGdCQUFnQjl6QixjQUFjM2dCLGNBQWMwMEMsaUJBQWlCQSxrQkFBa0IsTUFBTXoxQixRQUFRdzFCLGNBQWNwOUIsSUFBSSxLQUFLempCLEtBQUs4Z0QsZ0JBQWdCdDBDLElBQUksRUFBRSxDQUFDeE0sSUFBSXVJLEtBQUssS0FBTTs0QkFDL0tELEtBQUt3NEMsZ0JBQWdCOS9DLEtBQUs7NEJBQzFCdUgsS0FBSzs0QkFDTCxNQUFNZ25CLFFBQVFqbkI7NEJBQ2QsTUFBTWdkLE9BQU8wakIsaUNBQWtDLE9BQU0zZCxRQUFRa0UsTUFBTXJuQixJQUFJLEdBQUU7NEJBQ3pFb2QsSUFBSSxDQUFDLGtCQUFrQixHQUFHO2dDQUN0QnhkLFNBQVN5bkIsTUFBTXpuQixPQUFPOzRCQUMxQjs0QkFDQSxNQUFNaWUsWUFBWSxJQUFJMWQ7NEJBQ3RCekgsT0FBT3dCLE1BQU0sQ0FBQzJqQixXQUFXVDs0QkFDekIsTUFBTSxNQUFNK0YsUUFBUXRGO3dCQUN4QjtvQkFDSixFQUNBLE9BQU9nN0IsT0FBTzt3QkFBRUgsTUFBTTs0QkFBRXIrQyxPQUFPdytDO3dCQUFNO29CQUFHLFNBQ2hDO3dCQUNKLElBQUk7NEJBQ0EsSUFBSSxDQUFDeDRDLE1BQU0sQ0FBQ3ZJLE1BQU9DLENBQUFBLEtBQUs0Z0QsY0FBY2o5QixNQUFNLEdBQUcsTUFBTXlILFFBQVFwckIsR0FBR2MsSUFBSSxDQUFDOC9DO3dCQUN6RSxTQUNROzRCQUFFLElBQUlELEtBQUssTUFBTUEsSUFBSXIrQyxLQUFLO3dCQUFFO29CQUN4QztnQkFDSjtZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQW9CQyxHQUNELE1BQU15K0MsYUFBYTErQixNQUFNLEVBQUU7UUFDdkIsSUFBSXRpQixJQUFJQyxJQUFJcUksSUFBSUM7UUFDaEIsSUFBSWpDO1FBQ0osSUFBSStkLE9BQU87UUFDWCxJQUFJQyxjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUM3VyxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTWtZLE9BQU8wZiwrQkFBK0IsSUFBSSxDQUFDeDJCLFNBQVMsRUFBRTZVO1lBQzVEK0IsT0FBT2hrQixVQUFVLG1CQUFtQmtrQixJQUFJLENBQUMsT0FBTztZQUNoREQsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSSxHQUFHa2QsSUFBSSxDQUFDLENBQUNVO29CQUM3QixNQUFNeGYsV0FBV3dmO29CQUNqQnhmLFNBQVN1YyxlQUFlLEdBQUc7d0JBQ3ZCL2EsU0FBU3VkLGFBQWF2ZCxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBT2luQiwrQkFBK0JuZ0M7Z0JBQzVDLE1BQU0yWixZQUFZLElBQUlwYztnQkFDdEIvSSxPQUFPd0IsTUFBTSxDQUFDMmpCLFdBQVdUO2dCQUN6QixPQUFPUztZQUNYO1FBQ0osT0FDSztZQUNELE1BQU14QixPQUFPa2IsOEJBQThCLElBQUksQ0FBQ2h5QixTQUFTLEVBQUU2VTtZQUMzRCtCLE9BQU9oa0IsVUFBVSw4QkFBOEJra0IsSUFBSSxDQUFDLE9BQU87WUFDM0RELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUMwSSxLQUFLZ2EsT0FBTy9XLE1BQU0sTUFBTSxRQUFRakQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMUksV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDNWMsS0FBSytaLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWhELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRjLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJLEdBQUdrZCxJQUFJLENBQUMsQ0FBQ1U7b0JBQzdCLE1BQU14ZixXQUFXd2Y7b0JBQ2pCeGYsU0FBU3VjLGVBQWUsR0FBRzt3QkFDdkIvYSxTQUFTdWQsYUFBYXZkLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPOGpCLDhCQUE4Qmg5QjtnQkFDM0MsTUFBTTJaLFlBQVksSUFBSXBjO2dCQUN0Qi9JLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWtCQyxHQUNELE1BQU0wM0IsdUJBQXVCbjdCLE1BQU0sRUFBRTtRQUNqQyxJQUFJdGlCLElBQUlDLElBQUlxSSxJQUFJQztRQUNoQixJQUFJakM7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNa1ksT0FBTzhmLGlDQUFpQyxJQUFJLENBQUM1MkIsU0FBUyxFQUFFNlU7WUFDOUQrQixPQUFPaGtCLFVBQVUsbUJBQW1Ca2tCLElBQUksQ0FBQyxPQUFPO1lBQ2hERCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDSSxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDbGxCLEtBQUtxaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdEwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2xCLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJLEdBQUdrZCxJQUFJLENBQUMsQ0FBQ1U7b0JBQzdCLE1BQU14ZixXQUFXd2Y7b0JBQ2pCeGYsU0FBU3VjLGVBQWUsR0FBRzt3QkFDdkIvYSxTQUFTdWQsYUFBYXZkLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPc25CLGlDQUFpQ3hnQztnQkFDOUMsTUFBTTJaLFlBQVksSUFBSW5jO2dCQUN0QmhKLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTXhCLE9BQU9nYyxnQ0FBZ0MsSUFBSSxDQUFDOXlCLFNBQVMsRUFBRTZVO1lBQzdEK0IsT0FBT2hrQixVQUFVLG1CQUFtQmtrQixJQUFJLENBQUMsT0FBTztZQUNoREQsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQzBJLEtBQUtnYSxPQUFPL1csTUFBTSxNQUFNLFFBQVFqRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcxSSxXQUFXO2dCQUNyRnVsQixhQUFhLENBQUM1YyxLQUFLK1osT0FBTy9XLE1BQU0sTUFBTSxRQUFRaEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNGMsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUksR0FBR2tkLElBQUksQ0FBQyxDQUFDVTtvQkFDN0IsTUFBTXhmLFdBQVd3ZjtvQkFDakJ4ZixTQUFTdWMsZUFBZSxHQUFHO3dCQUN2Qi9hLFNBQVN1ZCxhQUFhdmQsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU95a0IsZ0NBQWdDMzlCO2dCQUM3QyxNQUFNMlosWUFBWSxJQUFJbmM7Z0JBQ3RCaEosT0FBT3dCLE1BQU0sQ0FBQzJqQixXQUFXVDtnQkFDekIsT0FBT1M7WUFDWDtRQUNKO0lBQ0o7SUFDQSxNQUFNeTRCLGtCQUFrQmw4QixNQUFNLEVBQUU7UUFDNUIsSUFBSXRpQixJQUFJQztRQUNSLElBQUlxRztRQUNKLElBQUkrZCxPQUFPO1FBQ1gsSUFBSUMsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDN1csU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCLE1BQU1rWSxPQUFPdWhCLG9DQUFvQyxJQUFJLENBQUNyNEIsU0FBUyxFQUFFNlU7WUFDakUrQixPQUFPaGtCLFVBQVUsbUJBQW1Ca2tCLElBQUksQ0FBQyxPQUFPO1lBQ2hERCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDSSxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDbGxCLEtBQUtxaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdEwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2xCLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJLEdBQUdrZCxJQUFJLENBQUMsQ0FBQ1U7b0JBQzdCLE1BQU14ZixXQUFXd2Y7b0JBQ2pCeGYsU0FBU3VjLGVBQWUsR0FBRzt3QkFDdkIvYSxTQUFTdWQsYUFBYXZkLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPdW5CLDRCQUE0QnpnQztnQkFDekMsTUFBTTJaLFlBQVksSUFBSWxjO2dCQUN0QmpKLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTSxJQUFJN2tCLE1BQU07UUFDcEI7SUFDSjtJQUNBLE1BQU04OUMscUJBQXFCMThCLE1BQU0sRUFBRTtRQUMvQixJQUFJdGlCLElBQUlDO1FBQ1IsSUFBSXFHO1FBQ0osSUFBSStkLE9BQU87UUFDWCxJQUFJQyxjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUM3VyxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTWtZLE9BQU80aEIsMENBQTBDLElBQUksQ0FBQzE0QixTQUFTLEVBQUU2VTtZQUN2RStCLE9BQU9oa0IsVUFBVSxtQkFBbUJra0IsSUFBSSxDQUFDLE9BQU87WUFDaERELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUNJLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVsQixhQUFhLENBQUNsbEIsS0FBS3FpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF0TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbEIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUksR0FBR2tkLElBQUksQ0FBQyxDQUFDVTtvQkFDN0IsTUFBTXhmLFdBQVd3ZjtvQkFDakJ4ZixTQUFTdWMsZUFBZSxHQUFHO3dCQUN2Qi9hLFNBQVN1ZCxhQUFhdmQsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU93bkIsK0JBQStCMWdDO2dCQUM1QyxNQUFNMlosWUFBWSxJQUFJamM7Z0JBQ3RCbEosT0FBT3dCLE1BQU0sQ0FBQzJqQixXQUFXVDtnQkFDekIsT0FBT1M7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNLElBQUk3a0IsTUFBTTtRQUNwQjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FxQ0MsR0FDRCxNQUFNKy9DLGVBQWUzK0IsTUFBTSxFQUFFO1FBQ3pCLElBQUl0aUIsSUFBSUM7UUFDUixJQUFJcUc7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNa1ksT0FBT29pQixpQ0FBaUMsSUFBSSxDQUFDbDVCLFNBQVMsRUFBRTZVO1lBQzlEK0IsT0FBT2hrQixVQUFVLG1CQUFtQmtrQixJQUFJLENBQUMsT0FBTztZQUNoREQsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QixTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU95bkIsaUNBQWlDM2dDO2dCQUM5QyxNQUFNMlosWUFBWSxJQUFJaGM7Z0JBQ3RCbkosT0FBT3dCLE1BQU0sQ0FBQzJqQixXQUFXVDtnQkFDekIsT0FBT1M7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNLElBQUk3a0IsTUFBTTtRQUNwQjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FtQkMsR0FDRCxNQUFNZ2dELGFBQWE1K0IsTUFBTSxFQUFFO1FBQ3ZCLElBQUl0aUIsSUFBSUM7UUFDUixJQUFJcUc7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNa1ksT0FBTzRpQiwrQkFBK0IsSUFBSSxDQUFDMTVCLFNBQVMsRUFBRTZVO1lBQzVEK0IsT0FBT2hrQixVQUFVLG1CQUFtQmtrQixJQUFJLENBQUMsT0FBTztZQUNoREQsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QixTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU8rbkIsK0JBQStCamhDO2dCQUM1QyxNQUFNMlosWUFBWSxJQUFJL2I7Z0JBQ3RCcEosT0FBT3dCLE1BQU0sQ0FBQzJqQixXQUFXVDtnQkFDekIsT0FBT1M7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNLElBQUk3a0IsTUFBTTtRQUNwQjtJQUNKO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNELE1BQU0wa0IsSUFBSXRELE1BQU0sRUFBRTtRQUNkLElBQUl0aUIsSUFBSUMsSUFBSXFJLElBQUlDO1FBQ2hCLElBQUlqQztRQUNKLElBQUkrZCxPQUFPO1FBQ1gsSUFBSUMsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDN1csU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCLE1BQU1rWSxPQUFPNmlCLDJCQUEyQixJQUFJLENBQUMzNUIsU0FBUyxFQUFFNlU7WUFDeEQrQixPQUFPaGtCLFVBQVUsVUFBVWtrQixJQUFJLENBQUMsT0FBTztZQUN2Q0QsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QixTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU93b0IsZ0JBQWdCMWhDO2dCQUM3QixPQUFPa1o7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNZixPQUFPa2MsMEJBQTBCLElBQUksQ0FBQ2h6QixTQUFTLEVBQUU2VTtZQUN2RCtCLE9BQU9oa0IsVUFBVSxVQUFVa2tCLElBQUksQ0FBQyxPQUFPO1lBQ3ZDRCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDMEksS0FBS2dhLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWpELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzFJLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQzVjLEtBQUsrWixPQUFPL1csTUFBTSxNQUFNLFFBQVFoRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUc0YyxXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QixTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU84a0IsZUFBZWgrQjtnQkFDNUIsT0FBT2taO1lBQ1g7UUFDSjtJQUNKO0lBQ0EsTUFBTUssYUFBYXJELE1BQU0sRUFBRTtRQUN2QixJQUFJdGlCLElBQUlDLElBQUlxSSxJQUFJQztRQUNoQixJQUFJakM7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNa1ksT0FBTytpQiw2QkFBNkIsSUFBSSxDQUFDNzVCLFNBQVMsRUFBRTZVO1lBQzFEK0IsT0FBT2hrQixVQUFVLGdCQUFnQmtrQixJQUFJLENBQUMsT0FBTztZQUM3Q0QsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSSxHQUFHa2QsSUFBSSxDQUFDLENBQUNVO29CQUM3QixNQUFNeGYsV0FBV3dmO29CQUNqQnhmLFNBQVN1YyxlQUFlLEdBQUc7d0JBQ3ZCL2EsU0FBU3VkLGFBQWF2ZCxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBTzJvQiw2QkFBNkI3aEM7Z0JBQzFDLE1BQU0yWixZQUFZLElBQUk5YjtnQkFDdEJySixPQUFPd0IsTUFBTSxDQUFDMmpCLFdBQVdUO2dCQUN6QixPQUFPUztZQUNYO1FBQ0osT0FDSztZQUNELE1BQU14QixPQUFPcWMsNEJBQTRCLElBQUksQ0FBQ256QixTQUFTLEVBQUU2VTtZQUN6RCtCLE9BQU9oa0IsVUFBVSxnQkFBZ0Jra0IsSUFBSSxDQUFDLE9BQU87WUFDN0NELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUMwSSxLQUFLZ2EsT0FBTy9XLE1BQU0sTUFBTSxRQUFRakQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMUksV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDNWMsS0FBSytaLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWhELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRjLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJLEdBQUdrZCxJQUFJLENBQUMsQ0FBQ1U7b0JBQzdCLE1BQU14ZixXQUFXd2Y7b0JBQ2pCeGYsU0FBU3VjLGVBQWUsR0FBRzt3QkFDdkIvYSxTQUFTdWQsYUFBYXZkLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPb2xCLDRCQUE0QnQrQjtnQkFDekMsTUFBTTJaLFlBQVksSUFBSTliO2dCQUN0QnJKLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7S0FnQkMsR0FDRCxNQUFNZ0YsT0FBT3pJLE1BQU0sRUFBRTtRQUNqQixJQUFJdGlCLElBQUlDLElBQUlxSSxJQUFJQztRQUNoQixJQUFJakM7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNa1ksT0FBT2lqQiw4QkFBOEIsSUFBSSxDQUFDLzVCLFNBQVMsRUFBRTZVO1lBQzNEK0IsT0FBT2hrQixVQUFVLFdBQVdra0IsSUFBSSxDQUFDLE9BQU87WUFDeENELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUNJLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVsQixhQUFhLENBQUNsbEIsS0FBS3FpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF0TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbEIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUk7WUFDNUI7WUFDQSxPQUFPNUIsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPd29CLGdCQUFnQjFoQztnQkFDN0IsT0FBT2taO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTWYsT0FBT3djLDZCQUE2QixJQUFJLENBQUN0ekIsU0FBUyxFQUFFNlU7WUFDMUQrQixPQUFPaGtCLFVBQVUsVUFBVWtrQixJQUFJLENBQUMsT0FBTztZQUN2Q0QsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQzBJLEtBQUtnYSxPQUFPL1csTUFBTSxNQUFNLFFBQVFqRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcxSSxXQUFXO2dCQUNyRnVsQixhQUFhLENBQUM1YyxLQUFLK1osT0FBTy9XLE1BQU0sTUFBTSxRQUFRaEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNGMsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUk7WUFDNUI7WUFDQSxPQUFPNUIsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPOGtCLGVBQWVoK0I7Z0JBQzVCLE9BQU9rWjtZQUNYO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxNQUFNVSxPQUFPMUQsTUFBTSxFQUFFO1FBQ2pCLElBQUl0aUIsSUFBSUMsSUFBSXFJLElBQUlDO1FBQ2hCLElBQUlqQztRQUNKLElBQUkrZCxPQUFPO1FBQ1gsSUFBSUMsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDN1csU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCLE1BQU1rWSxPQUFPa2pCLDhCQUE4QixJQUFJLENBQUNoNkIsU0FBUyxFQUFFNlU7WUFDM0QrQixPQUFPaGtCLFVBQVUsVUFBVWtrQixJQUFJLENBQUMsT0FBTztZQUN2Q0QsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QixTQUFTOGUsSUFBSSxDQUFDO2dCQUNqQixNQUFNRSxPQUFPNG9CO2dCQUNiLE1BQU1ub0IsWUFBWSxJQUFJN2I7Z0JBQ3RCdEosT0FBT3dCLE1BQU0sQ0FBQzJqQixXQUFXVDtnQkFDekIsT0FBT1M7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNeEIsT0FBT3ljLDZCQUE2QixJQUFJLENBQUN2ekIsU0FBUyxFQUFFNlU7WUFDMUQrQixPQUFPaGtCLFVBQVUsVUFBVWtrQixJQUFJLENBQUMsT0FBTztZQUN2Q0QsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQzBJLEtBQUtnYSxPQUFPL1csTUFBTSxNQUFNLFFBQVFqRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcxSSxXQUFXO2dCQUNyRnVsQixhQUFhLENBQUM1YyxLQUFLK1osT0FBTy9XLE1BQU0sTUFBTSxRQUFRaEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNGMsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUk7WUFDNUI7WUFDQSxPQUFPNUIsU0FBUzhlLElBQUksQ0FBQztnQkFDakIsTUFBTUUsT0FBT3NsQjtnQkFDYixNQUFNN2tCLFlBQVksSUFBSTdiO2dCQUN0QnRKLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7OztLQWVDLEdBQ0QsTUFBTW83QixZQUFZNytCLE1BQU0sRUFBRTtRQUN0QixJQUFJdGlCLElBQUlDLElBQUlxSSxJQUFJQztRQUNoQixJQUFJakM7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNa1ksT0FBT29qQiw4QkFBOEIsSUFBSSxDQUFDbDZCLFNBQVMsRUFBRTZVO1lBQzNEK0IsT0FBT2hrQixVQUFVLHVCQUF1QmtrQixJQUFJLENBQUMsT0FBTztZQUNwREQsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSSxHQUFHa2QsSUFBSSxDQUFDLENBQUNVO29CQUM3QixNQUFNeGYsV0FBV3dmO29CQUNqQnhmLFNBQVN1YyxlQUFlLEdBQUc7d0JBQ3ZCL2EsU0FBU3VkLGFBQWF2ZCxPQUFPO29CQUNqQztvQkFDQSxPQUFPeEI7Z0JBQ1g7WUFDSjtZQUNBLE9BQU9BLFNBQVM4ZSxJQUFJLENBQUMsQ0FBQ2haO2dCQUNsQixNQUFNa1osT0FBTzZvQiw4QkFBOEIvaEM7Z0JBQzNDLE1BQU0yWixZQUFZLElBQUk1YjtnQkFDdEJ2SixPQUFPd0IsTUFBTSxDQUFDMmpCLFdBQVdUO2dCQUN6QixPQUFPUztZQUNYO1FBQ0osT0FDSztZQUNELE1BQU14QixPQUFPMmMsNkJBQTZCLElBQUksQ0FBQ3p6QixTQUFTLEVBQUU2VTtZQUMxRCtCLE9BQU9oa0IsVUFBVSx1QkFBdUJra0IsSUFBSSxDQUFDLE9BQU87WUFDcERELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUMwSSxLQUFLZ2EsT0FBTy9XLE1BQU0sTUFBTSxRQUFRakQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMUksV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDNWMsS0FBSytaLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWhELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRjLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJLEdBQUdrZCxJQUFJLENBQUMsQ0FBQ1U7b0JBQzdCLE1BQU14ZixXQUFXd2Y7b0JBQ2pCeGYsU0FBU3VjLGVBQWUsR0FBRzt3QkFDdkIvYSxTQUFTdWQsYUFBYXZkLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPdWxCLDZCQUE2QnorQjtnQkFDMUMsTUFBTTJaLFlBQVksSUFBSTViO2dCQUN0QnZKLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBaUJDLEdBQ0QsTUFBTXE3QixjQUFjOStCLE1BQU0sRUFBRTtRQUN4QixJQUFJdGlCLElBQUlDO1FBQ1IsSUFBSXFHO1FBQ0osSUFBSStkLE9BQU87UUFDWCxJQUFJQyxjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUM3VyxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTWtZLE9BQU9xakIsZ0NBQWdDLElBQUksQ0FBQ242QixTQUFTLEVBQUU2VTtZQUM3RCtCLE9BQU9oa0IsVUFBVSx5QkFBeUJra0IsSUFBSSxDQUFDLE9BQU87WUFDdERELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUNJLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVsQixhQUFhLENBQUNsbEIsS0FBS3FpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF0TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbEIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUksR0FBR2tkLElBQUksQ0FBQyxDQUFDVTtvQkFDN0IsTUFBTXhmLFdBQVd3ZjtvQkFDakJ4ZixTQUFTdWMsZUFBZSxHQUFHO3dCQUN2Qi9hLFNBQVN1ZCxhQUFhdmQsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU84b0IsZ0NBQWdDaGlDO2dCQUM3QyxNQUFNMlosWUFBWSxJQUFJM2I7Z0JBQ3RCeEosT0FBT3dCLE1BQU0sQ0FBQzJqQixXQUFXVDtnQkFDekIsT0FBT1M7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNLElBQUk3a0IsTUFBTTtRQUNwQjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FzQkMsR0FDRCxNQUFNZytDLHVCQUF1QjU4QixNQUFNLEVBQUU7UUFDakMsSUFBSXRpQixJQUFJQyxJQUFJcUksSUFBSUM7UUFDaEIsSUFBSWpDO1FBQ0osSUFBSStkLE9BQU87UUFDWCxJQUFJQyxjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUM3VyxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTWtZLE9BQU8rakIsaUNBQWlDLElBQUksQ0FBQzc2QixTQUFTLEVBQUU2VTtZQUM5RCtCLE9BQU9oa0IsVUFBVSw4QkFBOEJra0IsSUFBSSxDQUFDLE9BQU87WUFDM0RELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUNJLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVsQixhQUFhLENBQUNsbEIsS0FBS3FpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF0TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbEIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUk7WUFDNUI7WUFDQSxPQUFPNUIsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPbXBCLGtDQUFrQ3JpQztnQkFDL0MsTUFBTTJaLFlBQVksSUFBSTdaO2dCQUN0QnRMLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTXhCLE9BQU9rZCxnQ0FBZ0MsSUFBSSxDQUFDaDBCLFNBQVMsRUFBRTZVO1lBQzdEK0IsT0FBT2hrQixVQUFVLDhCQUE4QmtrQixJQUFJLENBQUMsT0FBTztZQUMzREQsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQzBJLEtBQUtnYSxPQUFPL1csTUFBTSxNQUFNLFFBQVFqRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcxSSxXQUFXO2dCQUNyRnVsQixhQUFhLENBQUM1YyxLQUFLK1osT0FBTy9XLE1BQU0sTUFBTSxRQUFRaEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNGMsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUk7WUFDNUI7WUFDQSxPQUFPNUIsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPK2xCLGlDQUFpQ2ovQjtnQkFDOUMsTUFBTTJaLFlBQVksSUFBSTdaO2dCQUN0QnRMLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSjtJQUNKO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ0QsaUVBQWlFO0FBQ2pFLFNBQVNzN0IsOEJBQThCcHNDLFVBQVU7SUFDN0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vc0Msb0JBQW9Cai9DLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJcXNDLHFCQUFxQixNQUFNO1FBQzNCbmdELGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFnQixFQUFFb3NDO0lBQ3hEO0lBQ0EsTUFBTXBrQyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRWdJO0lBQ3pDO0lBQ0EsT0FBT2hJO0FBQ1g7QUFDQSxTQUFTcXNDLCtCQUErQnRzQyxVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb3NDLG9CQUFvQmovQyxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXFzQyxxQkFBcUIsTUFBTTtRQUMzQm5nRCxlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBZ0IsRUFBRW9zQztJQUN4RDtJQUNBLE1BQU1wa0MsYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVnSTtJQUN6QztJQUNBLE9BQU9oSTtBQUNYO0FBQ0EsU0FBU3NzQyx3Q0FBd0N2c0MsVUFBVTtJQUN2RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9zQyxvQkFBb0JqL0MsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUlxc0MscUJBQXFCLE1BQU07UUFDM0JuZ0QsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFb3NDO0lBQ2hEO0lBQ0EsTUFBTUcsbUJBQW1CcC9DLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJd3NDLG9CQUFvQixNQUFNO1FBQzFCdGdELGVBQWUrVCxVQUFVO1lBQUM7WUFBUTtTQUFlLEVBQUV1c0M7SUFDdkQ7SUFDQSxNQUFNdmtDLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFZ0k7SUFDekM7SUFDQSxPQUFPaEk7QUFDWDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNd3NDLG1CQUFtQnRoRDtJQUNyQnlILFlBQVk0RixTQUFTLENBQUU7UUFDbkIsS0FBSztRQUNMLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtJQUNyQjtJQUNBOzs7OztLQUtDLEdBQ0QsTUFBTWswQyxtQkFBbUJyd0MsVUFBVSxFQUFFO1FBQ2pDLE1BQU1oRixZQUFZZ0YsV0FBV2hGLFNBQVM7UUFDdEMsTUFBTWYsU0FBUytGLFdBQVcvRixNQUFNO1FBQ2hDLElBQUllLFVBQVVyRyxJQUFJLEtBQUs3RyxhQUFha04sVUFBVXJHLElBQUksS0FBSyxJQUFJO1lBQ3ZELE1BQU0sSUFBSS9FLE1BQU07UUFDcEI7UUFDQSxJQUFJLElBQUksQ0FBQ3VNLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNc0YsZUFBZXJGLFVBQVVyRyxJQUFJLENBQUM0SCxLQUFLLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDNUQsSUFBSWpPLGNBQWNSO1lBQ2xCLElBQUltTSxVQUFVLGlCQUFpQkEsUUFBUTtnQkFDbkMzTCxjQUFjMkwsT0FBTzNMLFdBQVc7WUFDcEM7WUFDQSxNQUFNZ2lELGVBQWUsTUFBTSxJQUFJLENBQUNDLG1DQUFtQyxDQUFDO2dCQUNoRUMsZUFBZXgxQyxVQUFVckcsSUFBSTtnQkFDN0IwTCxjQUFjQTtnQkFDZHBHLFFBQVE7b0JBQUUzTCxhQUFhQTtnQkFBWTtZQUN2QztZQUNBLE9BQU8wTSxVQUFVSCxnQkFBZ0IsQ0FBQztnQkFDOUJDLGFBQWF3MUM7Z0JBQ2J2MUMsWUFBWTtZQUNoQjtRQUNKLE9BQ0s7WUFDRCxNQUFNdTFDLGVBQWUsTUFBTSxJQUFJLENBQUNHLDBCQUEwQixDQUFDO2dCQUN2REQsZUFBZXgxQyxVQUFVckcsSUFBSTtnQkFDN0JzRixRQUFRQTtZQUNaO1lBQ0EsT0FBT2UsVUFBVUgsZ0JBQWdCLENBQUM7Z0JBQzlCQyxhQUFhdzFDO2dCQUNidjFDLFlBQVk7WUFDaEI7UUFDSjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRCxNQUFNdVosSUFBSXRVLFVBQVUsRUFBRTtRQUNsQixNQUFNaEYsWUFBWWdGLFdBQVdoRixTQUFTO1FBQ3RDLE1BQU1mLFNBQVMrRixXQUFXL0YsTUFBTTtRQUNoQyxJQUFJZSxVQUFVckcsSUFBSSxLQUFLN0csYUFBYWtOLFVBQVVyRyxJQUFJLEtBQUssSUFBSTtZQUN2RCxNQUFNLElBQUkvRSxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxJQUFJLENBQUN1TSxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTXNGLGVBQWVyRixVQUFVckcsSUFBSSxDQUFDNEgsS0FBSyxDQUFDLGVBQWUsQ0FBQyxFQUFFO1lBQzVELElBQUlqTyxjQUFjUjtZQUNsQixJQUFJbU0sVUFBVSxpQkFBaUJBLFFBQVE7Z0JBQ25DM0wsY0FBYzJMLE9BQU8zTCxXQUFXO1lBQ3BDO1lBQ0EsTUFBTWdpRCxlQUFlLE1BQU0sSUFBSSxDQUFDQyxtQ0FBbUMsQ0FBQztnQkFDaEVDLGVBQWV4MUMsVUFBVXJHLElBQUk7Z0JBQzdCMEwsY0FBY0E7Z0JBQ2RwRyxRQUFRO29CQUFFM0wsYUFBYUE7Z0JBQVk7WUFDdkM7WUFDQSxPQUFPME0sVUFBVUgsZ0JBQWdCLENBQUM7Z0JBQzlCQyxhQUFhdzFDO2dCQUNidjFDLFlBQVk7WUFDaEI7UUFDSixPQUNLO1lBQ0QsTUFBTXUxQyxlQUFlLE1BQU0sSUFBSSxDQUFDRywwQkFBMEIsQ0FBQztnQkFDdkRELGVBQWV4MUMsVUFBVXJHLElBQUk7Z0JBQzdCc0YsUUFBUUE7WUFDWjtZQUNBLE9BQU9lLFVBQVVILGdCQUFnQixDQUFDO2dCQUM5QkMsYUFBYXcxQztnQkFDYnYxQyxZQUFZO1lBQ2hCO1FBQ0o7SUFDSjtJQUNBLE1BQU0wMUMsMkJBQTJCei9CLE1BQU0sRUFBRTtRQUNyQyxJQUFJdGlCLElBQUlDLElBQUlxSSxJQUFJQztRQUNoQixJQUFJakM7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNa1ksT0FBT2c5QiwrQkFBK0JqL0I7WUFDNUMrQixPQUFPaGtCLFVBQVUsbUJBQW1Ca2tCLElBQUksQ0FBQyxPQUFPO1lBQ2hERCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDSSxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDbGxCLEtBQUtxaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdEwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2xCLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJO1lBQzVCO1lBQ0EsT0FBTzVCO1FBQ1gsT0FDSztZQUNELE1BQU1pZSxPQUFPODhCLDhCQUE4Qi8rQjtZQUMzQytCLE9BQU9oa0IsVUFBVSxtQkFBbUJra0IsSUFBSSxDQUFDLE9BQU87WUFDaERELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUMwSSxLQUFLZ2EsT0FBTy9XLE1BQU0sTUFBTSxRQUFRakQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMUksV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDNWMsS0FBSytaLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWhELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRjLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJO1lBQzVCO1lBQ0EsT0FBTzVCO1FBQ1g7SUFDSjtJQUNBLE1BQU11N0Msb0NBQW9Ddi9CLE1BQU0sRUFBRTtRQUM5QyxJQUFJdGlCLElBQUlDO1FBQ1IsSUFBSXFHO1FBQ0osSUFBSStkLE9BQU87UUFDWCxJQUFJQyxjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUM3VyxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTWtZLE9BQU9pOUIsd0NBQXdDbC9CO1lBQ3JEK0IsT0FBT2hrQixVQUFVLHdDQUF3Q2trQixJQUFJLENBQUMsT0FBTztZQUNyRUQsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QjtRQUNYLE9BQ0s7WUFDRCxNQUFNLElBQUlwRixNQUFNO1FBQ3BCO0lBQ0o7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTOGdELDJCQUEyQi9zQyxVQUFVO0lBQzFDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNd0YsZ0JBQWdCclksZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUl5RixpQkFBaUIsTUFBTTtRQUN2QnZaLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFd0Y7SUFDNUM7SUFDQSxPQUFPeEY7QUFDWDtBQUNBLFNBQVMrc0MsbUJBQW1CaHRDLFVBQVU7SUFDbEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0wRiwwQkFBMEJ2WSxlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSTJGLDJCQUEyQixNQUFNO1FBQ2pDelosZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFOHNDLDJCQUEyQnBuQztJQUNqRjtJQUNBLE9BQU8xRjtBQUNYO0FBQ0EsU0FBU2d0QywwQkFBMEJqdEMsVUFBVTtJQUN6QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTRGLGNBQWN6WSxlQUFlNFMsWUFBWTtRQUFDO0tBQVU7SUFDMUQsSUFBSTZGLGVBQWUsTUFBTTtRQUNyQjNaLGVBQWUrVCxVQUFVO1lBQUM7U0FBVSxFQUFFNEY7SUFDMUM7SUFDQSxNQUFNQyxrQkFBa0IxWSxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSThGLG1CQUFtQixNQUFNO1FBQ3pCNVosZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUUrc0MsbUJBQW1CbG5DO0lBQ2pFO0lBQ0EsT0FBTzdGO0FBQ1g7QUFDQSxTQUFTaXRDLCtCQUErQmx0QyxVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNK0YsMEJBQTBCNVksZUFBZTRTLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUlnRywyQkFBMkIsTUFBTTtRQUNqQyxJQUFJekUsa0JBQWtCeUU7UUFDdEIsSUFBSXRaLE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPc3pDLDBCQUEwQnR6QztZQUNyQztRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQXNCLEVBQUVzQjtJQUN0RDtJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBU2t0QyxvQkFBb0JudEMsVUFBVTtJQUNuQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTTZGLGtCQUFrQjFZLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJOEYsbUJBQW1CLE1BQU07UUFDekI1WixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRStzQyxtQkFBbUJsbkM7SUFDakU7SUFDQSxNQUFNSSw4QkFBOEI5WSxlQUFlNFMsWUFBWTtRQUMzRDtLQUNIO0lBQ0QsSUFBSWtHLCtCQUErQixNQUFNO1FBQ3JDaGEsZUFBZStULFVBQVU7WUFBQztTQUEwQixFQUFFaXRDLCtCQUErQmhuQztJQUN6RjtJQUNBLE1BQU1kLG1CQUFtQmhZLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJb0Ysb0JBQW9CLE1BQU07UUFDMUJsWixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRW1GO0lBQy9DO0lBQ0EsT0FBT25GO0FBQ1g7QUFDQSxTQUFTbXRDLHFCQUFxQnB0QyxVQUFVO0lBQ3BDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNQyxVQUFVOVMsZUFBZTRTLFlBQVk7UUFBQztLQUFNO0lBQ2xELElBQUlFLFdBQVcsTUFBTTtRQUNqQmhVLGVBQWUrVCxVQUFVO1lBQUM7U0FBTSxFQUFFQztJQUN0QztJQUNBLE1BQU1DLGdCQUFnQi9TLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJRyxpQkFBaUIsTUFBTTtRQUN2QmpVLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFRTtJQUM1QztJQUNBLE1BQU1DLGtCQUFrQmhULGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJSSxtQkFBbUIsTUFBTTtRQUN6QmxVLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFRztJQUM5QztJQUNBLE9BQU9IO0FBQ1g7QUFDQSxTQUFTb3RDLFlBQVlydEMsVUFBVTtJQUMzQixNQUFNQyxXQUFXLENBQUM7SUFDbEIsSUFBSTdTLGVBQWU0UyxZQUFZO1FBQUM7S0FBYyxNQUFNN1YsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXFVLFdBQVdsVCxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSU0sWUFBWSxNQUFNO1FBQ2xCcFUsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVLO0lBQ3ZDO0lBQ0EsTUFBTUMsZUFBZW5ULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJTyxnQkFBZ0IsTUFBTTtRQUN0QnJVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFTTtJQUMzQztJQUNBLE9BQU9OO0FBQ1g7QUFDQSxTQUFTcXRDLGdCQUFnQnR0QyxVQUFVO0lBQy9CLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJN1MsZUFBZTRTLFlBQVk7UUFBQztLQUFjLE1BQU03VixXQUFXO1FBQzNELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNd1UsY0FBY3JULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJUyxlQUFlLE1BQU07UUFDckJ2VSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVE7SUFDMUM7SUFDQSxNQUFNRixlQUFlblQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlPLGdCQUFnQixNQUFNO1FBQ3RCclUsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVNO0lBQzNDO0lBQ0EsT0FBT047QUFDWDtBQUNBLFNBQVNzdEMsWUFBWXZ0QyxVQUFVO0lBQzNCLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNVSxvQkFBb0J2VCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSVcscUJBQXFCLE1BQU07UUFDM0J6VSxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVtdEMscUJBQXFCenNDO0lBQ3JFO0lBQ0EsTUFBTUMsY0FBY3hULGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJWSxlQUFlLE1BQU07UUFDckIxVSxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRVc7SUFDMUM7SUFDQSxNQUFNQyxpQkFBaUJ6VCxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSWEsa0JBQWtCLE1BQU07UUFDeEIzVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRW90QyxZQUFZeHNDO0lBQ3pEO0lBQ0EsTUFBTUMsZUFBZTFULGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJYyxnQkFBZ0IsTUFBTTtRQUN0QjVVLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFcXRDLGdCQUFnQnhzQztJQUMzRDtJQUNBLE1BQU1DLHVCQUF1QjNULGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJZSx3QkFBd0IsTUFBTTtRQUM5QjdVLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWM7SUFDbkQ7SUFDQSxNQUFNQywwQkFBMEI1VCxlQUFlNFMsWUFBWTtRQUN2RDtLQUNIO0lBQ0QsSUFBSWdCLDJCQUEyQixNQUFNO1FBQ2pDOVUsZUFBZStULFVBQVU7WUFBQztTQUFzQixFQUFFZTtJQUN0RDtJQUNBLE1BQU1DLHFCQUFxQjdULGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJaUIsc0JBQXNCLE1BQU07UUFDNUIvVSxlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVnQjtJQUNqRDtJQUNBLE1BQU1DLG1CQUFtQjlULGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJa0Isb0JBQW9CLE1BQU07UUFDMUJoVixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRWlCO0lBQy9DO0lBQ0EsTUFBTUMsdUJBQXVCL1QsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUltQix3QkFBd0IsTUFBTTtRQUM5QmpWLGVBQWUrVCxVQUFVO1lBQUM7U0FBbUIsRUFBRWtCO0lBQ25EO0lBQ0EsTUFBTUMsV0FBV2hVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJb0IsWUFBWSxNQUFNO1FBQ2xCbFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUVtQjtJQUN2QztJQUNBLE9BQU9uQjtBQUNYO0FBQ0EsU0FBU3V0QyxlQUFleHRDLFVBQVU7SUFDOUIsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1xQixZQUFZbFUsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlzQixhQUFhLE1BQU07UUFDbkIsSUFBSUMsa0JBQWtCRDtRQUN0QixJQUFJNVUsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU80ekMsWUFBWTV6QztZQUN2QjtRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRXNCO0lBQ3hDO0lBQ0EsTUFBTUMsV0FBV3BVLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJd0IsWUFBWSxNQUFNO1FBQ2xCdFYsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV1QjtJQUN2QztJQUNBLE9BQU92QjtBQUNYO0FBQ0EsU0FBU3d0QywyQkFBMkJ6dEMsVUFBVTtJQUMxQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW1ELGVBQWVoVyxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSW9ELGdCQUFnQixNQUFNO1FBQ3RCbFgsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVtRDtJQUMzQztJQUNBLE1BQU14QixrQkFBa0J4VSxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTRCLG1CQUFtQixNQUFNO1FBQ3pCMVYsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUUyQjtJQUM5QztJQUNBLE1BQU1wRSxXQUFXcFEsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl4QyxZQUFZLE1BQU07UUFDbEJ0UixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXpDO0lBQ3ZDO0lBQ0EsTUFBTTZGLGlCQUFpQmpXLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJcUQsa0JBQWtCLE1BQU07UUFDeEJuWCxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRW9EO0lBQzdDO0lBQ0EsTUFBTUMsMkJBQTJCbFcsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUlzRCw0QkFBNEIsTUFBTTtRQUNsQ3BYLGVBQWUrVCxVQUFVO1lBQUM7U0FBdUIsRUFBRXFEO0lBQ3ZEO0lBQ0EsTUFBTUMsZUFBZW5XLGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJdUQsZ0JBQWdCLE1BQU07UUFDdEJyWCxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRXNEO0lBQzNDO0lBQ0EsTUFBTUMseUJBQXlCcFcsZUFBZTRTLFlBQVk7UUFDdEQ7S0FDSDtJQUNELElBQUl3RCwwQkFBMEIsTUFBTTtRQUNoQ3RYLGVBQWUrVCxVQUFVO1lBQUM7U0FBcUIsRUFBRXVEO0lBQ3JEO0lBQ0EsT0FBT3ZEO0FBQ1g7QUFDQSxTQUFTeXRDLGdCQUFnQjF0QyxVQUFVO0lBQy9CLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNeUQsZ0JBQWdCdFcsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUkwRCxpQkFBaUIsTUFBTTtRQUN2QnhYLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFeUQ7SUFDNUM7SUFDQSxNQUFNQyxjQUFjdlcsZUFBZTRTLFlBQVk7UUFBQztLQUFVO0lBQzFELElBQUkyRCxlQUFlLE1BQU07UUFDckJ6WCxlQUFlK1QsVUFBVTtZQUFDO1NBQVUsRUFBRTBEO0lBQzFDO0lBQ0EsT0FBTzFEO0FBQ1g7QUFDQSxTQUFTMHRDLG9CQUFvQjN0QyxVQUFVO0lBQ25DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNEQsc0JBQXNCelcsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUk2RCx1QkFBdUIsTUFBTTtRQUM3QjNYLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRXl0QyxnQkFBZ0I3cEM7SUFDbEU7SUFDQSxJQUFJelcsZUFBZTRTLFlBQVk7UUFBQztLQUFpQixNQUFNN1YsV0FBVztRQUM5RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsT0FBT2dVO0FBQ1g7QUFDQSxTQUFTMnRDLDhCQUE4QjV0QyxVQUFVO0lBQzdDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEQsV0FBVzNXLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJK0QsWUFBWSxNQUFNO1FBQ2xCN1gsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUU4RDtJQUN2QztJQUNBLE1BQU1DLHVCQUF1QjVXLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJZ0Usd0JBQXdCLE1BQU07UUFDOUI5WCxlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUUrRDtJQUNuRDtJQUNBLE9BQU8vRDtBQUNYO0FBQ0EsU0FBUzR0Qyw2QkFBNkI3dEMsVUFBVTtJQUM1QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTWlFLDZCQUE2QjlXLGVBQWU0UyxZQUFZO1FBQzFEO0tBQ0g7SUFDRCxJQUFJa0UsOEJBQThCLE1BQU07UUFDcENoWSxlQUFlK1QsVUFBVTtZQUFDO1NBQXlCLEVBQUUydEMsOEJBQThCMXBDO0lBQ3ZGO0lBQ0EsT0FBT2pFO0FBQ1g7QUFDQSxTQUFTNnRDO0lBQ0wsTUFBTTd0QyxXQUFXLENBQUM7SUFDbEIsT0FBT0E7QUFDWDtBQUNBLFNBQVM4dEMsdUJBQXVCL3RDLFVBQVU7SUFDdEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vRSxrQkFBa0JqWCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXFFLG1CQUFtQixNQUFNO1FBQ3pCblksZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVvRTtJQUM5QztJQUNBLE9BQU9wRTtBQUNYO0FBQ0EsU0FBUyt0QyxZQUFZaHVDLFVBQVU7SUFDM0IsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1zRSwyQkFBMkJuWCxlQUFlNFMsWUFBWTtRQUN4RDtLQUNIO0lBQ0QsSUFBSXVFLDRCQUE0QixNQUFNO1FBQ2xDLElBQUloRCxrQkFBa0JnRDtRQUN0QixJQUFJN1gsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU84ekMsMkJBQTJCOXpDO1lBQ3RDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBdUIsRUFBRXNCO0lBQ3ZEO0lBQ0EsSUFBSW5VLGVBQWU0UyxZQUFZO1FBQUM7S0FBWSxNQUFNN1YsV0FBVztRQUN6RCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTXVZLG1CQUFtQnBYLGVBQWU0UyxZQUFZO1FBQUM7S0FBZTtJQUNwRSxJQUFJd0Usb0JBQW9CLE1BQU07UUFDMUJ0WSxlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRTB0QyxvQkFBb0JucEM7SUFDbkU7SUFDQSxNQUFNQyw0QkFBNEJyWCxlQUFlNFMsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSXlFLDZCQUE2QixNQUFNO1FBQ25DdlksZUFBZStULFVBQVU7WUFBQztTQUF3QixFQUFFNHRDLDZCQUE2QnBwQztJQUNyRjtJQUNBLElBQUlyWCxlQUFlNFMsWUFBWTtRQUFDO0tBQXNCLE1BQU03VixXQUFXO1FBQ25FLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJbUIsZUFBZTRTLFlBQVk7UUFBQztLQUFhLE1BQU03VixXQUFXO1FBQzFELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNeVksaUJBQWlCdFgsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkwRSxrQkFBa0IsTUFBTTtRQUN4QnhZLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFNnRDO0lBQzdDO0lBQ0EsTUFBTW5wQyxrQkFBa0J2WCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTJFLG1CQUFtQixNQUFNO1FBQ3pCelksZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUU4dEMsdUJBQXVCcHBDO0lBQ3JFO0lBQ0EsTUFBTUMsb0JBQW9CeFgsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUk0RSxxQkFBcUIsTUFBTTtRQUMzQjFZLGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRTJFO0lBQ2hEO0lBQ0EsT0FBTzNFO0FBQ1g7QUFDQSxTQUFTZ3VDLCtCQUErQmp1QyxVQUFVO0lBQzlDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMmQsYUFBYXh3QixlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSTRkLGNBQWMsTUFBTTtRQUNwQjF4QixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRTJkO0lBQ3pDO0lBQ0EsSUFBSXh3QixlQUFlNFMsWUFBWTtRQUFDO0tBQWMsTUFBTTdWLFdBQVc7UUFDM0QsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLE9BQU9nVTtBQUNYO0FBQ0EsU0FBU2l1QztJQUNMLE1BQU1qdUMsV0FBVyxDQUFDO0lBQ2xCLE9BQU9BO0FBQ1g7QUFDQSxTQUFTa3VDLGtDQUFrQ251QyxVQUFVO0lBQ2pELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOGQsZUFBZTN3QixlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSStkLGdCQUFnQixNQUFNO1FBQ3RCN3hCLGVBQWUrVCxVQUFVO1lBQUM7U0FBVyxFQUFFOGQ7SUFDM0M7SUFDQSxNQUFNQywrQkFBK0I1d0IsZUFBZTRTLFlBQVk7UUFDNUQ7S0FDSDtJQUNELElBQUlnZSxnQ0FBZ0MsTUFBTTtRQUN0Qzl4QixlQUFlK1QsVUFBVTtZQUFDO1NBQTJCLEVBQUUrZDtJQUMzRDtJQUNBLE1BQU1DLDZCQUE2Qjd3QixlQUFlNFMsWUFBWTtRQUMxRDtLQUNIO0lBQ0QsSUFBSWllLDhCQUE4QixNQUFNO1FBQ3BDL3hCLGVBQWUrVCxVQUFVO1lBQUM7U0FBeUIsRUFBRWdlO0lBQ3pEO0lBQ0EsTUFBTUMsc0JBQXNCOXdCLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJa2UsdUJBQXVCLE1BQU07UUFDN0JoeUIsZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFaWU7SUFDbEQ7SUFDQSxNQUFNQyx3QkFBd0Ivd0IsZUFBZTRTLFlBQVk7UUFDckQ7S0FDSDtJQUNELElBQUltZSx5QkFBeUIsTUFBTTtRQUMvQmp5QixlQUFlK1QsVUFBVTtZQUFDO1NBQW9CLEVBQUVrZTtJQUNwRDtJQUNBLE9BQU9sZTtBQUNYO0FBQ0EsU0FBU211QywyQkFBMkJwdUMsVUFBVTtJQUMxQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9lLGlDQUFpQ2p4QixlQUFlNFMsWUFBWTtRQUM5RDtLQUNIO0lBQ0QsSUFBSXFlLGtDQUFrQyxNQUFNO1FBQ3hDbnlCLGVBQWUrVCxVQUFVO1lBQUM7U0FBNkIsRUFBRWt1QyxrQ0FBa0M5dkI7SUFDL0Y7SUFDQSxNQUFNQyx1QkFBdUJseEIsZUFBZTRTLFlBQVk7UUFDcEQ7S0FDSDtJQUNELElBQUlzZSx3QkFBd0IsTUFBTTtRQUM5QnB5QixlQUFlK1QsVUFBVTtZQUFDO1NBQW1CLEVBQUVxZTtJQUNuRDtJQUNBLE1BQU1DLG1CQUFtQm54QixlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXVlLG9CQUFvQixNQUFNO1FBQzFCcnlCLGVBQWUrVCxVQUFVO1lBQUM7U0FBZSxFQUFFc2U7SUFDL0M7SUFDQSxPQUFPdGU7QUFDWDtBQUNBLFNBQVNvdUMscUJBQXFCcnVDLFVBQVU7SUFDcEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU13ZSxtQkFBbUJyeEIsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUl5ZSxvQkFBb0IsTUFBTTtRQUMxQnZ5QixlQUFlK1QsVUFBVTtZQUFDO1NBQWUsRUFBRXdlO0lBQy9DO0lBQ0EsT0FBT3hlO0FBQ1g7QUFDQSxTQUFTcXVDLHNDQUFzQ3R1QyxVQUFVO0lBQ3JELE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNMGUsb0JBQW9CdnhCLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJMmUscUJBQXFCLE1BQU07UUFDM0J6eUIsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFMGU7SUFDaEQ7SUFDQSxNQUFNQyxvQkFBb0J4eEIsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUk0ZSxxQkFBcUIsTUFBTTtRQUMzQjF5QixlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVvdUMscUJBQXFCenZCO0lBQ3JFO0lBQ0EsT0FBTzNlO0FBQ1g7QUFDQSxTQUFTc3VDLHlCQUF5QnZ1QyxVQUFVO0lBQ3hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNNmUscUJBQXFCMXhCLGVBQWU0UyxZQUFZO1FBQ2xEO0tBQ0g7SUFDRCxJQUFJOGUsc0JBQXNCLE1BQU07UUFDNUI1eUIsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFNmU7SUFDakQ7SUFDQSxPQUFPN2U7QUFDWDtBQUNBLFNBQVN1dUMseUJBQXlCeHVDLFVBQVUsRUFBRXVHLFlBQVk7SUFDdEQsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNK2UsdUJBQXVCNXhCLGVBQWU0UyxZQUFZO1FBQ3BEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTYwQix3QkFBd0IsTUFBTTtRQUM1RDl5QixlQUFlcWEsY0FBYztZQUFDO1lBQVM7U0FBbUIsRUFBRXlZO0lBQ2hFO0lBQ0EsTUFBTXRYLHlCQUF5QnRhLGVBQWU0UyxZQUFZO1FBQ3REO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXVkLDBCQUEwQixNQUFNO1FBQzlEeGIsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQXFCLEVBQUVtQjtJQUN0RjtJQUNBLE1BQU1qQixrQkFBa0JyWixlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXVHLGlCQUFpQnBjLGFBQWFzYyxtQkFBbUIsTUFBTTtRQUN2RHZhLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFjLEVBQUVFO0lBQy9FO0lBQ0EsTUFBTUMsV0FBV3RaLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXVjLFlBQVksTUFBTTtRQUNoRHhhLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFPLEVBQUVHO0lBQ3hFO0lBQ0EsTUFBTUMsV0FBV3ZaLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJdUcsaUJBQWlCcGMsYUFBYXdjLFlBQVksTUFBTTtRQUNoRHphLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFPLEVBQUVJO0lBQ3hFO0lBQ0EsTUFBTUUsc0JBQXNCelosZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhMGMsdUJBQXVCLE1BQU07UUFDM0QzYSxlQUFlcWEsY0FBYztZQUFDO1lBQVM7WUFBb0I7U0FBa0IsRUFBRU07SUFDbkY7SUFDQSxNQUFNYyxzQkFBc0J2YSxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWF3ZCx1QkFBdUIsTUFBTTtRQUMzRHpiLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFrQixFQUFFb0I7SUFDbkY7SUFDQSxNQUFNUixXQUFXL1osZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl1RyxpQkFBaUJwYyxhQUFhZ2QsWUFBWSxNQUFNO1FBQ2hEamIsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQU8sRUFBRVk7SUFDeEU7SUFDQSxNQUFNUyxtQkFBbUJ4YSxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXVHLGlCQUFpQnBjLGFBQWF5ZCxvQkFBb0IsTUFBTTtRQUN4RDFiLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztZQUFvQjtTQUFlLEVBQUU0bUMsb0JBQW9CbnhDLGtCQUFrQjRMO0lBQ3RIO0lBQ0EsTUFBTXFYLDRCQUE0Qjd4QixlQUFlNFMsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWE4MEIsNkJBQTZCLE1BQU07UUFDakUveUIsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1lBQW9CO1NBQXdCLEVBQUUwWTtJQUN6RjtJQUNBLE1BQU16WSx3QkFBd0JwWixlQUFlNFMsWUFBWTtRQUNyRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFxYyx5QkFBeUIsTUFBTTtRQUM3RHRhLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztTQUFvQixFQUFFaW5DLGVBQWV6ekMsU0FBU3lNO0lBQ3pGO0lBQ0EsTUFBTWUsWUFBWW5hLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJdUcsaUJBQWlCcGMsYUFBYW9kLGFBQWEsTUFBTTtRQUNqRCxJQUFJaEcsa0JBQWtCL0UsT0FBTytLO1FBQzdCLElBQUk3YSxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3EwQyxZQUFZL3hDLE1BQU10QztZQUM3QjtRQUNKO1FBQ0F6TixlQUFlcWEsY0FBYztZQUFDO1lBQVM7U0FBUSxFQUFFaEY7SUFDckQ7SUFDQSxNQUFNMmQsd0JBQXdCOXhCLGVBQWU0UyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYSswQix5QkFBeUIsTUFBTTtRQUM3RGh6QixlQUFlcWEsY0FBYztZQUFDO1lBQVM7U0FBb0IsRUFBRTBuQywrQkFBK0IvdUI7SUFDaEc7SUFDQSxNQUFNQyw4QkFBOEIveEIsZUFBZTRTLFlBQVk7UUFDM0Q7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhZzFCLCtCQUErQixNQUFNO1FBQ25FanpCLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztTQUEwQixFQUFFMm5DO0lBQ3ZFO0lBQ0EsTUFBTTl1QiwrQkFBK0JoeUIsZUFBZTRTLFlBQVk7UUFDNUQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhaTFCLGdDQUFnQyxNQUFNO1FBQ3BFbHpCLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztTQUEyQixFQUFFMm5DO0lBQ3hFO0lBQ0EsTUFBTTd1QiwwQkFBMEJqeUIsZUFBZTRTLFlBQVk7UUFDdkQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhazFCLDJCQUEyQixNQUFNO1FBQy9EbnpCLGVBQWVxYSxjQUFjO1lBQUM7WUFBUztTQUFzQixFQUFFNm5DLDJCQUEyQi91QjtJQUM5RjtJQUNBLE1BQU1DLCtCQUErQmx5QixlQUFlNFMsWUFBWTtRQUM1RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWFtMUIsZ0NBQWdDLE1BQU07UUFDcEVwekIsZUFBZXFhLGNBQWM7WUFBQztZQUFTO1NBQTJCLEVBQUUrbkMsc0NBQXNDaHZCO0lBQzlHO0lBQ0EsTUFBTUMsa0JBQWtCbnlCLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJdUcsaUJBQWlCcGMsYUFBYW8xQixtQkFBbUIsTUFBTTtRQUN2RHJ6QixlQUFlcWEsY0FBYztZQUFDO1lBQVM7U0FBYyxFQUFFZ29DLHlCQUF5Qmh2QjtJQUNwRjtJQUNBLE9BQU90ZjtBQUNYO0FBQ0EsU0FBU3d1Qyw4QkFBOEJqMkMsU0FBUyxFQUFFd0gsVUFBVTtJQUN4RCxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7WUFBUztTQUFRLEVBQUUxSCxPQUFPQyxXQUFXdVA7SUFDbkU7SUFDQSxNQUFNRSxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRXV1Qyx5QkFBeUJ2bUMsWUFBWWhJO0lBQzlFO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVN5dUMsNkJBQTZCbDJDLFNBQVMsRUFBRXdILFVBQVUsRUFBRXVHLFlBQVk7SUFDckUsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNa1MsaUJBQWlCL2tCLGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJdUcsaUJBQWlCcGMsYUFBYWdvQixrQkFBa0IsTUFBTTtRQUN0RGptQixlQUFlcWEsY0FBYztZQUFDO1NBQWEsRUFBRTRMO0lBQ2pEO0lBQ0EsTUFBTXc4QiwyQkFBMkJ2aEQsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhd2tELDRCQUE0QixNQUFNO1FBQ2hFemlELGVBQWVxYSxjQUFjO1lBQUM7U0FBdUIsRUFBRW9vQztJQUMzRDtJQUNBLE1BQU1DLFdBQVd4aEQsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl1RyxpQkFBaUJwYyxhQUFheWtELFlBQVksTUFBTTtRQUNoRDFpRCxlQUFlcWEsY0FBYztZQUFDO1NBQU8sRUFBRXFvQztJQUMzQztJQUNBLE1BQU1DLDZCQUE2QnpoRCxlQUFlNFMsWUFBWTtRQUMxRDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWEwa0QsOEJBQThCLE1BQU07UUFDbEUzaUQsZUFBZXFhLGNBQWM7WUFBQztTQUEyQixFQUFFa29DLDhCQUE4QmoyQyxXQUFXcTJDO0lBQ3hHO0lBQ0EsTUFBTUMsMkJBQTJCMWhELGVBQWU0UyxZQUFZO1FBQ3hEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTJrRCw0QkFBNEIsTUFBTTtRQUNoRTVpRCxlQUFlcWEsY0FBYztZQUFDO1NBQVksRUFBRXVvQztJQUNoRDtJQUNBLE9BQU83dUM7QUFDWDtBQUNBLFNBQVM4dUMsaUNBQWlDdjJDLFNBQVMsRUFBRXdILFVBQVU7SUFDM0QsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1nSSxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRXl1Qyw2QkFBNkJsMkMsV0FBV3lQLFlBQVloSTtJQUM3RjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTK3VDLG1CQUFtQmh2QyxVQUFVO0lBQ2xDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNekMsV0FBV3BRLGVBQWU0UyxZQUFZO1FBQUM7S0FBTztJQUNwRCxJQUFJeEMsWUFBWSxNQUFNO1FBQ2xCdFIsZUFBZStULFVBQVU7WUFBQztTQUFPLEVBQUV6QztJQUN2QztJQUNBLE9BQU95QztBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNEOzs7OztDQUtDLEdBQ0QsU0FBU2d2QyxjQUFjdkwsS0FBSztJQUN4QixNQUFNd0wsU0FBUyxFQUFFO0lBQ2pCLElBQUssTUFBTXhqRCxPQUFPZzRDLE1BQU87UUFDckIsSUFBSS8zQyxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDNDNDLE9BQU9oNEMsTUFBTTtZQUNsRCxNQUFNSyxRQUFRMjNDLEtBQUssQ0FBQ2g0QyxJQUFJO1lBQ3hCLCtEQUErRDtZQUMvRCxJQUFJLE9BQU9LLFVBQVUsWUFDakJBLFNBQVMsUUFDVEosT0FBT1MsSUFBSSxDQUFDTCxPQUFPTyxNQUFNLEdBQUcsR0FBRztnQkFDL0IsTUFBTTZpRCxRQUFReGpELE9BQU9TLElBQUksQ0FBQ0wsT0FBT3NCLEdBQUcsQ0FBQyxDQUFDK2hELEtBQU8sQ0FBQyxFQUFFMWpELElBQUksQ0FBQyxFQUFFMGpELEdBQUcsQ0FBQztnQkFDM0RGLE9BQU81OEMsSUFBSSxJQUFJNjhDO1lBQ25CLE9BQ0s7Z0JBQ0RELE9BQU81OEMsSUFBSSxDQUFDNUcsTUFBTSxZQUFZO1lBQ2xDO1FBQ0o7SUFDSjtJQUNBLE9BQU93akQsT0FBTy9ULElBQUksQ0FBQztBQUN2QjtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU2tVLDZCQUE2QnovQixXQUFXLEVBQUV0WixNQUFNO0lBQ3JELHdFQUF3RTtJQUN4RSxJQUFJZzVDLHlCQUF5QjtJQUM3QixNQUFNQyxnQ0FBZ0MzL0IsV0FBVyxDQUFDLDJCQUEyQjtJQUM3RSxJQUFJLE9BQU8yL0Isa0NBQWtDLFlBQ3pDQSxrQ0FBa0MsUUFDbEMsV0FBV0EsK0JBQStCO1FBQzFDLDJFQUEyRTtRQUMzRSxZQUFZO1FBQ1osTUFBTUMsYUFBYUQsOEJBQ2Q3TCxLQUFLO1FBQ1YsSUFBSSxPQUFPOEwsZUFBZSxZQUFZQSxlQUFlLE1BQU07WUFDdkQsMkJBQTJCO1lBQzNCNS9CLFdBQVcsQ0FBQywyQkFBMkIsR0FBRzQvQjtZQUMxQ0YseUJBQXlCRTtRQUM3QixPQUNLO1lBQ0Qsd0VBQXdFO1lBQ3hFLDBDQUEwQztZQUMxQyxPQUFPNS9CLFdBQVcsQ0FBQywyQkFBMkI7UUFDbEQ7SUFDSixPQUNLLElBQUkyL0Isa0NBQWtDcGxELFdBQVc7UUFDbEQsNERBQTREO1FBQzVELDBDQUEwQztRQUMxQyxPQUFPeWxCLFdBQVcsQ0FBQywyQkFBMkI7SUFDbEQ7SUFDQSxNQUFNNi9CLHVCQUF1QjcvQixXQUFXLENBQUMsWUFBWTtJQUNyRCxnQ0FBZ0M7SUFDaEMsSUFBSTAvQix3QkFBd0I7UUFDeEIsTUFBTUksd0JBQXdCVCxjQUFjSztRQUM1QyxJQUFJNWlELE1BQU1DLE9BQU8sQ0FBQzJKLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPcTVDLG9CQUFvQixLQUN6RixDQUFDcjVDLFdBQVcsUUFBUUEsV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJQSxPQUFPcTVDLG9CQUFvQixDQUFDcmpELE1BQU0sTUFBTSxHQUFHO1lBQzVGLHdFQUF3RTtZQUN4RSxjQUFjO1lBQ2QsSUFBSW9qRCx1QkFBdUI7Z0JBQ3ZCLG1DQUFtQztnQkFDbkM5L0IsV0FBVyxDQUFDLFlBQVksR0FBRzgvQjtZQUMvQixPQUNLO2dCQUNELE9BQU85L0IsV0FBVyxDQUFDLFlBQVksRUFBRSxtQ0FBbUM7WUFDcEUsaUNBQWlDO1lBQ3JDO1FBQ0osT0FDSyxJQUFJLENBQUN0WixXQUFXLFFBQVFBLFdBQVcsS0FBSyxJQUFJLEtBQUssSUFBSUEsT0FBT3E1QyxvQkFBb0IsS0FDakZyNUMsT0FBT3E1QyxvQkFBb0IsQ0FBQ3JqRCxNQUFNLEdBQUcsS0FDckNtakQseUJBQXlCLFFBQ3pCL2lELE1BQU1DLE9BQU8sQ0FBQzhpRCx5QkFDZEEscUJBQXFCbmpELE1BQU0sR0FBRyxHQUFHO1lBQ2pDLDBEQUEwRDtZQUMxRCwwQkFBMEI7WUFDMUIsTUFBTXNqRCx5QkFBeUI7Z0JBQzNCO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0g7WUFDRCxJQUFJQyw4QkFBOEIsRUFBRTtZQUNwQyxJQUFJSixxQkFBcUJuakQsTUFBTSxHQUFHLEdBQUc7Z0JBQ2pDdWpELDhCQUE4QkoscUJBQXFCcGlELEdBQUcsQ0FBQyxDQUFDOGhEO29CQUNwRCxJQUFJUyx1QkFBdUJsMUMsUUFBUSxDQUFDeTBDLFFBQVE7d0JBQ3hDLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRUEsTUFBTSxDQUFDO29CQUN0QztvQkFDQSxPQUFPQSxPQUFPLHFDQUFxQztnQkFDbkQseUJBQXlCO2dCQUM3QjtZQUNKO1lBQ0EsTUFBTVcsaUJBQWlCLEVBQUU7WUFDekIsSUFBSUosdUJBQXVCO2dCQUN2QkksZUFBZXg5QyxJQUFJLENBQUNvOUM7WUFDeEI7WUFDQSxJQUFJRyw0QkFBNEJ2akQsTUFBTSxHQUFHLEdBQUc7Z0JBQ3hDd2pELGVBQWV4OUMsSUFBSSxJQUFJdTlDO1lBQzNCO1lBQ0EsSUFBSUMsZUFBZXhqRCxNQUFNLEdBQUcsR0FBRztnQkFDM0JzakIsV0FBVyxDQUFDLFlBQVksR0FBR2tnQyxlQUFlM1UsSUFBSSxDQUFDO1lBQ25ELE9BQ0s7Z0JBQ0QsNkRBQTZEO2dCQUM3RCxxQkFBcUI7Z0JBQ3JCLE9BQU92ckIsV0FBVyxDQUFDLFlBQVk7WUFDbkM7UUFDSixPQUNLO1lBQ0QsMEVBQTBFO1lBQzFFLHNEQUFzRDtZQUN0RCxpREFBaUQ7WUFDakQscURBQXFEO1lBQ3JELHFFQUFxRTtZQUNyRSxPQUFPQSxXQUFXLENBQUMsWUFBWTtRQUNuQztJQUNKLE9BQ0s7UUFDRCw4REFBOEQ7UUFDOUQsd0NBQXdDO1FBQ3hDLElBQUk2L0IseUJBQXlCLFFBQ3pCL2lELE1BQU1DLE9BQU8sQ0FBQzhpRCx5QkFDZEEscUJBQXFCbmpELE1BQU0sR0FBRyxHQUFHO1lBQ2pDLG9FQUFvRTtZQUNwRSx5Q0FBeUM7WUFDekNzakIsV0FBVyxDQUFDLFlBQVksR0FBRzYvQixxQkFBcUJ0VSxJQUFJLENBQUM7UUFDekQsT0FDSztZQUNELE9BQU92ckIsV0FBVyxDQUFDLFlBQVk7UUFDbkM7SUFDSjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxNQUFNbWdDLGVBQWU1a0Q7SUFDakJ5SCxZQUFZNEYsU0FBUyxDQUFFO1FBQ25CLEtBQUs7UUFDTCxJQUFJLENBQUNBLFNBQVMsR0FBR0E7SUFDckI7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWtGQyxHQUNELE1BQU1xVyxPQUFPeEIsTUFBTSxFQUFFO1FBQ2pCLElBQUl0aUIsSUFBSUM7UUFDUixJQUFJcUc7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNLElBQUluTCxNQUFNO1FBQ3BCLE9BQ0s7WUFDRCxNQUFNcWpCLE9BQU95L0IsaUNBQWlDLElBQUksQ0FBQ3YyQyxTQUFTLEVBQUU2VTtZQUM5RCtCLE9BQU9oa0IsVUFBVSxlQUFla2tCLElBQUksQ0FBQyxPQUFPO1lBQzVDRCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixNQUFNMGdDLGtCQUFrQlgsNkJBQTZCLy9CLE1BQU1qQyxPQUFPL1csTUFBTTtZQUN4RWpGLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDZ2dDO2dCQUNyQi8vQixZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQ0ksS0FBS3NpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF2TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdKLFdBQVc7Z0JBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1lBQ3pGLEdBQ0tDLElBQUksQ0FBQyxDQUFDQztnQkFDUCxPQUFPQSxhQUFhbmQsSUFBSTtZQUM1QjtZQUNBLE9BQU81QixTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU8yK0IsbUJBQW1CNzNDO2dCQUNoQyxPQUFPa1o7WUFDWDtRQUNKO0lBQ0o7QUFDSjtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNNC9CLHdCQUF3QjtBQUM5QixNQUFNQywyQkFBMkI7QUFDakMsTUFBTUM7SUFDRnY5QyxZQUFZdW5DLElBQUksQ0FBRTtRQUNkLElBQUlBLEtBQUtJLE1BQU0sS0FBS3B3QyxXQUFXO1lBQzNCLElBQUksQ0FBQ293QyxNQUFNLEdBQUdKLEtBQUtJLE1BQU07WUFDekI7UUFDSjtRQUNBLE1BQU02VixvQkFBb0JDLHVCQUF1QmxXLEtBQUttVyxpQkFBaUI7UUFDdkUsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSTNtRCwyREFBVUEsQ0FBQ3dtRDtJQUNyQztJQUNBLE1BQU1oUixlQUFldnNDLE9BQU8sRUFBRTtRQUMxQixJQUFJLElBQUksQ0FBQzBuQyxNQUFNLEtBQUtwd0MsV0FBVztZQUMzQixJQUFJLElBQUksQ0FBQ293QyxNQUFNLENBQUM3aEMsVUFBVSxDQUFDLGlCQUFpQjtnQkFDeEMsTUFBTSxJQUFJek0sTUFBTTtZQUNwQjtZQUNBLElBQUksQ0FBQ3VrRCxZQUFZLENBQUMzOUM7WUFDbEI7UUFDSjtRQUNBLE9BQU8sSUFBSSxDQUFDNDlDLG9CQUFvQixDQUFDNTlDO0lBQ3JDO0lBQ0EyOUMsYUFBYTM5QyxPQUFPLEVBQUU7UUFDbEIsSUFBSUEsUUFBUThkLEdBQUcsQ0FBQ3MvQiwyQkFBMkIsTUFBTTtZQUM3QztRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUMxVixNQUFNLEtBQUtwd0MsV0FBVztZQUMzQix1REFBdUQ7WUFDdkQsc0JBQXNCO1lBQ3RCLE1BQU0sSUFBSThCLE1BQU07UUFDcEI7UUFDQTRHLFFBQVFvcEMsTUFBTSxDQUFDZ1UsdUJBQXVCLElBQUksQ0FBQzFWLE1BQU07SUFDckQ7SUFDQSxNQUFNa1cscUJBQXFCNTlDLE9BQU8sRUFBRTtRQUNoQyxJQUFJLElBQUksQ0FBQzA5QyxVQUFVLEtBQUtwbUQsV0FBVztZQUMvQixnRUFBZ0U7WUFDaEUsbUVBQW1FO1lBQ25FLFVBQVU7WUFDVixNQUFNLElBQUk4QixNQUFNO1FBQ3BCO1FBQ0EsTUFBTXlrRCxjQUFjLE1BQU0sSUFBSSxDQUFDSCxVQUFVLENBQUNJLGlCQUFpQjtRQUMzRCxJQUFLLE1BQU1qbEQsT0FBT2dsRCxZQUFhO1lBQzNCLElBQUk3OUMsUUFBUThkLEdBQUcsQ0FBQ2psQixTQUFTLE1BQU07Z0JBQzNCO1lBQ0o7WUFDQW1ILFFBQVFvcEMsTUFBTSxDQUFDdndDLEtBQUtnbEQsV0FBVyxDQUFDaGxELElBQUk7UUFDeEM7SUFDSjtBQUNKO0FBQ0EsU0FBUzJrRCx1QkFBdUJDLGlCQUFpQjtJQUM3QyxJQUFJTTtJQUNKLElBQUksQ0FBQ04sbUJBQW1CO1FBQ3BCTSxjQUFjO1lBQ1ZDLFFBQVE7Z0JBQUNYO2FBQXlCO1FBQ3RDO1FBQ0EsT0FBT1U7SUFDWCxPQUNLO1FBQ0RBLGNBQWNOO1FBQ2QsSUFBSSxDQUFDTSxZQUFZQyxNQUFNLEVBQUU7WUFDckJELFlBQVlDLE1BQU0sR0FBRztnQkFBQ1g7YUFBeUI7WUFDL0MsT0FBT1U7UUFDWCxPQUNLLElBQUksT0FBUUEsWUFBWUMsTUFBTSxLQUFLLFlBQ3BDRCxZQUFZQyxNQUFNLEtBQUtYLDRCQUN0QnhqRCxNQUFNQyxPQUFPLENBQUNpa0QsWUFBWUMsTUFBTSxLQUM3QkQsWUFBWUMsTUFBTSxDQUFDbDRDLE9BQU8sQ0FBQ3UzQyw0QkFBNEIsR0FBSTtZQUMvRCxNQUFNLElBQUlqa0QsTUFBTSxDQUFDLDBDQUEwQyxFQUFFaWtELHlCQUF5QixDQUFDO1FBQzNGO1FBQ0EsT0FBT1U7SUFDWDtBQUNKO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1FO0lBQ0YsTUFBTXYwQixTQUFTbFAsTUFBTSxFQUFFN1UsU0FBUyxFQUFFO1FBQzlCLElBQUk2VSxPQUFPMGpDLFlBQVksRUFBRTtZQUNyQixNQUFNMS9DLFdBQVcsTUFBTW1yQixhQUFhblAsUUFBUTdVO1lBQzVDLElBQUluSCxvQkFBb0JzQixjQUFjO2dCQUNsQyxNQUFNcStDLFNBQVNubkQscURBQWlCQSxDQUFDd2pCLE9BQU8wakMsWUFBWTtnQkFDcERobkQsaURBQVFBLENBQUNrbkQsT0FBTyxDQUFDNS9DLFNBQVMyQixnQkFBZ0IsQ0FBQ3NjLElBQUksRUFBRTRoQyxJQUFJLENBQUNGO1lBQzFELE9BQ0s7Z0JBQ0RsbkQsNkNBQVNBLENBQUN1akIsT0FBTzBqQyxZQUFZLEVBQUUxL0MsVUFBVTtvQkFBRTgvQyxVQUFVO2dCQUFTLEdBQUcsQ0FBQzdqRDtvQkFDOUQsSUFBSUEsT0FBTzt3QkFDUCxNQUFNLElBQUlyQixNQUFNLENBQUMsd0JBQXdCLEVBQUVvaEIsT0FBTzBqQyxZQUFZLENBQUMsRUFBRSxFQUFFempELE1BQU0sQ0FBQztvQkFDOUU7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0o7QUFDSjtBQUNBLGVBQWVrdkIsYUFBYW5QLE1BQU0sRUFBRTdVLFNBQVM7SUFDekMsSUFBSXpOLElBQUlDLElBQUlxSTtJQUNaLE1BQU1yQyxPQUFPdU0sVUFBVThQLE9BQU9pUCxJQUFJO0lBQ2xDLElBQUl0ckIsU0FBUzdHLFdBQVc7UUFDcEIsT0FBTyxNQUFNcU8sVUFBVTRVLE9BQU8sQ0FBQztZQUMzQmdDLE1BQU0sQ0FBQyxNQUFNLEVBQUVwZSxLQUFLLFNBQVMsQ0FBQztZQUM5QmlmLFlBQVk7WUFDWlosYUFBYTtnQkFDVCxPQUFPO1lBQ1g7WUFDQTFrQixhQUFhLENBQUNJLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO1lBQ3JGdWxCLGFBQWEsQ0FBQ2xsQixLQUFLcWlCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXRMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2tsQixXQUFXO1FBQ3pGO0lBQ0osT0FDSyxJQUFJN1MsaUJBQWlCZ1EsT0FBT2lQLElBQUksR0FBRztRQUNwQyxNQUFNemtCLGFBQWEsQ0FBQ3hFLEtBQUtnYSxPQUFPaVAsSUFBSSxDQUFDMWtCLEtBQUssTUFBTSxRQUFRdkUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHd0UsVUFBVTtRQUM5RixJQUFJLE9BQU9BLGVBQWUsVUFBVTtZQUNoQyxPQUFPQTtRQUNYLE9BQ0s7WUFDRCxNQUFNLElBQUk1TCxNQUFNO1FBQ3BCO0lBQ0osT0FDSyxJQUFJcVIsUUFBUStQLE9BQU9pUCxJQUFJLEdBQUc7UUFDM0IsTUFBTXprQixhQUFhd1YsT0FBT2lQLElBQUksQ0FBQ3prQixVQUFVO1FBQ3pDLElBQUksT0FBT0EsZUFBZSxVQUFVO1lBQ2hDLE9BQU9BO1FBQ1gsT0FDSztZQUNELE1BQU0sSUFBSTVMLE1BQU07UUFDcEI7SUFDSixPQUNLO1FBQ0QsTUFBTSxJQUFJQSxNQUFNO0lBQ3BCO0FBQ0o7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTW1sRDtJQUNGdmlDLE9BQU84c0IsR0FBRyxFQUFFOW9DLE9BQU8sRUFBRXF3QyxTQUFTLEVBQUU7UUFDNUIsT0FBTyxJQUFJbU8sY0FBYzFWLEtBQUs5b0MsU0FBU3F3QztJQUMzQztBQUNKO0FBQ0EsTUFBTW1PO0lBQ0Z6K0MsWUFBWStvQyxHQUFHLEVBQUU5b0MsT0FBTyxFQUFFcXdDLFNBQVMsQ0FBRTtRQUNqQyxJQUFJLENBQUN2SCxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDOW9DLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNxd0MsU0FBUyxHQUFHQTtJQUNyQjtJQUNBTCxVQUFVO1FBQ04sSUFBSSxDQUFDeU8sRUFBRSxHQUFHLElBQUl0bkQseUNBQWdCLENBQUMsSUFBSSxDQUFDMnhDLEdBQUcsRUFBRTtZQUFFOW9DLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1FBQUM7UUFDakUsSUFBSSxDQUFDeStDLEVBQUUsQ0FBQ2pPLE1BQU0sR0FBRyxJQUFJLENBQUNILFNBQVMsQ0FBQ0csTUFBTTtRQUN0QyxJQUFJLENBQUNpTyxFQUFFLENBQUNoTyxPQUFPLEdBQUcsSUFBSSxDQUFDSixTQUFTLENBQUNJLE9BQU87UUFDeEMsSUFBSSxDQUFDZ08sRUFBRSxDQUFDL04sT0FBTyxHQUFHLElBQUksQ0FBQ0wsU0FBUyxDQUFDSyxPQUFPO1FBQ3hDLElBQUksQ0FBQytOLEVBQUUsQ0FBQzlPLFNBQVMsR0FBRyxJQUFJLENBQUNVLFNBQVMsQ0FBQ1YsU0FBUztJQUNoRDtJQUNBb0IsS0FBSzNyQixPQUFPLEVBQUU7UUFDVixJQUFJLElBQUksQ0FBQ3E1QixFQUFFLEtBQUtubkQsV0FBVztZQUN2QixNQUFNLElBQUk4QixNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxDQUFDcWxELEVBQUUsQ0FBQzFOLElBQUksQ0FBQzNyQjtJQUNqQjtJQUNBOHNCLFFBQVE7UUFDSixJQUFJLElBQUksQ0FBQ3VNLEVBQUUsS0FBS25uRCxXQUFXO1lBQ3ZCLE1BQU0sSUFBSThCLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNxbEQsRUFBRSxDQUFDdk0sS0FBSztJQUNqQjtBQUNKO0FBRUE7Ozs7Q0FJQyxHQUNELGlFQUFpRTtBQUNqRSxTQUFTeU0sOEJBQThCeHhDLFVBQVU7SUFDN0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU16QyxXQUFXcFEsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl4QyxZQUFZLE1BQU07UUFDbEJ0UixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFekM7SUFDL0M7SUFDQSxNQUFNeUssYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVnSTtJQUN6QztJQUNBLE9BQU9oSTtBQUNYO0FBQ0EsU0FBU3d4Qyw0QkFBNEJ6eEMsVUFBVSxFQUFFdUcsWUFBWTtJQUN6RCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU0ySSxlQUFleGIsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUl1RyxpQkFBaUJwYyxhQUFheWUsZ0JBQWdCLE1BQU07UUFDcEQxYyxlQUFlcWEsY0FBYztZQUFDO1lBQVU7U0FBVyxFQUFFcUM7SUFDekQ7SUFDQSxNQUFNQyxnQkFBZ0J6YixlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSXVHLGlCQUFpQnBjLGFBQWEwZSxpQkFBaUIsTUFBTTtRQUNyRDNjLGVBQWVxYSxjQUFjO1lBQUM7WUFBVTtTQUFZLEVBQUVzQztJQUMxRDtJQUNBLE1BQU1hLGFBQWF0YyxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSXVHLGlCQUFpQnBjLGFBQWF1ZixjQUFjLE1BQU07UUFDbER4ZCxlQUFlcWEsY0FBYztZQUFDO1lBQVU7U0FBUyxFQUFFbUQ7SUFDdkQ7SUFDQSxPQUFPeko7QUFDWDtBQUNBLFNBQVN5eEMsZ0NBQWdDMXhDLFVBQVU7SUFDL0MsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1nSSxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRXd4Qyw0QkFBNEJ4cEMsWUFBWWhJO0lBQ2pGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVMweEMscUJBQXFCM3hDLFVBQVU7SUFDcEMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU0yeEMsZ0JBQWdCeGtELGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJNHhDLGlCQUFpQixNQUFNO1FBQ3ZCMWxELGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFMnhDO0lBQzVDO0lBQ0EsTUFBTUMsYUFBYXprRCxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSTZ4QyxjQUFjLE1BQU07UUFDcEIzbEQsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUU0eEM7SUFDekM7SUFDQSxPQUFPNXhDO0FBQ1g7QUFDQSxTQUFTNnhDLHFCQUFxQjl4QyxVQUFVO0lBQ3BDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJN1MsZUFBZTRTLFlBQVk7UUFBQztLQUFTLE1BQU03VixXQUFXO1FBQ3RELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJbUIsZUFBZTRTLFlBQVk7UUFBQztLQUF3QixNQUFNN1YsV0FBVztRQUNyRSxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTThsRCxlQUFlM2tELGVBQWU0UyxZQUFZO1FBQUM7S0FBVztJQUM1RCxJQUFJK3hDLGdCQUFnQixNQUFNO1FBQ3RCLElBQUl4d0Msa0JBQWtCd3dDO1FBQ3RCLElBQUlybEQsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU9nNEMscUJBQXFCaDRDO1lBQ2hDO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7WUFBWTtTQUFXLEVBQUVzQjtJQUN2RDtJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBUyt4Qyw2QkFBNkJoeUMsVUFBVSxFQUFFdUcsWUFBWTtJQUMxRCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLElBQUk3UyxlQUFlNFMsWUFBWTtRQUFDO0tBQW9CLE1BQU03VixXQUFXO1FBQ2pFLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNZ21ELDRCQUE0QjdrRCxlQUFlNFMsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWE4bkQsNkJBQTZCLE1BQU07UUFDakUvbEQsZUFBZXFhLGNBQWM7WUFBQztTQUFjLEVBQUUwckM7SUFDbEQ7SUFDQSxJQUFJN2tELGVBQWU0UyxZQUFZO1FBQUM7S0FBYyxNQUFNN1YsV0FBVztRQUMzRCxNQUFNLElBQUk4QixNQUFNO0lBQ3BCO0lBQ0EsTUFBTWltRCxpQkFBaUI5a0QsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUl1RyxpQkFBaUJwYyxhQUFhK25ELGtCQUFrQixNQUFNO1FBQ3REaG1ELGVBQWVxYSxjQUFjO1lBQUM7WUFBYztZQUFtQjtTQUFhLEVBQUUyckM7SUFDbEY7SUFDQSxNQUFNQyw2QkFBNkIva0QsZUFBZTRTLFlBQVk7UUFDMUQ7S0FDSDtJQUNELElBQUlteUMsOEJBQThCLE1BQU07UUFDcENqbUQsZUFBZStULFVBQVU7WUFBQztZQUFjO1lBQW1CO1NBQXlCLEVBQUVreUM7SUFDMUY7SUFDQSxJQUFJL2tELGVBQWU0UyxZQUFZO1FBQUM7S0FBMkIsTUFDdkQ3VixXQUFXO1FBQ1gsTUFBTSxJQUFJOEIsTUFBTTtJQUNwQjtJQUNBLElBQUltQixlQUFlNFMsWUFBWTtRQUFDO0tBQTRCLE1BQ3hEN1YsV0FBVztRQUNYLE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJbUIsZUFBZTRTLFlBQVk7UUFBQztLQUFjLE1BQU03VixXQUFXO1FBQzNELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxNQUFNbW1ELGdCQUFnQmhsRCxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSXVHLGlCQUFpQnBjLGFBQWFpb0QsaUJBQWlCLE1BQU07UUFDckRsbUQsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1lBQW1CO1NBQVksRUFBRTZyQztJQUNqRjtJQUNBLE1BQU1DLG1CQUFtQmpsRCxlQUFlNFMsWUFBWTtRQUFDO0tBQWU7SUFDcEUsSUFBSXVHLGlCQUFpQnBjLGFBQWFrb0Qsb0JBQW9CLE1BQU07UUFDeERubUQsZUFBZXFhLGNBQWM7WUFBQztZQUFjO1lBQW1CO1NBQWUsRUFBRThyQztJQUNwRjtJQUNBLE9BQU9weUM7QUFDWDtBQUNBLFNBQVNxeUMsd0NBQXdDdHlDLFVBQVU7SUFDdkQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pMUIsZ0JBQWdCOW5DLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJazFCLGlCQUFpQixNQUFNO1FBQ3ZCaHBDLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFaTFCO0lBQzVDO0lBQ0EsTUFBTXFkLG9CQUFvQm5sRCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXV5QyxxQkFBcUIsTUFBTTtRQUMzQnJtRCxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVzeUM7SUFDaEQ7SUFDQSxNQUFNQyxzQkFBc0JwbEQsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUl3eUMsdUJBQXVCLE1BQU07UUFDN0J0bUQsZUFBZStULFVBQVU7WUFBQztZQUFjO1NBQWUsRUFBRTZ4QyxxQkFBcUJVO0lBQ2xGO0lBQ0EsTUFBTXZxQyxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRSt4Qyw2QkFBNkIvcEMsWUFBWWhJO0lBQ2xGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVN3eUMsK0JBQStCenlDLFVBQVU7SUFDOUMsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU16QyxXQUFXcFEsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl4QyxZQUFZLE1BQU07UUFDbEJ0UixlQUFlK1QsVUFBVTtZQUFDO1lBQVE7U0FBTyxFQUFFekM7SUFDL0M7SUFDQSxNQUFNeUssYUFBYTdhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUksY0FBYyxNQUFNO1FBQ3BCL2IsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUVnSTtJQUN6QztJQUNBLE9BQU9oSTtBQUNYO0FBQ0EsU0FBU3l5Qyw2QkFBNkIxeUMsVUFBVSxFQUFFdUcsWUFBWTtJQUMxRCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU0ySSxlQUFleGIsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUl1RyxpQkFBaUJwYyxhQUFheWUsZ0JBQWdCLE1BQU07UUFDcEQxYyxlQUFlcWEsY0FBYztZQUFDO1lBQVU7U0FBVyxFQUFFcUM7SUFDekQ7SUFDQSxNQUFNQyxnQkFBZ0J6YixlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSXVHLGlCQUFpQnBjLGFBQWEwZSxpQkFBaUIsTUFBTTtRQUNyRDNjLGVBQWVxYSxjQUFjO1lBQUM7WUFBVTtTQUFZLEVBQUVzQztJQUMxRDtJQUNBLE1BQU1hLGFBQWF0YyxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSXVHLGlCQUFpQnBjLGFBQWF1ZixjQUFjLE1BQU07UUFDbER4ZCxlQUFlcWEsY0FBYztZQUFDO1lBQVU7U0FBUyxFQUFFbUQ7SUFDdkQ7SUFDQSxPQUFPeko7QUFDWDtBQUNBLFNBQVMweUMsaUNBQWlDM3lDLFVBQVU7SUFDaEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1nSSxhQUFhN2EsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUlpSSxjQUFjLE1BQU07UUFDcEIvYixlQUFlK1QsVUFBVTtZQUFDO1NBQVMsRUFBRXl5Qyw2QkFBNkJ6cUMsWUFBWWhJO0lBQ2xGO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLFNBQVMyeUMsc0JBQXNCNXlDLFVBQVUsRUFBRXVHLFlBQVk7SUFDbkQsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNZ0osYUFBYTdiLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJdUcsaUJBQWlCcGMsYUFBYThlLGNBQWMsTUFBTTtRQUNsRC9jLGVBQWVxYSxjQUFjO1lBQUM7WUFBd0I7U0FBcUIsRUFBRTBDO0lBQ2pGO0lBQ0EsTUFBTTRwQyw0QkFBNEJ6bEQsZUFBZTRTLFlBQVk7UUFDekQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhMG9ELDZCQUE2QixNQUFNO1FBQ2pFM21ELGVBQWVxYSxjQUFjO1lBQUM7WUFBd0I7U0FBcUIsRUFBRXNzQztJQUNqRjtJQUNBLElBQUl6bEQsZUFBZTRTLFlBQVk7UUFBQztLQUFXLE1BQU03VixXQUFXO1FBQ3hELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPZ1U7QUFDWDtBQUNBLFNBQVM2eUMsZ0NBQWdDOXlDLFVBQVUsRUFBRXVHLFlBQVk7SUFDN0QsTUFBTXRHLFdBQVcsQ0FBQztJQUNsQixNQUFNZ0osYUFBYTdiLGVBQWU0UyxZQUFZO1FBQUM7S0FBUztJQUN4RCxJQUFJaUosY0FBYyxNQUFNO1FBQ3BCL2MsZUFBZStULFVBQVU7WUFBQztTQUF1QixFQUFFZ0o7SUFDdkQ7SUFDQSxNQUFNNHBDLDRCQUE0QnpsRCxlQUFlNFMsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWEwb0QsNkJBQTZCLE1BQU07UUFDakUzbUQsZUFBZXFhLGNBQWM7WUFBQztZQUF3QjtTQUFxQixFQUFFc3NDO0lBQ2pGO0lBQ0EsT0FBTzV5QztBQUNYO0FBQ0EsU0FBUzh5Qyw4QkFBOEIveUMsVUFBVSxFQUFFdUcsWUFBWTtJQUMzRCxNQUFNdEcsV0FBVyxDQUFDO0lBQ2xCLE1BQU0reUMsd0JBQXdCNWxELGVBQWU0UyxZQUFZO1FBQ3JEO0tBQ0g7SUFDRCxJQUFJdUcsaUJBQWlCcGMsYUFBYTZvRCx5QkFBeUIsTUFBTTtRQUM3RDltRCxlQUFlcWEsY0FBYztZQUFDO1NBQXVCLEVBQUV1c0MsZ0NBQWdDRSx1QkFBdUIveUM7SUFDbEg7SUFDQSxNQUFNZ3lDLDRCQUE0QjdrRCxlQUFlNFMsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWE4bkQsNkJBQTZCLE1BQU07UUFDakUvbEQsZUFBZXFhLGNBQWM7WUFBQztTQUF3QixFQUFFMHJDO0lBQzVEO0lBQ0EsTUFBTXJ3QyxrQkFBa0J4VSxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSXVHLGlCQUFpQnBjLGFBQWF5WCxtQkFBbUIsTUFBTTtRQUN2RDFWLGVBQWVxYSxjQUFjO1lBQUM7U0FBYyxFQUFFM0U7SUFDbEQ7SUFDQSxNQUFNc3dDLGlCQUFpQjlrRCxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXVHLGlCQUFpQnBjLGFBQWErbkQsa0JBQWtCLE1BQU07UUFDdERobUQsZUFBZXFhLGNBQWM7WUFBQztZQUF3QjtZQUFtQjtTQUFhLEVBQUUyckM7SUFDNUY7SUFDQSxNQUFNQyw2QkFBNkIva0QsZUFBZTRTLFlBQVk7UUFDMUQ7S0FDSDtJQUNELElBQUl1RyxpQkFBaUJwYyxhQUFhZ29ELDhCQUE4QixNQUFNO1FBQ2xFam1ELGVBQWVxYSxjQUFjO1lBQUM7WUFBd0I7WUFBbUI7U0FBeUIsRUFBRTRyQztJQUN4RztJQUNBLE1BQU1jLCtCQUErQjdsRCxlQUFlNFMsWUFBWTtRQUM1RDtLQUNIO0lBQ0QsSUFBSXVHLGlCQUFpQnBjLGFBQWE4b0QsZ0NBQWdDLE1BQU07UUFDcEUvbUQsZUFBZXFhLGNBQWM7WUFBQztZQUF3QjtTQUEyQixFQUFFMHNDO0lBQ3ZGO0lBQ0EsTUFBTUMsZ0NBQWdDOWxELGVBQWU0UyxZQUFZO1FBQzdEO0tBQ0g7SUFDRCxJQUFJa3pDLGlDQUFpQyxNQUFNO1FBQ3ZDaG5ELGVBQWUrVCxVQUFVO1lBQUM7WUFBaUI7U0FBZSxFQUFFaXpDO0lBQ2hFO0lBQ0EsTUFBTUMsa0JBQWtCL2xELGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJdUcsaUJBQWlCcGMsYUFBYWdwRCxtQkFBbUIsTUFBTTtRQUN2RGpuRCxlQUFlcWEsY0FBYztZQUFDO1lBQXdCO1lBQW1CO1NBQWMsRUFBRTRzQztJQUM3RjtJQUNBLElBQUkvbEQsZUFBZTRTLFlBQVk7UUFBQztLQUFZLE1BQU03VixXQUFXO1FBQ3pELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxJQUFJbUIsZUFBZTRTLFlBQVk7UUFBQztLQUFlLE1BQU03VixXQUFXO1FBQzVELE1BQU0sSUFBSThCLE1BQU07SUFDcEI7SUFDQSxPQUFPZ1U7QUFDWDtBQUNBLFNBQVNtekMseUNBQXlDcHpDLFVBQVU7SUFDeEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1pMUIsZ0JBQWdCOW5DLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJazFCLGlCQUFpQixNQUFNO1FBQ3ZCaHBDLGVBQWUrVCxVQUFVO1lBQUM7U0FBWSxFQUFFaTFCO0lBQzVDO0lBQ0EsTUFBTXFkLG9CQUFvQm5sRCxlQUFlNFMsWUFBWTtRQUNqRDtLQUNIO0lBQ0QsSUFBSXV5QyxxQkFBcUIsTUFBTTtRQUMzQnJtRCxlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUVzeUM7SUFDaEQ7SUFDQSxNQUFNQyxzQkFBc0JwbEQsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUl3eUMsdUJBQXVCLE1BQU07UUFDN0J0bUQsZUFBZStULFVBQVU7WUFBQztZQUF3QjtTQUFxQixFQUFFMnlDLHNCQUFzQkoscUJBQXFCdnlDO0lBQ3hIO0lBQ0EsTUFBTWdJLGFBQWE3YSxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSWlJLGNBQWMsTUFBTTtRQUNwQi9iLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFOHlDLDhCQUE4QjlxQyxZQUFZaEk7SUFDbkY7SUFDQSxPQUFPQTtBQUNYO0FBQ0EsU0FBU296QyxvQkFBb0JyekMsVUFBVTtJQUNuQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTThILFlBQVkzYSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDckQsSUFBSStILGFBQWEsTUFBTTtRQUNuQjdiLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFOEg7SUFDeEM7SUFDQSxNQUFNdXJDLGVBQWVsbUQsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3hELElBQUlzekMsZ0JBQWdCLE1BQU07UUFDdEJwbkQsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVxekM7SUFDM0M7SUFDQSxPQUFPcnpDO0FBQ1g7QUFDQSxTQUFTc3pDLG1CQUFtQnZ6QyxVQUFVO0lBQ2xDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0wsc0JBQXNCamUsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxTCx1QkFBdUIsTUFBTTtRQUM3Qm5mLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW9MO0lBQ2xEO0lBQ0EsTUFBTTdOLFdBQVdwUSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXhDLFlBQVksTUFBTTtRQUNsQnRSLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFekM7SUFDdkM7SUFDQSxNQUFNNE8sWUFBWWhmLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJb00sYUFBYSxNQUFNO1FBQ25CbGdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBUSxFQUFFakQsaUJBQWlCb1A7SUFDekQ7SUFDQSxNQUFNQyxpQkFBaUJqZixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXFNLGtCQUFrQixNQUFNO1FBQ3hCbmdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFb007SUFDN0M7SUFDQSxNQUFNM0ksZ0JBQWdCdFcsZUFBZTRTLFlBQVk7UUFDN0M7UUFDQTtLQUNIO0lBQ0QsSUFBSTBELGlCQUFpQixNQUFNO1FBQ3ZCeFgsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUV5RDtJQUM1QztJQUNBLE1BQU1DLGNBQWN2VyxlQUFlNFMsWUFBWTtRQUMzQztRQUNBO0tBQ0g7SUFDRCxJQUFJMkQsZUFBZSxNQUFNO1FBQ3JCelgsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUUwRDtJQUMxQztJQUNBLE1BQU0ySSxpQkFBaUJsZixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXNNLGtCQUFrQixNQUFNO1FBQ3hCcGdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFcU07SUFDN0M7SUFDQSxNQUFNMUssa0JBQWtCeFUsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUk0QixtQkFBbUIsTUFBTTtRQUN6QjFWLGVBQWUrVCxVQUFVO1lBQUM7U0FBYyxFQUFFMkI7SUFDOUM7SUFDQSxNQUFNc3pCLGdCQUFnQjluQyxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSWsxQixpQkFBaUIsTUFBTTtRQUN2QmhwQyxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRWkxQjtJQUM1QztJQUNBLE1BQU1zZSxpQkFBaUJwbUQsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQzNELElBQUl3ekMsa0JBQWtCLE1BQU07UUFDeEJ0bkQsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUVvekMsb0JBQW9CRztJQUNqRTtJQUNBLE1BQU1DLHNCQUFzQnJtRCxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSXl6Qyx1QkFBdUIsTUFBTTtRQUM3QnZuRCxlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUV3ekM7SUFDbEQ7SUFDQSxNQUFNQyxpQkFBaUJ0bUQsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUkwekMsa0JBQWtCLE1BQU07UUFDeEJ4bkQsZUFBZStULFVBQVU7WUFBQztTQUFhLEVBQUV5ekM7SUFDN0M7SUFDQSxNQUFNL2tCLGFBQWF2aEMsZUFBZTRTLFlBQVk7UUFBQztLQUFTO0lBQ3hELElBQUkydUIsY0FBYyxNQUFNO1FBQ3BCemlDLGVBQWUrVCxVQUFVO1lBQUM7U0FBUyxFQUFFMHVCO0lBQ3pDO0lBQ0EsTUFBTWdsQixnQkFBZ0J2bUQsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUkyekMsaUJBQWlCLE1BQU07UUFDdkJ6bkQsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUUwekM7SUFDNUM7SUFDQSxNQUFNQyxrQkFBa0J4bUQsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUk0ekMsbUJBQW1CLE1BQU07UUFDekIxbkQsZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUUyekM7SUFDOUM7SUFDQSxNQUFNQyxxQkFBcUJ6bUQsZUFBZTRTLFlBQVk7UUFDbEQ7S0FDSDtJQUNELElBQUk2ekMsc0JBQXNCLE1BQU07UUFDNUIzbkQsZUFBZStULFVBQVU7WUFBQztTQUFpQixFQUFFNHpDO0lBQ2pEO0lBQ0EsTUFBTTVCLDRCQUE0QjdrRCxlQUFlNFMsWUFBWTtRQUN6RDtLQUNIO0lBQ0QsSUFBSWl5Qyw2QkFBNkIsTUFBTTtRQUNuQy9sRCxlQUFlK1QsVUFBVTtZQUFDO1NBQXdCLEVBQUVneUM7SUFDeEQ7SUFDQSxPQUFPaHlDO0FBQ1g7QUFDQSxTQUFTNnpDLGdDQUFnQzl6QyxVQUFVO0lBQy9DLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0wsc0JBQXNCamUsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxTCx1QkFBdUIsTUFBTTtRQUM3Qm5mLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW9MO0lBQ2xEO0lBQ0EsTUFBTW1CLG9CQUFvQnBmLGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJd00scUJBQXFCLE1BQU07UUFDM0J0Z0IsZUFBZStULFVBQVU7WUFBQztTQUFnQixFQUFFdU07SUFDaEQ7SUFDQSxNQUFNdW5DLGlCQUFpQjNtRCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDakUsSUFBSSt6QyxrQkFBa0IsTUFBTTtRQUN4QixJQUFJeHlDLGtCQUFrQnd5QztRQUN0QixJQUFJcm5ELE1BQU1DLE9BQU8sQ0FBQzRVLGtCQUFrQjtZQUNoQ0Esa0JBQWtCQSxnQkFBZ0JsVSxHQUFHLENBQUMsQ0FBQ3NNO2dCQUNuQyxPQUFPNDVDLG1CQUFtQjU1QztZQUM5QjtRQUNKO1FBQ0F6TixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXNCO0lBQzdDO0lBQ0EsT0FBT3RCO0FBQ1g7QUFDQSxTQUFTK3pDLHlCQUF5QmgwQyxVQUFVO0lBQ3hDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNb0wsc0JBQXNCamUsZUFBZTRTLFlBQVk7UUFDbkQ7S0FDSDtJQUNELElBQUlxTCx1QkFBdUIsTUFBTTtRQUM3Qm5mLGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW9MO0lBQ2xEO0lBQ0EsTUFBTTdOLFdBQVdwUSxlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSXhDLFlBQVksTUFBTTtRQUNsQnRSLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFekM7SUFDdkM7SUFDQSxNQUFNNjJCLGVBQWVqbkMsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlxMEIsZ0JBQWdCLE1BQU07UUFDdEJub0MsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVvMEI7SUFDM0M7SUFDQSxNQUFNMW5CLFdBQVd2ZixlQUFlNFMsWUFBWTtRQUFDO0tBQU87SUFDcEQsSUFBSTJNLFlBQVksTUFBTTtRQUNsQnpnQixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRTBNO0lBQ3ZDO0lBQ0EsTUFBTVgsWUFBWTVlLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJZ00sYUFBYSxNQUFNO1FBQ25COWYsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUUrTDtJQUN4QztJQUNBLE9BQU8vTDtBQUNYO0FBQ0EsU0FBU2cwQywrQkFBK0JqMEMsVUFBVTtJQUM5QyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTXk0QixtQkFBbUJ0ckMsZUFBZTRTLFlBQVk7UUFBQztLQUFlO0lBQ3BFLElBQUkwNEIsb0JBQW9CLE1BQU07UUFDMUJ4c0MsZUFBZStULFVBQVU7WUFBQztTQUFlLEVBQUV5NEI7SUFDL0M7SUFDQSxNQUFNQyxZQUFZdnJDLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJMjRCLGFBQWEsTUFBTTtRQUNuQnpzQyxlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRTA0QjtJQUN4QztJQUNBLE1BQU1DLFdBQVd4ckMsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUk0NEIsWUFBWSxNQUFNO1FBQ2xCMXNDLGVBQWUrVCxVQUFVO1lBQUM7U0FBTyxFQUFFMjRCO0lBQ3ZDO0lBQ0EsTUFBTTBhLGVBQWVsbUQsZUFBZTRTLFlBQVk7UUFBQztLQUFXO0lBQzVELElBQUlzekMsZ0JBQWdCLE1BQU07UUFDdEJwbkQsZUFBZStULFVBQVU7WUFBQztTQUFXLEVBQUVxekM7SUFDM0M7SUFDQSxPQUFPcnpDO0FBQ1g7QUFDQSxTQUFTaTBDLHFCQUFxQmwwQyxVQUFVO0lBQ3BDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixNQUFNOEgsWUFBWTNhLGVBQWU0UyxZQUFZO1FBQUM7S0FBUTtJQUN0RCxJQUFJK0gsYUFBYSxNQUFNO1FBQ25CN2IsZUFBZStULFVBQVU7WUFBQztTQUFRLEVBQUU4SDtJQUN4QztJQUNBLE1BQU11ckMsZUFBZWxtRCxlQUFlNFMsWUFBWTtRQUFDO0tBQVc7SUFDNUQsSUFBSXN6QyxnQkFBZ0IsTUFBTTtRQUN0QnBuRCxlQUFlK1QsVUFBVTtZQUFDO1NBQVcsRUFBRXF6QztJQUMzQztJQUNBLE1BQU12YSxrQkFBa0IzckMsZUFBZTRTLFlBQVk7UUFBQztLQUFjO0lBQ2xFLElBQUkrNEIsbUJBQW1CLE1BQU07UUFDekIsSUFBSXgzQixrQkFBa0J3M0I7UUFDdEIsSUFBSXJzQyxNQUFNQyxPQUFPLENBQUM0VSxrQkFBa0I7WUFDaENBLGtCQUFrQkEsZ0JBQWdCbFUsR0FBRyxDQUFDLENBQUNzTTtnQkFDbkMsT0FBT3M2QywrQkFBK0J0NkM7WUFDMUM7UUFDSjtRQUNBek4sZUFBZStULFVBQVU7WUFBQztTQUFjLEVBQUVzQjtJQUM5QztJQUNBLE9BQU90QjtBQUNYO0FBQ0EsU0FBU2swQyxvQkFBb0JuMEMsVUFBVTtJQUNuQyxNQUFNQyxXQUFXLENBQUM7SUFDbEIsTUFBTW9MLHNCQUFzQmplLGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcUwsdUJBQXVCLE1BQU07UUFDN0JuZixlQUFlK1QsVUFBVTtZQUFDO1NBQWtCLEVBQUVvTDtJQUNsRDtJQUNBLE1BQU03TixXQUFXcFEsZUFBZTRTLFlBQVk7UUFBQztLQUFPO0lBQ3BELElBQUl4QyxZQUFZLE1BQU07UUFDbEJ0UixlQUFlK1QsVUFBVTtZQUFDO1NBQU8sRUFBRXpDO0lBQ3ZDO0lBQ0EsTUFBTTRPLFlBQVloZixlQUFlNFMsWUFBWTtRQUFDO0tBQVE7SUFDdEQsSUFBSW9NLGFBQWEsTUFBTTtRQUNuQmxnQixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRWpELGlCQUFpQm9QO0lBQ3pEO0lBQ0EsTUFBTUMsaUJBQWlCamYsZUFBZTRTLFlBQVk7UUFBQztLQUFhO0lBQ2hFLElBQUlxTSxrQkFBa0IsTUFBTTtRQUN4Qm5nQixlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRW9NO0lBQzdDO0lBQ0EsTUFBTTNJLGdCQUFnQnRXLGVBQWU0UyxZQUFZO1FBQUM7S0FBWTtJQUM5RCxJQUFJMEQsaUJBQWlCLE1BQU07UUFDdkJ4WCxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRXlEO0lBQzVDO0lBQ0EsTUFBTUMsY0FBY3ZXLGVBQWU0UyxZQUFZO1FBQUM7S0FBVTtJQUMxRCxJQUFJMkQsZUFBZSxNQUFNO1FBQ3JCelgsZUFBZStULFVBQVU7WUFBQztTQUFVLEVBQUUwRDtJQUMxQztJQUNBLE1BQU0ySSxpQkFBaUJsZixlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSXNNLGtCQUFrQixNQUFNO1FBQ3hCcGdCLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFcU07SUFDN0M7SUFDQSxNQUFNTixZQUFZNWUsZUFBZTRTLFlBQVk7UUFBQztLQUFRO0lBQ3RELElBQUlnTSxhQUFhLE1BQU07UUFDbkI5ZixlQUFlK1QsVUFBVTtZQUFDO1NBQVEsRUFBRStMO0lBQ3hDO0lBQ0EsTUFBTXBLLGtCQUFrQnhVLGVBQWU0UyxZQUFZO1FBQUM7S0FBYztJQUNsRSxJQUFJNEIsbUJBQW1CLE1BQU07UUFDekIxVixlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRTJCO0lBQzlDO0lBQ0EsTUFBTXN6QixnQkFBZ0I5bkMsZUFBZTRTLFlBQVk7UUFBQztLQUFZO0lBQzlELElBQUlrMUIsaUJBQWlCLE1BQU07UUFDdkJocEMsZUFBZStULFVBQVU7WUFBQztTQUFZLEVBQUVpMUI7SUFDNUM7SUFDQSxNQUFNc2UsaUJBQWlCcG1ELGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJd3pDLGtCQUFrQixNQUFNO1FBQ3hCdG5ELGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFaTBDLHFCQUFxQlY7SUFDbEU7SUFDQSxNQUFNakIsb0JBQW9CbmxELGVBQWU0UyxZQUFZO1FBQ2pEO0tBQ0g7SUFDRCxJQUFJdXlDLHFCQUFxQixNQUFNO1FBQzNCcm1ELGVBQWUrVCxVQUFVO1lBQUM7U0FBZ0IsRUFBRXN5QztJQUNoRDtJQUNBLE1BQU02QiwyQkFBMkJobkQsZUFBZTRTLFlBQVk7UUFDeEQ7S0FDSDtJQUNELElBQUlvMEMsNEJBQTRCLE1BQU07UUFDbENsb0QsZUFBZStULFVBQVU7WUFBQztTQUF1QixFQUFFbTBDO0lBQ3ZEO0lBQ0EsTUFBTUMsc0JBQXNCam5ELGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJcTBDLHVCQUF1QixNQUFNO1FBQzdCbm9ELGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRW8wQztJQUNsRDtJQUNBLE1BQU1DLHFCQUFxQmxuRCxlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSXMwQyxzQkFBc0IsTUFBTTtRQUM1QnBvRCxlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUVxMEM7SUFDakQ7SUFDQSxNQUFNQyw2QkFBNkJubkQsZUFBZTRTLFlBQVk7UUFDMUQ7S0FDSDtJQUNELElBQUl1MEMsOEJBQThCLE1BQU07UUFDcENyb0QsZUFBZStULFVBQVU7WUFBQztTQUF5QixFQUFFczBDO0lBQ3pEO0lBQ0EsTUFBTWQsc0JBQXNCcm1ELGVBQWU0UyxZQUFZO1FBQ25EO0tBQ0g7SUFDRCxJQUFJeXpDLHVCQUF1QixNQUFNO1FBQzdCdm5ELGVBQWUrVCxVQUFVO1lBQUM7U0FBa0IsRUFBRXd6QztJQUNsRDtJQUNBLE1BQU1DLGlCQUFpQnRtRCxlQUFlNFMsWUFBWTtRQUFDO0tBQWE7SUFDaEUsSUFBSTB6QyxrQkFBa0IsTUFBTTtRQUN4QnhuRCxlQUFlK1QsVUFBVTtZQUFDO1NBQWEsRUFBRXl6QztJQUM3QztJQUNBLE1BQU0va0IsYUFBYXZoQyxlQUFlNFMsWUFBWTtRQUFDO0tBQVM7SUFDeEQsSUFBSTJ1QixjQUFjLE1BQU07UUFDcEJ6aUMsZUFBZStULFVBQVU7WUFBQztTQUFTLEVBQUUwdUI7SUFDekM7SUFDQSxNQUFNZ2xCLGdCQUFnQnZtRCxlQUFlNFMsWUFBWTtRQUFDO0tBQVk7SUFDOUQsSUFBSTJ6QyxpQkFBaUIsTUFBTTtRQUN2QnpuRCxlQUFlK1QsVUFBVTtZQUFDO1NBQVksRUFBRTB6QztJQUM1QztJQUNBLE1BQU1DLGtCQUFrQnhtRCxlQUFlNFMsWUFBWTtRQUFDO0tBQWM7SUFDbEUsSUFBSTR6QyxtQkFBbUIsTUFBTTtRQUN6QjFuRCxlQUFlK1QsVUFBVTtZQUFDO1NBQWMsRUFBRTJ6QztJQUM5QztJQUNBLE1BQU1DLHFCQUFxQnptRCxlQUFlNFMsWUFBWTtRQUNsRDtLQUNIO0lBQ0QsSUFBSTZ6QyxzQkFBc0IsTUFBTTtRQUM1QjNuRCxlQUFlK1QsVUFBVTtZQUFDO1NBQWlCLEVBQUU0ekM7SUFDakQ7SUFDQSxNQUFNNUIsNEJBQTRCN2tELGVBQWU0UyxZQUFZO1FBQ3pEO0tBQ0g7SUFDRCxJQUFJaXlDLDZCQUE2QixNQUFNO1FBQ25DL2xELGVBQWUrVCxVQUFVO1lBQUM7U0FBd0IsRUFBRWd5QztJQUN4RDtJQUNBLE9BQU9oeUM7QUFDWDtBQUNBLFNBQVN1MEMsaUNBQWlDeDBDLFVBQVU7SUFDaEQsTUFBTUMsV0FBVyxDQUFDO0lBQ2xCLE1BQU1vTCxzQkFBc0JqZSxlQUFlNFMsWUFBWTtRQUNuRDtLQUNIO0lBQ0QsSUFBSXFMLHVCQUF1QixNQUFNO1FBQzdCbmYsZUFBZStULFVBQVU7WUFBQztTQUFrQixFQUFFb0w7SUFDbEQ7SUFDQSxNQUFNbUIsb0JBQW9CcGYsZUFBZTRTLFlBQVk7UUFDakQ7S0FDSDtJQUNELElBQUl3TSxxQkFBcUIsTUFBTTtRQUMzQnRnQixlQUFlK1QsVUFBVTtZQUFDO1NBQWdCLEVBQUV1TTtJQUNoRDtJQUNBLE1BQU11bkMsaUJBQWlCM21ELGVBQWU0UyxZQUFZO1FBQUM7S0FBYTtJQUNoRSxJQUFJK3pDLGtCQUFrQixNQUFNO1FBQ3hCLElBQUl4eUMsa0JBQWtCd3lDO1FBQ3RCLElBQUlybkQsTUFBTUMsT0FBTyxDQUFDNFUsa0JBQWtCO1lBQ2hDQSxrQkFBa0JBLGdCQUFnQmxVLEdBQUcsQ0FBQyxDQUFDc007Z0JBQ25DLE9BQU93NkMsb0JBQW9CeDZDO1lBQy9CO1FBQ0o7UUFDQXpOLGVBQWUrVCxVQUFVO1lBQUM7U0FBYSxFQUFFc0I7SUFDN0M7SUFDQSxPQUFPdEI7QUFDWDtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNdzBDLGdCQUFnQnRwRDtJQUNsQnlILFlBQVk0RixTQUFTLENBQUU7UUFDbkIsS0FBSztRQUNMLElBQUksQ0FBQ0EsU0FBUyxHQUFHQTtRQUNqQjs7Ozs7Ozs7U0FRQyxHQUNELElBQUksQ0FBQ21ZLEdBQUcsR0FBRyxPQUFPdEQ7WUFDZCxPQUFPLE1BQU0sSUFBSSxDQUFDcW5DLFdBQVcsQ0FBQ3JuQztRQUNsQztRQUNBOzs7Ozs7OztTQVFDLEdBQ0QsSUFBSSxDQUFDa0QsSUFBSSxHQUFHLE9BQU9sRCxTQUFTLENBQUMsQ0FBQztZQUMxQixPQUFPLElBQUlGLE1BQU1ELFVBQVV5bkMsc0JBQXNCLEVBQUUsQ0FBQ2xrQyxJQUFNLElBQUksQ0FBQ0MsWUFBWSxDQUFDRCxJQUFJLE1BQU0sSUFBSSxDQUFDQyxZQUFZLENBQUNyRCxTQUFTQTtRQUNySDtRQUNBOzs7Ozs7OztTQVFDLEdBQ0QsSUFBSSxDQUFDdW5DLElBQUksR0FBRyxPQUFPdm5DO1lBQ2YsSUFBSSxJQUFJLENBQUM3VSxTQUFTLENBQUNwQixVQUFVLElBQUk7Z0JBQzdCLElBQUlpVyxPQUFPd25DLFNBQVMsQ0FBQ244QyxVQUFVLENBQUMsY0FBYztvQkFDMUMsTUFBTW84QyxnQkFBZ0I7d0JBQ2xCQyxnQkFBZ0IxbkMsT0FBT3duQyxTQUFTO29CQUNwQztvQkFDQSxNQUFNRyxnQkFBZ0JycEQsT0FBT3dCLE1BQU0sQ0FBQ3hCLE9BQU93QixNQUFNLENBQUMsQ0FBQyxHQUFHa2dCLFNBQVM7d0JBQUV5bkMsZUFBZUE7b0JBQWM7b0JBQzlGRSxjQUFjSCxTQUFTLEdBQUcxcUQ7b0JBQzFCLE9BQU8sTUFBTSxJQUFJLENBQUM4cUQsWUFBWSxDQUFDRDtnQkFDbkMsT0FDSztvQkFDRCxNQUFNQSxnQkFBZ0JycEQsT0FBT3dCLE1BQU0sQ0FBQyxDQUFDLEdBQUdrZ0I7b0JBQ3hDLE9BQU8sTUFBTSxJQUFJLENBQUM0bkMsWUFBWSxDQUFDRDtnQkFDbkM7WUFDSixPQUNLO2dCQUNELE1BQU1BLGdCQUFnQnJwRCxPQUFPd0IsTUFBTSxDQUFDLENBQUMsR0FBR2tnQjtnQkFDeEMsTUFBTWhXLFlBQVksTUFBTSxJQUFJLENBQUM2OUMsaUJBQWlCLENBQUNGO2dCQUMvQyxJQUFJRCxpQkFBaUI7Z0JBQ3JCLElBQUkxOUMsU0FBUyxDQUFDLFdBQVcsS0FBS2xOLGFBQzFCa04sU0FBUyxDQUFDLFdBQVcsQ0FBQyxhQUFhLEtBQUtsTixXQUFXO29CQUNuRDRxRCxpQkFBaUIxOUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxhQUFhO2dCQUN4RCxPQUNLLElBQUlBLFNBQVMsQ0FBQyxPQUFPLEtBQUtsTixhQUMzQmtOLFNBQVMsQ0FBQyxPQUFPLENBQUNxRCxRQUFRLENBQUMsaUJBQWlCO29CQUM1Q3E2QyxpQkFBaUIxOUMsU0FBUyxDQUFDLE9BQU8sQ0FBQ3VCLEtBQUssQ0FBQyxlQUFlLENBQUMsRUFBRTtnQkFDL0Q7Z0JBQ0EsTUFBTXU4QyxZQUFZO29CQUNkbmtELE1BQU0rakQ7b0JBQ05sMUMsT0FBT2xSLFNBQVN5bUQsZ0JBQWdCO2dCQUNwQztnQkFDQSxPQUFPRDtZQUNYO1FBQ0o7SUFDSjtJQUNBLE1BQU1ULFlBQVlybkMsTUFBTSxFQUFFO1FBQ3RCLElBQUl0aUIsSUFBSUMsSUFBSXFJLElBQUlDO1FBQ2hCLElBQUlqQztRQUNKLElBQUkrZCxPQUFPO1FBQ1gsSUFBSUMsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDN1csU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCLE1BQU1rWSxPQUFPbWpDLCtCQUErQnBsQztZQUM1QytCLE9BQU9oa0IsVUFBVSxVQUFVa2tCLElBQUksQ0FBQyxPQUFPO1lBQ3ZDRCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDSSxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDbGxCLEtBQUtxaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdEwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2xCLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJLEdBQUdrZCxJQUFJLENBQUMsQ0FBQ1U7b0JBQzdCLE1BQU14ZixXQUFXd2Y7b0JBQ2pCeGYsU0FBU3VjLGVBQWUsR0FBRzt3QkFDdkIvYSxTQUFTdWQsYUFBYXZkLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPOGpDLG9CQUFvQmg5QztnQkFDakMsT0FBT2taO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTWYsT0FBT2tpQyw4QkFBOEJua0M7WUFDM0MrQixPQUFPaGtCLFVBQVUsVUFBVWtrQixJQUFJLENBQUMsT0FBTztZQUN2Q0QsY0FBY0MsSUFBSSxDQUFDLFNBQVM7WUFDNUIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckIsT0FBT0EsSUFBSSxDQUFDLE9BQU87WUFDbkIsT0FBT0EsSUFBSSxDQUFDLFNBQVM7WUFDckJqZSxXQUFXLElBQUksQ0FBQ21ILFNBQVMsQ0FDcEI0VSxPQUFPLENBQUM7Z0JBQ1RnQyxNQUFNQTtnQkFDTkMsYUFBYUE7Z0JBQ2JDLE1BQU1TLEtBQUtDLFNBQVMsQ0FBQ1Y7Z0JBQ3JCVyxZQUFZO2dCQUNadGxCLGFBQWEsQ0FBQzBJLEtBQUtnYSxPQUFPL1csTUFBTSxNQUFNLFFBQVFqRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcxSSxXQUFXO2dCQUNyRnVsQixhQUFhLENBQUM1YyxLQUFLK1osT0FBTy9XLE1BQU0sTUFBTSxRQUFRaEQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHNGMsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUksR0FBR2tkLElBQUksQ0FBQyxDQUFDVTtvQkFDN0IsTUFBTXhmLFdBQVd3ZjtvQkFDakJ4ZixTQUFTdWMsZUFBZSxHQUFHO3dCQUN2Qi9hLFNBQVN1ZCxhQUFhdmQsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU9rakMsbUJBQW1CcDhDO2dCQUNoQyxPQUFPa1o7WUFDWDtRQUNKO0lBQ0o7SUFDQSxNQUFNSyxhQUFhckQsTUFBTSxFQUFFO1FBQ3ZCLElBQUl0aUIsSUFBSUMsSUFBSXFJLElBQUlDO1FBQ2hCLElBQUlqQztRQUNKLElBQUkrZCxPQUFPO1FBQ1gsSUFBSUMsY0FBYyxDQUFDO1FBQ25CLElBQUksSUFBSSxDQUFDN1csU0FBUyxDQUFDcEIsVUFBVSxJQUFJO1lBQzdCLE1BQU1rWSxPQUFPcWpDLGlDQUFpQ3RsQztZQUM5QytCLE9BQU9oa0IsVUFBVSxjQUFja2tCLElBQUksQ0FBQyxPQUFPO1lBQzNDRCxjQUFjQyxJQUFJLENBQUMsU0FBUztZQUM1QixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQixPQUFPQSxJQUFJLENBQUMsT0FBTztZQUNuQixPQUFPQSxJQUFJLENBQUMsU0FBUztZQUNyQmplLFdBQVcsSUFBSSxDQUFDbUgsU0FBUyxDQUNwQjRVLE9BQU8sQ0FBQztnQkFDVGdDLE1BQU1BO2dCQUNOQyxhQUFhQTtnQkFDYkMsTUFBTVMsS0FBS0MsU0FBUyxDQUFDVjtnQkFDckJXLFlBQVk7Z0JBQ1p0bEIsYUFBYSxDQUFDSSxLQUFLc2lCLE9BQU8vVyxNQUFNLE1BQU0sUUFBUXZMLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0osV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDbGxCLEtBQUtxaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdEwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHa2xCLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJLEdBQUdrZCxJQUFJLENBQUMsQ0FBQ1U7b0JBQzdCLE1BQU14ZixXQUFXd2Y7b0JBQ2pCeGYsU0FBU3VjLGVBQWUsR0FBRzt3QkFDdkIvYSxTQUFTdWQsYUFBYXZkLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPbWtDLGlDQUFpQ3I5QztnQkFDOUMsTUFBTTJaLFlBQVksSUFBSXpiO2dCQUN0QjFKLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSixPQUNLO1lBQ0QsTUFBTXhCLE9BQU9vaUMsZ0NBQWdDcmtDO1lBQzdDK0IsT0FBT2hrQixVQUFVLGVBQWVra0IsSUFBSSxDQUFDLE9BQU87WUFDNUNELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUMwSSxLQUFLZ2EsT0FBTy9XLE1BQU0sTUFBTSxRQUFRakQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHMUksV0FBVztnQkFDckZ1bEIsYUFBYSxDQUFDNWMsS0FBSytaLE9BQU8vVyxNQUFNLE1BQU0sUUFBUWhELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzRjLFdBQVc7WUFDekYsR0FDS0MsSUFBSSxDQUFDLENBQUNDO2dCQUNQLE9BQU9BLGFBQWFuZCxJQUFJLEdBQUdrZCxJQUFJLENBQUMsQ0FBQ1U7b0JBQzdCLE1BQU14ZixXQUFXd2Y7b0JBQ2pCeGYsU0FBU3VjLGVBQWUsR0FBRzt3QkFDdkIvYSxTQUFTdWQsYUFBYXZkLE9BQU87b0JBQ2pDO29CQUNBLE9BQU94QjtnQkFDWDtZQUNKO1lBQ0EsT0FBT0EsU0FBUzhlLElBQUksQ0FBQyxDQUFDaFo7Z0JBQ2xCLE1BQU1rWixPQUFPeWpDLGdDQUFnQzM4QztnQkFDN0MsTUFBTTJaLFlBQVksSUFBSXpiO2dCQUN0QjFKLE9BQU93QixNQUFNLENBQUMyakIsV0FBV1Q7Z0JBQ3pCLE9BQU9TO1lBQ1g7UUFDSjtJQUNKO0lBQ0EsTUFBTW1rQyxhQUFhNW5DLE1BQU0sRUFBRTtRQUN2QixJQUFJdGlCLElBQUlDO1FBQ1IsSUFBSXFHO1FBQ0osSUFBSStkLE9BQU87UUFDWCxJQUFJQyxjQUFjLENBQUM7UUFDbkIsSUFBSSxJQUFJLENBQUM3VyxTQUFTLENBQUNwQixVQUFVLElBQUk7WUFDN0IsTUFBTWtZLE9BQU84akMseUNBQXlDL2xDO1lBQ3REK0IsT0FBT2hrQixVQUFVLGNBQWNra0IsSUFBSSxDQUFDLE9BQU87WUFDM0NELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUNJLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVsQixhQUFhLENBQUNsbEIsS0FBS3FpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF0TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbEIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUksR0FBR2tkLElBQUksQ0FBQyxDQUFDVTtvQkFDN0IsTUFBTXhmLFdBQVd3ZjtvQkFDakJ4ZixTQUFTdWMsZUFBZSxHQUFHO3dCQUN2Qi9hLFNBQVN1ZCxhQUFhdmQsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU84akMsb0JBQW9CaDlDO2dCQUNqQyxPQUFPa1o7WUFDWDtRQUNKLE9BQ0s7WUFDRCxNQUFNLElBQUlwa0IsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsTUFBTWlwRCxrQkFBa0I3bkMsTUFBTSxFQUFFO1FBQzVCLElBQUl0aUIsSUFBSUM7UUFDUixJQUFJcUc7UUFDSixJQUFJK2QsT0FBTztRQUNYLElBQUlDLGNBQWMsQ0FBQztRQUNuQixJQUFJLElBQUksQ0FBQzdXLFNBQVMsQ0FBQ3BCLFVBQVUsSUFBSTtZQUM3QixNQUFNLElBQUluTCxNQUFNO1FBQ3BCLE9BQ0s7WUFDRCxNQUFNcWpCLE9BQU9nakMsd0NBQXdDamxDO1lBQ3JEK0IsT0FBT2hrQixVQUFVLGVBQWVra0IsSUFBSSxDQUFDLE9BQU87WUFDNUNELGNBQWNDLElBQUksQ0FBQyxTQUFTO1lBQzVCLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCLE9BQU9BLElBQUksQ0FBQyxPQUFPO1lBQ25CLE9BQU9BLElBQUksQ0FBQyxTQUFTO1lBQ3JCamUsV0FBVyxJQUFJLENBQUNtSCxTQUFTLENBQ3BCNFUsT0FBTyxDQUFDO2dCQUNUZ0MsTUFBTUE7Z0JBQ05DLGFBQWFBO2dCQUNiQyxNQUFNUyxLQUFLQyxTQUFTLENBQUNWO2dCQUNyQlcsWUFBWTtnQkFDWnRsQixhQUFhLENBQUNJLEtBQUtzaUIsT0FBTy9XLE1BQU0sTUFBTSxRQUFRdkwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSixXQUFXO2dCQUNyRnVsQixhQUFhLENBQUNsbEIsS0FBS3FpQixPQUFPL1csTUFBTSxNQUFNLFFBQVF0TCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrbEIsV0FBVztZQUN6RixHQUNLQyxJQUFJLENBQUMsQ0FBQ0M7Z0JBQ1AsT0FBT0EsYUFBYW5kLElBQUksR0FBR2tkLElBQUksQ0FBQyxDQUFDVTtvQkFDN0IsTUFBTXhmLFdBQVd3ZjtvQkFDakJ4ZixTQUFTdWMsZUFBZSxHQUFHO3dCQUN2Qi9hLFNBQVN1ZCxhQUFhdmQsT0FBTztvQkFDakM7b0JBQ0EsT0FBT3hCO2dCQUNYO1lBQ0o7WUFDQSxPQUFPQSxTQUFTOGUsSUFBSSxDQUFDLENBQUNoWjtnQkFDbEIsTUFBTWtaLE9BQU8yakMseUJBQXlCNzhDO2dCQUN0QyxPQUFPa1o7WUFDWDtRQUNKO0lBQ0o7QUFDSjtBQUVBLE1BQU1nbEMsaUJBQWlCLE9BQU8sT0FBTyxHQUFHLFFBQVE7QUFDaEQsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLHlCQUF5QjtBQUMvQixNQUFNQyxtQkFBbUI7QUFDekIsTUFBTUMsb0NBQW9DO0FBQzFDLGVBQWVDLFdBQVdwNUIsSUFBSSxFQUFFcWpCLFNBQVMsRUFBRW5uQyxTQUFTO0lBQ2hELElBQUl6TixJQUFJQyxJQUFJcUk7SUFDWixJQUFJc2lELFdBQVc7SUFDZixJQUFJQyxTQUFTO0lBQ2IsSUFBSXZrRCxXQUFXLElBQUlzQixhQUFhLElBQUkrckM7SUFDcEMsSUFBSW1YLGdCQUFnQjtJQUNwQkYsV0FBV3I1QixLQUFLb2pCLElBQUk7SUFDcEIsTUFBT2tXLFNBQVNELFNBQVU7UUFDdEIsTUFBTUcsWUFBWTdXLEtBQUs4VyxHQUFHLENBQUNWLGdCQUFnQk0sV0FBV0M7UUFDdEQsTUFBTXQ3QixRQUFRZ0MsS0FBSzd2QixLQUFLLENBQUNtcEQsUUFBUUEsU0FBU0U7UUFDMUMsSUFBSUYsU0FBU0UsYUFBYUgsVUFBVTtZQUNoQ0UsaUJBQWlCO1FBQ3JCO1FBQ0EsSUFBSUcsYUFBYTtRQUNqQixJQUFJQyxpQkFBaUJWO1FBQ3JCLE1BQU9TLGFBQWFWLGdCQUFpQjtZQUNqQ2prRCxXQUFXLE1BQU1tSCxVQUFVNFUsT0FBTyxDQUFDO2dCQUMvQmdDLE1BQU07Z0JBQ05FLE1BQU1nTDtnQkFDTnJLLFlBQVk7Z0JBQ1p0bEIsYUFBYTtvQkFDVDh2QyxZQUFZO29CQUNaeHZDLFNBQVMwMEM7b0JBQ1Q5c0MsU0FBUzt3QkFDTCx5QkFBeUJnakQ7d0JBQ3pCLHdCQUF3QjdwRCxPQUFPNHBEO3dCQUMvQixrQkFBa0I1cEQsT0FBTzhwRDtvQkFDN0I7Z0JBQ0o7WUFDSjtZQUNBLElBQUksQ0FBQy9xRCxLQUFLc0csYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN3QixPQUFPLE1BQU0sUUFBUTlILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDMHFELGtDQUFrQyxFQUFFO2dCQUN4SjtZQUNKO1lBQ0FPO1lBQ0EsTUFBTUUsTUFBTUQ7WUFDWkEsaUJBQWlCQSxpQkFBaUJUO1FBQ3RDO1FBQ0FJLFVBQVVFO1FBQ1YsdUVBQXVFO1FBQ3ZFLDBCQUEwQjtRQUMxQixJQUFJLENBQUMsQ0FBQzlxRCxLQUFLcUcsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN3QixPQUFPLE1BQU0sUUFBUTdILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDeXFELGtDQUFrQyxNQUFNLFVBQVU7WUFDdks7UUFDSjtRQUNBLHVFQUF1RTtRQUN2RSw2Q0FBNkM7UUFDN0MsSUFBSUUsWUFBWUMsUUFBUTtZQUNwQixNQUFNLElBQUkzcEQsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsTUFBTWtxRCxlQUFnQixNQUFPOWtELENBQUFBLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTNEIsSUFBSSxFQUFDO0lBQy9GLElBQUksQ0FBQyxDQUFDSSxLQUFLaEMsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVN3QixPQUFPLE1BQU0sUUFBUVEsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUNvaUQsa0NBQWtDLE1BQU0sU0FBUztRQUN0SyxNQUFNLElBQUl4cEQsTUFBTTtJQUNwQjtJQUNBLE9BQU9rcUQsWUFBWSxDQUFDLE9BQU87QUFDL0I7QUFDQSxlQUFlQyxZQUFZOTVCLElBQUk7SUFDM0IsTUFBTWlqQixXQUFXO1FBQUVHLE1BQU1wakIsS0FBS29qQixJQUFJO1FBQUU5a0MsTUFBTTBoQixLQUFLMWhCLElBQUk7SUFBQztJQUNwRCxPQUFPMmtDO0FBQ1g7QUFDQSxTQUFTMlcsTUFBTUcsRUFBRTtJQUNiLE9BQU8sSUFBSXAvQixRQUFRLENBQUNxL0IsaUJBQW1CdFosV0FBV3NaLGdCQUFnQkQ7QUFDdEU7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUU7SUFDRixNQUFNL1csS0FBS2xqQixJQUFJLEVBQUU7UUFDYixNQUFNaWpCLFdBQVc7WUFBRUcsTUFBTTtZQUFHOWtDLE1BQU16UTtRQUFVO1FBQzVDLElBQUksT0FBT215QixTQUFTLFVBQVU7WUFDMUIsTUFBTWs2QixlQUFlLE1BQU12c0QsNkNBQU8sQ0FBQ3F5QjtZQUNuQ2lqQixTQUFTRyxJQUFJLEdBQUc4VyxhQUFhOVcsSUFBSTtZQUNqQ0gsU0FBUzNrQyxJQUFJLEdBQUcsSUFBSSxDQUFDNjdDLGFBQWEsQ0FBQ242QjtZQUNuQyxPQUFPaWpCO1FBQ1gsT0FDSztZQUNELE9BQU8sTUFBTTZXLFlBQVk5NUI7UUFDN0I7SUFDSjtJQUNBLE1BQU1GLE9BQU9FLElBQUksRUFBRXFqQixTQUFTLEVBQUVubkMsU0FBUyxFQUFFO1FBQ3JDLElBQUksT0FBTzhqQixTQUFTLFVBQVU7WUFDMUIsT0FBTyxNQUFNLElBQUksQ0FBQ282QixrQkFBa0IsQ0FBQ3A2QixNQUFNcWpCLFdBQVdubkM7UUFDMUQsT0FDSztZQUNELE9BQU9rOUMsV0FBV3A1QixNQUFNcWpCLFdBQVdubkM7UUFDdkM7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0RpK0MsY0FBY0UsUUFBUSxFQUFFO1FBQ3BCLDBCQUEwQjtRQUMxQixNQUFNQyxnQkFBZ0JELFNBQVNscUQsS0FBSyxDQUFDa3FELFNBQVNFLFdBQVcsQ0FBQyxPQUFPO1FBQ2pFLGlEQUFpRDtRQUNqRCxNQUFNQyxZQUFZO1lBQ2QsT0FBTztZQUNQLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLE1BQU07WUFDTixPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLFFBQVE7WUFDUixPQUFPO1lBQ1AsUUFBUTtZQUNSLE1BQU07WUFDTixPQUFPO1lBQ1AsT0FBTztZQUNQLFFBQVE7WUFDUixPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87WUFDUCxRQUFRO1lBQ1IsT0FBTztZQUNQLE1BQU07WUFDTixRQUFRO1lBQ1IsVUFBVTtZQUNWLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87WUFDUCxPQUFPO1lBQ1AsUUFBUTtZQUNSLFFBQVE7WUFDUixPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87WUFDUCxPQUFPO1lBQ1AsUUFBUTtZQUNSLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87WUFDUCxPQUFPO1lBQ1AsUUFBUTtZQUNSLE9BQU87WUFDUCxPQUFPO1lBQ1AsTUFBTTtZQUNOLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87WUFDUCxRQUFRO1lBQ1IsTUFBTTtZQUNOLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87WUFDUCxRQUFRO1lBQ1IsUUFBUTtZQUNSLFFBQVE7WUFDUixRQUFRO1lBQ1IsU0FBUztZQUNULFNBQVM7WUFDVCxPQUFPO1lBQ1AsUUFBUTtZQUNSLE9BQU87WUFDUCxPQUFPO1lBQ1AsT0FBTztZQUNQLE9BQU87WUFDUCxPQUFPO1lBQ1AsTUFBTTtRQUNWO1FBQ0EscURBQXFEO1FBQ3JELE1BQU1wbUQsV0FBV29tRCxTQUFTLENBQUNGLGNBQWNHLFdBQVcsR0FBRztRQUN2RCx3QkFBd0I7UUFDeEIsT0FBT3JtRDtJQUNYO0lBQ0EsTUFBTWdtRCxtQkFBbUJwNkIsSUFBSSxFQUFFcWpCLFNBQVMsRUFBRW5uQyxTQUFTLEVBQUU7UUFDakQsSUFBSXpOLElBQUlDLElBQUlxSTtRQUNaLElBQUlzaUQsV0FBVztRQUNmLElBQUlDLFNBQVM7UUFDYixJQUFJdmtELFdBQVcsSUFBSXNCLGFBQWEsSUFBSStyQztRQUNwQyxJQUFJbVgsZ0JBQWdCO1FBQ3BCLElBQUltQjtRQUNKLElBQUk7WUFDQUEsYUFBYSxNQUFNL3NELDZDQUFPLENBQUNxeUIsTUFBTTtZQUNqQyxJQUFJLENBQUMwNkIsWUFBWTtnQkFDYixNQUFNLElBQUkvcUQsTUFBTSxDQUFDLG1CQUFtQixDQUFDO1lBQ3pDO1lBQ0EwcEQsV0FBVyxDQUFDLE1BQU1xQixXQUFXeFgsSUFBSSxFQUFDLEVBQUdFLElBQUk7WUFDekMsTUFBT2tXLFNBQVNELFNBQVU7Z0JBQ3RCLE1BQU1HLFlBQVk3VyxLQUFLOFcsR0FBRyxDQUFDVixnQkFBZ0JNLFdBQVdDO2dCQUN0RCxJQUFJQSxTQUFTRSxhQUFhSCxVQUFVO29CQUNoQ0UsaUJBQWlCO2dCQUNyQjtnQkFDQSxNQUFNL1gsU0FBUyxJQUFJb1osV0FBV3BCO2dCQUM5QixNQUFNLEVBQUVxQixXQUFXQSxTQUFTLEVBQUUsR0FBRyxNQUFNSCxXQUFXalosSUFBSSxDQUFDRCxRQUFRLEdBQUdnWSxXQUFXRjtnQkFDN0UsSUFBSXVCLGNBQWNyQixXQUFXO29CQUN6QixNQUFNLElBQUk3cEQsTUFBTSxDQUFDLGVBQWUsRUFBRTZwRCxVQUFVLDJCQUEyQixFQUFFRixPQUFPLHVCQUF1QixFQUFFdUIsVUFBVSxDQUFDO2dCQUN4SDtnQkFDQSxNQUFNNzhCLFFBQVEsSUFBSTBsQixLQUFLO29CQUFDbEM7aUJBQU87Z0JBQy9CLElBQUlrWSxhQUFhO2dCQUNqQixJQUFJQyxpQkFBaUJWO2dCQUNyQixNQUFPUyxhQUFhVixnQkFBaUI7b0JBQ2pDamtELFdBQVcsTUFBTW1ILFVBQVU0VSxPQUFPLENBQUM7d0JBQy9CZ0MsTUFBTTt3QkFDTkUsTUFBTWdMO3dCQUNOckssWUFBWTt3QkFDWnRsQixhQUFhOzRCQUNUOHZDLFlBQVk7NEJBQ1p4dkMsU0FBUzAwQzs0QkFDVDlzQyxTQUFTO2dDQUNMLHlCQUF5QmdqRDtnQ0FDekIsd0JBQXdCN3BELE9BQU80cEQ7Z0NBQy9CLGtCQUFrQjVwRCxPQUFPbXJEOzRCQUM3Qjt3QkFDSjtvQkFDSjtvQkFDQSxJQUFJLENBQUNwc0QsS0FBS3NHLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTd0IsT0FBTyxNQUFNLFFBQVE5SCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQzBxRCxrQ0FBa0MsRUFBRTt3QkFDeEo7b0JBQ0o7b0JBQ0FPO29CQUNBLE1BQU1FLE1BQU1EO29CQUNaQSxpQkFBaUJBLGlCQUFpQlQ7Z0JBQ3RDO2dCQUNBSSxVQUFVdUI7Z0JBQ1YsdUVBQXVFO2dCQUN2RSwwQkFBMEI7Z0JBQzFCLElBQUksQ0FBQyxDQUFDbnNELEtBQUtxRyxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU3dCLE9BQU8sTUFBTSxRQUFRN0gsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxFQUFFLENBQUN5cUQsa0NBQWtDLE1BQU0sVUFBVTtvQkFDdks7Z0JBQ0o7Z0JBQ0EsSUFBSUUsWUFBWUMsUUFBUTtvQkFDcEIsTUFBTSxJQUFJM3BELE1BQU07Z0JBQ3BCO1lBQ0o7WUFDQSxNQUFNa3FELGVBQWdCLE1BQU85a0QsQ0FBQUEsYUFBYSxRQUFRQSxhQUFhLEtBQUssSUFBSSxLQUFLLElBQUlBLFNBQVM0QixJQUFJLEVBQUM7WUFDL0YsSUFBSSxDQUFDLENBQUNJLEtBQUtoQyxhQUFhLFFBQVFBLGFBQWEsS0FBSyxJQUFJLEtBQUssSUFBSUEsU0FBU3dCLE9BQU8sTUFBTSxRQUFRUSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQ29pRCxrQ0FBa0MsTUFBTSxTQUFTO2dCQUN0SyxNQUFNLElBQUl4cEQsTUFBTTtZQUNwQjtZQUNBLE9BQU9rcUQsWUFBWSxDQUFDLE9BQU87UUFDL0IsU0FDUTtZQUNKLDBDQUEwQztZQUMxQyxJQUFJYSxZQUFZO2dCQUNaLE1BQU1BLFdBQVdqUyxLQUFLO1lBQzFCO1FBQ0o7SUFDSjtBQUNKO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1xUyx3QkFBd0I7QUFDOUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXVDQyxHQUNELE1BQU1DO0lBQ0Z6a0QsWUFBWWdvQixPQUFPLENBQUU7UUFDakIsSUFBSTd2QixJQUFJQyxJQUFJcUksSUFBSUMsSUFBSUMsSUFBSUM7UUFDeEIsOENBQThDO1FBQzlDLElBQUksQ0FBQ29uQixRQUFReWYsT0FBTyxJQUFJemYsUUFBUTBmLFFBQVEsS0FBSzFmLFFBQVEyZixNQUFNLEVBQUU7WUFDekQsTUFBTSxJQUFJdHVDLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUNyQixRQUFRLEdBQ1QsQ0FBQ0ksS0FBSyxDQUFDRCxLQUFLNnZCLFFBQVFod0IsUUFBUSxNQUFNLFFBQVFHLE9BQU8sS0FBSyxJQUFJQSxLQUFLdXNELGNBQWMsNEJBQTJCLE1BQU8sUUFBUXRzRCxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUNoSixNQUFNdXNELFlBQVlDO1FBQ2xCLE1BQU1DLGFBQWFDLE9BQU87UUFDMUIsTUFBTUMsY0FBY0QsT0FBTztRQUMzQixJQUFJLENBQUNuZCxNQUFNLEdBQUcsQ0FBQ2xuQyxLQUFLdW5CLFFBQVEyZixNQUFNLE1BQU0sUUFBUWxuQyxPQUFPLEtBQUssSUFBSUEsS0FBS2trRDtRQUNyRSxJQUFJLENBQUNsZCxPQUFPLEdBQUcsQ0FBQy9tQyxLQUFLc25CLFFBQVF5ZixPQUFPLE1BQU0sUUFBUS9tQyxPQUFPLEtBQUssSUFBSUEsS0FBS21rRDtRQUN2RSxJQUFJLENBQUNuZCxRQUFRLEdBQUcsQ0FBQy9tQyxLQUFLcW5CLFFBQVEwZixRQUFRLE1BQU0sUUFBUS9tQyxPQUFPLEtBQUssSUFBSUEsS0FBS29rRDtRQUN6RSx5REFBeUQ7UUFDekQsSUFBSS84QixRQUFRaHdCLFFBQVEsRUFBRTtZQUNsQixJQUFJLENBQUM0SSxLQUFLb25CLFFBQVEwMUIsaUJBQWlCLE1BQU0sUUFBUTk4QyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdva0QsV0FBVyxFQUFFO2dCQUN0Riw4REFBOEQ7Z0JBQzlEL2pELFFBQVFna0QsS0FBSyxDQUFDLG9FQUNWO2dCQUNKLElBQUksQ0FBQ3RkLE1BQU0sR0FBR3B3QztZQUNsQjtZQUNBLHdFQUF3RTtZQUN4RSxJQUFJLENBQUNzdEQsY0FBY0UsV0FBVSxLQUFNLzhCLFFBQVEyZixNQUFNLEVBQUU7Z0JBQy9DLG9FQUFvRTtnQkFDcEUxbUMsUUFBUWdrRCxLQUFLLENBQUMsa0VBQ1Y7Z0JBQ0osSUFBSSxDQUFDeGQsT0FBTyxHQUFHbHdDO2dCQUNmLElBQUksQ0FBQ213QyxRQUFRLEdBQUdud0M7WUFDcEIsT0FDSyxJQUFJLENBQUN5d0IsUUFBUXlmLE9BQU8sSUFBSXpmLFFBQVEwZixRQUFRLEtBQUtpZCxXQUFXO2dCQUN6RCxvRUFBb0U7Z0JBQ3BFMWpELFFBQVFna0QsS0FBSyxDQUFDLGlFQUNWO2dCQUNKLElBQUksQ0FBQ3RkLE1BQU0sR0FBR3B3QztZQUNsQixPQUNLLElBQUksQ0FBQ3N0RCxjQUFjRSxXQUFVLEtBQU1KLFdBQVc7Z0JBQy9DLG9FQUFvRTtnQkFDcEUxakQsUUFBUWdrRCxLQUFLLENBQUMsa0VBQ1Y7Z0JBQ0osSUFBSSxDQUFDdGQsTUFBTSxHQUFHcHdDO1lBQ2xCO1FBQ0o7UUFDQSxNQUFNYyxVQUFVUCxXQUFXa3dCLFFBQVFqd0IsV0FBVyxFQUFFaXdCLFFBQVFod0IsUUFBUSxFQUFFOHNELE9BQU8sMkJBQTJCQSxPQUFPO1FBQzNHLElBQUl6c0QsU0FBUztZQUNULElBQUkydkIsUUFBUWp3QixXQUFXLEVBQUU7Z0JBQ3JCaXdCLFFBQVFqd0IsV0FBVyxDQUFDTSxPQUFPLEdBQUdBO1lBQ2xDLE9BQ0s7Z0JBQ0QydkIsUUFBUWp3QixXQUFXLEdBQUc7b0JBQUVNLFNBQVNBO2dCQUFRO1lBQzdDO1FBQ0o7UUFDQSxJQUFJLENBQUN3dkMsVUFBVSxHQUFHN2YsUUFBUTZmLFVBQVU7UUFDcEMsTUFBTTBFLE9BQU8sSUFBSWdSLFNBQVM7WUFDdEI1VixRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQitWLG1CQUFtQjExQixRQUFRMDFCLGlCQUFpQjtRQUNoRDtRQUNBLElBQUksQ0FBQzkzQyxTQUFTLEdBQUcsSUFBSTBoQyxVQUFVO1lBQzNCaUYsTUFBTUE7WUFDTjlFLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCQyxVQUFVLElBQUksQ0FBQ0EsUUFBUTtZQUN2QkcsWUFBWSxJQUFJLENBQUNBLFVBQVU7WUFDM0JGLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CM3ZDLFVBQVUsSUFBSSxDQUFDQSxRQUFRO1lBQ3ZCRCxhQUFhaXdCLFFBQVFqd0IsV0FBVztZQUNoQ28wQyxnQkFBZ0JxWSx3QkFBd0JVLFFBQVFDLE9BQU87WUFDdkR6WSxVQUFVLElBQUlpWDtZQUNkMVcsWUFBWSxJQUFJaVI7UUFDcEI7UUFDQSxJQUFJLENBQUMvRixNQUFNLEdBQUcsSUFBSXBELE9BQU8sSUFBSSxDQUFDbnZDLFNBQVM7UUFDdkMsSUFBSSxDQUFDdy9DLElBQUksR0FBRyxJQUFJMVMsS0FBSyxJQUFJLENBQUM5c0MsU0FBUyxFQUFFMm1DLE1BQU0sSUFBSWlTO1FBQy9DLElBQUksQ0FBQzZHLE9BQU8sR0FBRyxJQUFJcnBDLFFBQVEsSUFBSSxDQUFDcFcsU0FBUztRQUN6QyxJQUFJLENBQUMwL0MsS0FBSyxHQUFHLElBQUl2L0IsTUFBTSxJQUFJLENBQUNveUIsTUFBTSxFQUFFLElBQUksQ0FBQ3Z5QyxTQUFTO1FBQ2xELElBQUksQ0FBQzIvQyxNQUFNLEdBQUcsSUFBSXZpQyxPQUFPLElBQUksQ0FBQ3BkLFNBQVM7UUFDdkMsSUFBSSxDQUFDNC9DLEtBQUssR0FBRyxJQUFJbDhCLE1BQU0sSUFBSSxDQUFDMWpCLFNBQVM7UUFDckMsSUFBSSxDQUFDNi9DLFVBQVUsR0FBRyxJQUFJNUwsV0FBVyxJQUFJLENBQUNqMEMsU0FBUztRQUMvQyxJQUFJLENBQUM4L0MsVUFBVSxHQUFHLElBQUl2SSxPQUFPLElBQUksQ0FBQ3YzQyxTQUFTO1FBQzNDLElBQUksQ0FBQysvQyxPQUFPLEdBQUcsSUFBSTlELFFBQVEsSUFBSSxDQUFDajhDLFNBQVM7SUFDN0M7QUFDSjtBQUNBLFNBQVNrL0MsT0FBT2MsR0FBRztJQUNmLElBQUl6dEQsSUFBSUMsSUFBSXFJO0lBQ1osT0FBTyxDQUFDQSxLQUFLLENBQUNySSxLQUFLLENBQUNELEtBQUsrc0QsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFVLEdBQUcsTUFBTSxRQUFRenRELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDeXRELElBQUksTUFBTSxRQUFReHRELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2d6QyxJQUFJLEVBQUMsTUFBTyxRQUFRM3FDLE9BQU8sS0FBSyxJQUFJQSxLQUFLbEo7QUFDM047QUFDQSxTQUFTbXRELGNBQWNrQixHQUFHO0lBQ3RCLE9BQU9DLGdCQUFnQmYsT0FBT2M7QUFDbEM7QUFDQSxTQUFTQyxnQkFBZ0JDLEdBQUc7SUFDeEIsSUFBSUEsUUFBUXZ1RCxXQUFXO1FBQ25CLE9BQU87SUFDWDtJQUNBLE9BQU91dUQsSUFBSTNCLFdBQVcsT0FBTztBQUNqQztBQUNBLFNBQVNTO0lBQ0wsTUFBTW1CLGtCQUFrQmpCLE9BQU87SUFDL0IsTUFBTWtCLGtCQUFrQmxCLE9BQU87SUFDL0IsSUFBSWlCLG1CQUFtQkMsaUJBQWlCO1FBQ3BDL2tELFFBQVFDLElBQUksQ0FBQztJQUNqQjtJQUNBLE9BQU82a0QsbUJBQW1CQztBQUM5QjtBQUVrM0QsQ0FDbDNELGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2lzdHJhci1jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2VuYWkvZGlzdC9ub2RlL2luZGV4Lm1qcz8yZDc4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdvb2dsZUF1dGggfSBmcm9tICdnb29nbGUtYXV0aC1saWJyYXJ5JztcbmltcG9ydCB7IGNyZWF0ZVdyaXRlU3RyZWFtLCB3cml0ZUZpbGUgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJ25vZGU6c3RyZWFtJztcbmltcG9ydCAqIGFzIE5vZGVXcyBmcm9tICd3cyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy9wcm9taXNlcyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmxldCBfZGVmYXVsdEJhc2VHZW1pbmlVcmwgPSB1bmRlZmluZWQ7XG5sZXQgX2RlZmF1bHRCYXNlVmVydGV4VXJsID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBPdmVycmlkZXMgdGhlIGJhc2UgVVJMcyBmb3IgdGhlIEdlbWluaSBBUEkgYW5kIFZlcnRleCBBSSBBUEkuXG4gKlxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBpbml0aWFsaXppbmcgdGhlIFNESy4gSWYgdGhlXG4gKiBiYXNlIFVSTHMgYXJlIHNldCBhZnRlciBpbml0aWFsaXppbmcgdGhlIFNESywgdGhlIGJhc2UgVVJMcyB3aWxsIG5vdCBiZVxuICogdXBkYXRlZC4gQmFzZSBVUkxzIHByb3ZpZGVkIGluIHRoZSBIdHRwT3B0aW9ucyB3aWxsIGFsc28gdGFrZSBwcmVjZWRlbmNlIG92ZXJcbiAqIFVSTHMgc2V0IGhlcmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJLCBzZXREZWZhdWx0QmFzZVVybHN9IGZyb20gJ0Bnb29nbGUvZ2VuYWknO1xuICogLy8gT3ZlcnJpZGUgdGhlIGJhc2UgVVJMIGZvciB0aGUgR2VtaW5pIEFQSS5cbiAqIHNldERlZmF1bHRCYXNlVXJscyh7Z2VtaW5pVXJsOidodHRwczovL2dlbWluaS5nb29nbGUuY29tJ30pO1xuICpcbiAqIC8vIE92ZXJyaWRlIHRoZSBiYXNlIFVSTCBmb3IgdGhlIFZlcnRleCBBSSBBUEkuXG4gKiBzZXREZWZhdWx0QmFzZVVybHMoe3ZlcnRleFVybDogJ2h0dHBzOi8vdmVydGV4YWkuZ29vZ2xlYXBpcy5jb20nfSk7XG4gKlxuICogY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe2FwaUtleTogJ0dFTUlOSV9BUElfS0VZJ30pO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHNldERlZmF1bHRCYXNlVXJscyhiYXNlVXJsUGFyYW1zKSB7XG4gICAgX2RlZmF1bHRCYXNlR2VtaW5pVXJsID0gYmFzZVVybFBhcmFtcy5nZW1pbmlVcmw7XG4gICAgX2RlZmF1bHRCYXNlVmVydGV4VXJsID0gYmFzZVVybFBhcmFtcy52ZXJ0ZXhVcmw7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgYmFzZSBVUkxzIGZvciB0aGUgR2VtaW5pIEFQSSBhbmQgVmVydGV4IEFJIEFQSS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEJhc2VVcmxzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdlbWluaVVybDogX2RlZmF1bHRCYXNlR2VtaW5pVXJsLFxuICAgICAgICB2ZXJ0ZXhVcmw6IF9kZWZhdWx0QmFzZVZlcnRleFVybCxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGJhc2UgVVJMIGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgcHJpb3JpdHk6XG4gKiAgIDEuIEJhc2UgVVJMcyBzZXQgdmlhIEh0dHBPcHRpb25zLlxuICogICAyLiBCYXNlIFVSTHMgc2V0IHZpYSB0aGUgbGF0ZXN0IGNhbGwgdG8gc2V0RGVmYXVsdEJhc2VVcmxzLlxuICogICAzLiBCYXNlIFVSTHMgc2V0IHZpYSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEJhc2VVcmwoaHR0cE9wdGlvbnMsIHZlcnRleGFpLCB2ZXJ0ZXhCYXNlVXJsRnJvbUVudiwgZ2VtaW5pQmFzZVVybEZyb21FbnYpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghKGh0dHBPcHRpb25zID09PSBudWxsIHx8IGh0dHBPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwT3B0aW9ucy5iYXNlVXJsKSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0QmFzZVVybHMgPSBnZXREZWZhdWx0QmFzZVVybHMoKTtcbiAgICAgICAgaWYgKHZlcnRleGFpKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gZGVmYXVsdEJhc2VVcmxzLnZlcnRleFVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmVydGV4QmFzZVVybEZyb21FbnY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKF9iID0gZGVmYXVsdEJhc2VVcmxzLmdlbWluaVVybCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZ2VtaW5pQmFzZVVybEZyb21FbnY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0dHBPcHRpb25zLmJhc2VVcmw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIEJhc2VNb2R1bGUge1xufVxuZnVuY3Rpb24gZm9ybWF0TWFwKHRlbXBsYXRlU3RyaW5nLCB2YWx1ZU1hcCkge1xuICAgIC8vIFVzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaW5kIGFsbCBwbGFjZWhvbGRlcnMgaW4gdGhlIHRlbXBsYXRlIHN0cmluZ1xuICAgIGNvbnN0IHJlZ2V4ID0gL1xceyhbXn1dKylcXH0vZztcbiAgICAvLyBSZXBsYWNlIGVhY2ggcGxhY2Vob2xkZXIgd2l0aCBpdHMgY29ycmVzcG9uZGluZyB2YWx1ZSBmcm9tIHRoZSB2YWx1ZU1hcFxuICAgIHJldHVybiB0ZW1wbGF0ZVN0cmluZy5yZXBsYWNlKHJlZ2V4LCAobWF0Y2gsIGtleSkgPT4ge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlTWFwLCBrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlTWFwW2tleV07XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byBhIHN0cmluZyBpZiBpdCdzIG5vdCBhIHN0cmluZyBhbHJlYWR5XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtaXNzaW5nIGtleXNcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICcke2tleX0nIG5vdCBmb3VuZCBpbiB2YWx1ZU1hcC5gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFsdWVCeVBhdGgoZGF0YSwga2V5cywgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChrZXkuZW5kc1dpdGgoJ1tdJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgaWYgKCEoa2V5TmFtZSBpbiBkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2tleU5hbWVdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdmFsdWUubGVuZ3RoIH0sICgpID0+ICh7fSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBtdXN0IGJlIGEgbGlzdCBnaXZlbiBhbiBhcnJheSBwYXRoICR7a2V5fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5TmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gZGF0YVtrZXlOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhcnJheURhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gYXJyYXlEYXRhW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoZW50cnksIGtleXMuc2xpY2UoaSArIDEpLCB2YWx1ZVtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZCBvZiBhcnJheURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKGQsIGtleXMuc2xpY2UoaSArIDEpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5LmVuZHNXaXRoKCdbMF0nKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5zbGljZSgwLCAtMyk7XG4gICAgICAgICAgICBpZiAoIShrZXlOYW1lIGluIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtrZXlOYW1lXSA9IFt7fV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcnJheURhdGEgPSBkYXRhW2tleU5hbWVdO1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoYXJyYXlEYXRhWzBdLCBrZXlzLnNsaWNlKGkgKyAxKSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YVtrZXldIHx8IHR5cGVvZiBkYXRhW2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gZGF0YVtrZXldO1xuICAgIH1cbiAgICBjb25zdCBrZXlUb1NldCA9IGtleXNba2V5cy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBleGlzdGluZ0RhdGEgPSBkYXRhW2tleVRvU2V0XTtcbiAgICBpZiAoZXhpc3RpbmdEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IGV4aXN0aW5nRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXhpc3RpbmdEYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZXhpc3RpbmdEYXRhICE9PSBudWxsICYmXG4gICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihleGlzdGluZ0RhdGEsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNldCB2YWx1ZSBmb3IgYW4gZXhpc3Rpbmcga2V5LiBLZXk6ICR7a2V5VG9TZXR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGFba2V5VG9TZXRdID0gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VmFsdWVCeVBhdGgoZGF0YSwga2V5cykge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnX3NlbGYnKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKGtleS5lbmRzV2l0aCgnW10nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlOYW1lIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gZGF0YVtrZXlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5RGF0YS5tYXAoKGQpID0+IGdldFZhbHVlQnlQYXRoKGQsIGtleXMuc2xpY2UoaSArIDEpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiB0Qnl0ZXMkMShmcm9tQnl0ZXMpIHtcbiAgICBpZiAodHlwZW9mIGZyb21CeXRlcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tSW1hZ2VCeXRlcyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIC8vIFRPRE8oYi8zODkxMzM5MTQpOiBSZW1vdmUgZHVtbXkgYnl0ZXMgY29udmVydGVyLlxuICAgIHJldHVybiBmcm9tQnl0ZXM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG4vKiogUmVxdWlyZWQuIE91dGNvbWUgb2YgdGhlIGNvZGUgZXhlY3V0aW9uLiAqL1xudmFyIE91dGNvbWU7XG4oZnVuY3Rpb24gKE91dGNvbWUpIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCBzdGF0dXMuIFRoaXMgdmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX1VOU1BFQ0lGSUVEXCJdID0gXCJPVVRDT01FX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQ29kZSBleGVjdXRpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9PS1wiXSA9IFwiT1VUQ09NRV9PS1wiO1xuICAgIC8qKlxuICAgICAqIENvZGUgZXhlY3V0aW9uIGZpbmlzaGVkIGJ1dCB3aXRoIGEgZmFpbHVyZS4gYHN0ZGVycmAgc2hvdWxkIGNvbnRhaW4gdGhlIHJlYXNvbi5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9GQUlMRURcIl0gPSBcIk9VVENPTUVfRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogQ29kZSBleGVjdXRpb24gcmFuIGZvciB0b28gbG9uZywgYW5kIHdhcyBjYW5jZWxsZWQuIFRoZXJlIG1heSBvciBtYXkgbm90IGJlIGEgcGFydGlhbCBvdXRwdXQgcHJlc2VudC5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9ERUFETElORV9FWENFRURFRFwiXSA9IFwiT1VUQ09NRV9ERUFETElORV9FWENFRURFRFwiO1xufSkoT3V0Y29tZSB8fCAoT3V0Y29tZSA9IHt9KSk7XG4vKiogUmVxdWlyZWQuIFByb2dyYW1taW5nIGxhbmd1YWdlIG9mIHRoZSBgY29kZWAuICovXG52YXIgTGFuZ3VhZ2U7XG4oZnVuY3Rpb24gKExhbmd1YWdlKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgbGFuZ3VhZ2UuIFRoaXMgdmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIExhbmd1YWdlW1wiTEFOR1VBR0VfVU5TUEVDSUZJRURcIl0gPSBcIkxBTkdVQUdFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUHl0aG9uID49IDMuMTAsIHdpdGggbnVtcHkgYW5kIHNpbXB5IGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBMYW5ndWFnZVtcIlBZVEhPTlwiXSA9IFwiUFlUSE9OXCI7XG59KShMYW5ndWFnZSB8fCAoTGFuZ3VhZ2UgPSB7fSkpO1xuLyoqIE9wdGlvbmFsLiBUaGUgdHlwZSBvZiB0aGUgZGF0YS4gKi9cbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgLyoqXG4gICAgICogTm90IHNwZWNpZmllZCwgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIFR5cGVbXCJUWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBzdHJpbmcgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJTVFJJTkdcIl0gPSBcIlNUUklOR1wiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgbnVtYmVyIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiTlVNQkVSXCJdID0gXCJOVU1CRVJcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIGludGVnZXIgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJJTlRFR0VSXCJdID0gXCJJTlRFR0VSXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBib29sZWFuIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiQk9PTEVBTlwiXSA9IFwiQk9PTEVBTlwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgYXJyYXkgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJBUlJBWVwiXSA9IFwiQVJSQVlcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIG9iamVjdCB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk9CSkVDVFwiXSA9IFwiT0JKRUNUXCI7XG4gICAgLyoqXG4gICAgICogTnVsbCB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk5VTExcIl0gPSBcIk5VTExcIjtcbn0pKFR5cGUgfHwgKFR5cGUgPSB7fSkpO1xuLyoqIFJlcXVpcmVkLiBIYXJtIGNhdGVnb3J5LiAqL1xudmFyIEhhcm1DYXRlZ29yeTtcbihmdW5jdGlvbiAoSGFybUNhdGVnb3J5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGhhdGUgc3BlZWNoLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIl0gPSBcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBkYW5nZXJvdXMgY29udGVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaGFyYXNzbWVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSEFSQVNTTUVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIHNleHVhbGx5IGV4cGxpY2l0IGNvbnRlbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9TRVhVQUxMWV9FWFBMSUNJVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9TRVhVQUxMWV9FWFBMSUNJVFwiO1xuICAgIC8qKlxuICAgICAqIERlcHJlY2F0ZWQ6IEVsZWN0aW9uIGZpbHRlciBpcyBub3QgbG9uZ2VyIHN1cHBvcnRlZC4gVGhlIGhhcm0gY2F0ZWdvcnkgaXMgY2l2aWMgaW50ZWdyaXR5LlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfQ0lWSUNfSU5URUdSSVRZXCJdID0gXCJIQVJNX0NBVEVHT1JZX0NJVklDX0lOVEVHUklUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIGhhdGUuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9IQVRFXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBVEVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBpbWFnZSBkYW5nZXJvdXMgY29udGVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0RBTkdFUk9VU19DT05URU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0RBTkdFUk9VU19DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaW1hZ2UgaGFyYXNzbWVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBUkFTU01FTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSU1BR0VfSEFSQVNTTUVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIHNleHVhbGx5IGV4cGxpY2l0IGNvbnRlbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9TRVhVQUxMWV9FWFBMSUNJVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9JTUFHRV9TRVhVQUxMWV9FWFBMSUNJVFwiO1xufSkoSGFybUNhdGVnb3J5IHx8IChIYXJtQ2F0ZWdvcnkgPSB7fSkpO1xuLyoqIE9wdGlvbmFsLiBTcGVjaWZ5IGlmIHRoZSB0aHJlc2hvbGQgaXMgdXNlZCBmb3IgcHJvYmFiaWxpdHkgb3Igc2V2ZXJpdHkgc2NvcmUuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aHJlc2hvbGQgaXMgdXNlZCBmb3IgcHJvYmFiaWxpdHkgc2NvcmUuICovXG52YXIgSGFybUJsb2NrTWV0aG9kO1xuKGZ1bmN0aW9uIChIYXJtQmxvY2tNZXRob2QpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBibG9jayBtZXRob2QgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybUJsb2NrTWV0aG9kW1wiSEFSTV9CTE9DS19NRVRIT0RfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fQkxPQ0tfTUVUSE9EX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gYmxvY2sgbWV0aG9kIHVzZXMgYm90aCBwcm9iYWJpbGl0eSBhbmQgc2V2ZXJpdHkgc2NvcmVzLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja01ldGhvZFtcIlNFVkVSSVRZXCJdID0gXCJTRVZFUklUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGJsb2NrIG1ldGhvZCB1c2VzIHRoZSBwcm9iYWJpbGl0eSBzY29yZS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tNZXRob2RbXCJQUk9CQUJJTElUWVwiXSA9IFwiUFJPQkFCSUxJVFlcIjtcbn0pKEhhcm1CbG9ja01ldGhvZCB8fCAoSGFybUJsb2NrTWV0aG9kID0ge30pKTtcbi8qKiBSZXF1aXJlZC4gVGhlIGhhcm0gYmxvY2sgdGhyZXNob2xkLiAqL1xudmFyIEhhcm1CbG9ja1RocmVzaG9sZDtcbihmdW5jdGlvbiAoSGFybUJsb2NrVGhyZXNob2xkKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgaGFybSBibG9jayB0aHJlc2hvbGQuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiSEFSTV9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fQkxPQ0tfVEhSRVNIT0xEX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgbG93IHRocmVzaG9sZCBhbmQgYWJvdmUgKGkuZS4gYmxvY2sgbW9yZSkuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTE9XX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTE9XX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIG1lZGl1bSB0aHJlc2hvbGQgYW5kIGFib3ZlLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBvbmx5IGhpZ2ggdGhyZXNob2xkIChpLmUuIGJsb2NrIGxlc3MpLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX09OTFlfSElHSFwiXSA9IFwiQkxPQ0tfT05MWV9ISUdIXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgbm9uZS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19OT05FXCJdID0gXCJCTE9DS19OT05FXCI7XG4gICAgLyoqXG4gICAgICogVHVybiBvZmYgdGhlIHNhZmV0eSBmaWx0ZXIuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiT0ZGXCJdID0gXCJPRkZcIjtcbn0pKEhhcm1CbG9ja1RocmVzaG9sZCB8fCAoSGFybUJsb2NrVGhyZXNob2xkID0ge30pKTtcbi8qKiBUaGUgbW9kZSBvZiB0aGUgcHJlZGljdG9yIHRvIGJlIHVzZWQgaW4gZHluYW1pYyByZXRyaWV2YWwuICovXG52YXIgTW9kZTtcbihmdW5jdGlvbiAoTW9kZSkge1xuICAgIC8qKlxuICAgICAqIEFsd2F5cyB0cmlnZ2VyIHJldHJpZXZhbC5cbiAgICAgKi9cbiAgICBNb2RlW1wiTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFJ1biByZXRyaWV2YWwgb25seSB3aGVuIHN5c3RlbSBkZWNpZGVzIGl0IGlzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBNb2RlW1wiTU9ERV9EWU5BTUlDXCJdID0gXCJNT0RFX0RZTkFNSUNcIjtcbn0pKE1vZGUgfHwgKE1vZGUgPSB7fSkpO1xuLyoqIFR5cGUgb2YgYXV0aCBzY2hlbWUuICovXG52YXIgQXV0aFR5cGU7XG4oZnVuY3Rpb24gKEF1dGhUeXBlKSB7XG4gICAgQXV0aFR5cGVbXCJBVVRIX1RZUEVfVU5TUEVDSUZJRURcIl0gPSBcIkFVVEhfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE5vIEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJOT19BVVRIXCJdID0gXCJOT19BVVRIXCI7XG4gICAgLyoqXG4gICAgICogQVBJIEtleSBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiQVBJX0tFWV9BVVRIXCJdID0gXCJBUElfS0VZX0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBIVFRQIEJhc2ljIEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJIVFRQX0JBU0lDX0FVVEhcIl0gPSBcIkhUVFBfQkFTSUNfQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIEdvb2dsZSBTZXJ2aWNlIEFjY291bnQgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRfQVVUSFwiXSA9IFwiR09PR0xFX1NFUlZJQ0VfQUNDT1VOVF9BVVRIXCI7XG4gICAgLyoqXG4gICAgICogT0F1dGggYXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIk9BVVRIXCJdID0gXCJPQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5JRCBDb25uZWN0IChPSURDKSBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiT0lEQ19BVVRIXCJdID0gXCJPSURDX0FVVEhcIjtcbn0pKEF1dGhUeXBlIHx8IChBdXRoVHlwZSA9IHt9KSk7XG4vKiogVGhlIEFQSSBzcGVjIHRoYXQgdGhlIGV4dGVybmFsIEFQSSBpbXBsZW1lbnRzLiAqL1xudmFyIEFwaVNwZWM7XG4oZnVuY3Rpb24gKEFwaVNwZWMpIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCBBUEkgc3BlYy4gVGhpcyB2YWx1ZSBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgQXBpU3BlY1tcIkFQSV9TUEVDX1VOU1BFQ0lGSUVEXCJdID0gXCJBUElfU1BFQ19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFNpbXBsZSBzZWFyY2ggQVBJIHNwZWMuXG4gICAgICovXG4gICAgQXBpU3BlY1tcIlNJTVBMRV9TRUFSQ0hcIl0gPSBcIlNJTVBMRV9TRUFSQ0hcIjtcbiAgICAvKipcbiAgICAgKiBFbGFzdGljIHNlYXJjaCBBUEkgc3BlYy5cbiAgICAgKi9cbiAgICBBcGlTcGVjW1wiRUxBU1RJQ19TRUFSQ0hcIl0gPSBcIkVMQVNUSUNfU0VBUkNIXCI7XG59KShBcGlTcGVjIHx8IChBcGlTcGVjID0ge30pKTtcbi8qKiBTdGF0dXMgb2YgdGhlIHVybCByZXRyaWV2YWwuICovXG52YXIgVXJsUmV0cmlldmFsU3RhdHVzO1xuKGZ1bmN0aW9uIChVcmxSZXRyaWV2YWxTdGF0dXMpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBUaGlzIHZhbHVlIGlzIHVudXNlZFxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU1BFQ0lGSUVEXCJdID0gXCJVUkxfUkVUUklFVkFMX1NUQVRVU19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBVcmxSZXRyaWV2YWxTdGF0dXNbXCJVUkxfUkVUUklFVkFMX1NUQVRVU19TVUNDRVNTXCJdID0gXCJVUkxfUkVUUklFVkFMX1NUQVRVU19TVUNDRVNTXCI7XG4gICAgLyoqXG4gICAgICogVXJsIHJldHJpZXZhbCBpcyBmYWlsZWQgZHVlIHRvIGVycm9yLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX0VSUk9SXCJdID0gXCJVUkxfUkVUUklFVkFMX1NUQVRVU19FUlJPUlwiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgZmFpbGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgaXMgYmVoaW5kIHBheXdhbGwuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfUEFZV0FMTFwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfUEFZV0FMTFwiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgZmFpbGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgaXMgdW5zYWZlLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU0FGRVwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TQUZFXCI7XG59KShVcmxSZXRyaWV2YWxTdGF0dXMgfHwgKFVybFJldHJpZXZhbFN0YXR1cyA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIFRoZSByZWFzb24gd2h5IHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLlxuXG4gIElmIGVtcHR5LCB0aGUgbW9kZWwgaGFzIG5vdCBzdG9wcGVkIGdlbmVyYXRpbmcgdGhlIHRva2Vucy5cbiAgICovXG52YXIgRmluaXNoUmVhc29uO1xuKGZ1bmN0aW9uIChGaW5pc2hSZWFzb24pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZmluaXNoIHJlYXNvbiBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJGSU5JU0hfUkVBU09OX1VOU1BFQ0lGSUVEXCJdID0gXCJGSU5JU0hfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiByZWFjaGVkIGEgbmF0dXJhbCBzdG9wcGluZyBwb2ludCBvciBhIGNvbmZpZ3VyZWQgc3RvcCBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJTVE9QXCJdID0gXCJTVE9QXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiByZWFjaGVkIHRoZSBjb25maWd1cmVkIG1heGltdW0gb3V0cHV0IHRva2Vucy5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJNQVhfVE9LRU5TXCJdID0gXCJNQVhfVE9LRU5TXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgcG90ZW50aWFsbHkgY29udGFpbnMgc2FmZXR5IHZpb2xhdGlvbnMuIE5PVEU6IFdoZW4gc3RyZWFtaW5nLCBbY29udGVudF1bXSBpcyBlbXB0eSBpZiBjb250ZW50IGZpbHRlcnMgYmxvY2tzIHRoZSBvdXRwdXQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU0FGRVRZXCJdID0gXCJTQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2Ugb2YgcG90ZW50aWFsIHJlY2l0YXRpb24uXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiUkVDSVRBVElPTlwiXSA9IFwiUkVDSVRBVElPTlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSB0b2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSBvZiB1c2luZyBhbiB1bnN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJMQU5HVUFHRVwiXSA9IFwiTEFOR1VBR0VcIjtcbiAgICAvKipcbiAgICAgKiBBbGwgb3RoZXIgcmVhc29ucyB0aGF0IHN0b3BwZWQgdGhlIHRva2VuIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiT1RIRVJcIl0gPSBcIk9USEVSXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgY29udGFpbnMgZm9yYmlkZGVuIHRlcm1zLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIkJMT0NLTElTVFwiXSA9IFwiQkxPQ0tMSVNUXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGZvciBwb3RlbnRpYWxseSBjb250YWluaW5nIHByb2hpYml0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJQUk9ISUJJVEVEX0NPTlRFTlRcIl0gPSBcIlBST0hJQklURURfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IHBvdGVudGlhbGx5IGNvbnRhaW5zIFNlbnNpdGl2ZSBQZXJzb25hbGx5IElkZW50aWZpYWJsZSBJbmZvcm1hdGlvbiAoU1BJSSkuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU1BJSVwiXSA9IFwiU1BJSVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiXSA9IFwiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSBnZW5lcmF0ZWQgaW1hZ2VzIGhhdmUgc2FmZXR5IHZpb2xhdGlvbnMuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiSU1BR0VfU0FGRVRZXCJdID0gXCJJTUFHRV9TQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9vbCBjYWxsIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJVTkVYUEVDVEVEX1RPT0xfQ0FMTFwiXSA9IFwiVU5FWFBFQ1RFRF9UT09MX0NBTExcIjtcbn0pKEZpbmlzaFJlYXNvbiB8fCAoRmluaXNoUmVhc29uID0ge30pKTtcbi8qKiBPdXRwdXQgb25seS4gSGFybSBwcm9iYWJpbGl0eSBsZXZlbHMgaW4gdGhlIGNvbnRlbnQuICovXG52YXIgSGFybVByb2JhYmlsaXR5O1xuKGZ1bmN0aW9uIChIYXJtUHJvYmFiaWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBIYXJtIHByb2JhYmlsaXR5IHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIkhBUk1fUFJPQkFCSUxJVFlfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fUFJPQkFCSUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBOZWdsaWdpYmxlIGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiTkVHTElHSUJMRVwiXSA9IFwiTkVHTElHSUJMRVwiO1xuICAgIC8qKlxuICAgICAqIExvdyBsZXZlbCBvZiBoYXJtLlxuICAgICAqL1xuICAgIEhhcm1Qcm9iYWJpbGl0eVtcIkxPV1wiXSA9IFwiTE9XXCI7XG4gICAgLyoqXG4gICAgICogTWVkaXVtIGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiTUVESVVNXCJdID0gXCJNRURJVU1cIjtcbiAgICAvKipcbiAgICAgKiBIaWdoIGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiSElHSFwiXSA9IFwiSElHSFwiO1xufSkoSGFybVByb2JhYmlsaXR5IHx8IChIYXJtUHJvYmFiaWxpdHkgPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBIYXJtIHNldmVyaXR5IGxldmVscyBpbiB0aGUgY29udGVudC4gKi9cbnZhciBIYXJtU2V2ZXJpdHk7XG4oZnVuY3Rpb24gKEhhcm1TZXZlcml0eSkge1xuICAgIC8qKlxuICAgICAqIEhhcm0gc2V2ZXJpdHkgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9TRVZFUklUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE5lZ2xpZ2libGUgbGV2ZWwgb2YgaGFybSBzZXZlcml0eS5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX05FR0xJR0lCTEVcIl0gPSBcIkhBUk1fU0VWRVJJVFlfTkVHTElHSUJMRVwiO1xuICAgIC8qKlxuICAgICAqIExvdyBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfTE9XXCJdID0gXCJIQVJNX1NFVkVSSVRZX0xPV1wiO1xuICAgIC8qKlxuICAgICAqIE1lZGl1bSBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfTUVESVVNXCJdID0gXCJIQVJNX1NFVkVSSVRZX01FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgb2YgaGFybSBzZXZlcml0eS5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX0hJR0hcIl0gPSBcIkhBUk1fU0VWRVJJVFlfSElHSFwiO1xufSkoSGFybVNldmVyaXR5IHx8IChIYXJtU2V2ZXJpdHkgPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBCbG9ja2VkIHJlYXNvbi4gKi9cbnZhciBCbG9ja2VkUmVhc29uO1xuKGZ1bmN0aW9uIChCbG9ja2VkUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgYmxvY2tlZCByZWFzb24uXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIkJMT0NLRURfUkVBU09OX1VOU1BFQ0lGSUVEXCJdID0gXCJCTE9DS0VEX1JFQVNPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIENhbmRpZGF0ZXMgYmxvY2tlZCBkdWUgdG8gc2FmZXR5LlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJTQUZFVFlcIl0gPSBcIlNBRkVUWVwiO1xuICAgIC8qKlxuICAgICAqIENhbmRpZGF0ZXMgYmxvY2tlZCBkdWUgdG8gb3RoZXIgcmVhc29uLlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJPVEhFUlwiXSA9IFwiT1RIRVJcIjtcbiAgICAvKipcbiAgICAgKiBDYW5kaWRhdGVzIGJsb2NrZWQgZHVlIHRvIHRoZSB0ZXJtcyB3aGljaCBhcmUgaW5jbHVkZWQgZnJvbSB0aGUgdGVybWlub2xvZ3kgYmxvY2tsaXN0LlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJCTE9DS0xJU1RcIl0gPSBcIkJMT0NLTElTVFwiO1xuICAgIC8qKlxuICAgICAqIENhbmRpZGF0ZXMgYmxvY2tlZCBkdWUgdG8gcHJvaGliaXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJQUk9ISUJJVEVEX0NPTlRFTlRcIl0gPSBcIlBST0hJQklURURfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIENhbmRpZGF0ZXMgYmxvY2tlZCBkdWUgdG8gdW5zYWZlIGltYWdlIGdlbmVyYXRpb24gY29udGVudC5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiSU1BR0VfU0FGRVRZXCJdID0gXCJJTUFHRV9TQUZFVFlcIjtcbn0pKEJsb2NrZWRSZWFzb24gfHwgKEJsb2NrZWRSZWFzb24gPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBUcmFmZmljIHR5cGUuIFRoaXMgc2hvd3Mgd2hldGhlciBhIHJlcXVlc3QgY29uc3VtZXMgUGF5LUFzLVlvdS1HbyBvciBQcm92aXNpb25lZCBUaHJvdWdocHV0IHF1b3RhLiAqL1xudmFyIFRyYWZmaWNUeXBlO1xuKGZ1bmN0aW9uIChUcmFmZmljVHlwZSkge1xuICAgIC8qKlxuICAgICAqIFVuc3BlY2lmaWVkIHJlcXVlc3QgdHJhZmZpYyB0eXBlLlxuICAgICAqL1xuICAgIFRyYWZmaWNUeXBlW1wiVFJBRkZJQ19UWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUUkFGRklDX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUeXBlIGZvciBQYXktQXMtWW91LUdvIHRyYWZmaWMuXG4gICAgICovXG4gICAgVHJhZmZpY1R5cGVbXCJPTl9ERU1BTkRcIl0gPSBcIk9OX0RFTUFORFwiO1xuICAgIC8qKlxuICAgICAqIFR5cGUgZm9yIFByb3Zpc2lvbmVkIFRocm91Z2hwdXQgdHJhZmZpYy5cbiAgICAgKi9cbiAgICBUcmFmZmljVHlwZVtcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIl0gPSBcIlBST1ZJU0lPTkVEX1RIUk9VR0hQVVRcIjtcbn0pKFRyYWZmaWNUeXBlIHx8IChUcmFmZmljVHlwZSA9IHt9KSk7XG4vKiogU2VydmVyIGNvbnRlbnQgbW9kYWxpdGllcy4gKi9cbnZhciBNb2RhbGl0eTtcbihmdW5jdGlvbiAoTW9kYWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kYWxpdHkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiTU9EQUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gdGV4dFxuICAgICAqL1xuICAgIE1vZGFsaXR5W1wiVEVYVFwiXSA9IFwiVEVYVFwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbW9kZWwgc2hvdWxkIHJldHVybiBpbWFnZXMuXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIG1vZGVsIHNob3VsZCByZXR1cm4gYXVkaW8uXG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJBVURJT1wiXSA9IFwiQVVESU9cIjtcbn0pKE1vZGFsaXR5IHx8IChNb2RhbGl0eSA9IHt9KSk7XG4vKiogVGhlIG1lZGlhIHJlc29sdXRpb24gdG8gdXNlLiAqL1xudmFyIE1lZGlhUmVzb2x1dGlvbjtcbihmdW5jdGlvbiAoTWVkaWFSZXNvbHV0aW9uKSB7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBoYXMgbm90IGJlZW4gc2V0XG4gICAgICovXG4gICAgTWVkaWFSZXNvbHV0aW9uW1wiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGxvdyAoNjQgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9MT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIHNldCB0byBtZWRpdW0gKDI1NiB0b2tlbnMpLlxuICAgICAqL1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fTUVESVVNXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX01FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIGhpZ2ggKHpvb21lZCByZWZyYW1pbmcgd2l0aCAyNTYgdG9rZW5zKS5cbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX0hJR0hcIl0gPSBcIk1FRElBX1JFU09MVVRJT05fSElHSFwiO1xufSkoTWVkaWFSZXNvbHV0aW9uIHx8IChNZWRpYVJlc29sdXRpb24gPSB7fSkpO1xuLyoqIEpvYiBzdGF0ZS4gKi9cbnZhciBKb2JTdGF0ZTtcbihmdW5jdGlvbiAoSm9iU3RhdGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIHN0YXRlIGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1VOU1BFQ0lGSUVEXCJdID0gXCJKT0JfU1RBVEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBiZWVuIGp1c3QgY3JlYXRlZCBvciByZXN1bWVkIGFuZCBwcm9jZXNzaW5nIGhhcyBub3QgeWV0IGJlZ3VuLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1FVRVVFRFwiXSA9IFwiSk9CX1NUQVRFX1FVRVVFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2aWNlIGlzIHByZXBhcmluZyB0byBydW4gdGhlIGpvYi5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9QRU5ESU5HXCJdID0gXCJKT0JfU1RBVEVfUEVORElOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfUlVOTklOR1wiXSA9IFwiSk9CX1NUQVRFX1JVTk5JTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfU1VDQ0VFREVEXCJdID0gXCJKT0JfU1RBVEVfU1VDQ0VFREVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBmYWlsZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfRkFJTEVEXCJdID0gXCJKT0JfU1RBVEVfRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBiZWluZyBjYW5jZWxsZWQuIEZyb20gdGhpcyBzdGF0ZSB0aGUgam9iIG1heSBvbmx5IGdvIHRvIGVpdGhlciBgSk9CX1NUQVRFX1NVQ0NFRURFRGAsIGBKT0JfU1RBVEVfRkFJTEVEYCBvciBgSk9CX1NUQVRFX0NBTkNFTExFRGAuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfQ0FOQ0VMTElOR1wiXSA9IFwiSk9CX1NUQVRFX0NBTkNFTExJTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBiZWVuIGNhbmNlbGxlZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9DQU5DRUxMRURcIl0gPSBcIkpPQl9TVEFURV9DQU5DRUxMRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBiZWVuIHN0b3BwZWQsIGFuZCBjYW4gYmUgcmVzdW1lZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9QQVVTRURcIl0gPSBcIkpPQl9TVEFURV9QQVVTRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGhhcyBleHBpcmVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX0VYUElSRURcIl0gPSBcIkpPQl9TVEFURV9FWFBJUkVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBiZWluZyB1cGRhdGVkLiBPbmx5IGpvYnMgaW4gdGhlIGBKT0JfU1RBVEVfUlVOTklOR2Agc3RhdGUgY2FuIGJlIHVwZGF0ZWQuIEFmdGVyIHVwZGF0aW5nLCB0aGUgam9iIGdvZXMgYmFjayB0byB0aGUgYEpPQl9TVEFURV9SVU5OSU5HYCBzdGF0ZS5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9VUERBVElOR1wiXSA9IFwiSk9CX1NUQVRFX1VQREFUSU5HXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBwYXJ0aWFsbHkgc3VjY2VlZGVkLCBzb21lIHJlc3VsdHMgbWF5IGJlIG1pc3NpbmcgZHVlIHRvIGVycm9ycy5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9QQVJUSUFMTFlfU1VDQ0VFREVEXCJdID0gXCJKT0JfU1RBVEVfUEFSVElBTExZX1NVQ0NFRURFRFwiO1xufSkoSm9iU3RhdGUgfHwgKEpvYlN0YXRlID0ge30pKTtcbi8qKiBUdW5pbmcgbW9kZS4gKi9cbnZhciBUdW5pbmdNb2RlO1xuKGZ1bmN0aW9uIChUdW5pbmdNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVHVuaW5nIG1vZGUgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgVHVuaW5nTW9kZVtcIlRVTklOR19NT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJUVU5JTkdfTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEZ1bGwgZmluZS10dW5pbmcgbW9kZS5cbiAgICAgKi9cbiAgICBUdW5pbmdNb2RlW1wiVFVOSU5HX01PREVfRlVMTFwiXSA9IFwiVFVOSU5HX01PREVfRlVMTFwiO1xuICAgIC8qKlxuICAgICAqIFBFRlQgYWRhcHRlciB0dW5pbmcgbW9kZS5cbiAgICAgKi9cbiAgICBUdW5pbmdNb2RlW1wiVFVOSU5HX01PREVfUEVGVF9BREFQVEVSXCJdID0gXCJUVU5JTkdfTU9ERV9QRUZUX0FEQVBURVJcIjtcbn0pKFR1bmluZ01vZGUgfHwgKFR1bmluZ01vZGUgPSB7fSkpO1xuLyoqIE9wdGlvbmFsLiBBZGFwdGVyIHNpemUgZm9yIHR1bmluZy4gKi9cbnZhciBBZGFwdGVyU2l6ZTtcbihmdW5jdGlvbiAoQWRhcHRlclNpemUpIHtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfVU5TUEVDSUZJRURcIl0gPSBcIkFEQVBURVJfU0laRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSAxLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX09ORVwiXSA9IFwiQURBUFRFUl9TSVpFX09ORVwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSAyLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX1RXT1wiXSA9IFwiQURBUFRFUl9TSVpFX1RXT1wiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSA0LlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX0ZPVVJcIl0gPSBcIkFEQVBURVJfU0laRV9GT1VSXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDguXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfRUlHSFRcIl0gPSBcIkFEQVBURVJfU0laRV9FSUdIVFwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSAxNi5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9TSVhURUVOXCJdID0gXCJBREFQVEVSX1NJWkVfU0lYVEVFTlwiO1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSAzMi5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9USElSVFlfVFdPXCJdID0gXCJBREFQVEVSX1NJWkVfVEhJUlRZX1RXT1wiO1xufSkoQWRhcHRlclNpemUgfHwgKEFkYXB0ZXJTaXplID0ge30pKTtcbi8qKiBPcHRpb25zIGZvciBmZWF0dXJlIHNlbGVjdGlvbiBwcmVmZXJlbmNlLiAqL1xudmFyIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlO1xuKGZ1bmN0aW9uIChGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSkge1xuICAgIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlW1wiRkVBVFVSRV9TRUxFQ1RJT05fUFJFRkVSRU5DRV9VTlNQRUNJRklFRFwiXSA9IFwiRkVBVFVSRV9TRUxFQ1RJT05fUFJFRkVSRU5DRV9VTlNQRUNJRklFRFwiO1xuICAgIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlW1wiUFJJT1JJVElaRV9RVUFMSVRZXCJdID0gXCJQUklPUklUSVpFX1FVQUxJVFlcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIkJBTEFOQ0VEXCJdID0gXCJCQUxBTkNFRFwiO1xuICAgIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlW1wiUFJJT1JJVElaRV9DT1NUXCJdID0gXCJQUklPUklUSVpFX0NPU1RcIjtcbn0pKEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlIHx8IChGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSA9IHt9KSk7XG4vKiogRGVmaW5lcyB0aGUgZnVuY3Rpb24gYmVoYXZpb3IuIERlZmF1bHRzIHRvIGBCTE9DS0lOR2AuICovXG52YXIgQmVoYXZpb3I7XG4oZnVuY3Rpb24gKEJlaGF2aW9yKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgQmVoYXZpb3JbXCJVTlNQRUNJRklFRFwiXSA9IFwiVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHRoZSBzeXN0ZW0gd2lsbCB3YWl0IHRvIHJlY2VpdmUgdGhlIGZ1bmN0aW9uIHJlc3BvbnNlIGJlZm9yZSBjb250aW51aW5nIHRoZSBjb252ZXJzYXRpb24uXG4gICAgICovXG4gICAgQmVoYXZpb3JbXCJCTE9DS0lOR1wiXSA9IFwiQkxPQ0tJTkdcIjtcbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHRoZSBzeXN0ZW0gd2lsbCBub3Qgd2FpdCB0byByZWNlaXZlIHRoZSBmdW5jdGlvbiByZXNwb25zZS4gSW5zdGVhZCwgaXQgd2lsbCBhdHRlbXB0IHRvIGhhbmRsZSBmdW5jdGlvbiByZXNwb25zZXMgYXMgdGhleSBiZWNvbWUgYXZhaWxhYmxlIHdoaWxlIG1haW50YWluaW5nIHRoZSBjb252ZXJzYXRpb24gYmV0d2VlbiB0aGUgdXNlciBhbmQgdGhlIG1vZGVsLlxuICAgICAqL1xuICAgIEJlaGF2aW9yW1wiTk9OX0JMT0NLSU5HXCJdID0gXCJOT05fQkxPQ0tJTkdcIjtcbn0pKEJlaGF2aW9yIHx8IChCZWhhdmlvciA9IHt9KSk7XG4vKiogQ29uZmlnIGZvciB0aGUgZHluYW1pYyByZXRyaWV2YWwgY29uZmlnIG1vZGUuICovXG52YXIgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGU7XG4oZnVuY3Rpb24gKER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlKSB7XG4gICAgLyoqXG4gICAgICogQWx3YXlzIHRyaWdnZXIgcmV0cmlldmFsLlxuICAgICAqL1xuICAgIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlW1wiTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFJ1biByZXRyaWV2YWwgb25seSB3aGVuIHN5c3RlbSBkZWNpZGVzIGl0IGlzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZVtcIk1PREVfRFlOQU1JQ1wiXSA9IFwiTU9ERV9EWU5BTUlDXCI7XG59KShEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSB8fCAoRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUgPSB7fSkpO1xuLyoqIFRoZSBlbnZpcm9ubWVudCBiZWluZyBvcGVyYXRlZC4gKi9cbnZhciBFbnZpcm9ubWVudDtcbihmdW5jdGlvbiAoRW52aXJvbm1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0cyB0byBicm93c2VyLlxuICAgICAqL1xuICAgIEVudmlyb25tZW50W1wiRU5WSVJPTk1FTlRfVU5TUEVDSUZJRURcIl0gPSBcIkVOVklST05NRU5UX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogT3BlcmF0ZXMgaW4gYSB3ZWIgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFbnZpcm9ubWVudFtcIkVOVklST05NRU5UX0JST1dTRVJcIl0gPSBcIkVOVklST05NRU5UX0JST1dTRVJcIjtcbn0pKEVudmlyb25tZW50IHx8IChFbnZpcm9ubWVudCA9IHt9KSk7XG4vKiogQ29uZmlnIGZvciB0aGUgZnVuY3Rpb24gY2FsbGluZyBjb25maWcgbW9kZS4gKi9cbnZhciBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlO1xuKGZ1bmN0aW9uIChGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIGNhbGxpbmcgY29uZmlnIG1vZGUgaXMgdW5zcGVjaWZpZWQuIFNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgbW9kZWwgYmVoYXZpb3IsIG1vZGVsIGRlY2lkZXMgdG8gcHJlZGljdCBlaXRoZXIgZnVuY3Rpb24gY2FsbHMgb3IgbmF0dXJhbCBsYW5ndWFnZSByZXNwb25zZS5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiQVVUT1wiXSA9IFwiQVVUT1wiO1xuICAgIC8qKlxuICAgICAqIE1vZGVsIGlzIGNvbnN0cmFpbmVkIHRvIGFsd2F5cyBwcmVkaWN0aW5nIGZ1bmN0aW9uIGNhbGxzIG9ubHkuIElmIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiIGFyZSBzZXQsIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbHMgd2lsbCBiZSBsaW1pdGVkIHRvIGFueSBvbmUgb2YgXCJhbGxvd2VkX2Z1bmN0aW9uX25hbWVzXCIsIGVsc2UgdGhlIHByZWRpY3RlZCBmdW5jdGlvbiBjYWxscyB3aWxsIGJlIGFueSBvbmUgb2YgdGhlIHByb3ZpZGVkIFwiZnVuY3Rpb25fZGVjbGFyYXRpb25zXCIuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIkFOWVwiXSA9IFwiQU5ZXCI7XG4gICAgLyoqXG4gICAgICogTW9kZWwgd2lsbCBub3QgcHJlZGljdCBhbnkgZnVuY3Rpb24gY2FsbHMuIE1vZGVsIGJlaGF2aW9yIGlzIHNhbWUgYXMgd2hlbiBub3QgcGFzc2luZyBhbnkgZnVuY3Rpb24gZGVjbGFyYXRpb25zLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJOT05FXCJdID0gXCJOT05FXCI7XG59KShGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlIHx8IChGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgY29udHJvbHMgdGhlIHNhZmV0eSBmaWx0ZXIgbGV2ZWwgZm9yIG9iamVjdGlvbmFibGUgY29udGVudC4gKi9cbnZhciBTYWZldHlGaWx0ZXJMZXZlbDtcbihmdW5jdGlvbiAoU2FmZXR5RmlsdGVyTGV2ZWwpIHtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX0xPV19BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX0xPV19BTkRfQUJPVkVcIjtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIjtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX09OTFlfSElHSFwiXSA9IFwiQkxPQ0tfT05MWV9ISUdIXCI7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19OT05FXCJdID0gXCJCTE9DS19OT05FXCI7XG59KShTYWZldHlGaWx0ZXJMZXZlbCB8fCAoU2FmZXR5RmlsdGVyTGV2ZWwgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBjb250cm9scyB0aGUgZ2VuZXJhdGlvbiBvZiBwZW9wbGUuICovXG52YXIgUGVyc29uR2VuZXJhdGlvbjtcbihmdW5jdGlvbiAoUGVyc29uR2VuZXJhdGlvbikge1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGdlbmVyYXRpb24gb2YgaW1hZ2VzIG9mIHBlb3BsZS5cbiAgICAgKi9cbiAgICBQZXJzb25HZW5lcmF0aW9uW1wiRE9OVF9BTExPV1wiXSA9IFwiRE9OVF9BTExPV1wiO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGltYWdlcyBvZiBhZHVsdHMsIGJ1dCBub3QgY2hpbGRyZW4uXG4gICAgICovXG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkFMTE9XX0FEVUxUXCJdID0gXCJBTExPV19BRFVMVFwiO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGltYWdlcyB0aGF0IGluY2x1ZGUgYWR1bHRzIGFuZCBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBQZXJzb25HZW5lcmF0aW9uW1wiQUxMT1dfQUxMXCJdID0gXCJBTExPV19BTExcIjtcbn0pKFBlcnNvbkdlbmVyYXRpb24gfHwgKFBlcnNvbkdlbmVyYXRpb24gPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBzcGVjaWZpZXMgdGhlIGxhbmd1YWdlIG9mIHRoZSB0ZXh0IGluIHRoZSBwcm9tcHQuICovXG52YXIgSW1hZ2VQcm9tcHRMYW5ndWFnZTtcbihmdW5jdGlvbiAoSW1hZ2VQcm9tcHRMYW5ndWFnZSkge1xuICAgIC8qKlxuICAgICAqIEF1dG8tZGV0ZWN0IHRoZSBsYW5ndWFnZS5cbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiYXV0b1wiXSA9IFwiYXV0b1wiO1xuICAgIC8qKlxuICAgICAqIEVuZ2xpc2hcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiZW5cIl0gPSBcImVuXCI7XG4gICAgLyoqXG4gICAgICogSmFwYW5lc2VcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiamFcIl0gPSBcImphXCI7XG4gICAgLyoqXG4gICAgICogS29yZWFuXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImtvXCJdID0gXCJrb1wiO1xuICAgIC8qKlxuICAgICAqIEhpbmRpXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImhpXCJdID0gXCJoaVwiO1xuICAgIC8qKlxuICAgICAqIENoaW5lc2VcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiemhcIl0gPSBcInpoXCI7XG4gICAgLyoqXG4gICAgICogUG9ydHVndWVzZVxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJwdFwiXSA9IFwicHRcIjtcbiAgICAvKipcbiAgICAgKiBTcGFuaXNoXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImVzXCJdID0gXCJlc1wiO1xufSkoSW1hZ2VQcm9tcHRMYW5ndWFnZSB8fCAoSW1hZ2VQcm9tcHRMYW5ndWFnZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIG1hc2sgbW9kZSBvZiBhIG1hc2sgcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIE1hc2tSZWZlcmVuY2VNb2RlO1xuKGZ1bmN0aW9uIChNYXNrUmVmZXJlbmNlTW9kZSkge1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX0RFRkFVTFRcIl0gPSBcIk1BU0tfTU9ERV9ERUZBVUxUXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfVVNFUl9QUk9WSURFRFwiXSA9IFwiTUFTS19NT0RFX1VTRVJfUFJPVklERURcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9CQUNLR1JPVU5EXCJdID0gXCJNQVNLX01PREVfQkFDS0dST1VORFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX0ZPUkVHUk9VTkRcIl0gPSBcIk1BU0tfTU9ERV9GT1JFR1JPVU5EXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfU0VNQU5USUNcIl0gPSBcIk1BU0tfTU9ERV9TRU1BTlRJQ1wiO1xufSkoTWFza1JlZmVyZW5jZU1vZGUgfHwgKE1hc2tSZWZlcmVuY2VNb2RlID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgY29udHJvbCB0eXBlIG9mIGEgY29udHJvbCByZWZlcmVuY2UgaW1hZ2UuICovXG52YXIgQ29udHJvbFJlZmVyZW5jZVR5cGU7XG4oZnVuY3Rpb24gKENvbnRyb2xSZWZlcmVuY2VUeXBlKSB7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfREVGQVVMVFwiXSA9IFwiQ09OVFJPTF9UWVBFX0RFRkFVTFRcIjtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9DQU5OWVwiXSA9IFwiQ09OVFJPTF9UWVBFX0NBTk5ZXCI7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfU0NSSUJCTEVcIl0gPSBcIkNPTlRST0xfVFlQRV9TQ1JJQkJMRVwiO1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX0ZBQ0VfTUVTSFwiXSA9IFwiQ09OVFJPTF9UWVBFX0ZBQ0VfTUVTSFwiO1xufSkoQ29udHJvbFJlZmVyZW5jZVR5cGUgfHwgKENvbnRyb2xSZWZlcmVuY2VUeXBlID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgc3ViamVjdCB0eXBlIG9mIGEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UuICovXG52YXIgU3ViamVjdFJlZmVyZW5jZVR5cGU7XG4oZnVuY3Rpb24gKFN1YmplY3RSZWZlcmVuY2VUeXBlKSB7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfREVGQVVMVFwiXSA9IFwiU1VCSkVDVF9UWVBFX0RFRkFVTFRcIjtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9QRVJTT05cIl0gPSBcIlNVQkpFQ1RfVFlQRV9QRVJTT05cIjtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9BTklNQUxcIl0gPSBcIlNVQkpFQ1RfVFlQRV9BTklNQUxcIjtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9QUk9EVUNUXCJdID0gXCJTVUJKRUNUX1RZUEVfUFJPRFVDVFwiO1xufSkoU3ViamVjdFJlZmVyZW5jZVR5cGUgfHwgKFN1YmplY3RSZWZlcmVuY2VUeXBlID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgSW1hZ2VuIDMgRWRpdCBtb2RlLiAqL1xudmFyIEVkaXRNb2RlO1xuKGZ1bmN0aW9uIChFZGl0TW9kZSkge1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0RFRkFVTFRcIl0gPSBcIkVESVRfTU9ERV9ERUZBVUxUXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfSU5QQUlOVF9SRU1PVkFMXCJdID0gXCJFRElUX01PREVfSU5QQUlOVF9SRU1PVkFMXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfSU5QQUlOVF9JTlNFUlRJT05cIl0gPSBcIkVESVRfTU9ERV9JTlBBSU5UX0lOU0VSVElPTlwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX09VVFBBSU5UXCJdID0gXCJFRElUX01PREVfT1VUUEFJTlRcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9DT05UUk9MTEVEX0VESVRJTkdcIl0gPSBcIkVESVRfTU9ERV9DT05UUk9MTEVEX0VESVRJTkdcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9TVFlMRVwiXSA9IFwiRURJVF9NT0RFX1NUWUxFXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfQkdTV0FQXCJdID0gXCJFRElUX01PREVfQkdTV0FQXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfUFJPRFVDVF9JTUFHRVwiXSA9IFwiRURJVF9NT0RFX1BST0RVQ1RfSU1BR0VcIjtcbn0pKEVkaXRNb2RlIHx8IChFZGl0TW9kZSA9IHt9KSk7XG4vKiogRW51bSB0aGF0IHJlcHJlc2VudHMgdGhlIHNlZ21lbnRhdGlvbiBtb2RlLiAqL1xudmFyIFNlZ21lbnRNb2RlO1xuKGZ1bmN0aW9uIChTZWdtZW50TW9kZSkge1xuICAgIFNlZ21lbnRNb2RlW1wiRk9SRUdST1VORFwiXSA9IFwiRk9SRUdST1VORFwiO1xuICAgIFNlZ21lbnRNb2RlW1wiQkFDS0dST1VORFwiXSA9IFwiQkFDS0dST1VORFwiO1xuICAgIFNlZ21lbnRNb2RlW1wiUFJPTVBUXCJdID0gXCJQUk9NUFRcIjtcbiAgICBTZWdtZW50TW9kZVtcIlNFTUFOVElDXCJdID0gXCJTRU1BTlRJQ1wiO1xuICAgIFNlZ21lbnRNb2RlW1wiSU5URVJBQ1RJVkVcIl0gPSBcIklOVEVSQUNUSVZFXCI7XG59KShTZWdtZW50TW9kZSB8fCAoU2VnbWVudE1vZGUgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBjb250cm9scyB0aGUgY29tcHJlc3Npb24gcXVhbGl0eSBvZiB0aGUgZ2VuZXJhdGVkIHZpZGVvcy4gKi9cbnZhciBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eTtcbihmdW5jdGlvbiAoVmlkZW9Db21wcmVzc2lvblF1YWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBPcHRpbWl6ZWQgdmlkZW8gY29tcHJlc3Npb24gcXVhbGl0eS4gVGhpcyB3aWxsIHByb2R1Y2UgdmlkZW9zXG4gICAgICAgIHdpdGggYSBjb21wcmVzc2VkLCBzbWFsbGVyIGZpbGUgc2l6ZS5cbiAgICAgKi9cbiAgICBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eVtcIk9QVElNSVpFRFwiXSA9IFwiT1BUSU1JWkVEXCI7XG4gICAgLyoqXG4gICAgICogTG9zc2xlc3MgdmlkZW8gY29tcHJlc3Npb24gcXVhbGl0eS4gVGhpcyB3aWxsIHByb2R1Y2UgdmlkZW9zXG4gICAgICAgIHdpdGggYSBsYXJnZXIgZmlsZSBzaXplLlxuICAgICAqL1xuICAgIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5W1wiTE9TU0xFU1NcIl0gPSBcIkxPU1NMRVNTXCI7XG59KShWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSB8fCAoVmlkZW9Db21wcmVzc2lvblF1YWxpdHkgPSB7fSkpO1xuLyoqIFN0YXRlIGZvciB0aGUgbGlmZWN5Y2xlIG9mIGEgRmlsZS4gKi9cbnZhciBGaWxlU3RhdGU7XG4oZnVuY3Rpb24gKEZpbGVTdGF0ZSkge1xuICAgIEZpbGVTdGF0ZVtcIlNUQVRFX1VOU1BFQ0lGSUVEXCJdID0gXCJTVEFURV9VTlNQRUNJRklFRFwiO1xuICAgIEZpbGVTdGF0ZVtcIlBST0NFU1NJTkdcIl0gPSBcIlBST0NFU1NJTkdcIjtcbiAgICBGaWxlU3RhdGVbXCJBQ1RJVkVcIl0gPSBcIkFDVElWRVwiO1xuICAgIEZpbGVTdGF0ZVtcIkZBSUxFRFwiXSA9IFwiRkFJTEVEXCI7XG59KShGaWxlU3RhdGUgfHwgKEZpbGVTdGF0ZSA9IHt9KSk7XG4vKiogU291cmNlIG9mIHRoZSBGaWxlLiAqL1xudmFyIEZpbGVTb3VyY2U7XG4oZnVuY3Rpb24gKEZpbGVTb3VyY2UpIHtcbiAgICBGaWxlU291cmNlW1wiU09VUkNFX1VOU1BFQ0lGSUVEXCJdID0gXCJTT1VSQ0VfVU5TUEVDSUZJRURcIjtcbiAgICBGaWxlU291cmNlW1wiVVBMT0FERURcIl0gPSBcIlVQTE9BREVEXCI7XG4gICAgRmlsZVNvdXJjZVtcIkdFTkVSQVRFRFwiXSA9IFwiR0VORVJBVEVEXCI7XG59KShGaWxlU291cmNlIHx8IChGaWxlU291cmNlID0ge30pKTtcbi8qKiBTZXJ2ZXIgY29udGVudCBtb2RhbGl0aWVzLiAqL1xudmFyIE1lZGlhTW9kYWxpdHk7XG4oZnVuY3Rpb24gKE1lZGlhTW9kYWxpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kYWxpdHkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIk1PREFMSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHQuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIlRFWFRcIl0gPSBcIlRFWFRcIjtcbiAgICAvKipcbiAgICAgKiBJbWFnZXMuXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIklNQUdFXCJdID0gXCJJTUFHRVwiO1xuICAgIC8qKlxuICAgICAqIFZpZGVvLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJWSURFT1wiXSA9IFwiVklERU9cIjtcbiAgICAvKipcbiAgICAgKiBBdWRpby5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiQVVESU9cIl0gPSBcIkFVRElPXCI7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnQsIGUuZy4gUERGLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJET0NVTUVOVFwiXSA9IFwiRE9DVU1FTlRcIjtcbn0pKE1lZGlhTW9kYWxpdHkgfHwgKE1lZGlhTW9kYWxpdHkgPSB7fSkpO1xuLyoqIFN0YXJ0IG9mIHNwZWVjaCBzZW5zaXRpdml0eS4gKi9cbnZhciBTdGFydFNlbnNpdGl2aXR5O1xuKGZ1bmN0aW9uIChTdGFydFNlbnNpdGl2aXR5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgaXMgU1RBUlRfU0VOU0lUSVZJVFlfTE9XLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBvZiBzcGVlY2ggbW9yZSBvZnRlbi5cbiAgICAgKi9cbiAgICBTdGFydFNlbnNpdGl2aXR5W1wiU1RBUlRfU0VOU0lUSVZJVFlfSElHSFwiXSA9IFwiU1RBUlRfU0VOU0lUSVZJVFlfSElHSFwiO1xuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpYyBkZXRlY3Rpb24gd2lsbCBkZXRlY3QgdGhlIHN0YXJ0IG9mIHNwZWVjaCBsZXNzIG9mdGVuLlxuICAgICAqL1xuICAgIFN0YXJ0U2Vuc2l0aXZpdHlbXCJTVEFSVF9TRU5TSVRJVklUWV9MT1dcIl0gPSBcIlNUQVJUX1NFTlNJVElWSVRZX0xPV1wiO1xufSkoU3RhcnRTZW5zaXRpdml0eSB8fCAoU3RhcnRTZW5zaXRpdml0eSA9IHt9KSk7XG4vKiogRW5kIG9mIHNwZWVjaCBzZW5zaXRpdml0eS4gKi9cbnZhciBFbmRTZW5zaXRpdml0eTtcbihmdW5jdGlvbiAoRW5kU2Vuc2l0aXZpdHkpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBFTkRfU0VOU0lUSVZJVFlfTE9XLlxuICAgICAqL1xuICAgIEVuZFNlbnNpdGl2aXR5W1wiRU5EX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIGVuZHMgc3BlZWNoIG1vcmUgb2Z0ZW4uXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfSElHSFwiXSA9IFwiRU5EX1NFTlNJVElWSVRZX0hJR0hcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIGVuZHMgc3BlZWNoIGxlc3Mgb2Z0ZW4uXG4gICAgICovXG4gICAgRW5kU2Vuc2l0aXZpdHlbXCJFTkRfU0VOU0lUSVZJVFlfTE9XXCJdID0gXCJFTkRfU0VOU0lUSVZJVFlfTE9XXCI7XG59KShFbmRTZW5zaXRpdml0eSB8fCAoRW5kU2Vuc2l0aXZpdHkgPSB7fSkpO1xuLyoqIFRoZSBkaWZmZXJlbnQgd2F5cyBvZiBoYW5kbGluZyB1c2VyIGFjdGl2aXR5LiAqL1xudmFyIEFjdGl2aXR5SGFuZGxpbmc7XG4oZnVuY3Rpb24gKEFjdGl2aXR5SGFuZGxpbmcpIHtcbiAgICAvKipcbiAgICAgKiBJZiB1bnNwZWNpZmllZCwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgYFNUQVJUX09GX0FDVElWSVRZX0lOVEVSUlVQVFNgLlxuICAgICAqL1xuICAgIEFjdGl2aXR5SGFuZGxpbmdbXCJBQ1RJVklUWV9IQU5ETElOR19VTlNQRUNJRklFRFwiXSA9IFwiQUNUSVZJVFlfSEFORExJTkdfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBzdGFydCBvZiBhY3Rpdml0eSB3aWxsIGludGVycnVwdCB0aGUgbW9kZWwncyByZXNwb25zZSAoYWxzbyBjYWxsZWQgXCJiYXJnZSBpblwiKS4gVGhlIG1vZGVsJ3MgY3VycmVudCByZXNwb25zZSB3aWxsIGJlIGN1dC1vZmYgaW4gdGhlIG1vbWVudCBvZiB0aGUgaW50ZXJydXB0aW9uLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIEFjdGl2aXR5SGFuZGxpbmdbXCJTVEFSVF9PRl9BQ1RJVklUWV9JTlRFUlJVUFRTXCJdID0gXCJTVEFSVF9PRl9BQ1RJVklUWV9JTlRFUlJVUFRTXCI7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGVsJ3MgcmVzcG9uc2Ugd2lsbCBub3QgYmUgaW50ZXJydXB0ZWQuXG4gICAgICovXG4gICAgQWN0aXZpdHlIYW5kbGluZ1tcIk5PX0lOVEVSUlVQVElPTlwiXSA9IFwiTk9fSU5URVJSVVBUSU9OXCI7XG59KShBY3Rpdml0eUhhbmRsaW5nIHx8IChBY3Rpdml0eUhhbmRsaW5nID0ge30pKTtcbi8qKiBPcHRpb25zIGFib3V0IHdoaWNoIGlucHV0IGlzIGluY2x1ZGVkIGluIHRoZSB1c2VyJ3MgdHVybi4gKi9cbnZhciBUdXJuQ292ZXJhZ2U7XG4oZnVuY3Rpb24gKFR1cm5Db3ZlcmFnZSkge1xuICAgIC8qKlxuICAgICAqIElmIHVuc3BlY2lmaWVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBgVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZYC5cbiAgICAgKi9cbiAgICBUdXJuQ292ZXJhZ2VbXCJUVVJOX0NPVkVSQUdFX1VOU1BFQ0lGSUVEXCJdID0gXCJUVVJOX0NPVkVSQUdFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXJzIHR1cm4gb25seSBpbmNsdWRlcyBhY3Rpdml0eSBzaW5jZSB0aGUgbGFzdCB0dXJuLCBleGNsdWRpbmcgaW5hY3Rpdml0eSAoZS5nLiBzaWxlbmNlIG9uIHRoZSBhdWRpbyBzdHJlYW0pLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIFR1cm5Db3ZlcmFnZVtcIlRVUk5fSU5DTFVERVNfT05MWV9BQ1RJVklUWVwiXSA9IFwiVFVSTl9JTkNMVURFU19PTkxZX0FDVElWSVRZXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXJzIHR1cm4gaW5jbHVkZXMgYWxsIHJlYWx0aW1lIGlucHV0IHNpbmNlIHRoZSBsYXN0IHR1cm4sIGluY2x1ZGluZyBpbmFjdGl2aXR5IChlLmcuIHNpbGVuY2Ugb24gdGhlIGF1ZGlvIHN0cmVhbSkuXG4gICAgICovXG4gICAgVHVybkNvdmVyYWdlW1wiVFVSTl9JTkNMVURFU19BTExfSU5QVVRcIl0gPSBcIlRVUk5fSU5DTFVERVNfQUxMX0lOUFVUXCI7XG59KShUdXJuQ292ZXJhZ2UgfHwgKFR1cm5Db3ZlcmFnZSA9IHt9KSk7XG4vKiogU3BlY2lmaWVzIGhvdyB0aGUgcmVzcG9uc2Ugc2hvdWxkIGJlIHNjaGVkdWxlZCBpbiB0aGUgY29udmVyc2F0aW9uLiAqL1xudmFyIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nO1xuKGZ1bmN0aW9uIChGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZykge1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiU0NIRURVTElOR19VTlNQRUNJRklFRFwiXSA9IFwiU0NIRURVTElOR19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE9ubHkgYWRkIHRoZSByZXN1bHQgdG8gdGhlIGNvbnZlcnNhdGlvbiBjb250ZXh0LCBkbyBub3QgaW50ZXJydXB0IG9yIHRyaWdnZXIgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIlNJTEVOVFwiXSA9IFwiU0lMRU5UXCI7XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSByZXN1bHQgdG8gdGhlIGNvbnZlcnNhdGlvbiBjb250ZXh0LCBhbmQgcHJvbXB0IHRvIGdlbmVyYXRlIG91dHB1dCB3aXRob3V0IGludGVycnVwdGluZyBvbmdvaW5nIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJXSEVOX0lETEVcIl0gPSBcIldIRU5fSURMRVwiO1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgcmVzdWx0IHRvIHRoZSBjb252ZXJzYXRpb24gY29udGV4dCwgaW50ZXJydXB0IG9uZ29pbmcgZ2VuZXJhdGlvbiBhbmQgcHJvbXB0IHRvIGdlbmVyYXRlIG91dHB1dC5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIklOVEVSUlVQVFwiXSA9IFwiSU5URVJSVVBUXCI7XG59KShGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZyB8fCAoRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmcgPSB7fSkpO1xuLyoqIFNjYWxlIG9mIHRoZSBnZW5lcmF0ZWQgbXVzaWMuICovXG52YXIgU2NhbGU7XG4oZnVuY3Rpb24gKFNjYWxlKSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZS4gVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgU2NhbGVbXCJTQ0FMRV9VTlNQRUNJRklFRFwiXSA9IFwiU0NBTEVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBDIG1ham9yIG9yIEEgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJDX01BSk9SX0FfTUlOT1JcIl0gPSBcIkNfTUFKT1JfQV9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIERiIG1ham9yIG9yIEJiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiRF9GTEFUX01BSk9SX0JfRkxBVF9NSU5PUlwiXSA9IFwiRF9GTEFUX01BSk9SX0JfRkxBVF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEQgbWFqb3Igb3IgQiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkRfTUFKT1JfQl9NSU5PUlwiXSA9IFwiRF9NQUpPUl9CX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRWIgbWFqb3Igb3IgQyBtaW5vclxuICAgICAqL1xuICAgIFNjYWxlW1wiRV9GTEFUX01BSk9SX0NfTUlOT1JcIl0gPSBcIkVfRkxBVF9NQUpPUl9DX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRSBtYWpvciBvciBEYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkVfTUFKT1JfRF9GTEFUX01JTk9SXCJdID0gXCJFX01BSk9SX0RfRkxBVF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEYgbWFqb3Igb3IgRCBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkZfTUFKT1JfRF9NSU5PUlwiXSA9IFwiRl9NQUpPUl9EX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogR2IgbWFqb3Igb3IgRWIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJHX0ZMQVRfTUFKT1JfRV9GTEFUX01JTk9SXCJdID0gXCJHX0ZMQVRfTUFKT1JfRV9GTEFUX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogRyBtYWpvciBvciBFIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiR19NQUpPUl9FX01JTk9SXCJdID0gXCJHX01BSk9SX0VfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBBYiBtYWpvciBvciBGIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQV9GTEFUX01BSk9SX0ZfTUlOT1JcIl0gPSBcIkFfRkxBVF9NQUpPUl9GX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQSBtYWpvciBvciBHYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkFfTUFKT1JfR19GTEFUX01JTk9SXCJdID0gXCJBX01BSk9SX0dfRkxBVF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEJiIG1ham9yIG9yIEcgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJCX0ZMQVRfTUFKT1JfR19NSU5PUlwiXSA9IFwiQl9GTEFUX01BSk9SX0dfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBCIG1ham9yIG9yIEFiIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQl9NQUpPUl9BX0ZMQVRfTUlOT1JcIl0gPSBcIkJfTUFKT1JfQV9GTEFUX01JTk9SXCI7XG59KShTY2FsZSB8fCAoU2NhbGUgPSB7fSkpO1xuLyoqIFRoZSBtb2RlIG9mIG11c2ljIGdlbmVyYXRpb24uICovXG52YXIgTXVzaWNHZW5lcmF0aW9uTW9kZTtcbihmdW5jdGlvbiAoTXVzaWNHZW5lcmF0aW9uTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFJlbHkgb24gdGhlIHNlcnZlciBkZWZhdWx0IGdlbmVyYXRpb24gbW9kZS5cbiAgICAgKi9cbiAgICBNdXNpY0dlbmVyYXRpb25Nb2RlW1wiTVVTSUNfR0VORVJBVElPTl9NT0RFX1VOU1BFQ0lGSUVEXCJdID0gXCJNVVNJQ19HRU5FUkFUSU9OX01PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBTdGVlciB0ZXh0IHByb21wdHMgdG8gcmVnaW9ucyBvZiBsYXRlbnQgc3BhY2Ugd2l0aCBoaWdoZXIgcXVhbGl0eVxuICAgICAgICBtdXNpYy5cbiAgICAgKi9cbiAgICBNdXNpY0dlbmVyYXRpb25Nb2RlW1wiUVVBTElUWVwiXSA9IFwiUVVBTElUWVwiO1xuICAgIC8qKlxuICAgICAqIFN0ZWVyIHRleHQgcHJvbXB0cyB0byByZWdpb25zIG9mIGxhdGVudCBzcGFjZSB3aXRoIGEgbGFyZ2VyXG4gICAgICAgIGRpdmVyc2l0eSBvZiBtdXNpYy5cbiAgICAgKi9cbiAgICBNdXNpY0dlbmVyYXRpb25Nb2RlW1wiRElWRVJTSVRZXCJdID0gXCJESVZFUlNJVFlcIjtcbiAgICAvKipcbiAgICAgKiBTdGVlciB0ZXh0IHByb21wdHMgdG8gcmVnaW9ucyBvZiBsYXRlbnQgc3BhY2UgbW9yZSBsaWtlbHkgdG9cbiAgICAgICAgZ2VuZXJhdGUgbXVzaWMgd2l0aCB2b2NhbHMuXG4gICAgICovXG4gICAgTXVzaWNHZW5lcmF0aW9uTW9kZVtcIlZPQ0FMSVpBVElPTlwiXSA9IFwiVk9DQUxJWkFUSU9OXCI7XG59KShNdXNpY0dlbmVyYXRpb25Nb2RlIHx8IChNdXNpY0dlbmVyYXRpb25Nb2RlID0ge30pKTtcbi8qKiBUaGUgcGxheWJhY2sgY29udHJvbCBzaWduYWwgdG8gYXBwbHkgdG8gdGhlIG11c2ljIGdlbmVyYXRpb24uICovXG52YXIgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sO1xuKGZ1bmN0aW9uIChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJQTEFZQkFDS19DT05UUk9MX1VOU1BFQ0lGSUVEXCJdID0gXCJQTEFZQkFDS19DT05UUk9MX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogU3RhcnQgZ2VuZXJhdGluZyB0aGUgbXVzaWMuXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiUExBWVwiXSA9IFwiUExBWVwiO1xuICAgIC8qKlxuICAgICAqIEhvbGQgdGhlIG11c2ljIGdlbmVyYXRpb24uIFVzZSBQTEFZIHRvIHJlc3VtZSBmcm9tIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlBBVVNFXCJdID0gXCJQQVVTRVwiO1xuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIG11c2ljIGdlbmVyYXRpb24gYW5kIHJlc2V0IHRoZSBjb250ZXh0IChwcm9tcHRzIHJldGFpbmVkKS5cbiAgICAgICAgVXNlIFBMQVkgdG8gcmVzdGFydCB0aGUgbXVzaWMgZ2VuZXJhdGlvbi5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJTVE9QXCJdID0gXCJTVE9QXCI7XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGNvbnRleHQgb2YgdGhlIG11c2ljIGdlbmVyYXRpb24gd2l0aG91dCBzdG9wcGluZyBpdC5cbiAgICAgICAgUmV0YWlucyB0aGUgY3VycmVudCBwcm9tcHRzIGFuZCBjb25maWcuXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiUkVTRVRfQ09OVEVYVFwiXSA9IFwiUkVTRVRfQ09OVEVYVFwiO1xufSkoTGl2ZU11c2ljUGxheWJhY2tDb250cm9sIHx8IChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wgPSB7fSkpO1xuLyoqIEEgZnVuY3Rpb24gcmVzcG9uc2UuICovXG5jbGFzcyBGdW5jdGlvblJlc3BvbnNlIHtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBVUklgIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21VcmkodXJpLCBtaW1lVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVEYXRhOiB7XG4gICAgICAgICAgICBmaWxlVXJpOiB1cmksXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGB0ZXh0YCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYEZ1bmN0aW9uQ2FsbGAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uQ2FsbChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVuY3Rpb25DYWxsOiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYEZ1bmN0aW9uUmVzcG9uc2VgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21GdW5jdGlvblJlc3BvbnNlKGlkLCBuYW1lLCByZXNwb25zZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBiYXNlNjRgIGVuY29kZWQgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tQmFzZTY0KGRhdGEsIG1pbWVUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5saW5lRGF0YToge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIHRoZSBgb3V0Y29tZWAgYW5kIGBvdXRwdXRgIG9mIGEgYENvZGVFeGVjdXRpb25SZXN1bHRgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KG91dGNvbWUsIG91dHB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVFeGVjdXRpb25SZXN1bHQ6IHtcbiAgICAgICAgICAgIG91dGNvbWU6IG91dGNvbWUsXG4gICAgICAgICAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIHRoZSBgY29kZWAgYW5kIGBsYW5ndWFnZWAgb2YgYW4gYEV4ZWN1dGFibGVDb2RlYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tRXhlY3V0YWJsZUNvZGUoY29kZSwgbGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBleGVjdXRhYmxlQ29kZToge1xuICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gX2lzUGFydChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAoJ2ZpbGVEYXRhJyBpbiBvYmogfHxcbiAgICAgICAgICAgICd0ZXh0JyBpbiBvYmogfHxcbiAgICAgICAgICAgICdmdW5jdGlvbkNhbGwnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2lubGluZURhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyBpbiBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGlmICh0eXBlb2YgcGFydE9yU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJ0cy5wdXNoKGNyZWF0ZVBhcnRGcm9tVGV4dChwYXJ0T3JTdHJpbmcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzUGFydChwYXJ0T3JTdHJpbmcpKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGFydE9yU3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJ0T3JTdHJpbmcpKSB7XG4gICAgICAgIGlmIChwYXJ0T3JTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRPclN0cmluZyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydE9yU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChjcmVhdGVQYXJ0RnJvbVRleHQocGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2lzUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgaW4gUGFydFVuaW9uIG11c3QgYmUgYSBQYXJ0IG9iamVjdCBvciBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0T3JTdHJpbmcgbXVzdCBiZSBhIFBhcnQgb2JqZWN0LCBzdHJpbmcsIG9yIGFycmF5Jyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBDb250ZW50YCBvYmplY3Qgd2l0aCBhIHVzZXIgcm9sZSBmcm9tIGEgYFBhcnRMaXN0VW5pb25gIG9iamVjdCBvciBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVXNlckNvbnRlbnQocGFydE9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBwYXJ0czogX3RvUGFydHMocGFydE9yU3RyaW5nKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYENvbnRlbnRgIG9iamVjdCB3aXRoIGEgbW9kZWwgcm9sZSBmcm9tIGEgYFBhcnRMaXN0VW5pb25gIG9iamVjdCBvciBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kZWxDb250ZW50KHBhcnRPclN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICdtb2RlbCcsXG4gICAgICAgIHBhcnRzOiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpLFxuICAgIH07XG59XG4vKiogQSB3cmFwcGVyIGNsYXNzIGZvciB0aGUgaHR0cCByZXNwb25zZS4gKi9cbmNsYXNzIEh0dHBSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgaGVhZGVycy5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIC8vIEtlZXAgdGhlIG9yaWdpbmFsIHJlc3BvbnNlLlxuICAgICAgICB0aGlzLnJlc3BvbnNlSW50ZXJuYWwgPSByZXNwb25zZTtcbiAgICB9XG4gICAganNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VJbnRlcm5hbC5qc29uKCk7XG4gICAgfVxufVxuLyoqIENvbnRlbnQgZmlsdGVyIHJlc3VsdHMgZm9yIGEgcHJvbXB0IHNlbnQgaW4gdGhlIHJlcXVlc3QuICovXG5jbGFzcyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVByb21wdEZlZWRiYWNrIHtcbn1cbi8qKiBVc2FnZSBtZXRhZGF0YSBhYm91dCByZXNwb25zZShzKS4gKi9cbmNsYXNzIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlVXNhZ2VNZXRhZGF0YSB7XG59XG4vKiogUmVzcG9uc2UgbWVzc2FnZSBmb3IgUHJlZGljdGlvblNlcnZpY2UuR2VuZXJhdGVDb250ZW50LiAqL1xuY2xhc3MgR2VuZXJhdGVDb250ZW50UmVzcG9uc2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgdGV4dCBmcm9tIHRoZSBmaXJzdFxuICAgICAqIG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgdGhvdWdodCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgZXhjbHVkaW5nIHRoZSB0aG91Z2h0IHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICBjb250ZW50czpcbiAgICAgKiAgICAgJ1doeSBpcyB0aGUgc2t5IGJsdWU/JyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UudGV4dCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgdGV4dCBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgbGV0IGFueVRleHRQYXJ0VGV4dCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBub25UZXh0UGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICd0ZXh0JyAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgIT09ICd0aG91Z2h0JyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmllbGRWYWx1ZSAhPT0gbnVsbCB8fCBmaWVsZFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vblRleHRQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LnRob3VnaHQgPT09ICdib29sZWFuJyAmJiBwYXJ0LnRob3VnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueVRleHRQYXJ0VGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vblRleHRQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyAke25vblRleHRQYXJ0c30gaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dCBwYXJ0cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBub24gdGV4dCBwYXJ0cyBmb3IgYSBmdWxsIHJlc3BvbnNlIGZyb20gbW9kZWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFydC50ZXh0ID09PSAnJyBpcyBkaWZmZXJlbnQgZnJvbSBwYXJ0LnRleHQgaXMgbnVsbFxuICAgICAgICByZXR1cm4gYW55VGV4dFBhcnRUZXh0ID8gdGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlXG4gICAgICogaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBpbmxpbmUgZGF0YSBmcm9tIHRoZVxuICAgICAqIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGVyZSBhcmUgbm9uLWlubGluZSBkYXRhIHBhcnRzIGluIHRoZVxuICAgICAqIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kXG4gICAgICogYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGdldCBkYXRhKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGRhdGEgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gJyc7XG4gICAgICAgIGNvbnN0IG5vbkRhdGFQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ2lubGluZURhdGEnICYmXG4gICAgICAgICAgICAgICAgICAgIChmaWVsZFZhbHVlICE9PSBudWxsIHx8IGZpZWxkVmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uRGF0YVBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydC5pbmxpbmVEYXRhICYmIHR5cGVvZiBwYXJ0LmlubGluZURhdGEuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkYXRhICs9IGF0b2IocGFydC5pbmxpbmVEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25EYXRhUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLWRhdGEgcGFydHMgJHtub25EYXRhUGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIGRhdGEgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIGRhdGEgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBidG9hKGRhdGEpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBmdW5jdGlvbiBjYWxscyBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBmdW5jdGlvbiBjYWxscyBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNvbnRyb2xMaWdodEZ1bmN0aW9uRGVjbGFyYXRpb246IEZ1bmN0aW9uRGVjbGFyYXRpb24gPSB7XG4gICAgICogICBuYW1lOiAnY29udHJvbExpZ2h0JyxcbiAgICAgKiAgIHBhcmFtZXRlcnM6IHtcbiAgICAgKiAgIHR5cGU6IFR5cGUuT0JKRUNULFxuICAgICAqICAgZGVzY3JpcHRpb246ICdTZXQgdGhlIGJyaWdodG5lc3MgYW5kIGNvbG9yIHRlbXBlcmF0dXJlIG9mIGEgcm9vbSBsaWdodC4nLFxuICAgICAqICAgcHJvcGVydGllczoge1xuICAgICAqICAgICBicmlnaHRuZXNzOiB7XG4gICAgICogICAgICAgdHlwZTogVHlwZS5OVU1CRVIsXG4gICAgICogICAgICAgZGVzY3JpcHRpb246XG4gICAgICogICAgICAgICAnTGlnaHQgbGV2ZWwgZnJvbSAwIHRvIDEwMC4gWmVybyBpcyBvZmYgYW5kIDEwMCBpcyBmdWxsIGJyaWdodG5lc3MuJyxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgY29sb3JUZW1wZXJhdHVyZToge1xuICAgICAqICAgICAgIHR5cGU6IFR5cGUuU1RSSU5HLFxuICAgICAqICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAqICAgICAgICAgJ0NvbG9yIHRlbXBlcmF0dXJlIG9mIHRoZSBsaWdodCBmaXh0dXJlIHdoaWNoIGNhbiBiZSBgZGF5bGlnaHRgLCBgY29vbGAgb3IgYHdhcm1gLicsXG4gICAgICogICAgIH0sXG4gICAgICogICB9LFxuICAgICAqICAgcmVxdWlyZWQ6IFsnYnJpZ2h0bmVzcycsICdjb2xvclRlbXBlcmF0dXJlJ10sXG4gICAgICogIH07XG4gICAgICogIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICAgIGNvbnRlbnRzOiAnRGltIHRoZSBsaWdodHMgc28gdGhlIHJvb20gZmVlbHMgY296eSBhbmQgd2FybS4nLFxuICAgICAqICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICB0b29sczogW3tmdW5jdGlvbkRlY2xhcmF0aW9uczogW2NvbnRyb2xMaWdodEZ1bmN0aW9uRGVjbGFyYXRpb25dfV0sXG4gICAgICogICAgICAgdG9vbENvbmZpZzoge1xuICAgICAqICAgICAgICAgZnVuY3Rpb25DYWxsaW5nQ29uZmlnOiB7XG4gICAgICogICAgICAgICAgIG1vZGU6IEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUuQU5ZLFxuICAgICAqICAgICAgICAgICBhbGxvd2VkRnVuY3Rpb25OYW1lczogWydjb250cm9sTGlnaHQnXSxcbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIH0pO1xuICAgICAqICBjb25zb2xlLmRlYnVnKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZnVuY3Rpb25DYWxscygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxscyA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmZ1bmN0aW9uQ2FsbCkubWFwKChwYXJ0KSA9PiBwYXJ0LmZ1bmN0aW9uQ2FsbCkuZmlsdGVyKChmdW5jdGlvbkNhbGwpID0+IGZ1bmN0aW9uQ2FsbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKChmdW5jdGlvbkNhbGxzID09PSBudWxsIHx8IGZ1bmN0aW9uQ2FsbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZ1bmN0aW9uQ2FsbHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgZXhlY3V0YWJsZSBjb2RlIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGV4ZWN1dGFibGUgY29kZSBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBleGVjdXRhYmxlIGNvZGUgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaGF0IGlzIHRoZSBzdW0gb2YgdGhlIGZpcnN0IDUwIHByaW1lIG51bWJlcnM/IEdlbmVyYXRlIGFuZCBydW4gY29kZSBmb3IgdGhlIGNhbGN1bGF0aW9uLCBhbmQgbWFrZSBzdXJlIHlvdSBnZXQgYWxsIDUwLidcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICB0b29sczogW3tjb2RlRXhlY3V0aW9uOiB7fX1dLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UuZXhlY3V0YWJsZUNvZGUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBleGVjdXRhYmxlQ29kZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgZXhlY3V0YWJsZSBjb2RlIGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGVjdXRhYmxlQ29kZSA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmV4ZWN1dGFibGVDb2RlKS5tYXAoKHBhcnQpID0+IHBhcnQuZXhlY3V0YWJsZUNvZGUpLmZpbHRlcigoZXhlY3V0YWJsZUNvZGUpID0+IGV4ZWN1dGFibGVDb2RlICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKGV4ZWN1dGFibGVDb2RlID09PSBudWxsIHx8IGV4ZWN1dGFibGVDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGVjdXRhYmxlQ29kZS5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2ogPSBleGVjdXRhYmxlQ29kZSA9PT0gbnVsbCB8fCBleGVjdXRhYmxlQ29kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhlY3V0YWJsZUNvZGVbMF0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5jb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29kZSBleGVjdXRpb24gcmVzdWx0IGZyb21cbiAgICAgKiB0aGUgZmlyc3Qgb25lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaGF0IGlzIHRoZSBzdW0gb2YgdGhlIGZpcnN0IDUwIHByaW1lIG51bWJlcnM/IEdlbmVyYXRlIGFuZCBydW4gY29kZSBmb3IgdGhlIGNhbGN1bGF0aW9uLCBhbmQgbWFrZSBzdXJlIHlvdSBnZXQgYWxsIDUwLidcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICB0b29sczogW3tjb2RlRXhlY3V0aW9uOiB7fX1dLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UuY29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGNvZGVFeGVjdXRpb25SZXN1bHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZUV4ZWN1dGlvblJlc3VsdCA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmNvZGVFeGVjdXRpb25SZXN1bHQpLm1hcCgocGFydCkgPT4gcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0KS5maWx0ZXIoKGNvZGVFeGVjdXRpb25SZXN1bHQpID0+IGNvZGVFeGVjdXRpb25SZXN1bHQgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgoY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gbnVsbCB8fCBjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlRXhlY3V0aW9uUmVzdWx0Lmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfaiA9IGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IG51bGwgfHwgY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29kZUV4ZWN1dGlvblJlc3VsdFswXSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLm91dHB1dDtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBlbWJlZF9jb250ZW50IG1ldGhvZC4gKi9cbmNsYXNzIEVtYmVkQ29udGVudFJlc3BvbnNlIHtcbn1cbi8qKiBUaGUgb3V0cHV0IGltYWdlcyByZXNwb25zZS4gKi9cbmNsYXNzIEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgcmVxdWVzdCB0byBlZGl0IGFuIGltYWdlLiAqL1xuY2xhc3MgRWRpdEltYWdlUmVzcG9uc2Uge1xufVxuY2xhc3MgVXBzY2FsZUltYWdlUmVzcG9uc2Uge1xufVxuLyoqIFRoZSBvdXRwdXQgaW1hZ2VzIHJlc3BvbnNlLiAqL1xuY2xhc3MgUmVjb250ZXh0SW1hZ2VSZXNwb25zZSB7XG59XG4vKiogVGhlIG91dHB1dCBpbWFnZXMgcmVzcG9uc2UuICovXG5jbGFzcyBTZWdtZW50SW1hZ2VSZXNwb25zZSB7XG59XG5jbGFzcyBMaXN0TW9kZWxzUmVzcG9uc2Uge1xufVxuY2xhc3MgRGVsZXRlTW9kZWxSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIGNvdW50aW5nIHRva2Vucy4gKi9cbmNsYXNzIENvdW50VG9rZW5zUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciBjb21wdXRpbmcgdG9rZW5zLiAqL1xuY2xhc3MgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSB3aXRoIGdlbmVyYXRlZCB2aWRlb3MuICovXG5jbGFzcyBHZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgdHVuaW5nIGpvYnMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSB7XG59XG4vKiogRW1wdHkgcmVzcG9uc2UgZm9yIGNhY2hlcy5kZWxldGUgbWV0aG9kLiAqL1xuY2xhc3MgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlIHtcbn1cbmNsYXNzIExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgZmlsZXMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdEZpbGVzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgY3JlYXRlIGZpbGUgbWV0aG9kLiAqL1xuY2xhc3MgQ3JlYXRlRmlsZVJlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGRlbGV0ZSBmaWxlIG1ldGhvZC4gKi9cbmNsYXNzIERlbGV0ZUZpbGVSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgaW5saW5lZF9yZXNwb25zZXNgIHBhcmFtZXRlci4gKi9cbmNsYXNzIElubGluZWRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBiYXRjaGVzLmxpc3QgcmV0dXJuIHZhbHVlLiAqL1xuY2xhc3MgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXByZXNlbnRzIGEgc2luZ2xlIHJlc3BvbnNlIGluIGEgcmVwbGF5LiAqL1xuY2xhc3MgUmVwbGF5UmVzcG9uc2Uge1xufVxuLyoqIEEgcmF3IHJlZmVyZW5jZSBpbWFnZS5cblxuICBBIHJhdyByZWZlcmVuY2UgaW1hZ2UgcmVwcmVzZW50cyB0aGUgYmFzZSBpbWFnZSB0byBlZGl0LCBwcm92aWRlZCBieSB0aGUgdXNlci5cbiAgSXQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQgaW4gYWRkaXRpb24gdG8gYSBtYXNrIHJlZmVyZW5jZSBpbWFnZSBvclxuICBhIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cbiAgICovXG5jbGFzcyBSYXdSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfUkFXJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBtYXNrIHJlZmVyZW5jZSBpbWFnZS5cblxuICBUaGlzIGVuY2Fwc3VsYXRlcyBlaXRoZXIgYSBtYXNrIGltYWdlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGFuZCBjb25maWdzIGZvclxuICB0aGUgdXNlciBwcm92aWRlZCBtYXNrLCBvciBvbmx5IGNvbmZpZyBwYXJhbWV0ZXJzIGZvciB0aGUgbW9kZWwgdG8gZ2VuZXJhdGVcbiAgYSBtYXNrLlxuXG4gIEEgbWFzayBpbWFnZSBpcyBhbiBpbWFnZSB3aG9zZSBub24temVybyB2YWx1ZXMgaW5kaWNhdGUgd2hlcmUgdG8gZWRpdCB0aGUgYmFzZVxuICBpbWFnZS4gSWYgdGhlIHVzZXIgcHJvdmlkZXMgYSBtYXNrIGltYWdlLCB0aGUgbWFzayBtdXN0IGJlIGluIHRoZSBzYW1lXG4gIGRpbWVuc2lvbnMgYXMgdGhlIHJhdyBpbWFnZS5cbiAgICovXG5jbGFzcyBNYXNrUmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX01BU0snLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIG1hc2tJbWFnZUNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBjb250cm9sIHJlZmVyZW5jZSBpbWFnZS5cblxuICBUaGUgaW1hZ2Ugb2YgdGhlIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlIGlzIGVpdGhlciBhIGNvbnRyb2wgaW1hZ2UgcHJvdmlkZWRcbiAgYnkgdGhlIHVzZXIsIG9yIGEgcmVndWxhciBpbWFnZSB3aGljaCB0aGUgYmFja2VuZCB3aWxsIHVzZSB0byBnZW5lcmF0ZSBhXG4gIGNvbnRyb2wgaW1hZ2Ugb2YuIEluIHRoZSBjYXNlIG9mIHRoZSBsYXR0ZXIsIHRoZVxuICBlbmFibGVfY29udHJvbF9pbWFnZV9jb21wdXRhdGlvbiBmaWVsZCBpbiB0aGUgY29uZmlnIHNob3VsZCBiZSBzZXQgdG8gVHJ1ZS5cblxuICBBIGNvbnRyb2wgaW1hZ2UgaXMgYW4gaW1hZ2UgdGhhdCByZXByZXNlbnRzIGEgc2tldGNoIGltYWdlIG9mIGFyZWFzIGZvciB0aGVcbiAgbW9kZWwgdG8gZmlsbCBpbiBiYXNlZCBvbiB0aGUgcHJvbXB0LlxuICAgKi9cbmNsYXNzIENvbnRyb2xSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfQ09OVFJPTCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgY29udHJvbEltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cblxuICBUaGlzIGVuY2Fwc3VsYXRlcyBhIHN0eWxlIHJlZmVyZW5jZSBpbWFnZSBwcm92aWRlZCBieSB0aGUgdXNlciwgYW5kXG4gIGFkZGl0aW9uYWxseSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cblxuICBBIHJhdyByZWZlcmVuY2UgaW1hZ2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgYSBkZXN0aW5hdGlvbiBmb3IgdGhlIHN0eWxlIHRvXG4gIGJlIGFwcGxpZWQgdG8uXG4gICAqL1xuY2xhc3MgU3R5bGVSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfU1RZTEUnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIHN0eWxlSW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UuXG5cbiAgVGhpcyBlbmNhcHN1bGF0ZXMgYSBzdWJqZWN0IHJlZmVyZW5jZSBpbWFnZSBwcm92aWRlZCBieSB0aGUgdXNlciwgYW5kXG4gIGFkZGl0aW9uYWxseSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLlxuXG4gIEEgcmF3IHJlZmVyZW5jZSBpbWFnZSBjYW4gYWxzbyBiZSBwcm92aWRlZCBhcyBhIGRlc3RpbmF0aW9uIGZvciB0aGUgc3ViamVjdCB0b1xuICBiZSBhcHBsaWVkIHRvLlxuICAgKi9cbmNsYXNzIFN1YmplY3RSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9TVUJKRUNUJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBzdWJqZWN0SW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIFJlc3BvbnNlIG1lc3NhZ2UgZm9yIEFQSSBjYWxsLiAqL1xuY2xhc3MgTGl2ZVNlcnZlck1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzIGluIHRoZSByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHRcbiAgICAgKiBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmQgYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgbGV0IGFueVRleHRQYXJ0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9uVGV4dFBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnNlcnZlckNvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlbFR1cm4pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXJ0cykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFydCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSAndGV4dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lICE9PSAndGhvdWdodCcgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBub25UZXh0UGFydHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50aG91Z2h0ID09PSAnYm9vbGVhbicgJiYgcGFydC50aG91Z2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbnlUZXh0UGFydEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uVGV4dFBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi10ZXh0IHBhcnRzICR7bm9uVGV4dFBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiB0ZXh0IHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJ0LnRleHQgPT09ICcnIGlzIGRpZmZlcmVudCBmcm9tIHBhcnQudGV4dCBpcyBudWxsXG4gICAgICAgIHJldHVybiBhbnlUZXh0UGFydEZvdW5kID8gdGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG5vbi1pbmxpbmUgZGF0YSBwYXJ0cyBpbiB0aGVcbiAgICAgKiByZXNwb25zZSwgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQsIGFuZFxuICAgICAqIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCBkYXRhID0gJyc7XG4gICAgICAgIGNvbnN0IG5vbkRhdGFQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9jID0gKF9iID0gKF9hID0gdGhpcy5zZXJ2ZXJDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kZWxUdXJuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFydHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ2lubGluZURhdGEnICYmIGZpZWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uRGF0YVBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydC5pbmxpbmVEYXRhICYmIHR5cGVvZiBwYXJ0LmlubGluZURhdGEuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkYXRhICs9IGF0b2IocGFydC5pbmxpbmVEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25EYXRhUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLWRhdGEgcGFydHMgJHtub25EYXRhUGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIGRhdGEgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIGRhdGEgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBidG9hKGRhdGEpIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKiBBIHZpZGVvIGdlbmVyYXRpb24gbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi4gKi9cbmNsYXNzIEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uIHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYW4gT3BlcmF0aW9uIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIG9uZSBiZWluZyBjYWxsZWQgd2l0aCB0aGUgZmllbGRzIHNldCBmcm9tIHRoZSBBUEkgcmVzcG9uc2UuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2Zyb21BUElSZXNwb25zZSh7IGFwaVJlc3BvbnNlLCBpc1ZlcnRleEFJLCB9KSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG5ldyBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbigpO1xuICAgICAgICBvcGVyYXRpb24ubmFtZSA9IGFwaVJlc3BvbnNlWyduYW1lJ107XG4gICAgICAgIG9wZXJhdGlvbi5tZXRhZGF0YSA9IGFwaVJlc3BvbnNlWydtZXRhZGF0YSddO1xuICAgICAgICBvcGVyYXRpb24uZG9uZSA9IGFwaVJlc3BvbnNlWydkb25lJ107XG4gICAgICAgIG9wZXJhdGlvbi5lcnJvciA9IGFwaVJlc3BvbnNlWydlcnJvciddO1xuICAgICAgICBpZiAoaXNWZXJ0ZXhBSSkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhcGlSZXNwb25zZVsncmVzcG9uc2UnXTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvblJlc3BvbnNlID0gbmV3IEdlbmVyYXRlVmlkZW9zUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVZpZGVvcyA9IHJlc3BvbnNlWyd2aWRlb3MnXTtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25SZXNwb25zZS5nZW5lcmF0ZWRWaWRlb3MgPSByZXNwb25zZVZpZGVvcyA9PT0gbnVsbCB8fCByZXNwb25zZVZpZGVvcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2VWaWRlb3MubWFwKChnZW5lcmF0ZWRWaWRlbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmk6IGdlbmVyYXRlZFZpZGVvWydnY3NVcmknXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0J5dGVzOiBnZW5lcmF0ZWRWaWRlb1snYnl0ZXNCYXNlNjRFbmNvZGVkJ11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0Qnl0ZXMkMShnZW5lcmF0ZWRWaWRlb1snYnl0ZXNCYXNlNjRFbmNvZGVkJ10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBnZW5lcmF0ZWRWaWRlb1snbWltZVR5cGUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uUmVzcG9uc2UucmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gcmVzcG9uc2VbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvblJlc3BvbnNlLnJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gcmVzcG9uc2VbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ107XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnJlc3BvbnNlID0gb3BlcmF0aW9uUmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGFwaVJlc3BvbnNlWydyZXNwb25zZSddO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uUmVzcG9uc2UgPSBuZXcgR2VuZXJhdGVWaWRlb3NSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZFZpZGVvUmVzcG9uc2UgPSByZXNwb25zZVsnZ2VuZXJhdGVWaWRlb1Jlc3BvbnNlJ107XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VWaWRlb3MgPSBnZW5lcmF0ZWRWaWRlb1Jlc3BvbnNlID09PSBudWxsIHx8IGdlbmVyYXRlZFZpZGVvUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZFZpZGVvUmVzcG9uc2VbJ2dlbmVyYXRlZFNhbXBsZXMnXTtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25SZXNwb25zZS5nZW5lcmF0ZWRWaWRlb3MgPSByZXNwb25zZVZpZGVvcyA9PT0gbnVsbCB8fCByZXNwb25zZVZpZGVvcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2VWaWRlb3MubWFwKChnZW5lcmF0ZWRWaWRlbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWRlbyA9IGdlbmVyYXRlZFZpZGVvWyd2aWRlbyddO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmk6IHZpZGVvID09PSBudWxsIHx8IHZpZGVvID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWRlb1sndXJpJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9CeXRlczogKHZpZGVvID09PSBudWxsIHx8IHZpZGVvID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aWRlb1snZW5jb2RlZFZpZGVvJ10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdEJ5dGVzJDEodmlkZW8gPT09IG51bGwgfHwgdmlkZW8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZGVvWydlbmNvZGVkVmlkZW8nXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IGdlbmVyYXRlZFZpZGVvWydlbmNvZGluZyddLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25SZXNwb25zZS5yYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZW5lcmF0ZWRWaWRlb1Jlc3BvbnNlID09PSBudWxsIHx8IGdlbmVyYXRlZFZpZGVvUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZFZpZGVvUmVzcG9uc2VbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvblJlc3BvbnNlLnJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2VuZXJhdGVkVmlkZW9SZXNwb25zZSA9PT0gbnVsbCB8fCBnZW5lcmF0ZWRWaWRlb1Jlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZW5lcmF0ZWRWaWRlb1Jlc3BvbnNlWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5yZXNwb25zZSA9IG9wZXJhdGlvblJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGVyYXRpb247XG4gICAgfVxufVxuLyoqIENsaWVudCBnZW5lcmF0ZWQgcmVzcG9uc2UgdG8gYSBgVG9vbENhbGxgIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlci5cblxuICBJbmRpdmlkdWFsIGBGdW5jdGlvblJlc3BvbnNlYCBvYmplY3RzIGFyZSBtYXRjaGVkIHRvIHRoZSByZXNwZWN0aXZlXG4gIGBGdW5jdGlvbkNhbGxgIG9iamVjdHMgYnkgdGhlIGBpZGAgZmllbGQuXG5cbiAgTm90ZSB0aGF0IGluIHRoZSB1bmFyeSBhbmQgc2VydmVyLXN0cmVhbWluZyBHZW5lcmF0ZUNvbnRlbnQgQVBJcyBmdW5jdGlvblxuICBjYWxsaW5nIGhhcHBlbnMgYnkgZXhjaGFuZ2luZyB0aGUgYENvbnRlbnRgIHBhcnRzLCB3aGlsZSBpbiB0aGUgYmlkaVxuICBHZW5lcmF0ZUNvbnRlbnQgQVBJcyBmdW5jdGlvbiBjYWxsaW5nIGhhcHBlbnMgb3ZlciB0aGlzIGRlZGljYXRlZCBzZXQgb2ZcbiAgbWVzc2FnZXMuXG4gICAqL1xuY2xhc3MgTGl2ZUNsaWVudFRvb2xSZXNwb25zZSB7XG59XG4vKiogUGFyYW1ldGVycyBmb3Igc2VuZGluZyB0b29sIHJlc3BvbnNlcyB0byB0aGUgbGl2ZSBBUEkuICovXG5jbGFzcyBMaXZlU2VuZFRvb2xSZXNwb25zZVBhcmFtZXRlcnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiogVG9vbCByZXNwb25zZXMgdG8gc2VuZCB0byB0aGUgc2Vzc2lvbi4gKi9cbiAgICAgICAgdGhpcy5mdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBtZXNzYWdlIGZvciB0aGUgTGl2ZU11c2ljQ2xpZW50TWVzc2FnZSBjYWxsLiAqL1xuY2xhc3MgTGl2ZU11c2ljU2VydmVyTWVzc2FnZSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgYXVkaW8gY2h1bmsgZnJvbSB0aGUgc2VydmVyIGNvbnRlbnQsIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBubyBhdWRpbyBjaHVua3MgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXQgYXVkaW9DaHVuaygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyQ29udGVudCAmJlxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJDb250ZW50LmF1ZGlvQ2h1bmtzICYmXG4gICAgICAgICAgICB0aGlzLnNlcnZlckNvbnRlbnQuYXVkaW9DaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyQ29udGVudC5hdWRpb0NodW5rc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gdE1vZGVsKGFwaUNsaWVudCwgbW9kZWwpIHtcbiAgICBpZiAoIW1vZGVsIHx8IHR5cGVvZiBtb2RlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbCBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSB8fFxuICAgICAgICAgICAgbW9kZWwuc3RhcnRzV2l0aCgncHJvamVjdHMvJykgfHxcbiAgICAgICAgICAgIG1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vZGVsLmluZGV4T2YoJy8nKSA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IG1vZGVsLnNwbGl0KCcvJywgMik7XG4gICAgICAgICAgICByZXR1cm4gYHB1Ymxpc2hlcnMvJHtwYXJ0c1swXX0vbW9kZWxzLyR7cGFydHNbMV19YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgcHVibGlzaGVycy9nb29nbGUvbW9kZWxzLyR7bW9kZWx9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG1vZGVsLnN0YXJ0c1dpdGgoJ21vZGVscy8nKSB8fCBtb2RlbC5zdGFydHNXaXRoKCd0dW5lZE1vZGVscy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBtb2RlbHMvJHttb2RlbH1gO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdENhY2hlc01vZGVsKGFwaUNsaWVudCwgbW9kZWwpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZE1vZGVsID0gdE1vZGVsKGFwaUNsaWVudCwgbW9kZWwpO1xuICAgIGlmICghdHJhbnNmb3JtZWRNb2RlbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1lZE1vZGVsLnN0YXJ0c1dpdGgoJ3B1Ymxpc2hlcnMvJykgJiYgYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAvLyB2ZXJ0ZXggY2FjaGVzIG9ubHkgc3VwcG9ydCBtb2RlbCBuYW1lIHN0YXJ0IHdpdGggcHJvamVjdHMuXG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHthcGlDbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHthcGlDbGllbnQuZ2V0TG9jYXRpb24oKX0vJHt0cmFuc2Zvcm1lZE1vZGVsfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgnbW9kZWxzLycpICYmIGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke2FwaUNsaWVudC5nZXRQcm9qZWN0KCl9L2xvY2F0aW9ucy8ke2FwaUNsaWVudC5nZXRMb2NhdGlvbigpfS9wdWJsaXNoZXJzL2dvb2dsZS8ke3RyYW5zZm9ybWVkTW9kZWx9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZE1vZGVsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRCbG9icyhibG9icykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJsb2JzKSkge1xuICAgICAgICByZXR1cm4gYmxvYnMubWFwKChibG9iKSA9PiB0QmxvYihibG9iKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW3RCbG9iKGJsb2JzKV07XG4gICAgfVxufVxuZnVuY3Rpb24gdEJsb2IoYmxvYikge1xuICAgIGlmICh0eXBlb2YgYmxvYiA9PT0gJ29iamVjdCcgJiYgYmxvYiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgaW5wdXQgYXMgQmxvYi4gVW5zdXBwb3J0ZWQgYmxvYiB0eXBlOiAke3R5cGVvZiBibG9ifWApO1xufVxuZnVuY3Rpb24gdEltYWdlQmxvYihibG9iKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCbG9iID0gdEJsb2IoYmxvYik7XG4gICAgaWYgKHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZSAmJlxuICAgICAgICB0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkQmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtaW1lIHR5cGU6ICR7dHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlfWApO1xufVxuZnVuY3Rpb24gdEF1ZGlvQmxvYihibG9iKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCbG9iID0gdEJsb2IoYmxvYik7XG4gICAgaWYgKHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZSAmJlxuICAgICAgICB0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGUuc3RhcnRzV2l0aCgnYXVkaW8vJykpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkQmxvYjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtaW1lIHR5cGU6ICR7dHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlfWApO1xufVxuZnVuY3Rpb24gdFBhcnQob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fCBvcmlnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnRVbmlvbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcmlnaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7IHRleHQ6IG9yaWdpbiB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQgdHlwZTogJHt0eXBlb2Ygb3JpZ2lufWApO1xufVxuZnVuY3Rpb24gdFBhcnRzKG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHxcbiAgICAgICAgb3JpZ2luID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgKEFycmF5LmlzQXJyYXkob3JpZ2luKSAmJiBvcmlnaW4ubGVuZ3RoID09PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnRMaXN0VW5pb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gb3JpZ2luLm1hcCgoaXRlbSkgPT4gdFBhcnQoaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gW3RQYXJ0KG9yaWdpbildO1xufVxuZnVuY3Rpb24gX2lzQ29udGVudChvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAncGFydHMnIGluIG9yaWdpbiAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KG9yaWdpbi5wYXJ0cykpO1xufVxuZnVuY3Rpb24gX2lzRnVuY3Rpb25DYWxsUGFydChvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnZnVuY3Rpb25DYWxsJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiB0Q29udGVudChvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSBudWxsIHx8IG9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudFVuaW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChfaXNDb250ZW50KG9yaWdpbikpIHtcbiAgICAgICAgLy8gX2lzQ29udGVudCBpcyBhIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlXG4gICAgICAgIC8vIG9yaWdpbiBpcyBhIENvbnRlbnQuXG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgcGFydHM6IHRQYXJ0cyhvcmlnaW4pLFxuICAgIH07XG59XG5mdW5jdGlvbiB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIG9yaWdpbikge1xuICAgIGlmICghb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiYgQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW4uZmxhdE1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHRDb250ZW50KGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQucGFydHMgJiZcbiAgICAgICAgICAgICAgICBjb250ZW50LnBhcnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBjb250ZW50LnBhcnRzWzBdLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbY29udGVudC5wYXJ0c1swXS50ZXh0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRDb250ZW50KG9yaWdpbik7XG4gICAgICAgIGlmIChjb250ZW50LnBhcnRzICYmXG4gICAgICAgICAgICBjb250ZW50LnBhcnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGNvbnRlbnQucGFydHNbMF0udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gW2NvbnRlbnQucGFydHNbMF0udGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW4ubWFwKChpdGVtKSA9PiB0Q29udGVudChpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiBbdENvbnRlbnQob3JpZ2luKV07XG59XG5mdW5jdGlvbiB0Q29udGVudHMob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fFxuICAgICAgICBvcmlnaW4gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShvcmlnaW4pICYmIG9yaWdpbi5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udGVudHMgYXJlIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIC8vIElmIGl0J3Mgbm90IGFuIGFycmF5LCBpdCdzIGEgc2luZ2xlIGNvbnRlbnQgb3IgYSBzaW5nbGUgUGFydFVuaW9uLlxuICAgICAgICBpZiAoX2lzRnVuY3Rpb25DYWxsUGFydChvcmlnaW4pIHx8IF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KG9yaWdpbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gc3BlY2lmeSBmdW5jdGlvbkNhbGwgb3IgZnVuY3Rpb25SZXNwb25zZSBwYXJ0cywgcGxlYXNlIHdyYXAgdGhlbSBpbiBhIENvbnRlbnQgb2JqZWN0LCBzcGVjaWZ5aW5nIHRoZSByb2xlIGZvciB0aGVtJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0Q29udGVudChvcmlnaW4pXTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgYWNjdW11bGF0ZWRQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IGlzQ29udGVudEFycmF5ID0gX2lzQ29udGVudChvcmlnaW5bMF0pO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgaXNDb250ZW50ID0gX2lzQ29udGVudChpdGVtKTtcbiAgICAgICAgaWYgKGlzQ29udGVudCAhPSBpc0NvbnRlbnRBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXhpbmcgQ29udGVudCBhbmQgUGFydHMgaXMgbm90IHN1cHBvcnRlZCwgcGxlYXNlIGdyb3VwIHRoZSBwYXJ0cyBpbnRvIGEgdGhlIGFwcHJvcHJpYXRlIENvbnRlbnQgb2JqZWN0cyBhbmQgc3BlY2lmeSB0aGUgcm9sZXMgZm9yIHRoZW0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBgaXNDb250ZW50YCBjb250YWlucyB0aGUgcmVzdWx0IG9mIF9pc0NvbnRlbnQsIHdoaWNoIGlzIGEgdXRpbGl0eVxuICAgICAgICAgICAgLy8gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGl0ZW0gaXMgYSBDb250ZW50LlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX2lzRnVuY3Rpb25DYWxsUGFydChpdGVtKSB8fCBfaXNGdW5jdGlvblJlc3BvbnNlUGFydChpdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUbyBzcGVjaWZ5IGZ1bmN0aW9uQ2FsbCBvciBmdW5jdGlvblJlc3BvbnNlIHBhcnRzLCBwbGVhc2Ugd3JhcCB0aGVtLCBhbmQgYW55IG90aGVyIHBhcnRzLCBpbiBDb250ZW50IG9iamVjdHMgYXMgYXBwcm9wcmlhdGUsIHNwZWNpZnlpbmcgdGhlIHJvbGUgZm9yIHRoZW0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzQ29udGVudEFycmF5KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHsgcm9sZTogJ3VzZXInLCBwYXJ0czogdFBhcnRzKGFjY3VtdWxhdGVkUGFydHMpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLypcblRyYW5zZm9ybSB0aGUgdHlwZSBmaWVsZCBmcm9tIGFuIGFycmF5IG9mIHR5cGVzIHRvIGFuIGFycmF5IG9mIGFueU9mIGZpZWxkcy5cbkV4YW1wbGU6XG4gIHt0eXBlOiBbJ1NUUklORycsICdOVU1CRVInXX1cbndpbGwgYmUgdHJhbnNmb3JtZWQgdG9cbiAge2FueU9mOiBbe3R5cGU6ICdTVFJJTkcnfSwge3R5cGU6ICdOVU1CRVInfV19XG4qL1xuZnVuY3Rpb24gZmxhdHRlblR5cGVBcnJheVRvQW55T2YodHlwZUxpc3QsIHJlc3VsdGluZ1NjaGVtYSkge1xuICAgIGlmICh0eXBlTGlzdC5pbmNsdWRlcygnbnVsbCcpKSB7XG4gICAgICAgIHJlc3VsdGluZ1NjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGxpc3RXaXRob3V0TnVsbCA9IHR5cGVMaXN0LmZpbHRlcigodHlwZSkgPT4gdHlwZSAhPT0gJ251bGwnKTtcbiAgICBpZiAobGlzdFdpdGhvdXROdWxsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ3R5cGUnXSA9IE9iamVjdC52YWx1ZXMoVHlwZSkuaW5jbHVkZXMobGlzdFdpdGhvdXROdWxsWzBdLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICA/IGxpc3RXaXRob3V0TnVsbFswXS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICA6IFR5cGUuVFlQRV9VTlNQRUNJRklFRDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdGluZ1NjaGVtYVsnYW55T2YnXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgbGlzdFdpdGhvdXROdWxsKSB7XG4gICAgICAgICAgICByZXN1bHRpbmdTY2hlbWFbJ2FueU9mJ10ucHVzaCh7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiBPYmplY3QudmFsdWVzKFR5cGUpLmluY2x1ZGVzKGkudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgICAgICAgICAgPyBpLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgOiBUeXBlLlRZUEVfVU5TUEVDSUZJRUQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NKc29uU2NoZW1hKF9qc29uU2NoZW1hKSB7XG4gICAgY29uc3QgZ2VuQUlTY2hlbWEgPSB7fTtcbiAgICBjb25zdCBzY2hlbWFGaWVsZE5hbWVzID0gWydpdGVtcyddO1xuICAgIGNvbnN0IGxpc3RTY2hlbWFGaWVsZE5hbWVzID0gWydhbnlPZiddO1xuICAgIGNvbnN0IGRpY3RTY2hlbWFGaWVsZE5hbWVzID0gWydwcm9wZXJ0aWVzJ107XG4gICAgaWYgKF9qc29uU2NoZW1hWyd0eXBlJ10gJiYgX2pzb25TY2hlbWFbJ2FueU9mJ10pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIGFuZCBhbnlPZiBjYW5ub3QgYmUgYm90aCBwb3B1bGF0ZWQuJyk7XG4gICAgfVxuICAgIC8qXG4gICAgVGhpcyBpcyB0byBoYW5kbGUgdGhlIG51bGxhYmxlIGFycmF5IG9yIG9iamVjdC4gVGhlIF9qc29uU2NoZW1hIHdpbGxcbiAgICBiZSBpbiB0aGUgZm9ybWF0IG9mIHthbnlPZjogW3t0eXBlOiAnbnVsbCd9LCB7dHlwZTogJ29iamVjdCd9XX0uIFRoZVxuICAgIGxvZ2ljIGlzIHRvIGNoZWNrIGlmIGFueU9mIGhhcyAyIGVsZW1lbnRzIGFuZCBvbmUgb2YgdGhlIGVsZW1lbnQgaXMgbnVsbCxcbiAgICBpZiBzbywgdGhlIGFueU9mIGZpZWxkIGlzIHVubmVjZXNzYXJ5LCBzbyB3ZSBuZWVkIHRvIGdldCByaWQgb2YgdGhlIGFueU9mXG4gICAgZmllbGQgYW5kIG1ha2UgdGhlIHNjaGVtYSBudWxsYWJsZS4gVGhlbiB1c2UgdGhlIG90aGVyIGVsZW1lbnQgYXMgdGhlIG5ld1xuICAgIF9qc29uU2NoZW1hIGZvciBwcm9jZXNzaW5nLiBUaGlzIGlzIGJlY2F1c2UgdGhlIGJhY2tlbmQgZG9lc24ndCBoYXZlIGEgbnVsbFxuICAgIHR5cGUuXG4gICAgVGhpcyBoYXMgdG8gYmUgY2hlY2tlZCBiZWZvcmUgd2UgcHJvY2VzcyBhbnkgb3RoZXIgZmllbGRzLlxuICAgIEZvciBleGFtcGxlOlxuICAgICAgY29uc3Qgb2JqZWN0TnVsbGFibGUgPSB6Lm9iamVjdCh7XG4gICAgICAgIG51bGxhYmxlQXJyYXk6IHouYXJyYXkoei5zdHJpbmcoKSkubnVsbGFibGUoKSxcbiAgICAgIH0pO1xuICAgIFdpbGwgaGF2ZSB0aGUgcmF3IF9qc29uU2NoZW1hIGFzOlxuICAgIHtcbiAgICAgIHR5cGU6ICdPQkpFQ1QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIG51bGxhYmxlQXJyYXk6IHtcbiAgICAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgICAgIHt0eXBlOiAnbnVsbCd9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICBpdGVtczoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogWyAnbnVsbGFibGVBcnJheScgXSxcbiAgICB9XG4gICAgV2lsbCByZXN1bHQgaW4gZm9sbG93aW5nIHNjaGVtYSBjb21wYXRpYmxlIHdpdGggR2VtaW5pIEFQSTpcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ09CSkVDVCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgbnVsbGFibGVBcnJheToge1xuICAgICAgICAgICAgICBudWxsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogJ0FSUkFZJyxcbiAgICAgICAgICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZWQ6IFsgJ251bGxhYmxlQXJyYXknIF0sXG4gICAgICB9XG4gICAgKi9cbiAgICBjb25zdCBpbmNvbWluZ0FueU9mID0gX2pzb25TY2hlbWFbJ2FueU9mJ107XG4gICAgaWYgKGluY29taW5nQW55T2YgIT0gbnVsbCAmJiBpbmNvbWluZ0FueU9mLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGlmIChpbmNvbWluZ0FueU9mWzBdWyd0eXBlJ10gPT09ICdudWxsJykge1xuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgICAgICAgICAgX2pzb25TY2hlbWEgPSBpbmNvbWluZ0FueU9mWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluY29taW5nQW55T2ZbMV1bJ3R5cGUnXSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgICAgICAgICBfanNvblNjaGVtYSA9IGluY29taW5nQW55T2ZbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKF9qc29uU2NoZW1hWyd0eXBlJ10gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmbGF0dGVuVHlwZUFycmF5VG9BbnlPZihfanNvblNjaGVtYVsndHlwZSddLCBnZW5BSVNjaGVtYSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoX2pzb25TY2hlbWEpKSB7XG4gICAgICAgIC8vIFNraXAgaWYgdGhlIGZpZWxkdmFsdWUgaXMgdW5kZWZpbmVkIG9yIG51bGwuXG4gICAgICAgIGlmIChmaWVsZFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZE5hbWUgPT0gJ3R5cGUnKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlOiBudWxsIGNhbiBub3QgYmUgdGhlIG9ubHkgcG9zc2libGUgdHlwZSBmb3IgdGhlIGZpZWxkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpZWxkVmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkIHRoZSB0eXBlIGZpZWxkIHdpdGggYXJyYXkgb2YgdHlwZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVsndHlwZSddID0gT2JqZWN0LnZhbHVlcyhUeXBlKS5pbmNsdWRlcyhmaWVsZFZhbHVlLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgPyBmaWVsZFZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICA6IFR5cGUuVFlQRV9VTlNQRUNJRklFRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIHByb2Nlc3NKc29uU2NoZW1hKGZpZWxkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpc3RTY2hlbWFGaWVsZE5hbWVzLmluY2x1ZGVzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RTY2hlbWFGaWVsZFZhbHVlID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZmllbGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtWyd0eXBlJ10gPT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbkFJU2NoZW1hWydudWxsYWJsZSddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3RTY2hlbWFGaWVsZFZhbHVlLnB1c2gocHJvY2Vzc0pzb25TY2hlbWEoaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbZmllbGROYW1lXSA9XG4gICAgICAgICAgICAgICAgbGlzdFNjaGVtYUZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGljdFNjaGVtYUZpZWxkTmFtZXMuaW5jbHVkZXMoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgZGljdFNjaGVtYUZpZWxkVmFsdWUgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGljdFNjaGVtYUZpZWxkVmFsdWVba2V5XSA9IHByb2Nlc3NKc29uU2NoZW1hKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hW2ZpZWxkTmFtZV0gPVxuICAgICAgICAgICAgICAgIGRpY3RTY2hlbWFGaWVsZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYWRkaXRpb25hbFByb3BlcnRpZXMgaXMgbm90IGluY2x1ZGVkIGluIEpTT05TY2hlbWEsIHNraXBwaW5nIGl0LlxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbZmllbGROYW1lXSA9IGZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlbkFJU2NoZW1hO1xufVxuLy8gd2UgdGFrZSB0aGUgdW5rbm93biBpbiB0aGUgc2NoZW1hIGZpZWxkIGJlY2F1c2Ugd2Ugd2FudCBlbmFibGUgdXNlciB0byBwYXNzXG4vLyB0aGUgb3V0cHV0IG9mIG1ham9yIHNjaGVtYSBkZWNsYXJhdGlvbiB0b29scyB3aXRob3V0IGNhc3RpbmcuIFRvb2xzIHN1Y2ggYXNcbi8vIHpvZFRvSnNvblNjaGVtYSwgdHlwZWJveCwgem9kVG9Kc29uU2NoZW1hIGZ1bmN0aW9uIGNhbiByZXR1cm4gSnNvblNjaGVtYTdUeXBlXG4vLyBvciBvYmplY3QsIHNlZSBkZXRhaWxzIGluXG4vLyBodHRwczovL2dpdGh1Yi5jb20vU3RlZmFuVGVyZGVsbC96b2QtdG8tanNvbi1zY2hlbWEvYmxvYi83MDUyNWVmZTU1NWNkMjI2NjkxZTA5M2QxNzEzNzBhM2IxMDkyMWQxL3NyYy96b2RUb0pzb25TY2hlbWEudHMjTDdcbi8vIHR5cGVib3ggY2FuIHJldHVybiB1bmtub3duLCBzZWUgZGV0YWlscyBpblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmNsYWlyeng4MS90eXBlYm94L2Jsb2IvNWE1NDMxNDM5ZjdkNWNhNmI0OTRkMGQxOGZiZmQ3YjFhMzU2ZDY3Yy9zcmMvdHlwZS9jcmVhdGUvdHlwZS50cyNMMzVcbi8vIE5vdGU6IHByb3BlciBqc29uIHNjaGVtYXMgd2l0aCB0aGUgJHNjaGVtYSBmaWVsZCBzZXQgbmV2ZXIgYXJyaXZlIHRvIHRoaXNcbi8vIHRyYW5zZm9ybWVyLiBTY2hlbWFzIHdpdGggJHNjaGVtYSBhcmUgcm91dGVkIHRvIHRoZSBlcXVpdmFsZW50IEFQSSBqc29uXG4vLyBzY2hlbWEgZmllbGQuXG5mdW5jdGlvbiB0U2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBwcm9jZXNzSnNvblNjaGVtYShzY2hlbWEpO1xufVxuZnVuY3Rpb24gdFNwZWVjaENvbmZpZyhzcGVlY2hDb25maWcpIHtcbiAgICBpZiAodHlwZW9mIHNwZWVjaENvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHNwZWVjaENvbmZpZztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNwZWVjaENvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZvaWNlQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgcHJlYnVpbHRWb2ljZUNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICB2b2ljZU5hbWU6IHNwZWVjaENvbmZpZyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc3BlZWNoQ29uZmlnIHR5cGU6ICR7dHlwZW9mIHNwZWVjaENvbmZpZ31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0TGl2ZVNwZWVjaENvbmZpZyhzcGVlY2hDb25maWcpIHtcbiAgICBpZiAoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJyBpbiBzcGVlY2hDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBsaXZlIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWVjaENvbmZpZztcbn1cbmZ1bmN0aW9uIHRUb29sKHRvb2wpIHtcbiAgICBpZiAodG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb24gb2YgdG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzKS5pbmNsdWRlcygnJHNjaGVtYScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycyA9IHByb2Nlc3NKc29uU2NoZW1hKGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVyc0pzb25TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVyc0pzb25TY2hlbWEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSkuaW5jbHVkZXMoJyRzY2hlbWEnKSkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlID0gcHJvY2Vzc0pzb25TY2hlbWEoZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2VKc29uU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlSnNvblNjaGVtYSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b29sO1xufVxuZnVuY3Rpb24gdFRvb2xzKHRvb2xzKSB7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGluY29taW5nIHR5cGUgaXMgZGVmaW5lZC5cbiAgICBpZiAodG9vbHMgPT09IHVuZGVmaW5lZCB8fCB0b29scyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2xzIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0b29scykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b29scyBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhbiBhcnJheSBvZiBUb29scycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHMpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9vbCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFByZXBlbmRzIHJlc291cmNlIG5hbWUgd2l0aCBwcm9qZWN0LCBsb2NhdGlvbiwgcmVzb3VyY2VfcHJlZml4IGlmIG5lZWRlZC5cbiAqXG4gKiBAcGFyYW0gY2xpZW50IFRoZSBBUEkgY2xpZW50LlxuICogQHBhcmFtIHJlc291cmNlTmFtZSBUaGUgcmVzb3VyY2UgbmFtZS5cbiAqIEBwYXJhbSByZXNvdXJjZVByZWZpeCBUaGUgcmVzb3VyY2UgcHJlZml4LlxuICogQHBhcmFtIHNwbGl0c0FmdGVyUHJlZml4IFRoZSBudW1iZXIgb2Ygc3BsaXRzIGFmdGVyIHRoZSBwcmVmaXguXG4gKiBAcmV0dXJucyBUaGUgY29tcGxldGVkIHJlc291cmNlIG5hbWUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9iYXIvbG9jYXRpb25zL3VzLXdlc3QxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBjbGllbnQucHJvamVjdCA9ICdiYXInXG4gKiBjbGllbnQubG9jYXRpb24gPSAndXMtd2VzdDEnXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIHJldHVybnM6ICdwcm9qZWN0cy9mb28vbG9jYXRpb25zL3VzLWNlbnRyYWwxL2NhY2hlZENvbnRlbnRzLzEyMydcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogcmVzb3VyY2VfbmFtZSA9ICcxMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqIF9yZXNvdXJjZV9uYW1lKGNsaWVudCwgcmVzb3VyY2VfbmFtZSwgcmVzb3VyY2VfcHJlZml4LCBzcGxpdHNfYWZ0ZXJfcHJlZml4KVxuICogcmV0dXJucyAnY2FjaGVkQ29udGVudHMvMTIzJ1xuICogYGBgXG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJ3NvbWUvd3JvbmcvY2FjaGVkQ29udGVudHMvcmVzb3VyY2UvbmFtZS8xMjMnXG4gKiByZXNvdXJjZV9wcmVmaXggPSAnY2FjaGVkQ29udGVudHMnXG4gKiBzcGxpdHNfYWZ0ZXJfcHJlZml4ID0gMVxuICogY2xpZW50LnZlcnRleGFpID0gRmFsc2VcbiAqICMgY2xpZW50LnZlcnRleGFpID0gVHJ1ZVxuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiAtPiAnc29tZS93cm9uZy9yZXNvdXJjZS9uYW1lLzEyMydcbiAqIGBgYFxuICovXG5mdW5jdGlvbiByZXNvdXJjZU5hbWUoY2xpZW50LCByZXNvdXJjZU5hbWUsIHJlc291cmNlUHJlZml4LCBzcGxpdHNBZnRlclByZWZpeCA9IDEpIHtcbiAgICBjb25zdCBzaG91bGRBcHBlbmRQcmVmaXggPSAhcmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoYCR7cmVzb3VyY2VQcmVmaXh9L2ApICYmXG4gICAgICAgIHJlc291cmNlTmFtZS5zcGxpdCgnLycpLmxlbmd0aCA9PT0gc3BsaXRzQWZ0ZXJQcmVmaXg7XG4gICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgaWYgKHJlc291cmNlTmFtZS5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aCgnbG9jYXRpb25zLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7Y2xpZW50LmdldFByb2plY3QoKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aChgJHtyZXNvdXJjZVByZWZpeH0vYCkpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaG91bGRBcHBlbmRQcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS9sb2NhdGlvbnMvJHtjbGllbnQuZ2V0TG9jYXRpb24oKX0vJHtyZXNvdXJjZVByZWZpeH0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEFwcGVuZFByZWZpeCkge1xuICAgICAgICByZXR1cm4gYCR7cmVzb3VyY2VQcmVmaXh9LyR7cmVzb3VyY2VOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZU5hbWU7XG59XG5mdW5jdGlvbiB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb3VyY2VOYW1lKGFwaUNsaWVudCwgbmFtZSwgJ2NhY2hlZENvbnRlbnRzJyk7XG59XG5mdW5jdGlvbiB0VHVuaW5nSm9iU3RhdHVzKHN0YXR1cykge1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgJ1NUQVRFX1VOU1BFQ0lGSUVEJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1VOU1BFQ0lGSUVEJztcbiAgICAgICAgY2FzZSAnQ1JFQVRJTkcnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfUlVOTklORyc7XG4gICAgICAgIGNhc2UgJ0FDVElWRSc6XG4gICAgICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9TVUNDRUVERUQnO1xuICAgICAgICBjYXNlICdGQUlMRUQnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfRkFJTEVEJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxufVxuZnVuY3Rpb24gdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSB7XG4gICAgcmV0dXJuIHRCeXRlcyQxKGZyb21JbWFnZUJ5dGVzKTtcbn1cbmZ1bmN0aW9uIF9pc0ZpbGUob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ25hbWUnIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRlZFZpZGVvKG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICd2aWRlbycgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIGlzVmlkZW8ob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3VyaScgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIHRGaWxlTmFtZShmcm9tTmFtZSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgbmFtZTtcbiAgICBpZiAoX2lzRmlsZShmcm9tTmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lLm5hbWU7XG4gICAgfVxuICAgIGlmIChpc1ZpZGVvKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gZnJvbU5hbWUudXJpO1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0dlbmVyYXRlZFZpZGVvKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gKF9hID0gZnJvbU5hbWUudmlkZW8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cmk7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmcm9tTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGZyb21OYW1lO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGV4dHJhY3QgZmlsZSBuYW1lIGZyb20gdGhlIHByb3ZpZGVkIGlucHV0LicpO1xuICAgIH1cbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdodHRwczovLycpKSB7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IG5hbWUuc3BsaXQoJ2ZpbGVzLycpWzFdO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN1ZmZpeC5tYXRjaCgvW2EtejAtOV0rLyk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZXh0cmFjdCBmaWxlIG5hbWUgZnJvbSBVUkkgJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBtYXRjaFswXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaWxlcy8nKSkge1xuICAgICAgICBuYW1lID0gbmFtZS5zcGxpdCgnZmlsZXMvJylbMV07XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gdE1vZGVsc1VybChhcGlDbGllbnQsIGJhc2VNb2RlbHMpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIHJlcyA9IGJhc2VNb2RlbHMgPyAncHVibGlzaGVycy9nb29nbGUvbW9kZWxzJyA6ICdtb2RlbHMnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzID0gYmFzZU1vZGVscyA/ICdtb2RlbHMnIDogJ3R1bmVkTW9kZWxzJztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHRFeHRyYWN0TW9kZWxzKHJlc3BvbnNlKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgWydtb2RlbHMnLCAndHVuZWRNb2RlbHMnLCAncHVibGlzaGVyTW9kZWxzJ10pIHtcbiAgICAgICAgaWYgKGhhc0ZpZWxkKHJlc3BvbnNlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBoYXNGaWVsZChkYXRhLCBmaWVsZE5hbWUpIHtcbiAgICByZXR1cm4gZGF0YSAhPT0gbnVsbCAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZmllbGROYW1lIGluIGRhdGE7XG59XG5mdW5jdGlvbiBtY3BUb0dlbWluaVRvb2wobWNwVG9vbCwgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBtY3BUb29sU2NoZW1hID0gbWNwVG9vbDtcbiAgICBjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9uID0ge1xuICAgICAgICBuYW1lOiBtY3BUb29sU2NoZW1hWyduYW1lJ10sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBtY3BUb29sU2NoZW1hWydkZXNjcmlwdGlvbiddLFxuICAgICAgICBwYXJhbWV0ZXJzSnNvblNjaGVtYTogbWNwVG9vbFNjaGVtYVsnaW5wdXRTY2hlbWEnXSxcbiAgICB9O1xuICAgIGlmIChjb25maWcuYmVoYXZpb3IpIHtcbiAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvblsnYmVoYXZpb3InXSA9IGNvbmZpZy5iZWhhdmlvcjtcbiAgICB9XG4gICAgY29uc3QgZ2VtaW5pVG9vbCA9IHtcbiAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICAgIF0sXG4gICAgfTtcbiAgICByZXR1cm4gZ2VtaW5pVG9vbDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBsaXN0IG9mIE1DUCB0b29scyB0byBhIHNpbmdsZSBHZW1pbmkgdG9vbCB3aXRoIGEgbGlzdCBvZiBmdW5jdGlvblxuICogZGVjbGFyYXRpb25zLlxuICovXG5mdW5jdGlvbiBtY3BUb29sc1RvR2VtaW5pVG9vbChtY3BUb29scywgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHRvb2xOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IG1jcFRvb2wgb2YgbWNwVG9vbHMpIHtcbiAgICAgICAgY29uc3QgbWNwVG9vbE5hbWUgPSBtY3BUb29sLm5hbWU7XG4gICAgICAgIGlmICh0b29sTmFtZXMuaGFzKG1jcFRvb2xOYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgZnVuY3Rpb24gbmFtZSAke21jcFRvb2xOYW1lfSBmb3VuZCBpbiBNQ1AgdG9vbHMuIFBsZWFzZSBlbnN1cmUgZnVuY3Rpb24gbmFtZXMgYXJlIHVuaXF1ZS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0b29sTmFtZXMuYWRkKG1jcFRvb2xOYW1lKTtcbiAgICAgICAgY29uc3QgZ2VtaW5pVG9vbCA9IG1jcFRvR2VtaW5pVG9vbChtY3BUb29sLCBjb25maWcpO1xuICAgICAgICBpZiAoZ2VtaW5pVG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnMucHVzaCguLi5nZW1pbmlUb29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBmdW5jdGlvbkRlY2xhcmF0aW9uczogZnVuY3Rpb25EZWNsYXJhdGlvbnMgfTtcbn1cbi8vIFRyYW5zZm9ybXMgYSBzb3VyY2UgaW5wdXQgaW50byBhIEJhdGNoSm9iU291cmNlIG9iamVjdCB3aXRoIHZhbGlkYXRpb24uXG5mdW5jdGlvbiB0QmF0Y2hKb2JTb3VyY2UoYXBpQ2xpZW50LCBzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgICAgICBpZiAoYXBpQ2xpZW50ICYmIGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGlmIChzcmMuZ2NzVXJpICYmIHNyYy5iaWdxdWVyeVVyaSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgb2YgYGdjc1VyaWAgb3IgYGJpZ3F1ZXJ5VXJpYCBjYW4gYmUgc2V0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXNyYy5nY3NVcmkgJiYgIXNyYy5iaWdxdWVyeVVyaSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25lIG9mIGBnY3NVcmlgIG9yIGBiaWdxdWVyeVVyaWAgbXVzdCBiZSBzZXQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBMb2dpYyBmb3Igbm9uLVZlcnRleCBBSSBjbGllbnQgKGlubGluZWRfcmVxdWVzdHMsIGZpbGVfbmFtZSlcbiAgICAgICAgICAgIGlmIChzcmMuaW5saW5lZFJlcXVlc3RzICYmIHNyYy5maWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgb2YgYGlubGluZWRSZXF1ZXN0c2Agb3IgYGZpbGVOYW1lYCBjYW4gYmUgc2V0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXNyYy5pbmxpbmVkUmVxdWVzdHMgJiYgIXNyYy5maWxlTmFtZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25lIG9mIGBpbmxpbmVkUmVxdWVzdHNgIG9yIGBmaWxlTmFtZWAgbXVzdCBiZSBzZXQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgLy8gSWYgc3JjIGlzIGFuIGFycmF5IChsaXN0IGluIFB5dGhvbilcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAgICAgcmV0dXJuIHsgaW5saW5lZFJlcXVlc3RzOiBzcmMgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKCdnczovLycpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2pzb25sJyxcbiAgICAgICAgICAgICAgICBnY3NVcmk6IFtzcmNdLCAvLyBHQ1MgVVJJIGlzIGV4cGVjdGVkIGFzIGFuIGFycmF5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNyYy5zdGFydHNXaXRoKCdicTovLycpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogJ2JpZ3F1ZXJ5JyxcbiAgICAgICAgICAgICAgICBiaWdxdWVyeVVyaTogc3JjLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcmMuc3RhcnRzV2l0aCgnZmlsZXMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmlsZU5hbWU6IHNyYyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzb3VyY2U6ICR7c3JjfWApO1xufVxuZnVuY3Rpb24gdEJhdGNoSm9iRGVzdGluYXRpb24oZGVzdCkge1xuICAgIGlmICh0eXBlb2YgZGVzdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIGNvbnN0IGRlc3RTdHJpbmcgPSBkZXN0O1xuICAgIGlmIChkZXN0U3RyaW5nLnN0YXJ0c1dpdGgoJ2dzOi8vJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogJ2pzb25sJyxcbiAgICAgICAgICAgIGdjc1VyaTogZGVzdFN0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVzdFN0cmluZy5zdGFydHNXaXRoKCdicTovLycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6ICdiaWdxdWVyeScsXG4gICAgICAgICAgICBiaWdxdWVyeVVyaTogZGVzdFN0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVzdGluYXRpb246ICR7ZGVzdFN0cmluZ31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgbmFtZSkge1xuICAgIGNvbnN0IG5hbWVTdHJpbmcgPSBuYW1lO1xuICAgIGlmICghYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBjb25zdCBtbGRldlBhdHRlcm4gPSAvYmF0Y2hlc1xcL1teL10rJC87XG4gICAgICAgIGlmIChtbGRldlBhdHRlcm4udGVzdChuYW1lU3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmcuc3BsaXQoJy8nKS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiYXRjaCBqb2IgbmFtZTogJHtuYW1lU3RyaW5nfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2ZXJ0ZXhQYXR0ZXJuID0gL15wcm9qZWN0c1xcL1teL10rXFwvbG9jYXRpb25zXFwvW14vXStcXC9iYXRjaFByZWRpY3Rpb25Kb2JzXFwvW14vXSskLztcbiAgICBpZiAodmVydGV4UGF0dGVybi50ZXN0KG5hbWVTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBuYW1lU3RyaW5nLnNwbGl0KCcvJykucG9wKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eXFxkKyQvLnRlc3QobmFtZVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmF0Y2ggam9iIG5hbWU6ICR7bmFtZVN0cmluZ30uYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdEpvYlN0YXRlKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhdGVTdHJpbmcgPSBzdGF0ZTtcbiAgICBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9VTlNQRUNJRklFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfVU5TUEVDSUZJRUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1BFTkRJTkcnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1BFTkRJTkcnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1NVQ0NFRURFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfU1VDQ0VFREVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9GQUlMRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0ZBSUxFRCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfQ0FOQ0VMTEVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9DQU5DRUxMRUQnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlU3RyaW5nO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YVRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YVRvTWxkZXYkNChmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQ0KGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQ0KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldiQ0KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNjaGVtYVRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQW55T2YgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FueU9mJ10pO1xuICAgIGlmIChmcm9tQW55T2YgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbnlPZiddLCBmcm9tQW55T2YpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVmYXVsdCddKTtcbiAgICBpZiAoZnJvbURlZmF1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZWZhdWx0J10sIGZyb21EZWZhdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudW0nXSk7XG4gICAgaWYgKGZyb21FbnVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW51bSddLCBmcm9tRW51bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGFtcGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlJ10pO1xuICAgIGlmIChmcm9tRXhhbXBsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4YW1wbGUnXSwgZnJvbUV4YW1wbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaXRlbXMnXSk7XG4gICAgaWYgKGZyb21JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2l0ZW1zJ10sIGZyb21JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhJdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWF4SXRlbXMnXSk7XG4gICAgaWYgKGZyb21NYXhJdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heEl0ZW1zJ10sIGZyb21NYXhJdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhMZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heExlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1heExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heExlbmd0aCddLCBmcm9tTWF4TGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhQcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heFByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhQcm9wZXJ0aWVzJ10sIGZyb21NYXhQcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heGltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heGltdW0nXSk7XG4gICAgaWYgKGZyb21NYXhpbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4aW11bSddLCBmcm9tTWF4aW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluSXRlbXMnXSk7XG4gICAgaWYgKGZyb21NaW5JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkl0ZW1zJ10sIGZyb21NaW5JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5MZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbkxlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1pbkxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkxlbmd0aCddLCBmcm9tTWluTGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pblByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1pblByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5Qcm9wZXJ0aWVzJ10sIGZyb21NaW5Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbmltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbmltdW0nXSk7XG4gICAgaWYgKGZyb21NaW5pbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluaW11bSddLCBmcm9tTWluaW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdWxsYWJsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbnVsbGFibGUnXSk7XG4gICAgaWYgKGZyb21OdWxsYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ251bGxhYmxlJ10sIGZyb21OdWxsYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXR0ZXJuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXR0ZXJuJ10pO1xuICAgIGlmIChmcm9tUGF0dGVybiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhdHRlcm4nXSwgZnJvbVBhdHRlcm4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvcGVydGllcyddKTtcbiAgICBpZiAoZnJvbVByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0aWVzJ10sIGZyb21Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnR5T3JkZXJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9wZXJ0eU9yZGVyaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb3BlcnR5T3JkZXJpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0eU9yZGVyaW5nJ10sIGZyb21Qcm9wZXJ0eU9yZGVyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlcXVpcmVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXF1aXJlZCddKTtcbiAgICBpZiAoZnJvbVJlcXVpcmVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWlyZWQnXSwgZnJvbVJlcXVpcmVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAoZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R5cGUnXSk7XG4gICAgaWYgKGZyb21UeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHlwZSddLCBmcm9tVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0aG9kJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhdGVnb3J5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYXRlZ29yeSddKTtcbiAgICBpZiAoZnJvbUNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcnknXSwgZnJvbUNhdGVnb3J5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhyZXNob2xkJ10pO1xuICAgIGlmIChmcm9tVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhyZXNob2xkJ10sIGZyb21UaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CZWhhdmlvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSk7XG4gICAgaWYgKGZyb21CZWhhdmlvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JlaGF2aW9yJ10sIGZyb21CZWhhdmlvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGludGVydmFsVG9NbGRldiQ0KGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkNChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0VG9NbGRldiQ0KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbXB1dGVyVXNlVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbnZpcm9ubWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW52aXJvbm1lbnQnXSk7XG4gICAgaWYgKGZyb21FbnZpcm9ubWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vudmlyb25tZW50J10sIGZyb21FbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDQoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQ0KGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQ0KGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb29nbGVNYXBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvTWxkZXYkNCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgdG9vbENvbXB1dGVyVXNlVG9NbGRldiQ0KGZyb21Db21wdXRlclVzZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnXSwgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGF0TG5nVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0aXR1ZGUnXSk7XG4gICAgaWYgKGZyb21MYXRpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdGl0dWRlJ10sIGZyb21MYXRpdHVkZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb25naXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvbmdpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxvbmdpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvbmdpdHVkZSddLCBmcm9tTG9uZ2l0dWRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmV0cmlldmFsQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRMbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdExuZyddKTtcbiAgICBpZiAoZnJvbUxhdExuZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdExuZyddLCBsYXRMbmdUb01sZGV2JDIoZnJvbUxhdExuZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQyKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgcmV0cmlldmFsQ29uZmlnVG9NbGRldiQyKGZyb21SZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZU5hbWUnXSk7XG4gICAgaWYgKGZyb21Wb2ljZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZU5hbWUnXSwgZnJvbVZvaWNlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQ29uZmlnVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QcmVidWlsdFZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlYnVpbHRWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlYnVpbHRWb2ljZUNvbmZpZyddLCBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQzKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3BlYWtlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlYWtlciddKTtcbiAgICBpZiAoZnJvbVNwZWFrZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVha2VyJ10sIGZyb21TcGVha2VyKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2JDMoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyVm9pY2VDb25maWdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3BlYWtlclZvaWNlQ29uZmlncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TcGVha2VyVm9pY2VDb25maWdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TcGVha2VyVm9pY2VDb25maWdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWFrZXJWb2ljZUNvbmZpZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlZWNoQ29uZmlnVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIHZvaWNlQ29uZmlnVG9NbGRldiQzKGZyb21Wb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJ10sIG11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQzKGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRoaW5raW5nQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbmNsdWRlVGhvdWdodHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlVGhvdWdodHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5jbHVkZVRob3VnaHRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5jbHVkZVRob3VnaHRzJ10sIGZyb21JbmNsdWRlVGhvdWdodHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdCdWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0J1ZGdldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0J1ZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQnVkZ2V0J10sIGZyb21UaGlua2luZ0J1ZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYkMShhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYkNCh0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZUNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVDb3VudCddLCBmcm9tQ2FuZGlkYXRlQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0b3BTZXF1ZW5jZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdG9wU2VxdWVuY2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0b3BTZXF1ZW5jZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdG9wU2VxdWVuY2VzJ10sIGZyb21TdG9wU2VxdWVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUxvZ3Byb2JzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUxvZ3Byb2JzJ10sIGZyb21SZXNwb25zZUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnMnXSwgZnJvbUxvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZXNlbmNlUGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZXNlbmNlUGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVzZW5jZVBlbmFsdHknXSwgZnJvbVByZXNlbmNlUGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GcmVxdWVuY3lQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnJlcXVlbmN5UGVuYWx0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnJlcXVlbmN5UGVuYWx0eSddLCBmcm9tRnJlcXVlbmN5UGVuYWx0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTWltZVR5cGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTWltZVR5cGUnXSwgZnJvbVJlc3BvbnNlTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VTY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlU2NoZW1hJ10sIHNjaGVtYVRvTWxkZXYkMSh0U2NoZW1hKGZyb21SZXNwb25zZVNjaGVtYSkpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdXRpbmdDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxTZWxlY3Rpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsU2VsZWN0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZldHlTZXR0aW5nVG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQ0KHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldiQyKGZyb21Ub29sQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWxzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DYWNoZWRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NhY2hlZENvbnRlbnQnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbUNhY2hlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9NbGRldiQzKHRTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1ZGlvVGltZXN0YW1wIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgdGhpbmtpbmdDb25maWdUb01sZGV2JDEoZnJvbVRoaW5raW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGlubGluZWRSZXF1ZXN0VG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3QnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQ0KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdCcsICdjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0JywgJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiQxKGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3JtYXQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmlncXVlcnlVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ3F1ZXJ5VXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZU5hbWUnXSk7XG4gICAgaWYgKGZyb21GaWxlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVOYW1lJ10sIGZyb21GaWxlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVkUmVxdWVzdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmxpbmVkUmVxdWVzdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5saW5lZFJlcXVlc3RzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21JbmxpbmVkUmVxdWVzdHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5saW5lZFJlcXVlc3RUb01sZGV2KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0cycsICdyZXF1ZXN0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnYmF0Y2gnLCAnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3JjJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmF0Y2gnLCAnaW5wdXRDb25maWcnXSwgYmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgdEJhdGNoSm9iU291cmNlKGFwaUNsaWVudCwgZnJvbVNyYykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmNlbEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbHRlciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpc3RCYXRjaEpvYnNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNGb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1NvdXJjZScsICd1cmlzJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVNvdXJjZScsICdpbnB1dFVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVkUmVxdWVzdHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lubGluZWRSZXF1ZXN0cyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRGVzdGluYXRpb25Ub1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVkaWN0aW9uc0Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzRGVzdGluYXRpb24nLCAnb3V0cHV0VXJpUHJlZml4J10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeURlc3RpbmF0aW9uJywgJ291dHB1dFVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlTmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmlsZU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVkUmVzcG9uc2VzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmxpbmVkUmVzcG9uc2VzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc3QgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnb3V0cHV0Q29uZmlnJ10sIGJhdGNoSm9iRGVzdGluYXRpb25Ub1ZlcnRleCh0QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3JjJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRDb25maWcnXSwgYmF0Y2hKb2JTb3VyY2VUb1ZlcnRleCh0QmF0Y2hKb2JTb3VyY2UoYXBpQ2xpZW50LCBmcm9tU3JjKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgY3JlYXRlQmF0Y2hKb2JDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGlzdEJhdGNoSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFGcm9tTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYkZyb21NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YUZyb21NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0RnJvbU1sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFGcm9tTWxkZXYkMihmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iRnJvbU1sZGV2JDIoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFGcm9tTWxkZXYkMihmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RnJvbU1sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0RnJvbU1sZGV2JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DaXRhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NpdGF0aW9uU291cmNlcyddKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9ucyddLCBmcm9tQ2l0YXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsTWV0YWRhdGFGcm9tTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmV0cmlldmVkVXJsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2ZWRVcmwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2ZWRVcmwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2ZWRVcmwnXSwgZnJvbVJldHJpZXZlZFVybCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxSZXRyaWV2YWxTdGF0dXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxSZXRyaWV2YWxTdGF0dXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsUmV0cmlldmFsU3RhdHVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsUmV0cmlldmFsU3RhdHVzJ10sIGZyb21VcmxSZXRyaWV2YWxTdGF0dXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0TWV0YWRhdGFGcm9tTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJsTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tVXJsTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVVybE1ldGFkYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybE1ldGFkYXRhRnJvbU1sZGV2JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxNZXRhZGF0YSddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjYW5kaWRhdGVGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudCddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50J10sIGNvbnRlbnRGcm9tTWxkZXYkMihmcm9tQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2l0YXRpb25NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NpdGF0aW9uTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9uTWV0YWRhdGEnXSwgY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxKGZyb21DaXRhdGlvbk1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaW5pc2hSZWFzb24nXSk7XG4gICAgaWYgKGZyb21GaW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hSZWFzb24nXSwgZnJvbUZpbmlzaFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0TWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxDb250ZXh0TWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dE1ldGFkYXRhJ10sIHVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldiQyKGZyb21VcmxDb250ZXh0TWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF2Z0xvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdmdMb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUF2Z0xvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSwgZnJvbUF2Z0xvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2luZGV4J10pO1xuICAgIGlmIChmcm9tSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmRleCddLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnNSZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsb2dwcm9ic1Jlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9ic1Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzUmVzdWx0J10sIGZyb21Mb2dwcm9ic1Jlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlSYXRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5UmF0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TYWZldHlSYXRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5UmF0aW5ncyddLCBmcm9tU2FmZXR5UmF0aW5ncyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYW5kaWRhdGVzJ10pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FuZGlkYXRlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVGcm9tTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10pO1xuICAgIGlmIChmcm9tTW9kZWxWZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10sIGZyb21Nb2RlbFZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0RmVlZGJhY2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9tcHRGZWVkYmFjaycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRGZWVkYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdEZlZWRiYWNrJ10sIGZyb21Qcm9tcHRGZWVkYmFjayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZUlkJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSwgZnJvbVJlc3BvbnNlSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgZnJvbVVzYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBqb2JFcnJvckZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGV0YWlscyddKTtcbiAgICBpZiAoZnJvbURldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXRhaWxzJ10sIGZyb21EZXRhaWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvZGUnXSk7XG4gICAgaWYgKGZyb21Db2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZSddLCBmcm9tQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXNzYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXNzYWdlJ10pO1xuICAgIGlmIChmcm9tTWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lc3NhZ2UnXSwgZnJvbU1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbmxpbmVkUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgam9iRXJyb3JGcm9tTWxkZXYoZnJvbUVycm9yKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZXNGaWxlJ10pO1xuICAgIGlmIChmcm9tRmlsZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlTmFtZSddLCBmcm9tRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZFJlc3BvbnNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lubGluZWRSZXNwb25zZXMnLFxuICAgICAgICAnaW5saW5lZFJlc3BvbnNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmxpbmVkUmVzcG9uc2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21JbmxpbmVkUmVzcG9uc2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubGluZWRSZXNwb25zZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZWRSZXNwb25zZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2Rpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YScsICdzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdEpvYlN0YXRlKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2NyZWF0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2VuZFRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ3VwZGF0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJywgJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnLCAnb3V0cHV0J10pO1xuICAgIGlmIChmcm9tRGVzdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc3QnXSwgYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldihmcm9tRGVzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXRjaEpvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ29wZXJhdGlvbnMnXSk7XG4gICAgaWYgKGZyb21CYXRjaEpvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUJhdGNoSm9icztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaEpvYkZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoSm9icyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVSZXNvdXJjZUpvYkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBqb2JFcnJvckZyb21NbGRldihmcm9tRXJyb3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gam9iRXJyb3JGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXRhaWxzJ10pO1xuICAgIGlmIChmcm9tRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RldGFpbHMnXSwgZnJvbURldGFpbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29kZSddKTtcbiAgICBpZiAoZnJvbUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlJ10sIGZyb21Db2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lc3NhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lc3NhZ2UnXSk7XG4gICAgaWYgKGZyb21NZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVzc2FnZSddLCBmcm9tTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iU291cmNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbnN0YW5jZXNGb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1NvdXJjZScsICd1cmlzJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmlncXVlcnlVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdiaWdxdWVyeVNvdXJjZScsXG4gICAgICAgICdpbnB1dFVyaScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CaWdxdWVyeVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpZ3F1ZXJ5VXJpJ10sIGZyb21CaWdxdWVyeVVyaSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ByZWRpY3Rpb25zRm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2NzRGVzdGluYXRpb24nLFxuICAgICAgICAnb3V0cHV0VXJpUHJlZml4JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpZ3F1ZXJ5VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmlncXVlcnlEZXN0aW5hdGlvbicsXG4gICAgICAgICdvdXRwdXRVcmknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmlncXVlcnlVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWdxdWVyeVVyaSddLCBmcm9tQmlncXVlcnlVcmkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRKb2JTdGF0ZShmcm9tU3RhdGUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgam9iRXJyb3JGcm9tVmVydGV4KGZyb21FcnJvcikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lucHV0Q29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3JjJ10sIGJhdGNoSm9iU291cmNlRnJvbVZlcnRleChmcm9tU3JjKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXN0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRDb25maWcnXSk7XG4gICAgaWYgKGZyb21EZXN0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzdCddLCBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbVZlcnRleChmcm9tRGVzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmF0Y2hKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmF0Y2hQcmVkaWN0aW9uSm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CYXRjaEpvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUJhdGNoSm9icztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaEpvYkZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaEpvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlUmVzb3VyY2VKb2JGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGpvYkVycm9yRnJvbVZlcnRleChmcm9tRXJyb3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG52YXIgUGFnZWRJdGVtO1xuKGZ1bmN0aW9uIChQYWdlZEl0ZW0pIHtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0JBVENIX0pPQlNcIl0gPSBcImJhdGNoSm9ic1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fTU9ERUxTXCJdID0gXCJtb2RlbHNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX1RVTklOR19KT0JTXCJdID0gXCJ0dW5pbmdKb2JzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9GSUxFU1wiXSA9IFwiZmlsZXNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0NBQ0hFRF9DT05URU5UU1wiXSA9IFwiY2FjaGVkQ29udGVudHNcIjtcbn0pKFBhZ2VkSXRlbSB8fCAoUGFnZWRJdGVtID0ge30pKTtcbi8qKlxuICogUGFnZXIgY2xhc3MgZm9yIGl0ZXJhdGluZyB0aHJvdWdoIHBhZ2luYXRlZCByZXN1bHRzLlxuICovXG5jbGFzcyBQYWdlciB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcmVxdWVzdCwgcmVzcG9uc2UsIHBhcmFtcykge1xuICAgICAgICB0aGlzLnBhZ2VJbnRlcm5hbCA9IFtdO1xuICAgICAgICB0aGlzLnBhcmFtc0ludGVybmFsID0ge307XG4gICAgICAgIHRoaXMucmVxdWVzdEludGVybmFsID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5pbml0KG5hbWUsIHJlc3BvbnNlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBpbml0KG5hbWUsIHJlc3BvbnNlLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5uYW1lSW50ZXJuYWwgPSBuYW1lO1xuICAgICAgICB0aGlzLnBhZ2VJbnRlcm5hbCA9IHJlc3BvbnNlW3RoaXMubmFtZUludGVybmFsXSB8fCBbXTtcbiAgICAgICAgdGhpcy5zZGtIdHRwUmVzcG9uc2VJbnRlcm5hbCA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2U7XG4gICAgICAgIHRoaXMuaWR4SW50ZXJuYWwgPSAwO1xuICAgICAgICBsZXQgcmVxdWVzdFBhcmFtcyA9IHsgY29uZmlnOiB7fSB9O1xuICAgICAgICBpZiAoIXBhcmFtcyB8fCBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IHsgY29uZmlnOiB7fSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3RQYXJhbXNbJ2NvbmZpZyddKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zWydjb25maWcnXVsncGFnZVRva2VuJ10gPSByZXNwb25zZVsnbmV4dFBhZ2VUb2tlbiddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyYW1zSW50ZXJuYWwgPSByZXF1ZXN0UGFyYW1zO1xuICAgICAgICB0aGlzLnBhZ2VJbnRlcm5hbFNpemUgPVxuICAgICAgICAgICAgKF9iID0gKF9hID0gcmVxdWVzdFBhcmFtc1snY29uZmlnJ10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsncGFnZVNpemUnXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5wYWdlSW50ZXJuYWwubGVuZ3RoO1xuICAgIH1cbiAgICBpbml0TmV4dFBhZ2UocmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5pbml0KHRoaXMubmFtZUludGVybmFsLCByZXNwb25zZSwgdGhpcy5wYXJhbXNJbnRlcm5hbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGFnZSwgd2hpY2ggaXMgYSBsaXN0IG9mIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgZmlyc3QgcGFnZSBpcyByZXRyaWV2ZWQgd2hlbiB0aGUgcGFnZXIgaXMgY3JlYXRlZC4gVGhlIHJldHVybmVkIGxpc3Qgb2ZcbiAgICAgKiBpdGVtcyBjb3VsZCBiZSBhIHN1YnNldCBvZiB0aGUgZW50aXJlIGxpc3QuXG4gICAgICovXG4gICAgZ2V0IHBhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHlwZSBvZiBwYWdlZCBpdGVtIChmb3IgZXhhbXBsZSwgYGBiYXRjaF9qb2JzYGApLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgcGFnZSBmZXRjaGVkIGVhY2ggdGltZSBieSB0aGlzIHBhZ2VyLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBwYWdlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGFnZSBsZW5ndGguXG4gICAgICovXG4gICAgZ2V0IHBhZ2VTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWxTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBoZWFkZXJzIG9mIHRoZSBBUEkgcmVzcG9uc2UuXG4gICAgICovXG4gICAgZ2V0IHNka0h0dHBSZXNwb25zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2RrSHR0cFJlc3BvbnNlSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcmFtZXRlcnMgd2hlbiBtYWtpbmcgdGhlIEFQSSByZXF1ZXN0IGZvciB0aGUgbmV4dCBwYWdlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBQYXJhbWV0ZXJzIGNvbnRhaW4gYSBzZXQgb2Ygb3B0aW9uYWwgY29uZmlncyB0aGF0IGNhbiBiZVxuICAgICAqIHVzZWQgdG8gY3VzdG9taXplIHRoZSBBUEkgcmVxdWVzdC4gRm9yIGV4YW1wbGUsIHRoZSBgcGFnZVRva2VuYCBwYXJhbWV0ZXJcbiAgICAgKiBjb250YWlucyB0aGUgdG9rZW4gdG8gcmVxdWVzdCB0aGUgbmV4dCBwYWdlLlxuICAgICAqL1xuICAgIGdldCBwYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtc0ludGVybmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIGN1cnJlbnQgcGFnZS5cbiAgICAgKi9cbiAgICBnZXQgcGFnZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaXRlbSBhdCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICovXG4gICAgZ2V0SXRlbShpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWxbaW5kZXhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFzeW5jIGl0ZXJhdG9yIHRoYXQgc3VwcG9ydCBpdGVyYXRpbmcgdGhyb3VnaCBhbGwgaXRlbXNcbiAgICAgKiByZXRyaWV2ZWQgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgaXRlcmF0b3Igd2lsbCBhdXRvbWF0aWNhbGx5IGZldGNoIHRoZSBuZXh0IHBhZ2UgaWYgdGhlcmUgYXJlIG1vcmUgaXRlbXNcbiAgICAgKiB0byBmZXRjaCBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBwYWdlciA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzoge3BhZ2VTaXplOiAxMH19KTtcbiAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGZpbGUgb2YgcGFnZXIpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWR4SW50ZXJuYWwgPj0gdGhpcy5wYWdlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubmV4dFBhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5nZXRJdGVtKHRoaXMuaWR4SW50ZXJuYWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuaWR4SW50ZXJuYWwgKz0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXR1cm46IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBuZXh0IHBhZ2Ugb2YgaXRlbXMuIFRoaXMgbWFrZXMgYSBuZXcgQVBJIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgYXJlIG5vIG1vcmUgcGFnZXMgdG8gZmV0Y2guXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBwYWdlciA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzoge3BhZ2VTaXplOiAxMH19KTtcbiAgICAgKiBsZXQgcGFnZSA9IHBhZ2VyLnBhZ2U7XG4gICAgICogd2hpbGUgKHRydWUpIHtcbiAgICAgKiAgIGZvciAoY29uc3QgZmlsZSBvZiBwYWdlKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogICB9XG4gICAgICogICBpZiAoIXBhZ2VyLmhhc05leHRQYWdlKCkpIHtcbiAgICAgKiAgICAgYnJlYWs7XG4gICAgICogICB9XG4gICAgICogICBwYWdlID0gYXdhaXQgcGFnZXIubmV4dFBhZ2UoKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgbmV4dFBhZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNOZXh0UGFnZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1vcmUgcGFnZXMgdG8gZmV0Y2guJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3RJbnRlcm5hbCh0aGlzLnBhcmFtcyk7XG4gICAgICAgIHRoaXMuaW5pdE5leHRQYWdlKHJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBtb3JlIHBhZ2VzIHRvIGZldGNoIGZyb20gdGhlIEFQSS5cbiAgICAgKi9cbiAgICBoYXNOZXh0UGFnZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMucGFyYW1zWydjb25maWcnXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWydwYWdlVG9rZW4nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQmF0Y2hlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGJhdGNoIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5iYXRjaGVzLmNyZWF0ZSh7XG4gICAgICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgICAgICogICBzcmM6IHtnY3NVcmk6ICdnczovL2J1Y2tldC9wYXRoL3RvL2ZpbGUuanNvbmwnLCBmb3JtYXQ6ICdqc29ubCd9LFxuICAgICAgICAgKiAgIGNvbmZpZzoge1xuICAgICAgICAgKiAgICAgZGVzdDoge2djc1VyaTogJ2dzOi8vYnVja2V0L3BhdGgvb3V0cHV0L2RpcmVjdG9yeScsIGZvcm1hdDogJ2pzb25sJ30sXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3JlYXRlID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcFN0ciA9IHRpbWVzdGFtcC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcy5zcmMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5saW5lZFJlcXVlc3RbXSBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4gUGxlYXNlIHVzZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdHb29nbGUgQ2xvdWQgU3RvcmFnZSBVUkkgb3IgQmlnUXVlcnkgVVJJIGluc3RlYWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcgPSBwYXJhbXMuY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuY29uZmlnLmRpc3BsYXlOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy5kaXNwbGF5TmFtZSA9ICdnZW5haUJhdGNoSm9iXyR7dGltZXN0YW1wU3RyfSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuY29uZmlnLmRlc3QgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGFyYW1zLnNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5zcmMuc3RhcnRzV2l0aCgnZ3M6Ly8nKSAmJiBwYXJhbXMuc3JjLmVuZHNXaXRoKCcuanNvbmwnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy5kZXN0ID0gYCR7cGFyYW1zLnNyYy5zbGljZSgwLCAtNil9L2Rlc3RgO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtcy5zcmMuc3RhcnRzV2l0aCgnYnE6Ly8nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy5kZXN0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHtwYXJhbXMuc3JjfV9kZXN0XyR7dGltZXN0YW1wU3RyfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNvdXJjZTonICsgcGFyYW1zLnNyYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMuc3JjKSB8fFxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHBhcmFtcy5zcmMgIT09ICdzdHJpbmcnICYmIHBhcmFtcy5zcmMuaW5saW5lZFJlcXVlc3RzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHN5c3RlbSBpbnN0cnVjdGlvbiB0byBodHRwT3B0aW9ucyBleHRyYUJvZHkuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpiYXRjaEdlbmVyYXRlQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgc3lzdGVtIGluc3RydWN0aW9uIHRvICdyZXF1ZXN0JzpcbiAgICAgICAgICAgICAgICAgICAgLy8geydzeXN0ZW1JbnN0cnVjdGlvbic6IHN5c3RlbV9pbnN0cnVjdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSBib2R5WydiYXRjaCddO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dENvbmZpZyA9IGJhdGNoWydpbnB1dENvbmZpZyddO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0c1dyYXBwZXIgPSBpbnB1dENvbmZpZ1sncmVxdWVzdHMnXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdHMgPSByZXF1ZXN0c1dyYXBwZXJbJ3JlcXVlc3RzJ107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1JlcXVlc3RzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdERpY3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3REaWN0WydzeXN0ZW1JbnN0cnVjdGlvbiddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3lzdGVtSW5zdHJ1Y3Rpb25WYWx1ZSA9IHJlcXVlc3REaWN0WydzeXN0ZW1JbnN0cnVjdGlvbiddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0Q29udGVudCA9IHJlcXVlc3REaWN0WydyZXF1ZXN0J107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdENvbnRlbnRbJ3N5c3RlbUluc3RydWN0aW9uJ10gPSBzeXN0ZW1JbnN0cnVjdGlvblZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REaWN0WydyZXF1ZXN0J10gPSByZXF1ZXN0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1JlcXVlc3RzLnB1c2gocmVxdWVzdERpY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RzV3JhcHBlclsncmVxdWVzdHMnXSA9IG5ld1JlcXVlc3RzO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgYmF0Y2ggam9iIGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHBhZ2luYXRlZCByZXN1bHRzIG9mIHRoZSBsaXN0IG9mIGJhdGNoIGpvYnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGJhdGNoSm9icyA9IGF3YWl0IGFpLmJhdGNoZXMubGlzdCh7Y29uZmlnOiB7J3BhZ2VTaXplJzogMn19KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCBiYXRjaEpvYiBvZiBiYXRjaEpvYnMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhiYXRjaEpvYik7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fQkFUQ0hfSk9CUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmJhdGNoR2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGJhdGNoIGpvYiBjb25maWd1cmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGdldCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5iYXRjaGVzLmdldCh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldEJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icy97bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldEJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgY2FuY2VsIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgZW1wdHkgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5iYXRjaGVzLmNhbmNlbCh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjYW5jZWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMve25hbWV9OmNhbmNlbCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcy97bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RCYXRjaEpvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEJhdGNoSm9ic1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkZWxldGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBlbXB0eSByZXNwb25zZSByZXR1cm5lZCBieSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmJhdGNoZXMuZGVsZXRlKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlUmVzb3VyY2VKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaGVzL3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlUmVzb3VyY2VKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFUb01sZGV2JDMoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkMyhmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkMyhmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CZWhhdmlvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSk7XG4gICAgaWYgKGZyb21CZWhhdmlvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JlaGF2aW9yJ10sIGZyb21CZWhhdmlvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGludGVydmFsVG9NbGRldiQzKGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMyhmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0VG9NbGRldiQzKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbXB1dGVyVXNlVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbnZpcm9ubWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW52aXJvbm1lbnQnXSk7XG4gICAgaWYgKGZyb21FbnZpcm9ubWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vudmlyb25tZW50J10sIGZyb21FbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQzKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQzKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb29nbGVNYXBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvTWxkZXYkMygpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgdG9vbENvbXB1dGVyVXNlVG9NbGRldiQzKGZyb21Db21wdXRlclVzZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnXSwgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGF0TG5nVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0aXR1ZGUnXSk7XG4gICAgaWYgKGZyb21MYXRpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdGl0dWRlJ10sIGZyb21MYXRpdHVkZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb25naXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvbmdpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxvbmdpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvbmdpdHVkZSddLCBmcm9tTG9uZ2l0dWRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmV0cmlldmFsQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRMbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdExuZyddKTtcbiAgICBpZiAoZnJvbUxhdExuZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdExuZyddLCBsYXRMbmdUb01sZGV2JDEoZnJvbUxhdExuZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQxKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgcmV0cmlldmFsQ29uZmlnVG9NbGRldiQxKGZyb21SZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQzKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29scztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQzKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb01sZGV2JDEoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsna21zS2V5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna21zS2V5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0Q2FjaGVzTW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFUb1ZlcnRleCQyKGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb1ZlcnRleCQyKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9WZXJ0ZXgkMihmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb1ZlcnRleCQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZWhhdmlvciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb1ZlcnRleCQyKGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVEb21haW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZURvbWFpbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZURvbWFpbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlRG9tYWlucyddLCBmcm9tRXhjbHVkZURvbWFpbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR5bmFtaWNUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljVGhyZXNob2xkJ10sIGZyb21EeW5hbWljVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4JDIoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW50ZXJwcmlzZVdlYlNlYXJjaFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVEb21haW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZURvbWFpbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZURvbWFpbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlRG9tYWlucyddLCBmcm9tRXhjbHVkZURvbWFpbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhcGlLZXlDb25maWdUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BcGlLZXlTdHJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FwaUtleVN0cmluZyddKTtcbiAgICBpZiAoZnJvbUFwaUtleVN0cmluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FwaUtleVN0cmluZyddLCBmcm9tQXBpS2V5U3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXV0aENvbmZpZ1RvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFwaUtleUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXBpS2V5Q29uZmlnJ10pO1xuICAgIGlmIChmcm9tQXBpS2V5Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXBpS2V5Q29uZmlnJ10sIGFwaUtleUNvbmZpZ1RvVmVydGV4JDIoZnJvbUFwaUtleUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXV0aFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhUeXBlJ10pO1xuICAgIGlmIChmcm9tQXV0aFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdXRoVHlwZSddLCBmcm9tQXV0aFR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnJ10sIGZyb21Hb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21IdHRwQmFzaWNBdXRoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaHR0cEJhc2ljQXV0aENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21IdHRwQmFzaWNBdXRoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaHR0cEJhc2ljQXV0aENvbmZpZyddLCBmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PYXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb2F1dGhDb25maWcnXSk7XG4gICAgaWYgKGZyb21PYXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29hdXRoQ29uZmlnJ10sIGZyb21PYXV0aENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PaWRjQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvaWRjQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tT2lkY0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29pZGNDb25maWcnXSwgZnJvbU9pZGNDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKTtcbiAgICBpZiAoZnJvbUF1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdXRoQ29uZmlnJ10sIGF1dGhDb25maWdUb1ZlcnRleCQyKGZyb21BdXRoQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRUb1ZlcnRleCQyKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbXB1dGVyVXNlVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRW52aXJvbm1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vudmlyb25tZW50J10pO1xuICAgIGlmIChmcm9tRW52aXJvbm1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnZpcm9ubWVudCddLCBmcm9tRW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb1ZlcnRleCQyKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgkMihmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnRlcnByaXNlV2ViU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW50ZXJwcmlzZVdlYlNlYXJjaCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddLCBlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgkMihmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb1ZlcnRleCQyKGZyb21Hb29nbGVNYXBzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvVmVydGV4JDIoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIHRvb2xDb21wdXRlclVzZVRvVmVydGV4JDIoZnJvbUNvbXB1dGVyVXNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnXSwgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGF0TG5nVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGF0aXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdGl0dWRlJ10pO1xuICAgIGlmIChmcm9tTGF0aXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXRpdHVkZSddLCBmcm9tTGF0aXR1ZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9uZ2l0dWRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb25naXR1ZGUnXSk7XG4gICAgaWYgKGZyb21Mb25naXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb25naXR1ZGUnXSwgZnJvbUxvbmdpdHVkZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJldHJpZXZhbENvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhdExuZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0TG5nJ10pO1xuICAgIGlmIChmcm9tTGF0TG5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGF0TG5nJ10sIGxhdExuZ1RvVmVydGV4JDEoZnJvbUxhdExuZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvVmVydGV4JDEoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbENvbmZpZyddLCByZXRyaWV2YWxDb25maWdUb1ZlcnRleCQxKGZyb21SZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb1ZlcnRleCQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb1ZlcnRleCQyKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29scztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9WZXJ0ZXgkMShmcm9tVG9vbENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tS21zS2V5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsna21zS2V5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUttc0tleU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZW5jcnlwdGlvbl9zcGVjJywgJ2ttc0tleU5hbWUnXSwgZnJvbUttc0tleU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgdENhY2hlc01vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHRsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dGwnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHRsJ10sIGZyb21UdGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FjaGVkQ29udGVudEZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAoZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZWRDb250ZW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRDb250ZW50RnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FjaGVkQ29udGVudEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZWRDb250ZW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRDb250ZW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgQ2FjaGVzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgY2FjaGVkIGNvbnRlbnQgY29uZmlndXJhdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGxpc3QgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgcGFnaW5hdGVkIHJlc3VsdHMgb2YgdGhlIGxpc3Qgb2YgY2FjaGVkIGNvbnRlbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCBjYWNoZWRDb250ZW50cyA9IGF3YWl0IGFpLmNhY2hlcy5saXN0KHtjb25maWc6IHsncGFnZVNpemUnOiAyfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGNhY2hlZENvbnRlbnQgb2YgY2FjaGVkQ29udGVudHMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhjYWNoZWRDb250ZW50KTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9DQUNIRURfQ09OVEVOVFMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNhY2hlZCBjb250ZW50cyByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogQ29udGV4dCBjYWNoaW5nIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBzcGVjaWZpYyBtb2RlbHMuIFNlZSBbR2VtaW5pXG4gICAgICogRGV2ZWxvcGVyIEFQSSByZWZlcmVuY2VdKGh0dHBzOi8vYWkuZ29vZ2xlLmRldi9nZW1pbmktYXBpL2RvY3MvY2FjaGluZz9sYW5nPW5vZGUvY29udGV4dC1jYWMpXG4gICAgICogYW5kIFtWZXJ0ZXggQUkgcmVmZXJlbmNlXShodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2dlbmVyYXRpdmUtYWkvZG9jcy9jb250ZXh0LWNhY2hlL2NvbnRleHQtY2FjaGUtb3ZlcnZpZXcjc3VwcG9ydGVkX21vZGVscylcbiAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNyZWF0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgY2FjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY29udGVudHMgPSAuLi47IC8vIEluaXRpYWxpemUgdGhlIGNvbnRlbnQgdG8gY2FjaGUuXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5jYWNoZXMuY3JlYXRlKHtcbiAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgJ2NvbnRlbnRzJzogY29udGVudHMsXG4gICAgICogICAgJ2Rpc3BsYXlOYW1lJzogJ3Rlc3QgY2FjaGUnLFxuICAgICAqICAgICdzeXN0ZW1JbnN0cnVjdGlvbic6ICdXaGF0IGlzIHRoZSBzdW0gb2YgdGhlIHR3byBwZGZzPycsXG4gICAgICogICAgJ3R0bCc6ICc4NjQwMHMnLFxuICAgICAqICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNhY2hlZENvbnRlbnRGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjYWNoZWRDb250ZW50RnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY2FjaGVkIGNvbnRlbnQgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5jYWNoZXMuZ2V0KHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjYWNoZWRDb250ZW50RnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FjaGVkQ29udGVudEZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGNhY2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZGVsZXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgZW1wdHkgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5jYWNoZXMuZGVsZXRlKHtuYW1lOiAnLi4uJ30pOyAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjYWNoZWQgY29udGVudCBjb25maWd1cmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIHVwZGF0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgY2FjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5jYWNoZXMudXBkYXRlKHtcbiAgICAgKiAgIG5hbWU6ICcuLi4nLCAgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiAgIGNvbmZpZzogeyd0dGwnOiAnNzYwMHMnfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNhY2hlZENvbnRlbnRGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNhY2hlZENvbnRlbnRGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlc3BvbnNlIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAocmVzcG9uc2UuY2FuZGlkYXRlcyA9PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UuY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gKF9hID0gcmVzcG9uc2UuY2FuZGlkYXRlc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc1ZhbGlkQ29udGVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAoY29udGVudC5wYXJ0cyA9PT0gdW5kZWZpbmVkIHx8IGNvbnRlbnQucGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQucGFydHMpIHtcbiAgICAgICAgaWYgKHBhcnQgPT09IHVuZGVmaW5lZCB8fCBPYmplY3Qua2V5cyhwYXJ0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBoaXN0b3J5IGNvbnRhaW5zIHRoZSBjb3JyZWN0IHJvbGVzLlxuICpcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIHVzZXIgdHVybi5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhpc3RvcnkgY29udGFpbnMgYW4gaW52YWxpZCByb2xlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSkge1xuICAgIC8vIEVtcHR5IGhpc3RvcnkgaXMgdmFsaWQuXG4gICAgaWYgKGhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb250ZW50IG9mIGhpc3RvcnkpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQucm9sZSAhPT0gJ3VzZXInICYmIGNvbnRlbnQucm9sZSAhPT0gJ21vZGVsJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb2xlIG11c3QgYmUgdXNlciBvciBtb2RlbCwgYnV0IGdvdCAke2NvbnRlbnQucm9sZX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBjdXJhdGVkICh2YWxpZCkgaGlzdG9yeSBmcm9tIGEgY29tcHJlaGVuc2l2ZSBoaXN0b3J5LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgbW9kZWwgbWF5IHNvbWV0aW1lcyBnZW5lcmF0ZSBpbnZhbGlkIG9yIGVtcHR5IGNvbnRlbnRzKGUuZy4sIGR1ZSB0byBzYWZ0eVxuICogZmlsdGVycyBvciByZWNpdGF0aW9uKS4gRXh0cmFjdGluZyB2YWxpZCB0dXJucyBmcm9tIHRoZSBoaXN0b3J5XG4gKiBlbnN1cmVzIHRoYXQgc3Vic2VxdWVudCByZXF1ZXN0cyBjb3VsZCBiZSBhY2NwZXRlZCBieSB0aGUgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDdXJhdGVkSGlzdG9yeShjb21wcmVoZW5zaXZlSGlzdG9yeSkge1xuICAgIGlmIChjb21wcmVoZW5zaXZlSGlzdG9yeSA9PT0gdW5kZWZpbmVkIHx8IGNvbXByZWhlbnNpdmVIaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGN1cmF0ZWRIaXN0b3J5ID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gY29tcHJlaGVuc2l2ZUhpc3RvcnkubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0ucm9sZSA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wdXNoKGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gW107XG4gICAgICAgICAgICBsZXQgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbmd0aCAmJiBjb21wcmVoZW5zaXZlSGlzdG9yeVtpXS5yb2xlID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxPdXRwdXQucHVzaChjb21wcmVoZW5zaXZlSGlzdG9yeVtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQgJiYgIWlzVmFsaWRDb250ZW50KGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY3VyYXRlZEhpc3RvcnkucHVzaCguLi5tb2RlbE91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgdXNlciBpbnB1dCB3aGVuIG1vZGVsIGNvbnRlbnQgaXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VyYXRlZEhpc3Rvcnk7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBjbGFzcyB0byBjcmVhdGUgYSBjaGF0IHNlc3Npb24uXG4gKi9cbmNsYXNzIENoYXRzIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RlbHNNb2R1bGUsIGFwaUNsaWVudCkge1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgY29uZmlnIGluIHRoZSBwYXJhbXMgd2lsbCBiZSB1c2VkIGZvciBhbGwgcmVxdWVzdHMgd2l0aGluIHRoZSBjaGF0XG4gICAgICogc2Vzc2lvbiB1bmxlc3Mgb3ZlcnJpZGRlbiBieSBhIHBlci1yZXF1ZXN0IGBjb25maWdgIGluXG4gICAgICogQHNlZSB7QGxpbmsgdHlwZXMuU2VuZE1lc3NhZ2VQYXJhbWV0ZXJzI2NvbmZpZ30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgQSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNoYXQgPSBhaS5jaGF0cy5jcmVhdGUoe1xuICAgICAqICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIHRlbXBlcmF0dXJlOiAwLjUsXG4gICAgICogICAgIG1heE91dHB1dFRva2VuczogMTAyNCxcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhdCh0aGlzLmFwaUNsaWVudCwgdGhpcy5tb2RlbHNNb2R1bGUsIHBhcmFtcy5tb2RlbCwgcGFyYW1zLmNvbmZpZywgXG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHN0cnVjdHVyZWRDbG9uZShwYXJhbXMuaGlzdG9yeSkpO1xuICAgIH1cbn1cbi8qKlxuICogQ2hhdCBzZXNzaW9uIHRoYXQgZW5hYmxlcyBzZW5kaW5nIG1lc3NhZ2VzIHRvIHRoZSBtb2RlbCB3aXRoIHByZXZpb3VzXG4gKiBjb252ZXJzYXRpb24gY29udGV4dC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHNlc3Npb24gbWFpbnRhaW5zIGFsbCB0aGUgdHVybnMgYmV0d2VlbiB1c2VyIGFuZCBtb2RlbC5cbiAqL1xuY2xhc3MgQ2hhdCB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50LCBtb2RlbHNNb2R1bGUsIG1vZGVsLCBjb25maWcgPSB7fSwgaGlzdG9yeSA9IFtdKSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLm1vZGVsc01vZHVsZSA9IG1vZGVsc01vZHVsZTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcbiAgICAgICAgLy8gQSBwcm9taXNlIHRvIHJlcHJlc2VudCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgbWVzc2FnZSBiZWluZyBzZW50IHRvIHRoZVxuICAgICAgICAvLyBtb2RlbC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB2YWxpZGF0ZUhpc3RvcnkoaGlzdG9yeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBtZXNzYWdlIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmVcbiAgICAgKiBzZW5kaW5nIHRoZSBuZXh0IG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBDaGF0I3NlbmRNZXNzYWdlU3RyZWFtfSBmb3Igc3RyZWFtaW5nIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gcGFyYW1ldGVycyBmb3Igc2VuZGluZyBtZXNzYWdlcyB3aXRoaW4gYSBjaGF0IHNlc3Npb24uXG4gICAgICogQHJldHVybnMgVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UudGV4dCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUHJvbWlzZTtcbiAgICAgICAgY29uc3QgaW5wdXRDb250ZW50ID0gdENvbnRlbnQocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnQoe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSAoX2IgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50O1xuICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgQUZDIGlucHV0IGNvbnRhaW5zIHRoZSBlbnRpcmUgY3VyYXRlZCBjaGF0IGhpc3RvcnkgaW5cbiAgICAgICAgICAgIC8vIGFkZGl0aW9uIHRvIHRoZSBuZXcgdXNlciBpbnB1dCwgd2UgbmVlZCB0byB0cnVuY2F0ZSB0aGUgQUZDIGhpc3RvcnlcbiAgICAgICAgICAgIC8vIHRvIGRlZHVwbGljYXRlIHRoZSBleGlzdGluZyBjaGF0IGhpc3RvcnkuXG4gICAgICAgICAgICBjb25zdCBmdWxsQXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IHJlc3BvbnNlLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SGlzdG9yeSh0cnVlKS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgaWYgKGZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgKF9jID0gZnVsbEF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3Rvcnkuc2xpY2UoaW5kZXgpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1vZGVsT3V0cHV0ID0gb3V0cHV0Q29udGVudCA/IFtvdXRwdXRDb250ZW50XSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRIaXN0b3J5KGlucHV0Q29udGVudCwgbW9kZWxPdXRwdXQsIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KSgpO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJlc2V0cyBzZW5kUHJvbWlzZSB0byBhdm9pZCBzdWJzZXF1ZW50IGNhbGxzIGZhaWxpbmdcbiAgICAgICAgICAgIHRoaXMuc2VuZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgbW9kZWwgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlIGluIGNodW5rcy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgbWVzc2FnZSB0byBiZSBwcm9jZXNzZWQgYmVmb3JlXG4gICAgICogc2VuZGluZyB0aGUgbmV4dCBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQ2hhdCNzZW5kTWVzc2FnZX0gZm9yIG5vbi1zdHJlYW1pbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIHRoZSBtZXNzYWdlLlxuICAgICAqIEByZXR1cm4gVGhlIG1vZGVsJ3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2hhdC5zZW5kTWVzc2FnZVN0cmVhbSh7XG4gICAgICogICBtZXNzYWdlOiAnV2h5IGlzIHRoZSBza3kgYmx1ZT8nXG4gICAgICogfSk7XG4gICAgICogZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZSkge1xuICAgICAqICAgY29uc29sZS5sb2coY2h1bmsudGV4dCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRNZXNzYWdlU3RyZWFtKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFByb21pc2U7XG4gICAgICAgIGNvbnN0IGlucHV0Q29udGVudCA9IHRDb250ZW50KHBhcmFtcy5tZXNzYWdlKTtcbiAgICAgICAgY29uc3Qgc3RyZWFtUmVzcG9uc2UgPSB0aGlzLm1vZGVsc01vZHVsZS5nZW5lcmF0ZUNvbnRlbnRTdHJlYW0oe1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgICAgICBjb250ZW50czogdGhpcy5nZXRIaXN0b3J5KHRydWUpLmNvbmNhdChpbnB1dENvbnRlbnQpLFxuICAgICAgICAgICAgY29uZmlnOiAoX2EgPSBwYXJhbXMuY29uZmlnKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlc29sdmUgdGhlIGludGVybmFsIHRyYWNraW5nIG9mIHNlbmQgY29tcGxldGlvbiBwcm9taXNlIC0gYHNlbmRQcm9taXNlYFxuICAgICAgICAvLyBmb3IgYm90aCBzdWNjZXNzIGFuZCBmYWlsdXJlIHJlc3BvbnNlLiBUaGUgYWN0dWFsIGZhaWx1cmUgaXMgc3RpbGxcbiAgICAgICAgLy8gcHJvcGFnYXRlZCBieSB0aGUgYGF3YWl0IHN0cmVhbVJlc3BvbnNlYC5cbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IHN0cmVhbVJlc3BvbnNlXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1bmRlZmluZWQpXG4gICAgICAgICAgICAuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzdHJlYW1SZXNwb25zZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UsIGlucHV0Q29udGVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoYXQgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGhpc3RvcnkgaXMgYSBsaXN0IG9mIGNvbnRlbnRzIGFsdGVybmF0aW5nIGJldHdlZW4gdXNlciBhbmQgbW9kZWwuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIGhpc3Rvcnk6XG4gICAgICogLSBUaGUgYGN1cmF0ZWQgaGlzdG9yeWAgY29udGFpbnMgb25seSB0aGUgdmFsaWQgdHVybnMgYmV0d2VlbiB1c2VyIGFuZFxuICAgICAqIG1vZGVsLCB3aGljaCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJzZXF1ZW50IHJlcXVlc3RzIHNlbnQgdG8gdGhlIG1vZGVsLlxuICAgICAqIC0gVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGNvbnRhaW5zIGFsbCB0dXJucywgaW5jbHVkaW5nIGludmFsaWQgb3JcbiAgICAgKiAgIGVtcHR5IG1vZGVsIG91dHB1dHMsIHByb3ZpZGluZyBhIGNvbXBsZXRlIHJlY29yZCBvZiB0aGUgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIFRoZSBoaXN0b3J5IGlzIHVwZGF0ZWQgYWZ0ZXIgcmVjZWl2aW5nIHRoZSByZXNwb25zZSBmcm9tIHRoZSBtb2RlbCxcbiAgICAgKiBmb3Igc3RyZWFtaW5nIHJlc3BvbnNlLCBpdCBtZWFucyByZWNlaXZpbmcgdGhlIGxhc3QgY2h1bmsgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogVGhlIGBjb21wcmVoZW5zaXZlIGhpc3RvcnlgIGlzIHJldHVybmVkIGJ5IGRlZmF1bHQuIFRvIGdldCB0aGUgYGN1cmF0ZWRcbiAgICAgKiBoaXN0b3J5YCwgc2V0IHRoZSBgY3VyYXRlZGAgcGFyYW1ldGVyIHRvIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjdXJhdGVkIC0gd2hldGhlciB0byByZXR1cm4gdGhlIGN1cmF0ZWQgaGlzdG9yeSBvciB0aGUgY29tcHJlaGVuc2l2ZVxuICAgICAqICAgICBoaXN0b3J5LlxuICAgICAqIEByZXR1cm4gSGlzdG9yeSBjb250ZW50cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsIGZvciB0aGUgZW50aXJlXG4gICAgICogICAgIGNoYXQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBnZXRIaXN0b3J5KGN1cmF0ZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoaXN0b3J5ID0gY3VyYXRlZFxuICAgICAgICAgICAgPyBleHRyYWN0Q3VyYXRlZEhpc3RvcnkodGhpcy5oaXN0b3J5KVxuICAgICAgICAgICAgOiB0aGlzLmhpc3Rvcnk7XG4gICAgICAgIC8vIERlZXAgY29weSB0aGUgaGlzdG9yeSB0byBhdm9pZCBtdXRhdGluZyB0aGUgaGlzdG9yeSBvdXRzaWRlIG9mIHRoZVxuICAgICAgICAvLyBjaGF0IHNlc3Npb24uXG4gICAgICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUoaGlzdG9yeSk7XG4gICAgfVxuICAgIHByb2Nlc3NTdHJlYW1SZXNwb25zZShzdHJlYW1SZXNwb25zZSwgaW5wdXRDb250ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHByb2Nlc3NTdHJlYW1SZXNwb25zZV8xKCkge1xuICAgICAgICAgICAgdmFyIF9jLCBlXzEsIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dENvbnRlbnQgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBzdHJlYW1SZXNwb25zZV8xID0gX19hc3luY1ZhbHVlcyhzdHJlYW1SZXNwb25zZSksIHN0cmVhbVJlc3BvbnNlXzFfMTsgc3RyZWFtUmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChzdHJlYW1SZXNwb25zZV8xLm5leHQoKSksIF9jID0gc3RyZWFtUmVzcG9uc2VfMV8xLmRvbmUsICFfYzsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9lID0gc3RyZWFtUmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9lO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFJlc3BvbnNlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChfYiA9IChfYSA9IGNodW5rLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q29udGVudC5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYyAmJiAoX2QgPSBzdHJlYW1SZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2QuY2FsbChzdHJlYW1SZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVjb3JkSGlzdG9yeShpbnB1dENvbnRlbnQsIG91dHB1dENvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVjb3JkSGlzdG9yeSh1c2VySW5wdXQsIG1vZGVsT3V0cHV0LCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5KSB7XG4gICAgICAgIGxldCBvdXRwdXRDb250ZW50cyA9IFtdO1xuICAgICAgICBpZiAobW9kZWxPdXRwdXQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgbW9kZWxPdXRwdXQuZXZlcnkoKGNvbnRlbnQpID0+IGNvbnRlbnQucm9sZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMgPSBtb2RlbE91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFwcGVuZHMgYW4gZW1wdHkgY29udGVudCB3aGVuIG1vZGVsIHJldHVybnMgZW1wdHkgcmVzcG9uc2UsIHNvIHRoYXQgdGhlXG4gICAgICAgICAgICAvLyBoaXN0b3J5IGlzIGFsd2F5cyBhbHRlcm5hdGluZyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICAgICAgICAgICAgb3V0cHV0Q29udGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm9sZTogJ21vZGVsJyxcbiAgICAgICAgICAgICAgICBwYXJ0czogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSAmJlxuICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5leHRyYWN0Q3VyYXRlZEhpc3RvcnkoYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2godXNlcklucHV0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCguLi5vdXRwdXRDb250ZW50cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIEFQSSBlcnJvcnMgcmFpc2VkIGJ5IHRoZSBHZW5BSSBBUEkuXG4gKi9cbmNsYXNzIEFwaUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FwaUVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEFwaUVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gbGlzdEZpbGVzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlc1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXN0RmlsZXNDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVTdGF0dXNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXRhaWxzJ10pO1xuICAgIGlmIChmcm9tRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RldGFpbHMnXSwgZnJvbURldGFpbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVzc2FnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVzc2FnZSddKTtcbiAgICBpZiAoZnJvbU1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXNzYWdlJ10sIGZyb21NZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvZGUnXSk7XG4gICAgaWYgKGZyb21Db2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZSddLCBmcm9tQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2l6ZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzaXplQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21TaXplQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzaXplQnl0ZXMnXSwgZnJvbVNpemVCeXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJhdGlvblRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleHBpcmF0aW9uVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeHBpcmF0aW9uVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4cGlyYXRpb25UaW1lJ10sIGZyb21FeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2hhMjU2SGFzaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2hhMjU2SGFzaCddKTtcbiAgICBpZiAoZnJvbVNoYTI1Nkhhc2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzaGEyNTZIYXNoJ10sIGZyb21TaGEyNTZIYXNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG93bmxvYWRVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rvd25sb2FkVXJpJ10pO1xuICAgIGlmIChmcm9tRG93bmxvYWRVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb3dubG9hZFVyaSddLCBmcm9tRG93bmxvYWRVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCBmcm9tU3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzb3VyY2UnXSwgZnJvbVNvdXJjZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZpbGVTdGF0dXNUb01sZGV2KGZyb21FcnJvcikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGUnXSk7XG4gICAgaWYgKGZyb21GaWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZSddLCBmaWxlVG9NbGRldihmcm9tRmlsZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldEZpbGVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ2ZpbGUnXSwgdEZpbGVOYW1lKGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnZmlsZSddLCB0RmlsZU5hbWUoZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlU3RhdHVzRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXRhaWxzJ10pO1xuICAgIGlmIChmcm9tRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RldGFpbHMnXSwgZnJvbURldGFpbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVzc2FnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVzc2FnZSddKTtcbiAgICBpZiAoZnJvbU1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXNzYWdlJ10sIGZyb21NZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvZGUnXSk7XG4gICAgaWYgKGZyb21Db2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZSddLCBmcm9tQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaXplQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NpemVCeXRlcyddKTtcbiAgICBpZiAoZnJvbVNpemVCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NpemVCeXRlcyddLCBmcm9tU2l6ZUJ5dGVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmF0aW9uVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4cGlyYXRpb25UaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4cGlyYXRpb25UaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhwaXJhdGlvblRpbWUnXSwgZnJvbUV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaGEyNTZIYXNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzaGEyNTZIYXNoJ10pO1xuICAgIGlmIChmcm9tU2hhMjU2SGFzaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NoYTI1Nkhhc2gnXSwgZnJvbVNoYTI1Nkhhc2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb3dubG9hZFVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG93bmxvYWRVcmknXSk7XG4gICAgaWYgKGZyb21Eb3dubG9hZFVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rvd25sb2FkVXJpJ10sIGZyb21Eb3dubG9hZFVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIGZyb21TdGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NvdXJjZSddLCBmcm9tU291cmNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIGZyb21WaWRlb01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZmlsZVN0YXR1c0Zyb21NbGRldihmcm9tRXJyb3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZXMnXSk7XG4gICAgaWYgKGZyb21GaWxlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRmlsZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlRmlsZVJlc3BvbnNlRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBGaWxlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGFsbCBjdXJyZW50IHByb2plY3QgZmlsZXMgZnJvbSB0aGUgc2VydmljZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgbGlzdCByZXF1ZXN0XG4gICAgICAgICAqIEByZXR1cm4gVGhlIHBhZ2luYXRlZCByZXN1bHRzIG9mIHRoZSBsaXN0IG9mIGZpbGVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSBwcmludHMgdGhlIG5hbWVzIG9mIGFsbCBmaWxlcyBmcm9tIHRoZSBzZXJ2aWNlLCB0aGVcbiAgICAgICAgICogc2l6ZSBvZiBlYWNoIHBhZ2UgaXMgMTAuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGxpc3RSZXNwb25zZSA9IGF3YWl0IGFpLmZpbGVzLmxpc3Qoe2NvbmZpZzogeydwYWdlU2l6ZSc6IDEwfX0pO1xuICAgICAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGZpbGUgb2YgbGlzdFJlc3BvbnNlKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9GSUxFUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgZmlsZSBhc3luY2hyb25vdXNseSB0byB0aGUgR2VtaW5pIEFQSS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBub3QgYXZhaWxhYmxlIGluIFZlcnRleCBBSS5cbiAgICAgKiBTdXBwb3J0ZWQgdXBsb2FkIHNvdXJjZXM6XG4gICAgICogLSBOb2RlLmpzOiBGaWxlIHBhdGggKHN0cmluZykgb3IgQmxvYiBvYmplY3QuXG4gICAgICogLSBCcm93c2VyOiBCbG9iIG9iamVjdCAoZS5nLiwgRmlsZSkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBgbWltZVR5cGVgIGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIGBjb25maWdgIHBhcmFtZXRlci4gSWYgb21pdHRlZDpcbiAgICAgKiAgLSBGb3IgZmlsZSBwYXRoIChzdHJpbmcpIGlucHV0cywgdGhlIGBtaW1lVHlwZWAgd2lsbCBiZSBpbmZlcnJlZCBmcm9tIHRoZVxuICAgICAqICAgICBmaWxlIGV4dGVuc2lvbi5cbiAgICAgKiAgLSBGb3IgQmxvYiBvYmplY3QgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIHNldCB0byB0aGUgQmxvYidzIGB0eXBlYFxuICAgICAqICAgICBwcm9wZXJ0eS5cbiAgICAgKiBTb21leCBlYW1wbGVzIGZvciBmaWxlIGV4dGVuc2lvbiB0byBtaW1lVHlwZSBtYXBwaW5nOlxuICAgICAqIC50eHQgLT4gdGV4dC9wbGFpblxuICAgICAqIC5qc29uIC0+IGFwcGxpY2F0aW9uL2pzb25cbiAgICAgKiAuanBnICAtPiBpbWFnZS9qcGVnXG4gICAgICogLnBuZyAtPiBpbWFnZS9wbmdcbiAgICAgKiAubXAzIC0+IGF1ZGlvL21wZWdcbiAgICAgKiAubXA0IC0+IHZpZGVvL21wNFxuICAgICAqXG4gICAgICogVGhpcyBzZWN0aW9uIGNhbiBjb250YWluIG11bHRpcGxlIHBhcmFncmFwaHMgYW5kIGNvZGUgZXhhbXBsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gdGhlXG4gICAgICogICAgICAgIGB0eXBlcy5VcGxvYWRGaWxlUGFyYW1ldGVyc2AgaW50ZXJmYWNlLlxuICAgICAqICAgICAgICAgQHNlZSB7QGxpbmsgdHlwZXMuVXBsb2FkRmlsZVBhcmFtZXRlcnMjY29uZmlnfSBmb3IgdGhlIG9wdGlvbmFsXG4gICAgICogICAgICAgICBjb25maWcgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGB0eXBlcy5GaWxlYCBvYmplY3QuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBjYWxsZWQgb24gYSBWZXJ0ZXggQUkgY2xpZW50LlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgdGhlIGBtaW1lVHlwZWAgaXMgbm90IHByb3ZpZGVkIGFuZCBjYW4gbm90IGJlIGluZmVycmVkLFxuICAgICAqIHRoZSBgbWltZVR5cGVgIGNhbiBiZSBwcm92aWRlZCBpbiB0aGUgYHBhcmFtcy5jb25maWdgIHBhcmFtZXRlci5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIG9jY3VycyBpZiBhIHN1aXRhYmxlIHVwbG9hZCBsb2NhdGlvbiBjYW5ub3QgYmUgZXN0YWJsaXNoZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSB1cGxvYWRzIGEgZmlsZSB0byBHZW1pbmkgQVBJLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBmaWxlID0gYXdhaXQgYWkuZmlsZXMudXBsb2FkKHtmaWxlOiAnZmlsZS50eHQnLCBjb25maWc6IHtcbiAgICAgKiAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgICogfX0pO1xuICAgICAqIGNvbnNvbGUubG9nKGZpbGUubmFtZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnRleCBBSSBkb2VzIG5vdCBzdXBwb3J0IHVwbG9hZGluZyBmaWxlcy4gWW91IGNhbiBzaGFyZSBmaWxlcyB0aHJvdWdoIGEgR0NTIGJ1Y2tldC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgIC51cGxvYWRGaWxlKHBhcmFtcy5maWxlLCBwYXJhbXMuY29uZmlnKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gZmlsZUZyb21NbGRldihyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkcyBhIHJlbW90ZWx5IHN0b3JlZCBmaWxlIGFzeW5jaHJvbm91c2x5IHRvIGEgbG9jYXRpb24gc3BlY2lmaWVkIGluXG4gICAgICogdGhlIGBwYXJhbXNgIG9iamVjdC4gVGhpcyBtZXRob2Qgb25seSB3b3JrcyBvbiBOb2RlIGVudmlyb25tZW50LCB0b1xuICAgICAqIGRvd25sb2FkIGZpbGVzIGluIHRoZSBicm93c2VyLCB1c2UgYSBicm93c2VyIGNvbXBsaWFudCBtZXRob2QgbGlrZSBhbiA8YT5cbiAgICAgKiB0YWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkb3dubG9hZCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgZG93bmxvYWRzIGFuIGV4YW1wbGUgZmlsZSBuYW1lZCBcImZpbGVzL21laG96cHhmODc3ZFwiIGFzXG4gICAgICogXCJmaWxlLnR4dFwiLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5maWxlcy5kb3dubG9hZCh7ZmlsZTogZmlsZS5uYW1lLCBkb3dubG9hZFBhdGg6ICdmaWxlLnR4dCd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZChwYXJhbXMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQuZG93bmxvYWRGaWxlKHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdEZpbGVzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2ZpbGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0RmlsZXNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RGaWxlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjcmVhdGVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd1cGxvYWQvdjFiZXRhL2ZpbGVzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBDcmVhdGVGaWxlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZmlsZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IHJlcXVlc3RcbiAgICAgKiBAcmV0dXJuIFRoZSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHR5cGVzLkZpbGUgb2JqZWN0IHJlcXVlc3RlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjb25maWc6IEdldEZpbGVQYXJhbWV0ZXJzID0ge1xuICAgICAqICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICogfTtcbiAgICAgKiBmaWxlID0gYXdhaXQgYWkuZmlsZXMuZ2V0KGNvbmZpZyk7XG4gICAgICogY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldEZpbGVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMve2ZpbGV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGZpbGVGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHJlbW90ZWx5IHN0b3JlZCBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZGVsZXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgRGVsZXRlRmlsZVJlc3BvbnNlLCB0aGUgcmVzcG9uc2UgZm9yIHRoZSBkZWxldGUgbWV0aG9kLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNvZGUgZGVsZXRlcyBhbiBleGFtcGxlIGZpbGUgbmFtZWQgXCJmaWxlcy9tZWhvenB4Zjg3N2RcIi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuZmlsZXMuZGVsZXRlKHtuYW1lOiBmaWxlLm5hbWV9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMve2ZpbGV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlRmlsZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gcHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZU5hbWUnXSk7XG4gICAgaWYgKGZyb21Wb2ljZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZU5hbWUnXSwgZnJvbVZvaWNlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QcmVidWlsdFZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlYnVpbHRWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlYnVpbHRWb2ljZUNvbmZpZyddLCBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3BlYWtlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlYWtlciddKTtcbiAgICBpZiAoZnJvbVNwZWFrZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVha2VyJ10sIGZyb21TcGVha2VyKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2JDIoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyVm9pY2VDb25maWdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3BlYWtlclZvaWNlQ29uZmlncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TcGVha2VyVm9pY2VDb25maWdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TcGVha2VyVm9pY2VDb25maWdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWFrZXJWb2ljZUNvbmZpZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlZWNoQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIHZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21Wb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJ10sIG11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFUb01sZGV2JDIoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkMihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkMihmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CZWhhdmlvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSk7XG4gICAgaWYgKGZyb21CZWhhdmlvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JlaGF2aW9yJ10sIGZyb21CZWhhdmlvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGludGVydmFsVG9NbGRldiQyKGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMihmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0VG9NbGRldiQyKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbXB1dGVyVXNlVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbnZpcm9ubWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW52aXJvbm1lbnQnXSk7XG4gICAgaWYgKGZyb21FbnZpcm9ubWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vudmlyb25tZW50J10sIGZyb21FbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQyKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQyKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb29nbGVNYXBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvTWxkZXYkMigpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgdG9vbENvbXB1dGVyVXNlVG9NbGRldiQyKGZyb21Db21wdXRlclVzZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydoYW5kbGUnXSk7XG4gICAgaWYgKGZyb21IYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydoYW5kbGUnXSwgZnJvbUhhbmRsZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYW5zcGFyZW50J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc3BhcmVudCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2JDEoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzYWJsZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc2FibGVkJ10pO1xuICAgIGlmIChmcm9tRGlzYWJsZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNhYmxlZCddLCBmcm9tRGlzYWJsZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSddLCBmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmRPZlNwZWVjaFNlbnNpdGl2aXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZlNwZWVjaFNlbnNpdGl2aXR5J10sIGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZWZpeFBhZGRpbmdNcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWZpeFBhZGRpbmdNcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVmaXhQYWRkaW5nTXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVmaXhQYWRkaW5nTXMnXSwgZnJvbVByZWZpeFBhZGRpbmdNcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaWxlbmNlRHVyYXRpb25NcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NpbGVuY2VEdXJhdGlvbk1zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNpbGVuY2VEdXJhdGlvbk1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2lsZW5jZUR1cmF0aW9uTXMnXSwgZnJvbVNpbGVuY2VEdXJhdGlvbk1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVhbHRpbWVJbnB1dENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uJ10sIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9NbGRldiQxKGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlIYW5kbGluZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FjdGl2aXR5SGFuZGxpbmcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlIYW5kbGluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5SGFuZGxpbmcnXSwgZnJvbUFjdGl2aXR5SGFuZGxpbmcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVybkNvdmVyYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dXJuQ292ZXJhZ2UnXSk7XG4gICAgaWYgKGZyb21UdXJuQ292ZXJhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dXJuQ292ZXJhZ2UnXSwgZnJvbVR1cm5Db3ZlcmFnZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNsaWRpbmdXaW5kb3dUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhcmdldFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFyZ2V0VG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVGFyZ2V0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGFyZ2V0VG9rZW5zJ10sIGZyb21UYXJnZXRUb2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRyaWdnZXJUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0cmlnZ2VyVG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyaWdnZXJUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmlnZ2VyVG9rZW5zJ10sIGZyb21UcmlnZ2VyVG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNsaWRpbmdXaW5kb3cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzbGlkaW5nV2luZG93JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNsaWRpbmdXaW5kb3cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzbGlkaW5nV2luZG93J10sIHNsaWRpbmdXaW5kb3dUb01sZGV2JDEoZnJvbVNsaWRpbmdXaW5kb3cpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJvYWN0aXZpdHlDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb2FjdGl2ZUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvYWN0aXZlQXVkaW8nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvYWN0aXZlQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9hY3RpdmVBdWRpbyddLCBmcm9tUHJvYWN0aXZlQXVkaW8pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnXSwgZnJvbUdlbmVyYXRpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9NbGRldiQyKHRMaXZlU3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQyKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDIodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9NbGRldiQxKGZyb21TZXNzaW9uUmVzdW1wdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2JDEoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2JDEoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWFsdGltZUlucHV0Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVhbHRpbWVJbnB1dENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWFsdGltZUlucHV0Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3JlYWx0aW1lSW5wdXRDb25maWcnXSwgcmVhbHRpbWVJbnB1dENvbmZpZ1RvTWxkZXYkMShmcm9tUmVhbHRpbWVJbnB1dENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nXSwgY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9NbGRldiQxKGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2FjdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9hY3Rpdml0eSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2FjdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Byb2FjdGl2aXR5J10sIHByb2FjdGl2aXR5Q29uZmlnVG9NbGRldiQxKGZyb21Qcm9hY3Rpdml0eSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYkMShmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhY3Rpdml0eVN0YXJ0VG9NbGRldigpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGFjdGl2aXR5RW5kVG9NbGRldigpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVkaWEnXSk7XG4gICAgaWYgKGZyb21NZWRpYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhQ2h1bmtzJ10sIHRCbG9icyhmcm9tTWVkaWEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpbyddKTtcbiAgICBpZiAoZnJvbUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW8nXSwgdEF1ZGlvQmxvYihmcm9tQXVkaW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvU3RyZWFtRW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9TdHJlYW1FbmQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9TdHJlYW1FbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1N0cmVhbUVuZCddLCBmcm9tQXVkaW9TdHJlYW1FbmQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB0SW1hZ2VCbG9iKGZyb21WaWRlbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5U3RhcnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhY3Rpdml0eVN0YXJ0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5U3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eVN0YXJ0J10sIGFjdGl2aXR5U3RhcnRUb01sZGV2KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlFbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlFbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eUVuZCddLCBhY3Rpdml0eUVuZFRvTWxkZXYoKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHdlaWdodGVkUHJvbXB0VG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVdlaWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnd2VpZ2h0J10pO1xuICAgIGlmIChmcm9tV2VpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnd2VpZ2h0J10sIGZyb21XZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNTZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tV2VpZ2h0ZWRQcm9tcHRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnd2VpZ2h0ZWRQcm9tcHRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVdlaWdodGVkUHJvbXB0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tV2VpZ2h0ZWRQcm9tcHRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdlaWdodGVkUHJvbXB0VG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3dlaWdodGVkUHJvbXB0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNHZW5lcmF0aW9uQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ3VpZGFuY2UnXSk7XG4gICAgaWYgKGZyb21HdWlkYW5jZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2d1aWRhbmNlJ10sIGZyb21HdWlkYW5jZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CcG0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JwbSddKTtcbiAgICBpZiAoZnJvbUJwbSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JwbSddLCBmcm9tQnBtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlbnNpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlbnNpdHknXSk7XG4gICAgaWYgKGZyb21EZW5zaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVuc2l0eSddLCBmcm9tRGVuc2l0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CcmlnaHRuZXNzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydicmlnaHRuZXNzJ10pO1xuICAgIGlmIChmcm9tQnJpZ2h0bmVzcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JyaWdodG5lc3MnXSwgZnJvbUJyaWdodG5lc3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NjYWxlJ10pO1xuICAgIGlmIChmcm9tU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY2FsZSddLCBmcm9tU2NhbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXV0ZUJhc3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ211dGVCYXNzJ10pO1xuICAgIGlmIChmcm9tTXV0ZUJhc3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXRlQmFzcyddLCBmcm9tTXV0ZUJhc3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXV0ZURydW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtdXRlRHJ1bXMnXSk7XG4gICAgaWYgKGZyb21NdXRlRHJ1bXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXRlRHJ1bXMnXSwgZnJvbU11dGVEcnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Pbmx5QmFzc0FuZERydW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb25seUJhc3NBbmREcnVtcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Pbmx5QmFzc0FuZERydW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb25seUJhc3NBbmREcnVtcyddLCBmcm9tT25seUJhc3NBbmREcnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdXNpY0dlbmVyYXRpb25Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbXVzaWNHZW5lcmF0aW9uTW9kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdXNpY0dlbmVyYXRpb25Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVzaWNHZW5lcmF0aW9uTW9kZSddLCBmcm9tTXVzaWNHZW5lcmF0aW9uTW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdXNpY0dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVzaWNHZW5lcmF0aW9uQ29uZmlnJ10sIGxpdmVNdXNpY0dlbmVyYXRpb25Db25maWdUb01sZGV2KGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljQ2xpZW50U2V0dXBUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY0NsaWVudENvbnRlbnRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21XZWlnaHRlZFByb21wdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd3ZWlnaHRlZFByb21wdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tV2VpZ2h0ZWRQcm9tcHRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21XZWlnaHRlZFByb21wdHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2VpZ2h0ZWRQcm9tcHRUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnd2VpZ2h0ZWRQcm9tcHRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY0NsaWVudE1lc3NhZ2VUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZXR1cCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2V0dXAnXSk7XG4gICAgaWYgKGZyb21TZXR1cCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwJ10sIGxpdmVNdXNpY0NsaWVudFNldHVwVG9NbGRldihmcm9tU2V0dXApKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNsaWVudENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjbGllbnRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNsaWVudENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjbGllbnRDb250ZW50J10sIGxpdmVNdXNpY0NsaWVudENvbnRlbnRUb01sZGV2KGZyb21DbGllbnRDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdXNpY0dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVzaWNHZW5lcmF0aW9uQ29uZmlnJ10sIGxpdmVNdXNpY0dlbmVyYXRpb25Db25maWdUb01sZGV2KGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBsYXliYWNrQ29udHJvbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BsYXliYWNrQ29udHJvbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QbGF5YmFja0NvbnRyb2wgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwbGF5YmFja0NvbnRyb2wnXSwgZnJvbVBsYXliYWNrQ29udHJvbCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHByZWJ1aWx0Vm9pY2VDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVZvaWNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlTmFtZSddLCBmcm9tVm9pY2VOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdm9pY2VDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QcmVidWlsdFZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlYnVpbHRWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlYnVpbHRWb2ljZUNvbmZpZyddLCBwcmVidWlsdFZvaWNlQ29uZmlnVG9WZXJ0ZXgkMShmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIHZvaWNlQ29uZmlnVG9WZXJ0ZXgkMShmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10pO1xuICAgIGlmIChmcm9tTGFuZ3VhZ2VDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10sIGZyb21MYW5ndWFnZUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFUb1ZlcnRleCQxKGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb1ZlcnRleCQxKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9WZXJ0ZXgkMShmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnJvbUZ1bmN0aW9uQ2FsbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb1ZlcnRleCQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZWhhdmlvciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb1ZlcnRleCQxKGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVEb21haW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZURvbWFpbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZURvbWFpbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlRG9tYWlucyddLCBmcm9tRXhjbHVkZURvbWFpbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR5bmFtaWNUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljVGhyZXNob2xkJ10sIGZyb21EeW5hbWljVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4JDEoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW50ZXJwcmlzZVdlYlNlYXJjaFRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVEb21haW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZURvbWFpbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZURvbWFpbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlRG9tYWlucyddLCBmcm9tRXhjbHVkZURvbWFpbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhcGlLZXlDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BcGlLZXlTdHJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FwaUtleVN0cmluZyddKTtcbiAgICBpZiAoZnJvbUFwaUtleVN0cmluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FwaUtleVN0cmluZyddLCBmcm9tQXBpS2V5U3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXV0aENvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFwaUtleUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXBpS2V5Q29uZmlnJ10pO1xuICAgIGlmIChmcm9tQXBpS2V5Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXBpS2V5Q29uZmlnJ10sIGFwaUtleUNvbmZpZ1RvVmVydGV4JDEoZnJvbUFwaUtleUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXV0aFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhUeXBlJ10pO1xuICAgIGlmIChmcm9tQXV0aFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdXRoVHlwZSddLCBmcm9tQXV0aFR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnJ10sIGZyb21Hb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21IdHRwQmFzaWNBdXRoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaHR0cEJhc2ljQXV0aENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21IdHRwQmFzaWNBdXRoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaHR0cEJhc2ljQXV0aENvbmZpZyddLCBmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PYXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb2F1dGhDb25maWcnXSk7XG4gICAgaWYgKGZyb21PYXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29hdXRoQ29uZmlnJ10sIGZyb21PYXV0aENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PaWRjQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvaWRjQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tT2lkY0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29pZGNDb25maWcnXSwgZnJvbU9pZGNDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKTtcbiAgICBpZiAoZnJvbUF1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdXRoQ29uZmlnJ10sIGF1dGhDb25maWdUb1ZlcnRleCQxKGZyb21BdXRoQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRUb1ZlcnRleCQxKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbXB1dGVyVXNlVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRW52aXJvbm1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vudmlyb25tZW50J10pO1xuICAgIGlmIChmcm9tRW52aXJvbm1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnZpcm9ubWVudCddLCBmcm9tRW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb1ZlcnRleCQxKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgkMShmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnRlcnByaXNlV2ViU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW50ZXJwcmlzZVdlYlNlYXJjaCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddLCBlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgkMShmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb1ZlcnRleCQxKGZyb21Hb29nbGVNYXBzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvVmVydGV4JDEoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIHRvb2xDb21wdXRlclVzZVRvVmVydGV4JDEoZnJvbUNvbXB1dGVyVXNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaGFuZGxlJ10pO1xuICAgIGlmIChmcm9tSGFuZGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaGFuZGxlJ10sIGZyb21IYW5kbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhbnNwYXJlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYW5zcGFyZW50J10pO1xuICAgIGlmIChmcm9tVHJhbnNwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmFuc3BhcmVudCddLCBmcm9tVHJhbnNwYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb1ZlcnRleCgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc2FibGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNhYmxlZCddKTtcbiAgICBpZiAoZnJvbURpc2FibGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzYWJsZWQnXSwgZnJvbURpc2FibGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHknXSwgZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5kT2ZTcGVlY2hTZW5zaXRpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2ZTcGVlY2hTZW5zaXRpdml0eSddLCBmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVmaXhQYWRkaW5nTXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVmaXhQYWRkaW5nTXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlZml4UGFkZGluZ01zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlZml4UGFkZGluZ01zJ10sIGZyb21QcmVmaXhQYWRkaW5nTXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2lsZW5jZUR1cmF0aW9uTXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzaWxlbmNlRHVyYXRpb25NcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TaWxlbmNlRHVyYXRpb25NcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NpbGVuY2VEdXJhdGlvbk1zJ10sIGZyb21TaWxlbmNlRHVyYXRpb25Ncyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlYWx0aW1lSW5wdXRDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uJ10sIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9WZXJ0ZXgoZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUhhbmRsaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWN0aXZpdHlIYW5kbGluZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUhhbmRsaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlIYW5kbGluZyddLCBmcm9tQWN0aXZpdHlIYW5kbGluZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ292ZXJhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1cm5Db3ZlcmFnZSddKTtcbiAgICBpZiAoZnJvbVR1cm5Db3ZlcmFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db3ZlcmFnZSddLCBmcm9tVHVybkNvdmVyYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2xpZGluZ1dpbmRvd1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UYXJnZXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RhcmdldFRva2VucyddKTtcbiAgICBpZiAoZnJvbVRhcmdldFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RhcmdldFRva2VucyddLCBmcm9tVGFyZ2V0VG9rZW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRyaWdnZXJUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0cmlnZ2VyVG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyaWdnZXJUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmlnZ2VyVG9rZW5zJ10sIGZyb21UcmlnZ2VyVG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNsaWRpbmdXaW5kb3cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzbGlkaW5nV2luZG93JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNsaWRpbmdXaW5kb3cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzbGlkaW5nV2luZG93J10sIHNsaWRpbmdXaW5kb3dUb1ZlcnRleChmcm9tU2xpZGluZ1dpbmRvdykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcm9hY3Rpdml0eUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9hY3RpdmVBdWRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb2FjdGl2ZUF1ZGlvJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb2FjdGl2ZUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvYWN0aXZlQXVkaW8nXSwgZnJvbVByb2FjdGl2ZUF1ZGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnXSwgZnJvbUdlbmVyYXRpb25Db25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4T3V0cHV0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4T3V0cHV0VG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1heE91dHB1dFRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21heE91dHB1dFRva2VucyddLCBmcm9tTWF4T3V0cHV0VG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9WZXJ0ZXgkMSh0TGl2ZVNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZyddLCBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvVmVydGV4JDEodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4JDEodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlc3Npb25SZXN1bXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Nlc3Npb25SZXN1bXB0aW9uJ10sIHNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbVNlc3Npb25SZXN1bXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvVmVydGV4KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9WZXJ0ZXgoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWFsdGltZUlucHV0Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVhbHRpbWVJbnB1dENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZWFsdGltZUlucHV0Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3JlYWx0aW1lSW5wdXRDb25maWcnXSwgcmVhbHRpbWVJbnB1dENvbmZpZ1RvVmVydGV4KGZyb21SZWFsdGltZUlucHV0Q29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbiddLCBjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb1ZlcnRleChmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9hY3Rpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvYWN0aXZpdHknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9hY3Rpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdwcm9hY3Rpdml0eSddLCBwcm9hY3Rpdml0eUNvbmZpZ1RvVmVydGV4KGZyb21Qcm9hY3Rpdml0eSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGl2ZUNvbm5lY3RDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhY3Rpdml0eVN0YXJ0VG9WZXJ0ZXgoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhY3Rpdml0eUVuZFRvVmVydGV4KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVkaWEnXSk7XG4gICAgaWYgKGZyb21NZWRpYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhQ2h1bmtzJ10sIHRCbG9icyhmcm9tTWVkaWEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpbyddKTtcbiAgICBpZiAoZnJvbUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW8nXSwgdEF1ZGlvQmxvYihmcm9tQXVkaW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvU3RyZWFtRW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9TdHJlYW1FbmQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9TdHJlYW1FbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1N0cmVhbUVuZCddLCBmcm9tQXVkaW9TdHJlYW1FbmQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB0SW1hZ2VCbG9iKGZyb21WaWRlbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5U3RhcnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhY3Rpdml0eVN0YXJ0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5U3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eVN0YXJ0J10sIGFjdGl2aXR5U3RhcnRUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5RW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhY3Rpdml0eUVuZCddKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5RW5kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSwgYWN0aXZpdHlFbmRUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclNldHVwQ29tcGxldGVGcm9tTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydEZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYkZyb21NbGRldiQxKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhRnJvbU1sZGV2JDEoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZyb21GdW5jdGlvbkNhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydEZyb21NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRyYW5zY3JpcHRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmluaXNoZWQnXSk7XG4gICAgaWYgKGZyb21GaW5pc2hlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaGVkJ10sIGZyb21GaW5pc2hlZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybE1ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJldHJpZXZlZFVybCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmVkVXJsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmVkVXJsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmVkVXJsJ10sIGZyb21SZXRyaWV2ZWRVcmwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsUmV0cmlldmFsU3RhdHVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybFJldHJpZXZhbFN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybFJldHJpZXZhbFN0YXR1cyddLCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dE1ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVybE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxNZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbVVybE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21VcmxNZXRhZGF0YTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmxNZXRhZGF0YUZyb21NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsTWV0YWRhdGEnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlckNvbnRlbnRGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsVHVybiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxUdXJuJ10pO1xuICAgIGlmIChmcm9tTW9kZWxUdXJuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxUdXJuJ10sIGNvbnRlbnRGcm9tTWxkZXYkMShmcm9tTW9kZWxUdXJuKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZSddKTtcbiAgICBpZiAoZnJvbVR1cm5Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZSddLCBmcm9tVHVybkNvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUludGVycnVwdGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbnRlcnJ1cHRlZCddKTtcbiAgICBpZiAoZnJvbUludGVycnVwdGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW50ZXJydXB0ZWQnXSwgZnJvbUludGVycnVwdGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbXBsZXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRpb25Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRpb25Db21wbGV0ZSddLCBmcm9tR2VuZXJhdGlvbkNvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0VHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0VHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbnB1dFRyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnB1dFRyYW5zY3JpcHRpb24nXSwgdHJhbnNjcmlwdGlvbkZyb21NbGRldihmcm9tSW5wdXRUcmFuc2NyaXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0VHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VHJhbnNjcmlwdGlvbiddLCB0cmFuc2NyaXB0aW9uRnJvbU1sZGV2KGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0TWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxDb250ZXh0TWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dE1ldGFkYXRhJ10sIHVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldiQxKGZyb21VcmxDb250ZXh0TWV0YWRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclRvb2xDYWxsRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkNhbGxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2FsbEZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclRvb2xDYWxsQ2FuY2VsbGF0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkcyddKTtcbiAgICBpZiAoZnJvbUlkcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkcyddLCBmcm9tSWRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbW9kYWxpdHlUb2tlbkNvdW50RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kYWxpdHknXSk7XG4gICAgaWYgKGZyb21Nb2RhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGFsaXR5J10sIGZyb21Nb2RhbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbkNvdW50J10pO1xuICAgIGlmIChmcm9tVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSwgZnJvbVRva2VuQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1c2FnZU1ldGFkYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5Db3VudCddLCBmcm9tUHJvbXB0VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudFRva2VuQ291bnQnXSwgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2VuQ291bnQnXSwgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xVc2VQcm9tcHRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbFVzZVByb21wdFRva2VuQ291bnQnXSwgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRzVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRzVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0c1Rva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0c1Rva2VuQ291bnQnXSwgZnJvbVRob3VnaHRzVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3RhbFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b3RhbFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbkNvdW50J10sIGZyb21Ub3RhbFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUHJvbXB0VG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZVRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZVRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyR29Bd2F5RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaW1lTGVmdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGltZUxlZnQnXSk7XG4gICAgaWYgKGZyb21UaW1lTGVmdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVMZWZ0J10sIGZyb21UaW1lTGVmdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmV3SGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduZXdIYW5kbGUnXSk7XG4gICAgaWYgKGZyb21OZXdIYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXdIYW5kbGUnXSwgZnJvbU5ld0hhbmRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXN1bWFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3VtYWJsZSddKTtcbiAgICBpZiAoZnJvbVJlc3VtYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3VtYWJsZSddLCBmcm9tUmVzdW1hYmxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgnXSwgZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZXR1cENvbXBsZXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2V0dXBDb21wbGV0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXR1cENvbXBsZXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXBDb21wbGV0ZSddLCBsaXZlU2VydmVyU2V0dXBDb21wbGV0ZUZyb21NbGRldigpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlcnZlckNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2ZXJDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZlckNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXJ2ZXJDb250ZW50J10sIGxpdmVTZXJ2ZXJDb250ZW50RnJvbU1sZGV2KGZyb21TZXJ2ZXJDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENhbGwnXSk7XG4gICAgaWYgKGZyb21Ub29sQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xDYWxsJ10sIGxpdmVTZXJ2ZXJUb29sQ2FsbEZyb21NbGRldihmcm9tVG9vbENhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbENhbGxDYW5jZWxsYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbENhbmNlbGxhdGlvbiddLCBsaXZlU2VydmVyVG9vbENhbGxDYW5jZWxsYXRpb25Gcm9tTWxkZXYoZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCB1c2FnZU1ldGFkYXRhRnJvbU1sZGV2KGZyb21Vc2FnZU1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb0F3YXkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvQXdheSddKTtcbiAgICBpZiAoZnJvbUdvQXdheSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvQXdheSddLCBsaXZlU2VydmVyR29Bd2F5RnJvbU1sZGV2KGZyb21Hb0F3YXkpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb25VcGRhdGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSddLCBsaXZlU2VydmVyU2Vzc2lvblJlc3VtcHRpb25VcGRhdGVGcm9tTWxkZXYoZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NlcnZlclNldHVwQ29tcGxldGVGcm9tTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB3ZWlnaHRlZFByb21wdEZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVdlaWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnd2VpZ2h0J10pO1xuICAgIGlmIChmcm9tV2VpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnd2VpZ2h0J10sIGZyb21XZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNDbGllbnRDb250ZW50RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21XZWlnaHRlZFByb21wdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd3ZWlnaHRlZFByb21wdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tV2VpZ2h0ZWRQcm9tcHRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21XZWlnaHRlZFByb21wdHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2VpZ2h0ZWRQcm9tcHRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3ZWlnaHRlZFByb21wdHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljR2VuZXJhdGlvbkNvbmZpZ0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ3VpZGFuY2UnXSk7XG4gICAgaWYgKGZyb21HdWlkYW5jZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2d1aWRhbmNlJ10sIGZyb21HdWlkYW5jZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CcG0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JwbSddKTtcbiAgICBpZiAoZnJvbUJwbSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JwbSddLCBmcm9tQnBtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlbnNpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlbnNpdHknXSk7XG4gICAgaWYgKGZyb21EZW5zaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVuc2l0eSddLCBmcm9tRGVuc2l0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CcmlnaHRuZXNzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydicmlnaHRuZXNzJ10pO1xuICAgIGlmIChmcm9tQnJpZ2h0bmVzcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JyaWdodG5lc3MnXSwgZnJvbUJyaWdodG5lc3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NjYWxlJ10pO1xuICAgIGlmIChmcm9tU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY2FsZSddLCBmcm9tU2NhbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXV0ZUJhc3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ211dGVCYXNzJ10pO1xuICAgIGlmIChmcm9tTXV0ZUJhc3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXRlQmFzcyddLCBmcm9tTXV0ZUJhc3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXV0ZURydW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtdXRlRHJ1bXMnXSk7XG4gICAgaWYgKGZyb21NdXRlRHJ1bXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXRlRHJ1bXMnXSwgZnJvbU11dGVEcnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Pbmx5QmFzc0FuZERydW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb25seUJhc3NBbmREcnVtcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Pbmx5QmFzc0FuZERydW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb25seUJhc3NBbmREcnVtcyddLCBmcm9tT25seUJhc3NBbmREcnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdXNpY0dlbmVyYXRpb25Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbXVzaWNHZW5lcmF0aW9uTW9kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdXNpY0dlbmVyYXRpb25Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVzaWNHZW5lcmF0aW9uTW9kZSddLCBmcm9tTXVzaWNHZW5lcmF0aW9uTW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NvdXJjZU1ldGFkYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DbGllbnRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2xpZW50Q29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DbGllbnRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2xpZW50Q29udGVudCddLCBsaXZlTXVzaWNDbGllbnRDb250ZW50RnJvbU1sZGV2KGZyb21DbGllbnRDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdXNpY0dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVzaWNHZW5lcmF0aW9uQ29uZmlnJ10sIGxpdmVNdXNpY0dlbmVyYXRpb25Db25maWdGcm9tTWxkZXYoZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdWRpb0NodW5rRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzb3VyY2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Tb3VyY2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NvdXJjZU1ldGFkYXRhJ10sIGxpdmVNdXNpY1NvdXJjZU1ldGFkYXRhRnJvbU1sZGV2KGZyb21Tb3VyY2VNZXRhZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNTZXJ2ZXJDb250ZW50RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BdWRpb0NodW5rcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXVkaW9DaHVua3MnXSk7XG4gICAgaWYgKGZyb21BdWRpb0NodW5rcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQXVkaW9DaHVua3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXVkaW9DaHVua0Zyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvQ2h1bmtzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY0ZpbHRlcmVkUHJvbXB0RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyZWRSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmaWx0ZXJlZFJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GaWx0ZXJlZFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbHRlcmVkUmVhc29uJ10sIGZyb21GaWx0ZXJlZFJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY1NlcnZlck1lc3NhZ2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXR1cENvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNldHVwQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cENvbXBsZXRlJ10sIGxpdmVNdXNpY1NlcnZlclNldHVwQ29tcGxldGVGcm9tTWxkZXYoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXJ2ZXJDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2VydmVyQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXJ2ZXJDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VydmVyQ29udGVudCddLCBsaXZlTXVzaWNTZXJ2ZXJDb250ZW50RnJvbU1sZGV2KGZyb21TZXJ2ZXJDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXJlZFByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZpbHRlcmVkUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZpbHRlcmVkUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsdGVyZWRQcm9tcHQnXSwgbGl2ZU11c2ljRmlsdGVyZWRQcm9tcHRGcm9tTWxkZXYoZnJvbUZpbHRlcmVkUHJvbXB0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2Vzc2lvbklkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZXNzaW9uSWQnXSk7XG4gICAgaWYgKGZyb21TZXNzaW9uSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXNzaW9uSWQnXSwgZnJvbVNlc3Npb25JZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JGcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0RnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhRnJvbVZlcnRleCQxKGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JGcm9tVmVydGV4JDEoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFGcm9tVmVydGV4JDEoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZyb21GdW5jdGlvbkNhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRGcm9tVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHJhbnNjcmlwdGlvbkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmluaXNoZWQnXSk7XG4gICAgaWYgKGZyb21GaW5pc2hlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaGVkJ10sIGZyb21GaW5pc2hlZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJDb250ZW50RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWxUdXJuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFR1cm4nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFR1cm4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFR1cm4nXSwgY29udGVudEZyb21WZXJ0ZXgkMShmcm9tTW9kZWxUdXJuKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZSddKTtcbiAgICBpZiAoZnJvbVR1cm5Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZSddLCBmcm9tVHVybkNvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUludGVycnVwdGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbnRlcnJ1cHRlZCddKTtcbiAgICBpZiAoZnJvbUludGVycnVwdGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW50ZXJydXB0ZWQnXSwgZnJvbUludGVycnVwdGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbXBsZXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRpb25Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRpb25Db21wbGV0ZSddLCBmcm9tR2VuZXJhdGlvbkNvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0VHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0VHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbnB1dFRyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnB1dFRyYW5zY3JpcHRpb24nXSwgdHJhbnNjcmlwdGlvbkZyb21WZXJ0ZXgoZnJvbUlucHV0VHJhbnNjcmlwdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0VHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dFRyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3V0cHV0VHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ291dHB1dFRyYW5zY3JpcHRpb24nXSwgdHJhbnNjcmlwdGlvbkZyb21WZXJ0ZXgoZnJvbU91dHB1dFRyYW5zY3JpcHRpb24pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJUb29sQ2FsbEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uQ2FsbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxsRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclRvb2xDYWxsQ2FuY2VsbGF0aW9uRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZHMnXSk7XG4gICAgaWYgKGZyb21JZHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZHMnXSwgZnJvbUlkcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGFsaXR5VG9rZW5Db3VudEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RhbGl0eSddKTtcbiAgICBpZiAoZnJvbU1vZGFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kYWxpdHknXSwgZnJvbU1vZGFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVzYWdlTWV0YWRhdGFGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5Db3VudCddLCBmcm9tUHJvbXB0VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudFRva2VuQ291bnQnXSwgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZXNUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlVG9rZW5Db3VudCddLCBmcm9tUmVzcG9uc2VUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5Db3VudCddLCBmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodHNUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodHNUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRzVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRzVG9rZW5Db3VudCddLCBmcm9tVGhvdWdodHNUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RvdGFsVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub3RhbFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VuQ291bnQnXSwgZnJvbVRvdGFsVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGFsaXR5VG9rZW5Db3VudEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZVRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlVG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlc1Rva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlVG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UcmFmZmljVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhZmZpY1R5cGUnXSk7XG4gICAgaWYgKGZyb21UcmFmZmljVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RyYWZmaWNUeXBlJ10sIGZyb21UcmFmZmljVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJHb0F3YXlGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaW1lTGVmdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGltZUxlZnQnXSk7XG4gICAgaWYgKGZyb21UaW1lTGVmdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVMZWZ0J10sIGZyb21UaW1lTGVmdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5ld0hhbmRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmV3SGFuZGxlJ10pO1xuICAgIGlmIChmcm9tTmV3SGFuZGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV3SGFuZGxlJ10sIGZyb21OZXdIYW5kbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzdW1hYmxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXN1bWFibGUnXSk7XG4gICAgaWYgKGZyb21SZXN1bWFibGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXN1bWFibGUnXSwgZnJvbVJlc3VtYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTGFzdENvbnN1bWVkQ2xpZW50TWVzc2FnZUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFzdENvbnN1bWVkQ2xpZW50TWVzc2FnZUluZGV4J10sIGZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyTWVzc2FnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXR1cENvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNldHVwQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cENvbXBsZXRlJ10sIGxpdmVTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbVZlcnRleChmcm9tU2V0dXBDb21wbGV0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmVyQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlcnZlckNvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VydmVyQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZlckNvbnRlbnQnXSwgbGl2ZVNlcnZlckNvbnRlbnRGcm9tVmVydGV4KGZyb21TZXJ2ZXJDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENhbGwnXSk7XG4gICAgaWYgKGZyb21Ub29sQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xDYWxsJ10sIGxpdmVTZXJ2ZXJUb29sQ2FsbEZyb21WZXJ0ZXgoZnJvbVRvb2xDYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xDYWxsQ2FuY2VsbGF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbENhbGxDYW5jZWxsYXRpb24nXSwgbGl2ZVNlcnZlclRvb2xDYWxsQ2FuY2VsbGF0aW9uRnJvbVZlcnRleChmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIHVzYWdlTWV0YWRhdGFGcm9tVmVydGV4KGZyb21Vc2FnZU1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb0F3YXkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvQXdheSddKTtcbiAgICBpZiAoZnJvbUdvQXdheSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvQXdheSddLCBsaXZlU2VydmVyR29Bd2F5RnJvbVZlcnRleChmcm9tR29Bd2F5KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uVXBkYXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2Vzc2lvblJlc3VtcHRpb25VcGRhdGUnXSwgbGl2ZVNlcnZlclNlc3Npb25SZXN1bXB0aW9uVXBkYXRlRnJvbVZlcnRleChmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0VG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhVG9NbGRldiQxKGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb01sZGV2JDEoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFUb01sZGV2JDEoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZyb21GdW5jdGlvbkNhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2NoZW1hVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQW55T2YgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FueU9mJ10pO1xuICAgIGlmIChmcm9tQW55T2YgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbnlPZiddLCBmcm9tQW55T2YpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVmYXVsdCddKTtcbiAgICBpZiAoZnJvbURlZmF1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZWZhdWx0J10sIGZyb21EZWZhdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudW0nXSk7XG4gICAgaWYgKGZyb21FbnVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW51bSddLCBmcm9tRW51bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGFtcGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlJ10pO1xuICAgIGlmIChmcm9tRXhhbXBsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4YW1wbGUnXSwgZnJvbUV4YW1wbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaXRlbXMnXSk7XG4gICAgaWYgKGZyb21JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2l0ZW1zJ10sIGZyb21JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhJdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWF4SXRlbXMnXSk7XG4gICAgaWYgKGZyb21NYXhJdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heEl0ZW1zJ10sIGZyb21NYXhJdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhMZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heExlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1heExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heExlbmd0aCddLCBmcm9tTWF4TGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhQcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heFByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhQcm9wZXJ0aWVzJ10sIGZyb21NYXhQcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heGltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heGltdW0nXSk7XG4gICAgaWYgKGZyb21NYXhpbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4aW11bSddLCBmcm9tTWF4aW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluSXRlbXMnXSk7XG4gICAgaWYgKGZyb21NaW5JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkl0ZW1zJ10sIGZyb21NaW5JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5MZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbkxlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1pbkxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkxlbmd0aCddLCBmcm9tTWluTGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pblByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1pblByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5Qcm9wZXJ0aWVzJ10sIGZyb21NaW5Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbmltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbmltdW0nXSk7XG4gICAgaWYgKGZyb21NaW5pbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluaW11bSddLCBmcm9tTWluaW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdWxsYWJsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbnVsbGFibGUnXSk7XG4gICAgaWYgKGZyb21OdWxsYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ251bGxhYmxlJ10sIGZyb21OdWxsYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXR0ZXJuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXR0ZXJuJ10pO1xuICAgIGlmIChmcm9tUGF0dGVybiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhdHRlcm4nXSwgZnJvbVBhdHRlcm4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvcGVydGllcyddKTtcbiAgICBpZiAoZnJvbVByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0aWVzJ10sIGZyb21Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnR5T3JkZXJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9wZXJ0eU9yZGVyaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb3BlcnR5T3JkZXJpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0eU9yZGVyaW5nJ10sIGZyb21Qcm9wZXJ0eU9yZGVyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlcXVpcmVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXF1aXJlZCddKTtcbiAgICBpZiAoZnJvbVJlcXVpcmVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWlyZWQnXSwgZnJvbVJlcXVpcmVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAoZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R5cGUnXSk7XG4gICAgaWYgKGZyb21UeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHlwZSddLCBmcm9tVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGhvZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYXRlZ29yeSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2F0ZWdvcnknXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yeSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3J5J10sIGZyb21DYXRlZ29yeSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RocmVzaG9sZCddKTtcbiAgICBpZiAoZnJvbVRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RocmVzaG9sZCddLCBmcm9tVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmVoYXZpb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pO1xuICAgIGlmIChmcm9tQmVoYXZpb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiZWhhdmlvciddLCBmcm9tQmVoYXZpb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGludGVydmFsVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBpbnRlcnZhbFRvTWxkZXYkMShmcm9tVGltZVJhbmdlRmlsdGVyKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHluYW1pY1RocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1RocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNUaHJlc2hvbGQnXSwgZnJvbUR5bmFtaWNUaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljUmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljUmV0cmlldmFsQ29uZmlnJ10sIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDEoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dFRvTWxkZXYkMSgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb21wdXRlclVzZVRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRW52aXJvbm1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vudmlyb25tZW50J10pO1xuICAgIGlmIChmcm9tRW52aXJvbm1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnZpcm9ubWVudCddLCBmcm9tRW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYkMShmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkMShmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ29vZ2xlTWFwcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIHVybENvbnRleHRUb01sZGV2JDEoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIHRvb2xDb21wdXRlclVzZVRvTWxkZXYkMShmcm9tQ29tcHV0ZXJVc2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsYXRMbmdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0aXR1ZGUnXSk7XG4gICAgaWYgKGZyb21MYXRpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdGl0dWRlJ10sIGZyb21MYXRpdHVkZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb25naXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvbmdpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxvbmdpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvbmdpdHVkZSddLCBmcm9tTG9uZ2l0dWRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmV0cmlldmFsQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGF0TG5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXRMbmcnXSk7XG4gICAgaWYgKGZyb21MYXRMbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXRMbmcnXSwgbGF0TG5nVG9NbGRldihmcm9tTGF0TG5nKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldihmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsQ29uZmlnJ10sIHJldHJpZXZhbENvbmZpZ1RvTWxkZXYoZnJvbVJldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVZvaWNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlTmFtZSddLCBmcm9tVm9pY2VOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdm9pY2VDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVidWlsdFZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVidWlsdFZvaWNlQ29uZmlnJ10sIHByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2JDEoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVha2VyJ10pO1xuICAgIGlmIChmcm9tU3BlYWtlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWFrZXInXSwgZnJvbVNwZWFrZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvTWxkZXYkMShmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzcGVha2VyVm9pY2VDb25maWdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlYWtlclZvaWNlQ29uZmlncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2JDEoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSwgbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDEoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdGhpbmtpbmdDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbmNsdWRlVGhvdWdodHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlVGhvdWdodHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5jbHVkZVRob3VnaHRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5jbHVkZVRob3VnaHRzJ10sIGZyb21JbmNsdWRlVGhvdWdodHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdCdWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0J1ZGdldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0J1ZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQnVkZ2V0J10sIGZyb21UaGlua2luZ0J1ZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDEodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZUNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZUNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlQ291bnQnXSwgZnJvbUNhbmRpZGF0ZUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdG9wU2VxdWVuY2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RvcFNlcXVlbmNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdG9wU2VxdWVuY2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RvcFNlcXVlbmNlcyddLCBmcm9tU3RvcFNlcXVlbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzJ10sIGZyb21Mb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1pbWVUeXBlJ10sIGZyb21SZXNwb25zZU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCBzY2hlbWFUb01sZGV2KHRTY2hlbWEoZnJvbVJlc3BvbnNlU2NoZW1hKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm91dGluZ0NvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncm91dGluZ0NvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFNlbGVjdGlvbkNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWxTZWxlY3Rpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVNldHRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmV0eVNldHRpbmdUb01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NhZmV0eVNldHRpbmdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldiQxKHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldihmcm9tVG9vbENvbmZpZykpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xhYmVscyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ2FjaGVkQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydjYWNoZWRDb250ZW50J10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21DYWNoZWRDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10sIHNwZWVjaENvbmZpZ1RvTWxkZXYkMSh0U3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdWRpb1RpbWVzdGFtcCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQ29uZmlnJ10sIHRoaW5raW5nQ29uZmlnVG9NbGRldihmcm9tVGhpbmtpbmdDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFza1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rhc2tUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGFza1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0YXNrVHlwZSddLCBmcm9tVGFza1R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXREaW1lbnNpb25hbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydyZXF1ZXN0c1tdJywgJ291dHB1dERpbWVuc2lvbmFsaXR5J10sIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaW1lVHlwZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRvVHJ1bmNhdGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F1dG9UcnVuY2F0ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAnY29udGVudCddLCB0Q29udGVudHNGb3JFbWJlZChhcGlDbGllbnQsIGZyb21Db250ZW50cykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0c1tdJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbEZvckVtYmVkQ29udGVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dEdjc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduZWdhdGl2ZVByb21wdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVnYXRpdmVQcm9tcHQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3VpZGFuY2VTY2FsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2d1aWRhbmNlU2NhbGUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR3VpZGFuY2VTY2FsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2d1aWRhbmNlU2NhbGUnXSwgZnJvbUd1aWRhbmNlU2NhbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWVkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZFdhdGVybWFyayBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVJbWFnZVNpemUnXSwgZnJvbUltYWdlU2l6ZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuaGFuY2VQcm9tcHQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuaGFuY2VQcm9tcHQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0TW9kZWxzQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21RdWVyeUJhc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3F1ZXJ5QmFzZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVF1ZXJ5QmFzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfdXJsJywgJ21vZGVsc191cmwnXSwgdE1vZGVsc1VybChhcGlDbGllbnQsIGZyb21RdWVyeUJhc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpc3RNb2RlbHNDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlZmF1bHRDaGVja3BvaW50SWQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZWZhdWx0Q2hlY2twb2ludElkJ10sIGZyb21EZWZhdWx0Q2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIHVwZGF0ZU1vZGVsQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3lzdGVtSW5zdHJ1Y3Rpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2xzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9NbGRldiQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGNvdW50VG9rZW5zQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2djc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VCeXRlcyddKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydieXRlc0Jhc2U2NEVuY29kZWQnXSwgdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OdW1iZXJPZlZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mVmlkZW9zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mVmlkZW9zKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRHY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR1cmF0aW9uU2Vjb25kcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R1cmF0aW9uU2Vjb25kcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EdXJhdGlvblNlY29uZHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdkdXJhdGlvblNlY29uZHMnXSwgZnJvbUR1cmF0aW9uU2Vjb25kcyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlZWQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzb2x1dGlvbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzb2x1dGlvbiBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwdWJzdWJUb3BpYyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHVic3ViVG9waWMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VuaGFuY2VQcm9tcHQnXSwgZnJvbUVuaGFuY2VQcm9tcHQpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnZW5lcmF0ZUF1ZGlvJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmF0ZUF1ZGlvIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhc3RGcmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFzdEZyYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JlZmVyZW5jZUltYWdlcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVmZXJlbmNlSW1hZ2VzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXByZXNzaW9uUXVhbGl0eSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29tcHJlc3Npb25RdWFsaXR5IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb01sZGV2KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmlkZW8gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhVG9WZXJ0ZXgoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvVmVydGV4KGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9WZXJ0ZXgoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZyb21GdW5jdGlvbkNhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNjaGVtYVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BbnlPZiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYW55T2YnXSk7XG4gICAgaWYgKGZyb21BbnlPZiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FueU9mJ10sIGZyb21BbnlPZik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZWZhdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZWZhdWx0J10pO1xuICAgIGlmIChmcm9tRGVmYXVsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RlZmF1bHQnXSwgZnJvbURlZmF1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW51bSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW51bSddKTtcbiAgICBpZiAoZnJvbUVudW0gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnVtJ10sIGZyb21FbnVtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4YW1wbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4YW1wbGUnXSk7XG4gICAgaWYgKGZyb21FeGFtcGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhhbXBsZSddLCBmcm9tRXhhbXBsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpdGVtcyddKTtcbiAgICBpZiAoZnJvbUl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaXRlbXMnXSwgZnJvbUl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heEl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhJdGVtcyddKTtcbiAgICBpZiAoZnJvbU1heEl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4SXRlbXMnXSwgZnJvbU1heEl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heExlbmd0aCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWF4TGVuZ3RoJ10pO1xuICAgIGlmIChmcm9tTWF4TGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4TGVuZ3RoJ10sIGZyb21NYXhMZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4UHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heFByb3BlcnRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4UHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heFByb3BlcnRpZXMnXSwgZnJvbU1heFByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4aW11bSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWF4aW11bSddKTtcbiAgICBpZiAoZnJvbU1heGltdW0gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhpbXVtJ10sIGZyb21NYXhpbXVtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbkl0ZW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5JdGVtcyddKTtcbiAgICBpZiAoZnJvbU1pbkl0ZW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluSXRlbXMnXSwgZnJvbU1pbkl0ZW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbkxlbmd0aCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluTGVuZ3RoJ10pO1xuICAgIGlmIChmcm9tTWluTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluTGVuZ3RoJ10sIGZyb21NaW5MZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluUHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21pblByb3BlcnRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWluUHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pblByb3BlcnRpZXMnXSwgZnJvbU1pblByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluaW11bSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluaW11bSddKTtcbiAgICBpZiAoZnJvbU1pbmltdW0gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5pbXVtJ10sIGZyb21NaW5pbXVtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU51bGxhYmxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydudWxsYWJsZSddKTtcbiAgICBpZiAoZnJvbU51bGxhYmxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbnVsbGFibGUnXSwgZnJvbU51bGxhYmxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhdHRlcm4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhdHRlcm4nXSk7XG4gICAgaWYgKGZyb21QYXR0ZXJuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGF0dGVybiddLCBmcm9tUGF0dGVybik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9wZXJ0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9wZXJ0aWVzJ10pO1xuICAgIGlmIChmcm9tUHJvcGVydGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb3BlcnRpZXMnXSwgZnJvbVByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvcGVydHlPcmRlcmluZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb3BlcnR5T3JkZXJpbmcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvcGVydHlPcmRlcmluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb3BlcnR5T3JkZXJpbmcnXSwgZnJvbVByb3BlcnR5T3JkZXJpbmcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVxdWlyZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JlcXVpcmVkJ10pO1xuICAgIGlmIChmcm9tUmVxdWlyZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1aXJlZCddLCBmcm9tUmVxdWlyZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHlwZSddKTtcbiAgICBpZiAoZnJvbVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0eXBlJ10sIGZyb21UeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbW9kZWxTZWxlY3Rpb25Db25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlJ10sIGZyb21GZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eVNldHRpbmdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWV0aG9kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRob2QnXSk7XG4gICAgaWYgKGZyb21NZXRob2QgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRob2QnXSwgZnJvbU1ldGhvZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYXRlZ29yeSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2F0ZWdvcnknXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yeSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3J5J10sIGZyb21DYXRlZ29yeSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RocmVzaG9sZCddKTtcbiAgICBpZiAoZnJvbVRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RocmVzaG9sZCddLCBmcm9tVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZWhhdmlvciBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBpbnRlcnZhbFRvVmVydGV4KGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVEb21haW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZURvbWFpbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZURvbWFpbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlRG9tYWlucyddLCBmcm9tRXhjbHVkZURvbWFpbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1JldHJpZXZhbENvbmZpZyddLCBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW50ZXJwcmlzZVdlYlNlYXJjaFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FeGNsdWRlRG9tYWlucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4Y2x1ZGVEb21haW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4Y2x1ZGVEb21haW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSwgZnJvbUV4Y2x1ZGVEb21haW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXBpS2V5Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFwaUtleVN0cmluZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXBpS2V5U3RyaW5nJ10pO1xuICAgIGlmIChmcm9tQXBpS2V5U3RyaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXBpS2V5U3RyaW5nJ10sIGZyb21BcGlLZXlTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdXRoQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFwaUtleUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXBpS2V5Q29uZmlnJ10pO1xuICAgIGlmIChmcm9tQXBpS2V5Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXBpS2V5Q29uZmlnJ10sIGFwaUtleUNvbmZpZ1RvVmVydGV4KGZyb21BcGlLZXlDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1dGhUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoVHlwZSddKTtcbiAgICBpZiAoZnJvbUF1dGhUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXV0aFR5cGUnXSwgZnJvbUF1dGhUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VydmljZUFjY291bnRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyddLCBmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2h0dHBCYXNpY0F1dGhDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2h0dHBCYXNpY0F1dGhDb25maWcnXSwgZnJvbUh0dHBCYXNpY0F1dGhDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT2F1dGhDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ29hdXRoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tT2F1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvYXV0aENvbmZpZyddLCBmcm9tT2F1dGhDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT2lkY0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb2lkY0NvbmZpZyddKTtcbiAgICBpZiAoZnJvbU9pZGNDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvaWRjQ29uZmlnJ10sIGZyb21PaWRjQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BdXRoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tQXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dGhDb25maWcnXSwgYXV0aENvbmZpZ1RvVmVydGV4KGZyb21BdXRoQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRUb1ZlcnRleCgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb21wdXRlclVzZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbnZpcm9ubWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW52aXJvbm1lbnQnXSk7XG4gICAgaWYgKGZyb21FbnZpcm9ubWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vudmlyb25tZW50J10sIGZyb21FbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsJ10sIGZyb21SZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9WZXJ0ZXgoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnRlcnByaXNlV2ViU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW50ZXJwcmlzZVdlYlNlYXJjaCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddLCBlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgoZnJvbUVudGVycHJpc2VXZWJTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9WZXJ0ZXgoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCB1cmxDb250ZXh0VG9WZXJ0ZXgoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIHRvb2xDb21wdXRlclVzZVRvVmVydGV4KGZyb21Db21wdXRlclVzZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsYXRMbmdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGF0aXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdGl0dWRlJ10pO1xuICAgIGlmIChmcm9tTGF0aXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXRpdHVkZSddLCBmcm9tTGF0aXR1ZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9uZ2l0dWRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb25naXR1ZGUnXSk7XG4gICAgaWYgKGZyb21Mb25naXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb25naXR1ZGUnXSwgZnJvbUxvbmdpdHVkZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJldHJpZXZhbENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRMbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdExuZyddKTtcbiAgICBpZiAoZnJvbUxhdExuZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdExuZyddLCBsYXRMbmdUb1ZlcnRleChmcm9tTGF0TG5nKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkNhbGxpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJ10sIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvVmVydGV4KGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgcmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgoZnJvbVJldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcmVidWlsdFZvaWNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tVm9pY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VOYW1lJ10sIGZyb21Wb2ljZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2b2ljZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QcmVidWlsdFZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlYnVpbHRWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlYnVpbHRWb2ljZUNvbmZpZyddLCBwcmVidWlsdFZvaWNlQ29uZmlnVG9WZXJ0ZXgoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlZWNoQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb1ZlcnRleChmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10pO1xuICAgIGlmIChmcm9tTGFuZ3VhZ2VDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10sIGZyb21MYW5ndWFnZUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0aGlua2luZ0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbmNsdWRlVGhvdWdodHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlVGhvdWdodHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5jbHVkZVRob3VnaHRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5jbHVkZVRob3VnaHRzJ10sIGZyb21JbmNsdWRlVGhvdWdodHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdCdWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0J1ZGdldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0J1ZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQnVkZ2V0J10sIGZyb21UaGlua2luZ0J1ZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9WZXJ0ZXgodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAoZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZUNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZUNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FuZGlkYXRlQ291bnQnXSwgZnJvbUNhbmRpZGF0ZUNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdG9wU2VxdWVuY2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RvcFNlcXVlbmNlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdG9wU2VxdWVuY2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RvcFNlcXVlbmNlcyddLCBmcm9tU3RvcFNlcXVlbmNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUxvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VMb2dwcm9icycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUxvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VMb2dwcm9icyddLCBmcm9tUmVzcG9uc2VMb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9ncHJvYnMnXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzJ10sIGZyb21Mb2dwcm9icyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVzZW5jZVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVzZW5jZVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlc2VuY2VQZW5hbHR5J10sIGZyb21QcmVzZW5jZVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnJlcXVlbmN5UGVuYWx0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZyZXF1ZW5jeVBlbmFsdHknXSwgZnJvbUZyZXF1ZW5jeVBlbmFsdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1pbWVUeXBlJ10sIGZyb21SZXNwb25zZU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VTY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VTY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVNjaGVtYSddLCBzY2hlbWFUb1ZlcnRleCh0U2NoZW1hKGZyb21SZXNwb25zZVNjaGVtYSkpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb3V0aW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncm91dGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Sb3V0aW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm91dGluZ0NvbmZpZyddLCBmcm9tUm91dGluZ0NvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21vZGVsU2VsZWN0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxDb25maWcnXSwgbW9kZWxTZWxlY3Rpb25Db25maWdUb1ZlcnRleChmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVNldHRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmV0eVNldHRpbmdUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzYWZldHlTZXR0aW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4KHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9WZXJ0ZXgoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb1ZlcnRleCh0U3BlZWNoQ29uZmlnKGZyb21TcGVlY2hDb25maWcpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BdWRpb1RpbWVzdGFtcCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1ZGlvVGltZXN0YW1wJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1ZGlvVGltZXN0YW1wICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW9UaW1lc3RhbXAnXSwgZnJvbUF1ZGlvVGltZXN0YW1wKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCB0aGlua2luZ0NvbmZpZ1RvVmVydGV4KGZyb21UaGlua2luZ0NvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGlvbkNvbmZpZyddLCBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhc2tUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXNrVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRhc2tUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1tdJywgJ3Rhc2tfdHlwZSddLCBmcm9tVGFza1R5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGl0bGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpdGxlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGl0bGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0RGltZW5zaW9uYWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXREaW1lbnNpb25hbGl0eSddLCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1dG9UcnVuY2F0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0b1RydW5jYXRlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQXV0b1RydW5jYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXV0b1RydW5jYXRlJ10sIGZyb21BdXRvVHJ1bmNhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbXScsICdjb250ZW50J10sIHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBlbWJlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUltYWdlc0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVJbWFnZVNpemUnXSwgZnJvbUltYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUJ5dGVzJ10pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2J5dGVzQmFzZTY0RW5jb2RlZCddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbWFza1JlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NYXNrTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFza01vZGUnXSk7XG4gICAgaWYgKGZyb21NYXNrTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2tNb2RlJ10sIGZyb21NYXNrTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWdtZW50YXRpb25DbGFzc2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2VnbWVudGF0aW9uQ2xhc3NlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZWdtZW50YXRpb25DbGFzc2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza0NsYXNzZXMnXSwgZnJvbVNlZ21lbnRhdGlvbkNsYXNzZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza0RpbGF0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXNrRGlsYXRpb24nXSk7XG4gICAgaWYgKGZyb21NYXNrRGlsYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaWxhdGlvbiddLCBmcm9tTWFza0RpbGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udHJvbFJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250cm9sVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udHJvbFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250cm9sVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRyb2xUeXBlJ10sIGZyb21Db250cm9sVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZUNvbnRyb2wnXSwgZnJvbUVuYWJsZUNvbnRyb2xJbWFnZUNvbXB1dGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3R5bGVSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3R5bGVEZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0eWxlRGVzY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3R5bGVEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0eWxlRGVzY3JpcHRpb24nXSwgZnJvbVN0eWxlRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzdWJqZWN0UmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN1YmplY3RUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdWJqZWN0VHlwZSddKTtcbiAgICBpZiAoZnJvbVN1YmplY3RUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3ViamVjdFR5cGUnXSwgZnJvbVN1YmplY3RUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1YmplY3REZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1YmplY3REZXNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdWJqZWN0RGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdWJqZWN0RGVzY3JpcHRpb24nXSwgZnJvbVN1YmplY3REZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZUltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbVJlZmVyZW5jZUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVmZXJlbmNlSWQnXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZUlkJ10sIGZyb21SZWZlcmVuY2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlVHlwZSddLCBmcm9tUmVmZXJlbmNlVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXNrSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWFza0ltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza0ltYWdlQ29uZmlnJ10sIG1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tTWFza0ltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250cm9sSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250cm9sSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29udHJvbEltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udHJvbEltYWdlQ29uZmlnJ10sIGNvbnRyb2xSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tQ29udHJvbEltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdHlsZUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3R5bGVJbWFnZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdHlsZUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3R5bGVJbWFnZUNvbmZpZyddLCBzdHlsZVJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21TdHlsZUltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdWJqZWN0SW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdWJqZWN0SW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3ViamVjdEltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3ViamVjdEltYWdlQ29uZmlnJ10sIHN1YmplY3RSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tU3ViamVjdEltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVkaXRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZVNjYWxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3VpZGFuY2VTY2FsZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HdWlkYW5jZVNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ3VpZGFuY2VTY2FsZSddLCBmcm9tR3VpZGFuY2VTY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRWRpdE1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VkaXRNb2RlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRWRpdE1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0TW9kZSddLCBmcm9tRWRpdE1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZVN0ZXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlU3RlcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXNlU3RlcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0Q29uZmlnJywgJ2Jhc2VTdGVwcyddLCBmcm9tQmFzZVN0ZXBzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZUltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVmZXJlbmNlSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdyZWZlcmVuY2VJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGVkaXRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwc2NhbGVJbWFnZUFQSUNvbmZpZ0ludGVybmFsVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VJbnB1dEltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZUlucHV0SW1hZ2UnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZUlucHV0SW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICd1cHNjYWxlQ29uZmlnJywgJ2VuaGFuY2VJbnB1dEltYWdlJ10sIGZyb21FbmhhbmNlSW5wdXRJbWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVByZXNlcnZhdGlvbkZhY3RvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ltYWdlUHJlc2VydmF0aW9uRmFjdG9yJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAndXBzY2FsZUNvbmZpZycsICdpbWFnZVByZXNlcnZhdGlvbkZhY3RvciddLCBmcm9tSW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZkltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZkltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZkltYWdlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cHNjYWxlSW1hZ2VBUElQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBzY2FsZUZhY3RvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Vwc2NhbGVGYWN0b3InLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXBzY2FsZUZhY3RvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAndXBzY2FsZUNvbmZpZycsICd1cHNjYWxlRmFjdG9yJ10sIGZyb21VcHNjYWxlRmFjdG9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIHVwc2NhbGVJbWFnZUFQSUNvbmZpZ0ludGVybmFsVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJvZHVjdEltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb2R1Y3RJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvZHVjdEltYWdlJ10pO1xuICAgIGlmIChmcm9tUHJvZHVjdEltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tUHJvZHVjdEltYWdlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwZXJzb25JbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwZXJzb25JbWFnZScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21QZXJzb25JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvZHVjdEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb2R1Y3RJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvZHVjdEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUHJvZHVjdEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9kdWN0SW1hZ2VUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvZHVjdEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWNvbnRleHRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU51bWJlck9mSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbnVtYmVyT2ZJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTnVtYmVyT2ZJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzYW1wbGVDb3VudCddLCBmcm9tTnVtYmVyT2ZJbWFnZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZVN0ZXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlU3RlcHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXNlU3RlcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlZGl0Q29uZmlnJywgJ2Jhc2VTdGVwcyddLCBmcm9tQmFzZVN0ZXBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVjb250ZXh0SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgcmVjb250ZXh0SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tU291cmNlLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgcmVjb250ZXh0SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzY3JpYmJsZUltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlU291cmNlVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NyaWJibGVJbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NjcmliYmxlSW1hZ2UnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2NyaWJibGVJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnc2NyaWJibGUnXSwgc2NyaWJibGVJbWFnZVRvVmVydGV4KGZyb21TY3JpYmJsZUltYWdlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhQcmVkaWN0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heFByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1heFByZWRpY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbWF4UHJlZGljdGlvbnMnXSwgZnJvbU1heFByZWRpY3Rpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb25maWRlbmNlVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbmZpZGVuY2VUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdjb25maWRlbmNlVGhyZXNob2xkJ10sIGZyb21Db25maWRlbmNlVGhyZXNob2xkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2tEaWxhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFza0RpbGF0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWFza0RpbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbWFza0RpbGF0aW9uJ10sIGZyb21NYXNrRGlsYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmluYXJ5Q29sb3JUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdiaW5hcnlDb2xvclRocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CaW5hcnlDb2xvclRocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2JpbmFyeUNvbG9yVGhyZXNob2xkJ10sIGZyb21CaW5hcnlDb2xvclRocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBzZWdtZW50SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tU291cmNlLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgc2VnbWVudEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc0NvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVF1ZXJ5QmFzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncXVlcnlCYXNlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUXVlcnlCYXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ191cmwnLCAnbW9kZWxzX3VybCddLCB0TW9kZWxzVXJsKGFwaUNsaWVudCwgZnJvbVF1ZXJ5QmFzZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0TW9kZWxzUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpc3RNb2RlbHNDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vZGVsQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZWZhdWx0Q2hlY2twb2ludElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGVmYXVsdENoZWNrcG9pbnRJZCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZWZhdWx0Q2hlY2twb2ludElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2RlZmF1bHRDaGVja3BvaW50SWQnXSwgZnJvbURlZmF1bHRDaGVja3BvaW50SWQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCB1cGRhdGVNb2RlbENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9WZXJ0ZXgodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21HZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9CeXRlcyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydieXRlc0Jhc2U2NEVuY29kZWQnXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlZmVyZW5jZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlZmVyZW5jZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZWZlcmVuY2VUeXBlJ10sIGZyb21SZWZlcmVuY2VUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OdW1iZXJPZlZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mVmlkZW9zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mVmlkZW9zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHVyYXRpb25TZWNvbmRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHVyYXRpb25TZWNvbmRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUR1cmF0aW9uU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2R1cmF0aW9uU2Vjb25kcyddLCBmcm9tRHVyYXRpb25TZWNvbmRzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvbHV0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Jlc29sdXRpb24nXSwgZnJvbVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHVic3ViVG9waWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3B1YnN1YlRvcGljJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHVic3ViVG9waWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwdWJzdWJUb3BpYyddLCBmcm9tUHVic3ViVG9waWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVBdWRpbycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0ZUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ2VuZXJhdGVBdWRpbyddLCBmcm9tR2VuZXJhdGVBdWRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYXN0RnJhbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhc3RGcmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhc3RGcmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnbGFzdEZyYW1lJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUxhc3RGcmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlZmVyZW5jZUltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVmZXJlbmNlSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3JlZmVyZW5jZUltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tQ29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbyddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3ZpZGVvJ10sIHZpZGVvVG9WZXJ0ZXgoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0RnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhRnJvbU1sZGV2KGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JGcm9tTWxkZXYoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFGcm9tTWxkZXYoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZyb21GdW5jdGlvbkNhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2l0YXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaXRhdGlvblNvdXJjZXMnXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaXRhdGlvbnMnXSwgZnJvbUNpdGF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybE1ldGFkYXRhRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21SZXRyaWV2ZWRVcmwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZlZFVybCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZlZFVybCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZlZFVybCddLCBmcm9tUmV0cmlldmVkVXJsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybFJldHJpZXZhbFN0YXR1cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VybFJldHJpZXZhbFN0YXR1cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcmxSZXRyaWV2YWxTdGF0dXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxSZXRyaWV2YWxTdGF0dXMnXSwgZnJvbVVybFJldHJpZXZhbFN0YXR1cyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJsTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tVXJsTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVVybE1ldGFkYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybE1ldGFkYXRhRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsTWV0YWRhdGEnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuZGlkYXRlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50J10pO1xuICAgIGlmIChmcm9tQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnQnXSwgY29udGVudEZyb21NbGRldihmcm9tQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2l0YXRpb25NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NpdGF0aW9uTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9uTWV0YWRhdGEnXSwgY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldihmcm9tQ2l0YXRpb25NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9rZW5Db3VudCddKTtcbiAgICBpZiAoZnJvbVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbkNvdW50J10sIGZyb21Ub2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbmlzaFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmluaXNoUmVhc29uJ10pO1xuICAgIGlmIChmcm9tRmluaXNoUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmluaXNoUmVhc29uJ10sIGZyb21GaW5pc2hSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsQ29udGV4dE1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHRNZXRhZGF0YSddLCB1cmxDb250ZXh0TWV0YWRhdGFGcm9tTWxkZXYoZnJvbVVybENvbnRleHRNZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXZnTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tQXZnTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdmdMb2dwcm9icyddLCBmcm9tQXZnTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdncm91bmRpbmdNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hcm91bmRpbmdNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dyb3VuZGluZ01ldGFkYXRhJ10sIGZyb21Hcm91bmRpbmdNZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmRleCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5kZXgnXSk7XG4gICAgaWYgKGZyb21JbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luZGV4J10sIGZyb21JbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9ic1Jlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xvZ3Byb2JzUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnNSZXN1bHQnXSwgZnJvbUxvZ3Byb2JzUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVJhdGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlSYXRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNhZmV0eVJhdGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlSYXRpbmdzJ10sIGZyb21TYWZldHlSYXRpbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYW5kaWRhdGVzJ10pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FuZGlkYXRlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddLCBmcm9tTW9kZWxWZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdEZlZWRiYWNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0RmVlZGJhY2snLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0RmVlZGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRGZWVkYmFjayddLCBmcm9tUHJvbXB0RmVlZGJhY2spO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2VJZCddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUlkJ10sIGZyb21SZXNwb25zZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEVtYmVkZGluZ0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmFsdWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2YWx1ZXMnXSk7XG4gICAgaWYgKGZyb21WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWx1ZXMnXSwgZnJvbVZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudE1ldGFkYXRhRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbWJlZGRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbWJlZGRpbmdzJ10pO1xuICAgIGlmIChmcm9tRW1iZWRkaW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRW1iZWRkaW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50RW1iZWRkaW5nRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW1iZWRkaW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBlbWJlZENvbnRlbnRNZXRhZGF0YUZyb21NbGRldigpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSwgdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eUF0dHJpYnV0ZXNGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNhdGVnb3JpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ2NhdGVnb3JpZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcmllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhdGVnb3JpZXMnXSwgZnJvbUNhdGVnb3JpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NvcmVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5QXR0cmlidXRlcycsXG4gICAgICAgICdzY29yZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2NvcmVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2NvcmVzJ10sIGZyb21TY29yZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10pO1xuICAgIGlmIChmcm9tQ29udGVudFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50VHlwZSddLCBmcm9tQ29udGVudFR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRJbWFnZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZUZyb21NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaUZpbHRlcmVkUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpRmlsdGVyZWRSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpRmlsdGVyZWRSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlGaWx0ZXJlZFJlYXNvbiddLCBmcm9tUmFpRmlsdGVyZWRSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21TYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGZyb21TYWZldHlBdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuZWRNb2RlbEluZm9Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbVZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2ZXJzaW9uJ10sIGZyb21WZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWxJbmZvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbEluZm8nXSwgdHVuZWRNb2RlbEluZm9Gcm9tTWxkZXYoZnJvbVR1bmVkTW9kZWxJbmZvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dFRva2VuTGltaXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dFRva2VuTGltaXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5wdXRUb2tlbkxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRUb2tlbkxpbWl0J10sIGZyb21JbnB1dFRva2VuTGltaXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0VG9rZW5MaW1pdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dFRva2VuTGltaXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3V0cHV0VG9rZW5MaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ291dHB1dFRva2VuTGltaXQnXSwgZnJvbU91dHB1dFRva2VuTGltaXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3VwcG9ydGVkQWN0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1cHBvcnRlZEdlbmVyYXRpb25NZXRob2RzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN1cHBvcnRlZEFjdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdXBwb3J0ZWRBY3Rpb25zJ10sIGZyb21TdXBwb3J0ZWRBY3Rpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbU1vZGVscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0RXh0cmFjdE1vZGVscyhmcm9tTW9kZWxzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbEZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFJlc3BvbnNlRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3RhbFRva2VucyddKTtcbiAgICBpZiAoZnJvbVRvdGFsVG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG90YWxUb2tlbnMnXSwgZnJvbVRvdGFsVG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50VG9rZW5Db3VudCddLCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbycsICd1cmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW8nLFxuICAgICAgICAnZW5jb2RlZFZpZGVvJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyhmcm9tVmlkZW9CeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuY29kaW5nJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21NbGRldihmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkVmlkZW9zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVkU2FtcGxlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRWaWRlb3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZFZpZGVvcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRWaWRlb0Zyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlJyxcbiAgICAgICAgJ2dlbmVyYXRlVmlkZW9SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYkZyb21WZXJ0ZXgoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFGcm9tVmVydGV4KGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmcm9tRnVuY3Rpb25DYWxsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2l0YXRpb25NZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNpdGF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2l0YXRpb25zJ10pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25zJ10sIGZyb21DaXRhdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxNZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJldHJpZXZlZFVybCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmVkVXJsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmVkVXJsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmVkVXJsJ10sIGZyb21SZXRyaWV2ZWRVcmwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsUmV0cmlldmFsU3RhdHVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybFJldHJpZXZhbFN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybFJldHJpZXZhbFN0YXR1cyddLCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dE1ldGFkYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJsTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tVXJsTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVVybE1ldGFkYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybE1ldGFkYXRhRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmRpZGF0ZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnQnXSk7XG4gICAgaWYgKGZyb21Db250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudCddLCBjb250ZW50RnJvbVZlcnRleChmcm9tQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2l0YXRpb25NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NpdGF0aW9uTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9uTWV0YWRhdGEnXSwgY2l0YXRpb25NZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbUNpdGF0aW9uTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbmlzaE1lc3NhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmaW5pc2hNZXNzYWdlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZpbmlzaE1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hNZXNzYWdlJ10sIGZyb21GaW5pc2hNZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbmlzaFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmluaXNoUmVhc29uJ10pO1xuICAgIGlmIChmcm9tRmluaXNoUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmluaXNoUmVhc29uJ10sIGZyb21GaW5pc2hSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsQ29udGV4dE1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHRNZXRhZGF0YSddLCB1cmxDb250ZXh0TWV0YWRhdGFGcm9tVmVydGV4KGZyb21VcmxDb250ZXh0TWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF2Z0xvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdmdMb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUF2Z0xvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSwgZnJvbUF2Z0xvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2luZGV4J10pO1xuICAgIGlmIChmcm9tSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmRleCddLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnNSZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsb2dwcm9ic1Jlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9ic1Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzUmVzdWx0J10sIGZyb21Mb2dwcm9ic1Jlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlSYXRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5UmF0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TYWZldHlSYXRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5UmF0aW5ncyddLCBmcm9tU2FmZXR5UmF0aW5ncyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhbmRpZGF0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYW5kaWRhdGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxWZXJzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFZlcnNpb24nXSk7XG4gICAgaWYgKGZyb21Nb2RlbFZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbFZlcnNpb24nXSwgZnJvbU1vZGVsVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRGZWVkYmFjayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Byb21wdEZlZWRiYWNrJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdEZlZWRiYWNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0RmVlZGJhY2snXSwgZnJvbVByb21wdEZlZWRiYWNrKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VJZCddLCBmcm9tUmVzcG9uc2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRFbWJlZGRpbmdTdGF0aXN0aWNzRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHJ1bmNhdGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cnVuY2F0ZWQnXSk7XG4gICAgaWYgKGZyb21UcnVuY2F0ZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cnVuY2F0ZWQnXSwgZnJvbVRydW5jYXRlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b2tlbl9jb3VudCddKTtcbiAgICBpZiAoZnJvbVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbkNvdW50J10sIGZyb21Ub2tlbkNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEVtYmVkZGluZ0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZhbHVlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmFsdWVzJ10pO1xuICAgIGlmIChmcm9tVmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmFsdWVzJ10sIGZyb21WYWx1ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGlzdGljcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGlzdGljcyddKTtcbiAgICBpZiAoZnJvbVN0YXRpc3RpY3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0aXN0aWNzJ10sIGNvbnRlbnRFbWJlZGRpbmdTdGF0aXN0aWNzRnJvbVZlcnRleChmcm9tU3RhdGlzdGljcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRNZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJpbGxhYmxlQ2hhcmFjdGVyQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdiaWxsYWJsZUNoYXJhY3RlckNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJpbGxhYmxlQ2hhcmFjdGVyQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiaWxsYWJsZUNoYXJhY3RlckNvdW50J10sIGZyb21CaWxsYWJsZUNoYXJhY3RlckNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW1iZWRkaW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zW10nLFxuICAgICAgICAnZW1iZWRkaW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbWJlZGRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FbWJlZGRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRFbWJlZGRpbmdGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW1iZWRkaW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBlbWJlZENvbnRlbnRNZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbU1ldGFkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYnl0ZXNCYXNlNjRFbmNvZGVkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZUJ5dGVzJ10sIHRCeXRlcyhmcm9tSW1hZ2VCeXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZldHlBdHRyaWJ1dGVzRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcmllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnY2F0ZWdvcmllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yaWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcmllcyddLCBmcm9tQ2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY29yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3Njb3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TY29yZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY29yZXMnXSwgZnJvbVNjb3Jlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50VHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250ZW50VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10sIGZyb21Db250ZW50VHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZUZyb21WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlGaWx0ZXJlZFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaUZpbHRlcmVkUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaUZpbHRlcmVkUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpRmlsdGVyZWRSZWFzb24nXSwgZnJvbVJhaUZpbHRlcmVkUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoZnJvbVNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VkUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKGZyb21FbmhhbmNlZFByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuaGFuY2VkUHJvbXB0J10sIGZyb21FbmhhbmNlZFByb21wdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZWRpdEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwc2NhbGVJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWNvbnRleHRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVudGl0eUxhYmVsRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGFiZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVsJ10pO1xuICAgIGlmIChmcm9tTGFiZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbCddLCBmcm9tTGFiZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NvcmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Njb3JlJ10pO1xuICAgIGlmIChmcm9tU2NvcmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY29yZSddLCBmcm9tU2NvcmUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRJbWFnZU1hc2tGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NYXNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbU1hc2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrJ10sIGltYWdlRnJvbVZlcnRleChmcm9tTWFzaykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUxhYmVscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRpdHlMYWJlbEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRNYXNrcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJlZGljdGlvbnMnXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRNYXNrcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkTWFza3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VNYXNrRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZE1hc2tzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVuZHBvaW50RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kcG9pbnQnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXBsb3llZE1vZGVsSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZXBsb3llZE1vZGVsSWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRGVwbG95ZWRNb2RlbElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVwbG95ZWRNb2RlbElkJ10sIGZyb21EZXBsb3llZE1vZGVsSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xhYmVscycsXG4gICAgICAgICdnb29nbGUtdmVydGV4LWxsbS10dW5pbmctYmFzZS1tb2RlbC1pZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2hlY2twb2ludEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2hlY2twb2ludElkJ10pO1xuICAgIGlmIChmcm9tQ2hlY2twb2ludElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2hlY2twb2ludElkJ10sIGZyb21DaGVja3BvaW50SWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXBvY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vwb2NoJ10pO1xuICAgIGlmIChmcm9tRXBvY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcG9jaCddLCBmcm9tRXBvY2gpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RlcCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RlcCddKTtcbiAgICBpZiAoZnJvbVN0ZXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGVwJ10sIGZyb21TdGVwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbW9kZWxGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVyc2lvbklkJ10pO1xuICAgIGlmIChmcm9tVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZlcnNpb24nXSwgZnJvbVZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kcG9pbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXBsb3llZE1vZGVscyddKTtcbiAgICBpZiAoZnJvbUVuZHBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRW5kcG9pbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZHBvaW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZHBvaW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsSW5mbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWxJbmZvJ10sIHR1bmVkTW9kZWxJbmZvRnJvbVZlcnRleChmcm9tVHVuZWRNb2RlbEluZm8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZWZhdWx0Q2hlY2twb2ludElkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURlZmF1bHRDaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZWZhdWx0Q2hlY2twb2ludElkJ10sIGZyb21EZWZhdWx0Q2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNoZWNrcG9pbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaGVja3BvaW50cyddKTtcbiAgICBpZiAoZnJvbUNoZWNrcG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DaGVja3BvaW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja3BvaW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NoZWNrcG9pbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXh0UGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmV4dFBhZ2VUb2tlbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21OZXh0UGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmV4dFBhZ2VUb2tlbiddLCBmcm9tTmV4dFBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tTW9kZWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRFeHRyYWN0TW9kZWxzKGZyb21Nb2RlbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFJlc3BvbnNlRnJvbVZlcnRleCgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG90YWxUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VucyddLCBmcm9tVG90YWxUb2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlVG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9rZW5zSW5mbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9rZW5zSW5mbyddKTtcbiAgICBpZiAoZnJvbVRva2Vuc0luZm8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbnNJbmZvJ10sIGZyb21Ub2tlbnNJbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB2aWRlb0Zyb21WZXJ0ZXgoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvcyddKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBDT05URU5UX1RZUEVfSEVBREVSID0gJ0NvbnRlbnQtVHlwZSc7XG5jb25zdCBTRVJWRVJfVElNRU9VVF9IRUFERVIgPSAnWC1TZXJ2ZXItVGltZW91dCc7XG5jb25zdCBVU0VSX0FHRU5UX0hFQURFUiA9ICdVc2VyLUFnZW50JztcbmNvbnN0IEdPT0dMRV9BUElfQ0xJRU5UX0hFQURFUiA9ICd4LWdvb2ctYXBpLWNsaWVudCc7XG5jb25zdCBTREtfVkVSU0lPTiA9ICcxLjE1LjAnOyAvLyB4LXJlbGVhc2UtcGxlYXNlLXZlcnNpb25cbmNvbnN0IExJQlJBUllfTEFCRUwgPSBgZ29vZ2xlLWdlbmFpLXNkay8ke1NES19WRVJTSU9OfWA7XG5jb25zdCBWRVJURVhfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiA9ICd2MWJldGExJztcbmNvbnN0IEdPT0dMRV9BSV9BUElfREVGQVVMVF9WRVJTSU9OID0gJ3YxYmV0YSc7XG5jb25zdCByZXNwb25zZUxpbmVSRSA9IC9eZGF0YTogKC4qKSg/OlxcblxcbnxcXHJcXHJ8XFxyXFxuXFxyXFxuKS87XG4vKipcbiAqIFRoZSBBcGlDbGllbnQgY2xhc3MgaXMgdXNlZCB0byBzZW5kIHJlcXVlc3RzIHRvIHRoZSBHZW1pbmkgQVBJIG9yIFZlcnRleCBBSVxuICogZW5kcG9pbnRzLlxuICovXG5jbGFzcyBBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBwcm9qZWN0OiBvcHRzLnByb2plY3QsIGxvY2F0aW9uOiBvcHRzLmxvY2F0aW9uLCBhcGlLZXk6IG9wdHMuYXBpS2V5LCB2ZXJ0ZXhhaTogb3B0cy52ZXJ0ZXhhaSB9KTtcbiAgICAgICAgY29uc3QgaW5pdEh0dHBPcHRpb25zID0ge307XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5hcGlWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNsaWVudE9wdGlvbnMuYXBpVmVyc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVkVSVEVYX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT047XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IHRoaXMuYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplQXV0aFBhcmFtZXRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdlbWluaSBBUElcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5hcGlWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmNsaWVudE9wdGlvbnMuYXBpVmVyc2lvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogR09PR0xFX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT047XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS9gO1xuICAgICAgICB9XG4gICAgICAgIGluaXRIdHRwT3B0aW9ucy5oZWFkZXJzID0gdGhpcy5nZXREZWZhdWx0SGVhZGVycygpO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSBpbml0SHR0cE9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRzLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSB0aGlzLnBhdGNoSHR0cE9wdGlvbnMoaW5pdEh0dHBPcHRpb25zLCBvcHRzLmh0dHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBiYXNlIFVSTCBmb3IgVmVydGV4IEFJIGJhc2VkIG9uIHByb2plY3QgYW5kIGxvY2F0aW9uLlxuICAgICAqIFVzZXMgdGhlIGdsb2JhbCBlbmRwb2ludCBpZiBsb2NhdGlvbiBpcyAnZ2xvYmFsJyBvciBpZiBwcm9qZWN0L2xvY2F0aW9uXG4gICAgICogYXJlIG5vdCBzcGVjaWZpZWQgKGltcGx5aW5nIEFQSSBrZXkgdXNhZ2UpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24gIT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICAvLyBSZWdpb25hbCBlbmRwb2ludFxuICAgICAgICAgICAgcmV0dXJuIGBodHRwczovLyR7dGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9ufS1haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2xvYmFsIGVuZHBvaW50IChjb3ZlcnMgJ2dsb2JhbCcgbG9jYXRpb24gYW5kIEFQSSBrZXkgdXNhZ2UpXG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly9haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYXV0aGVudGljYXRpb24gcGFyYW1ldGVycyBmb3IgVmVydGV4IEFJLlxuICAgICAqIElmIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBwcm92aWRlZCwgQVBJIGtleSBpcyBjbGVhcmVkLlxuICAgICAqIElmIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBub3QgcHJvdmlkZWQgKGltcGx5aW5nIEFQSSBrZXkgdXNhZ2UpLFxuICAgICAqIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBjbGVhcmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbm9ybWFsaXplQXV0aFBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCAmJiB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIC8vIFVzaW5nIHByb2plY3QvbG9jYXRpb24gZm9yIGF1dGgsIGNsZWFyIHBvdGVudGlhbCBBUEkga2V5XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzaW5nIEFQSSBrZXkgZm9yIGF1dGggKG9yIG5vIGF1dGggcHJvdmlkZWQgeWV0KSwgY2xlYXIgcHJvamVjdC9sb2NhdGlvblxuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpc1ZlcnRleEFJKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLnByb2plY3Q7XG4gICAgfVxuICAgIGdldExvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uO1xuICAgIH1cbiAgICBnZXRBcGlWZXJzaW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmFwaVZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkgdmVyc2lvbiBpcyBub3Qgc2V0LicpO1xuICAgIH1cbiAgICBnZXRCYXNlVXJsKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXNlIFVSTCBpcyBub3Qgc2V0LicpO1xuICAgIH1cbiAgICBnZXRSZXF1ZXN0VXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXF1ZXN0VXJsSW50ZXJuYWwodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmhlYWRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkZXJzIGFyZSBub3Qgc2V0LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlcXVlc3RVcmxJbnRlcm5hbChodHRwT3B0aW9ucykge1xuICAgICAgICBpZiAoIWh0dHBPcHRpb25zIHx8XG4gICAgICAgICAgICBodHRwT3B0aW9ucy5iYXNlVXJsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zLmFwaVZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVFRQIG9wdGlvbnMgYXJlIG5vdCBjb3JyZWN0bHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBodHRwT3B0aW9ucy5iYXNlVXJsLmVuZHNXaXRoKCcvJylcbiAgICAgICAgICAgID8gaHR0cE9wdGlvbnMuYmFzZVVybC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgIDogaHR0cE9wdGlvbnMuYmFzZVVybDtcbiAgICAgICAgY29uc3QgdXJsRWxlbWVudCA9IFtiYXNlVXJsXTtcbiAgICAgICAgaWYgKGh0dHBPcHRpb25zLmFwaVZlcnNpb24gJiYgaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAhPT0gJycpIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaChodHRwT3B0aW9ucy5hcGlWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsRWxlbWVudC5qb2luKCcvJyk7XG4gICAgfVxuICAgIGdldEJhc2VSZXNvdXJjZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHt0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdH0vbG9jYXRpb25zLyR7dGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9ufWA7XG4gICAgfVxuICAgIGdldEFwaUtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXk7XG4gICAgfVxuICAgIGdldFdlYnNvY2tldEJhc2VVcmwoKSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmdldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgdXJsUGFydHMgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgICAgICB1cmxQYXJ0cy5wcm90b2NvbCA9IHVybFBhcnRzLnByb3RvY29sID09ICdodHRwOicgPyAnd3MnIDogJ3dzcyc7XG4gICAgICAgIHJldHVybiB1cmxQYXJ0cy50b1N0cmluZygpO1xuICAgIH1cbiAgICBzZXRCYXNlVXJsKHVybCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSFRUUCBvcHRpb25zIGFyZSBub3QgY29ycmVjdGx5IHNldC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RVcmwocGF0aCwgaHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pIHtcbiAgICAgICAgY29uc3QgdXJsRWxlbWVudCA9IFt0aGlzLmdldFJlcXVlc3RVcmxJbnRlcm5hbChodHRwT3B0aW9ucyldO1xuICAgICAgICBpZiAocHJlcGVuZFByb2plY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgdXJsRWxlbWVudC5wdXNoKHRoaXMuZ2V0QmFzZVJlc291cmNlUGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAhPT0gJycpIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3VybEVsZW1lbnQuam9pbignLycpfWApO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBzaG91bGRQcmVwZW5kVmVydGV4UHJvamVjdFBhdGgocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jbGllbnRPcHRpb25zLnZlcnRleGFpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QucGF0aC5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgLy8gQXNzdW1lIHRoZSBwYXRoIGFscmVhZHkgc3RhcnRzIHdpdGhcbiAgICAgICAgICAgIC8vIGBwcm9qZWN0cy88cHJvamVjdD4vbG9jYXRpb24vPGxvY2F0aW9uPmAuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE1ldGhvZCA9PT0gJ0dFVCcgJiZcbiAgICAgICAgICAgIHJlcXVlc3QucGF0aC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMnKSkge1xuICAgICAgICAgICAgLy8gVGhlc2UgcGF0aHMgYXJlIHVzZWQgYnkgVmVydGV4J3MgbW9kZWxzLmdldCBhbmQgbW9kZWxzLmxpc3RcbiAgICAgICAgICAgIC8vIGNhbGxzLiBGb3IgYmFzZSBtb2RlbHMgVmVydGV4IGRvZXMgbm90IGFjY2VwdCBhIHByb2plY3QvbG9jYXRpb25cbiAgICAgICAgICAgIC8vIHByZWZpeCAoZm9yIHR1bmVkIG1vZGVsIHRoZSBwcmVmaXggaXMgcmVxdWlyZWQpLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgbGV0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucztcbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMucGF0Y2hIdHRwT3B0aW9ucyh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMsIHJlcXVlc3QuaHR0cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXBlbmRQcm9qZWN0TG9jYXRpb24gPSB0aGlzLnNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5jb25zdHJ1Y3RVcmwocmVxdWVzdC5wYXRoLCBwYXRjaGVkSHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pO1xuICAgICAgICBpZiAocmVxdWVzdC5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVxdWVzdC5xdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0SW5pdCA9IHt9O1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwTWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QuYm9keSAmJiByZXF1ZXN0LmJvZHkgIT09ICd7fScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgYm9keSBzaG91bGQgYmUgZW1wdHkgZm9yIEdFVCByZXF1ZXN0LCBidXQgZ290IG5vbiBlbXB0eSByZXF1ZXN0IGJvZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEluaXQgPSBhd2FpdCB0aGlzLmluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgcGF0Y2hlZEh0dHBPcHRpb25zLCByZXF1ZXN0LmFib3J0U2lnbmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5hcnlBcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIHJlcXVlc3QuaHR0cE1ldGhvZCk7XG4gICAgfVxuICAgIHBhdGNoSHR0cE9wdGlvbnMoYmFzZUh0dHBPcHRpb25zLCByZXF1ZXN0SHR0cE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGF0Y2hlZEh0dHBPcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShiYXNlSHR0cE9wdGlvbnMpKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVxdWVzdEh0dHBPcHRpb25zKSkge1xuICAgICAgICAgICAgLy8gUmVjb3JkcyBjb21waWxlIHRvIG9iamVjdHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMyMzQ1VFM3MDUzOiBFbGVtZW50IGltcGxpY2l0bHkgaGFzIGFuICdhbnknIHR5cGVcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGV4cHJlc3Npb24gb2YgdHlwZSAnc3RyaW5nJyBjYW4ndCBiZSB1c2VkIHRvIGluZGV4IHR5cGVcbiAgICAgICAgICAgICAgICAvLyAnSHR0cE9wdGlvbnMnLlxuICAgICAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9uc1trZXldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTMjM0NVRTNzA1MzogRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBleHByZXNzaW9uIG9mIHR5cGUgJ3N0cmluZycgY2FuJ3QgYmUgdXNlZCB0byBpbmRleCB0eXBlXG4gICAgICAgICAgICAgICAgLy8gJ0h0dHBPcHRpb25zJy5cbiAgICAgICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRjaGVkSHR0cE9wdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3RTdHJlYW0ocmVxdWVzdCkge1xuICAgICAgICBsZXQgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zO1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5wYXRjaEh0dHBPcHRpb25zKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucywgcmVxdWVzdC5odHRwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlcGVuZFByb2plY3RMb2NhdGlvbiA9IHRoaXMuc2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbnN0cnVjdFVybChyZXF1ZXN0LnBhdGgsIHBhdGNoZWRIdHRwT3B0aW9ucywgcHJlcGVuZFByb2plY3RMb2NhdGlvbik7XG4gICAgICAgIGlmICghdXJsLnNlYXJjaFBhcmFtcy5oYXMoJ2FsdCcpIHx8IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdhbHQnKSAhPT0gJ3NzZScpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdhbHQnLCAnc3NlJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RJbml0ID0ge307XG4gICAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIHJlcXVlc3RJbml0ID0gYXdhaXQgdGhpcy5pbmNsdWRlRXh0cmFIdHRwT3B0aW9uc1RvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIHBhdGNoZWRIdHRwT3B0aW9ucywgcmVxdWVzdC5hYm9ydFNpZ25hbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCwgcmVxdWVzdC5odHRwTWV0aG9kKTtcbiAgICB9XG4gICAgYXN5bmMgaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBodHRwT3B0aW9ucywgYWJvcnRTaWduYWwpIHtcbiAgICAgICAgaWYgKChodHRwT3B0aW9ucyAmJiBodHRwT3B0aW9ucy50aW1lb3V0KSB8fCBhYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgIGlmIChodHRwT3B0aW9ucy50aW1lb3V0ICYmIChodHRwT3B0aW9ucyA9PT0gbnVsbCB8fCBodHRwT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cE9wdGlvbnMudGltZW91dCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gYWJvcnRDb250cm9sbGVyLmFib3J0KCksIGh0dHBPcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SGFuZGxlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aW1lb3V0SGFuZGxlLnVucmVmID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHVucmVmIHRvIHByZXZlbnQgbm9kZWpzIHByb2Nlc3MgZnJvbSBoYW5naW5nLCBzZWVcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lb3V0dW5yZWZcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZS51bnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RJbml0LnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMuZXh0cmFCb2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmNsdWRlRXh0cmFCb2R5VG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgaHR0cE9wdGlvbnMuZXh0cmFCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0SW5pdC5oZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRIZWFkZXJzSW50ZXJuYWwoaHR0cE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdEluaXQ7XG4gICAgfVxuICAgIGFzeW5jIHVuYXJ5QXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCBodHRwTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUNhbGwodXJsLnRvU3RyaW5nKCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdEluaXQpLCB7IG1ldGhvZDogaHR0cE1ldGhvZCB9KSlcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhyb3dFcnJvcklmTm90T0socmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIdHRwUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW1BcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIGh0dHBNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2FsbCh1cmwudG9TdHJpbmcoKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0SW5pdCksIHsgbWV0aG9kOiBodHRwTWV0aG9kIH0pKVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aHJvd0Vycm9ySWZOb3RPSyhyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBwcm9jZXNzU3RyZWFtUmVzcG9uc2VfMSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5ib2R5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGJvZHkgaXMgZW1wdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHlpZWxkIF9fYXdhaXQocmVhZGVyLnJlYWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBsZXRlIEpTT04gc2VnbWVudCBhdCB0aGUgZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua1N0cmluZyA9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgYW5kIHRocm93IGFuIGVycm9yIGlmIHRoZSBjaHVuayBjb250YWlucyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rSnNvbiA9IEpTT04ucGFyc2UoY2h1bmtTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gY2h1bmtKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjaHVua0pzb25bJ2Vycm9yJ10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBlcnJvckpzb25bJ3N0YXR1cyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBlcnJvckpzb25bJ2NvZGUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgZ290IHN0YXR1czogJHtzdGF0dXN9LiAke0pTT04uc3RyaW5naWZ5KGNodW5rSnNvbil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA+PSA0MDAgJiYgY29kZSA8IDYwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBhcGlFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQXBpRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0gY2h1bmtTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IGJ1ZmZlci5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ2h1bmtTdHJpbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHByb2Nlc3NlZENodW5rU3RyaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQobmV3IEh0dHBSZXNwb25zZShwYXJ0aWFsUmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGJ1ZmZlci5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uIHBhcnNpbmcgc3RyZWFtIGNodW5rICR7cHJvY2Vzc2VkQ2h1bmtTdHJpbmd9LiAke2V9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCkge1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCByZXF1ZXN0SW5pdCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uICR7ZX0gc2VuZGluZyByZXF1ZXN0YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREZWZhdWx0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBjb25zdCB2ZXJzaW9uSGVhZGVyVmFsdWUgPSBMSUJSQVJZX0xBQkVMICsgJyAnICsgdGhpcy5jbGllbnRPcHRpb25zLnVzZXJBZ2VudEV4dHJhO1xuICAgICAgICBoZWFkZXJzW1VTRVJfQUdFTlRfSEVBREVSXSA9IHZlcnNpb25IZWFkZXJWYWx1ZTtcbiAgICAgICAgaGVhZGVyc1tHT09HTEVfQVBJX0NMSUVOVF9IRUFERVJdID0gdmVyc2lvbkhlYWRlclZhbHVlO1xuICAgICAgICBoZWFkZXJzW0NPTlRFTlRfVFlQRV9IRUFERVJdID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgYXN5bmMgZ2V0SGVhZGVyc0ludGVybmFsKGh0dHBPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICBpZiAoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaHR0cE9wdGlvbnMuaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGVuZCBhIHRpbWVvdXQgaGVhZGVyIGlmIGl0IGlzIHNldCwgbm90ZSB0aGF0IHRoZSB0aW1lb3V0IG9wdGlvbiBpc1xuICAgICAgICAgICAgLy8gaW4gbWlsbGlzZWNvbmRzIGJ1dCB0aGUgaGVhZGVyIGlzIGluIHNlY29uZHMuXG4gICAgICAgICAgICBpZiAoaHR0cE9wdGlvbnMudGltZW91dCAmJiBodHRwT3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKFNFUlZFUl9USU1FT1VUX0hFQURFUiwgU3RyaW5nKE1hdGguY2VpbChodHRwT3B0aW9ucy50aW1lb3V0IC8gMTAwMCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudE9wdGlvbnMuYXV0aC5hZGRBdXRoSGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHVzaW5nIEdlbWluaSBBUEkgb25seSwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICogaW4gVmVydGV4IEFJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIHN0cmluZyBwYXRoIHRvIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkIG9yIGEgQmxvYiBvYmplY3QuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25hbCBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiB0aGUgYFVwbG9hZEZpbGVDb25maWdgXG4gICAgICogICAgIGludGVyZmFjZS4gQHNlZSB7QGxpbmsgVXBsb2FkRmlsZUNvbmZpZ31cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZpbGVgIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNhbGxlZCBvbiBhIFZlcnRleCBBSSBjbGllbnQuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgYG1pbWVUeXBlYCBpcyBub3QgcHJvdmlkZWQgYW5kIGNhbiBub3QgYmUgaW5mZXJyZWQsXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkRmlsZShmaWxlLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBmaWxlVG9VcGxvYWQgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQubWltZVR5cGUgPSBjb25maWcubWltZVR5cGU7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQubmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLmRpc3BsYXlOYW1lID0gY29uZmlnLmRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlVG9VcGxvYWQubmFtZSAmJiAhZmlsZVRvVXBsb2FkLm5hbWUuc3RhcnRzV2l0aCgnZmlsZXMvJykpIHtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5uYW1lID0gYGZpbGVzLyR7ZmlsZVRvVXBsb2FkLm5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRlciA9IHRoaXMuY2xpZW50T3B0aW9ucy51cGxvYWRlcjtcbiAgICAgICAgY29uc3QgZmlsZVN0YXQgPSBhd2FpdCB1cGxvYWRlci5zdGF0KGZpbGUpO1xuICAgICAgICBmaWxlVG9VcGxvYWQuc2l6ZUJ5dGVzID0gU3RyaW5nKGZpbGVTdGF0LnNpemUpO1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5taW1lVHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlsZVN0YXQudHlwZTtcbiAgICAgICAgaWYgKG1pbWVUeXBlID09PSB1bmRlZmluZWQgfHwgbWltZVR5cGUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZGV0ZXJtaW5lIG1pbWVUeXBlLiBQbGVhc2UgcHJvdmlkZSBtaW1lVHlwZSBpbiB0aGUgY29uZmlnLicpO1xuICAgICAgICB9XG4gICAgICAgIGZpbGVUb1VwbG9hZC5taW1lVHlwZSA9IG1pbWVUeXBlO1xuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSBhd2FpdCB0aGlzLmZldGNoVXBsb2FkVXJsKGZpbGVUb1VwbG9hZCwgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZGVyLnVwbG9hZChmaWxlLCB1cGxvYWRVcmwsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHRvIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbXMgcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkb3dubG9hZCByZXF1ZXN0LCBzZWUge0BsaW5rXG4gICAgICogRG93bmxvYWRGaWxlUGFyYW1ldGVyc31cbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZEZpbGUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGRvd25sb2FkZXIgPSB0aGlzLmNsaWVudE9wdGlvbnMuZG93bmxvYWRlcjtcbiAgICAgICAgYXdhaXQgZG93bmxvYWRlci5kb3dubG9hZChwYXJhbXMsIHRoaXMpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFVwbG9hZFVybChmaWxlLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaHR0cE9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWcuaHR0cE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBodHRwT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLVByb3RvY29sJzogJ3Jlc3VtYWJsZScsXG4gICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1MZW5ndGgnOiBgJHtmaWxlLnNpemVCeXRlc31gLFxuICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1UeXBlJzogYCR7ZmlsZS5taW1lVHlwZX1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICAnZmlsZSc6IGZpbGUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGh0dHBSZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBwYXRoOiBmb3JtYXRNYXAoJ3VwbG9hZC92MWJldGEvZmlsZXMnLCBib2R5WydfdXJsJ10pLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBodHRwT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaHR0cFJlc3BvbnNlIHx8ICEoaHR0cFJlc3BvbnNlID09PSBudWxsIHx8IGh0dHBSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cFJlc3BvbnNlLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBkaWQgbm90IHJldHVybiBhbiBIdHRwUmVzcG9uc2Ugb3IgdGhlIHJldHVybmVkIEh0dHBSZXNwb25zZSBkaWQgbm90IGhhdmUgaGVhZGVycy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSAoX2EgPSBodHRwUmVzcG9uc2UgPT09IG51bGwgfHwgaHR0cFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwUmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWyd4LWdvb2ctdXBsb2FkLXVybCddO1xuICAgICAgICBpZiAodXBsb2FkVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB1cGxvYWQgdXJsLiBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gdGhlIHgtZ29vZ2xlLXVwbG9hZC11cmwgaW4gdGhlIGhlYWRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBsb2FkVXJsO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzcG9uc2UgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICBsZXQgZXJyb3JCb2R5O1xuICAgICAgICBpZiAoKF9hID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0ge1xuICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHJlc3BvbnNlLnRleHQoKSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZXJyb3JCb2R5KTtcbiAgICAgICAgaWYgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBhcGlFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHVwZGF0ZXMgdGhlIGByZXF1ZXN0SW5pdC5ib2R5YCB3aXRoIHZhbHVlcyBmcm9tIGFuIGBleHRyYUJvZHlgIG9iamVjdC5cbiAqXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBzdHJpbmcsIGl0J3MgYXNzdW1lZCB0byBiZSBKU09OIGFuZCB3aWxsIGJlIHBhcnNlZC5cbiAqIFRoZSBgZXh0cmFCb2R5YCBpcyB0aGVuIGRlZXBseSBtZXJnZWQgaW50byB0aGlzIHBhcnNlZCBvYmplY3QuXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBCbG9iLCBgZXh0cmFCb2R5YCB3aWxsIGJlIGlnbm9yZWQsIGFuZCBhIHdhcm5pbmcgbG9nZ2VkLFxuICogYXMgbWVyZ2luZyBzdHJ1Y3R1cmVkIGRhdGEgaW50byBhbiBvcGFxdWUgQmxvYiBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBkb2VzIG5vdCBlbmZvcmNlIHRoYXQgdXBkYXRlZCB2YWx1ZXMgZnJvbSBgZXh0cmFCb2R5YCBoYXZlIHRoZVxuICogc2FtZSB0eXBlIGFzIGV4aXN0aW5nIHZhbHVlcyBpbiBgcmVxdWVzdEluaXQuYm9keWAuIFR5cGUgbWlzbWF0Y2hlcyBkdXJpbmdcbiAqIHRoZSBtZXJnZSB3aWxsIHJlc3VsdCBpbiBhIHdhcm5pbmcsIGJ1dCB0aGUgdmFsdWUgZnJvbSBgZXh0cmFCb2R5YCB3aWxsIG92ZXJ3cml0ZVxuICogdGhlIG9yaWdpbmFsLiBgZXh0cmFCb2R5YCB1c2VycyBhcmUgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIGBleHRyYUJvZHlgIGhhcyB0aGUgY29ycmVjdCBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIHJlcXVlc3RJbml0IFRoZSBSZXF1ZXN0SW5pdCBvYmplY3Qgd2hvc2UgYm9keSB3aWxsIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0gZXh0cmFCb2R5IFRoZSBvYmplY3QgY29udGFpbmluZyB1cGRhdGVzIHRvIGJlIG1lcmdlZCBpbnRvIGByZXF1ZXN0SW5pdC5ib2R5YC5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGV4dHJhQm9keSkge1xuICAgIGlmICghZXh0cmFCb2R5IHx8IE9iamVjdC5rZXlzKGV4dHJhQm9keSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3RJbml0LmJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IGV4dHJhQm9keSBwcm92aWRlZCBidXQgY3VycmVudCByZXF1ZXN0IGJvZHkgaXMgYSBCbG9iLiBleHRyYUJvZHkgd2lsbCBiZSBpZ25vcmVkIGFzIG1lcmdpbmcgaXMgbm90IHN1cHBvcnRlZCBmb3IgQmxvYiBib2RpZXMuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRCb2R5T2JqZWN0ID0ge307XG4gICAgLy8gSWYgYWRkaW5nIG5ldyB0eXBlIHRvIEh0dHBSZXF1ZXN0LmJvZHksIHBsZWFzZSBjaGVjayB0aGUgY29kZSBiZWxvdyB0b1xuICAgIC8vIHNlZSBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbG9naWMuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0SW5pdC5ib2R5ID09PSAnc3RyaW5nJyAmJiByZXF1ZXN0SW5pdC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKHJlcXVlc3RJbml0LmJvZHkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRCb2R5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHBhcnNlZEJvZHkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJzZWRCb2R5KSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCb2R5T2JqZWN0ID0gcGFyc2VkQm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyB2YWxpZCBKU09OIGJ1dCBub3QgYSBub24tYXJyYXkgb2JqZWN0LiBTa2lwIGFwcGx5aW5nIGV4dHJhQm9keSB0byB0aGUgcmVxdWVzdCBib2R5LicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qICBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyBub3QgdmFsaWQgSlNPTi4gU2tpcCBhcHBseWluZyBleHRyYUJvZHkgdG8gdGhlIHJlcXVlc3QgYm9keS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWVwTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSBvdXRwdXRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNvdXJjZVZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBkZWVwTWVyZ2UodGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRWYWx1ZSAhPT0gdHlwZW9mIHNvdXJjZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OmRlZXBNZXJnZTogVHlwZSBtaXNtYXRjaCBmb3Iga2V5IFwiJHtrZXl9XCIuIE9yaWdpbmFsIHR5cGU6ICR7dHlwZW9mIHRhcmdldFZhbHVlfSwgTmV3IHR5cGU6ICR7dHlwZW9mIHNvdXJjZVZhbHVlfS4gT3ZlcndyaXRpbmcuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkQm9keSA9IGRlZXBNZXJnZShjdXJyZW50Qm9keU9iamVjdCwgZXh0cmFCb2R5KTtcbiAgICByZXF1ZXN0SW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkobWVyZ2VkQm9keSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIFRPRE86IGIvNDE2MDQxMjI5IC0gRGV0ZXJtaW5lIGhvdyB0byByZXRyaWV2ZSB0aGUgTUNQIHBhY2thZ2UgdmVyc2lvbi5cbmNvbnN0IE1DUF9MQUJFTCA9ICdtY3BfdXNlZC91bmtub3duJztcbi8vIFdoZXRoZXIgTUNQIHRvb2wgdXNhZ2UgaXMgZGV0ZWN0ZWQgZnJvbSBtY3BUb1Rvb2wuIFRoaXMgaXMgdXNlZCBmb3Jcbi8vIHRlbGVtZXRyeS5cbmxldCBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sID0gZmFsc2U7XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgTUNQIHRvb2xzLlxuZnVuY3Rpb24gaGFzTWNwVG9vbFVzYWdlKHRvb2xzKSB7XG4gICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzKSB7XG4gICAgICAgIGlmIChpc01jcENhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b29sID09PSAnb2JqZWN0JyAmJiAnaW5wdXRTY2hlbWEnIGluIHRvb2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sO1xufVxuLy8gU2V0cyB0aGUgTUNQIHZlcnNpb24gbGFiZWwgaW4gdGhlIEdvb2dsZSBBUEkgY2xpZW50IGhlYWRlci5cbmZ1bmN0aW9uIHNldE1jcFVzYWdlSGVhZGVyKGhlYWRlcnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXhpc3RpbmdIZWFkZXIgPSAoX2EgPSBoZWFkZXJzW0dPT0dMRV9BUElfQ0xJRU5UX0hFQURFUl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgIGhlYWRlcnNbR09PR0xFX0FQSV9DTElFTlRfSEVBREVSXSA9IChleGlzdGluZ0hlYWRlciArIGAgJHtNQ1BfTEFCRUx9YCkudHJpbVN0YXJ0KCk7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIE1DUCBDYWxsYWJsZVRvb2wsIG90aGVyd2lzZSBmYWxzZS5cbmZ1bmN0aW9uIGlzTWNwQ2FsbGFibGVUb29sKG9iamVjdCkge1xuICAgIHJldHVybiAob2JqZWN0ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9iamVjdCBpbnN0YW5jZW9mIE1jcENhbGxhYmxlVG9vbCk7XG59XG4vLyBMaXN0IGFsbCB0b29scyBmcm9tIHRoZSBNQ1AgY2xpZW50LlxuZnVuY3Rpb24gbGlzdEFsbFRvb2xzKG1jcENsaWVudCwgbWF4VG9vbHMgPSAxMDApIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBsaXN0QWxsVG9vbHNfMSgpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG51bVRvb2xzID0gMDtcbiAgICAgICAgd2hpbGUgKG51bVRvb2xzIDwgbWF4VG9vbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB5aWVsZCBfX2F3YWl0KG1jcENsaWVudC5saXN0VG9vbHMoeyBjdXJzb3IgfSkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHQudG9vbHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHRvb2wpO1xuICAgICAgICAgICAgICAgIG51bVRvb2xzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXQubmV4dEN1cnNvcikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3Vyc29yID0gdC5uZXh0Q3Vyc29yO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIE1jcENhbGxhYmxlVG9vbCBjYW4gYmUgdXNlZCBmb3IgbW9kZWwgaW5mZXJlbmNlIGFuZCBpbnZva2luZyBNQ1AgY2xpZW50cyB3aXRoXG4gKiBnaXZlbiBmdW5jdGlvbiBjYWxsIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIEJ1aWx0LWluIE1DUCBzdXBwb3J0IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLCBtYXkgY2hhbmdlIGluIGZ1dHVyZVxuICogdmVyc2lvbnMuXG4gKi9cbmNsYXNzIE1jcENhbGxhYmxlVG9vbCB7XG4gICAgY29uc3RydWN0b3IobWNwQ2xpZW50cyA9IFtdLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5tY3BUb29scyA9IFtdO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTmFtZVRvTWNwQ2xpZW50ID0ge307XG4gICAgICAgIHRoaXMubWNwQ2xpZW50cyA9IG1jcENsaWVudHM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWNwQ2FsbGFibGVUb29sLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUobWNwQ2xpZW50cywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWNwQ2FsbGFibGVUb29sKG1jcENsaWVudHMsIGNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgZnVuY3Rpb24gbmFtZXMgYXJlIG5vdCBkdXBsaWNhdGUgYW5kIGluaXRpYWxpemUgdGhlIGZ1bmN0aW9uXG4gICAgICogbmFtZSB0byBNQ1AgY2xpZW50IG1hcHBpbmcuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIE1DUCB0b29scyBmcm9tIHRoZSBNQ1AgY2xpZW50cyBoYXZlIGR1cGxpY2F0ZSB0b29sXG4gICAgICogICAgIG5hbWVzLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICAgIGlmICh0aGlzLm1jcFRvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbk1hcCA9IHt9O1xuICAgICAgICBjb25zdCBtY3BUb29scyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1jcENsaWVudCBvZiB0aGlzLm1jcENsaWVudHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IChlXzEgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMobGlzdEFsbFRvb2xzKG1jcENsaWVudCkpKSwgX2Y7IF9mID0gYXdhaXQgX2UubmV4dCgpLCBfYSA9IF9mLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1jcFRvb2wgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgbWNwVG9vbHMucHVzaChtY3BUb29sKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWNwVG9vbE5hbWUgPSBtY3BUb29sLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbk1hcFttY3BUb29sTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZ1bmN0aW9uIG5hbWUgJHttY3BUb29sTmFtZX0gZm91bmQgaW4gTUNQIHRvb2xzLiBQbGVhc2UgZW5zdXJlIGZ1bmN0aW9uIG5hbWVzIGFyZSB1bmlxdWUuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25NYXBbbWNwVG9vbE5hbWVdID0gbWNwQ2xpZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBhd2FpdCBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWNwVG9vbHMgPSBtY3BUb29scztcbiAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCA9IGZ1bmN0aW9uTWFwO1xuICAgIH1cbiAgICBhc3luYyB0b29sKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIG1jcFRvb2xzVG9HZW1pbmlUb29sKHRoaXMubWNwVG9vbHMsIHRoaXMuY29uZmlnKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbFRvb2woZnVuY3Rpb25DYWxscykge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uQ2FsbCBvZiBmdW5jdGlvbkNhbGxzKSB7XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsLm5hbWUgaW4gdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1jcENsaWVudCA9IHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnRbZnVuY3Rpb25DYWxsLm5hbWVdO1xuICAgICAgICAgICAgICAgIGxldCByZXF1ZXN0T3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBiLzQyNDIzODY1NCAtIEFkZCBzdXBwb3J0IGZvciBmaW5lciBncmFpbmVkIHRpbWVvdXQgY29udHJvbC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcudGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMuY29uZmlnLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxUb29sUmVzcG9uc2UgPSBhd2FpdCBtY3BDbGllbnQuY2FsbFRvb2woe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbkNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBmdW5jdGlvbkNhbGwuYXJncyxcbiAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHJlc3VsdCBzY2hlbWEgdG8gdW5kZWZpbmVkIHRvIGFsbG93IE1DUCB0byByZWx5IG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgc2NoZW1hLlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbFJlc3BvbnNlUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uQ2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGNhbGxUb29sUmVzcG9uc2UuaXNFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBlcnJvcjogY2FsbFRvb2xSZXNwb25zZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjYWxsVG9vbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxSZXNwb25zZVBhcnRzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTWNwQ2xpZW50KGNsaWVudCkge1xuICAgIHJldHVybiAoY2xpZW50ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBjbGllbnQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICdsaXN0VG9vbHMnIGluIGNsaWVudCAmJlxuICAgICAgICB0eXBlb2YgY2xpZW50Lmxpc3RUb29scyA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBNY3BDYWxsYWJsZVRvb2wgZnJvbSBNQ1AgY2xpZW50cyBhbmQgYW4gb3B0aW9uYWwgY29uZmlnLlxuICpcbiAqIFRoZSBjYWxsYWJsZSB0b29sIGNhbiBpbnZva2UgdGhlIE1DUCBjbGllbnRzIHdpdGggZ2l2ZW4gZnVuY3Rpb24gY2FsbFxuICogYXJndW1lbnRzLiAob2Z0ZW4gZm9yIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nKS5cbiAqIFVzZSB0aGUgY29uZmlnIHRvIG1vZGlmeSB0b29sIHBhcmFtZXRlcnMgc3VjaCBhcyBiZWhhdmlvci5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIEJ1aWx0LWluIE1DUCBzdXBwb3J0IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLCBtYXkgY2hhbmdlIGluIGZ1dHVyZVxuICogdmVyc2lvbnMuXG4gKi9cbmZ1bmN0aW9uIG1jcFRvVG9vbCguLi5hcmdzKSB7XG4gICAgLy8gU2V0IE1DUCB1c2FnZSBmb3IgdGVsZW1ldHJ5LlxuICAgIGhhc01jcFRvb2xVc2FnZUZyb21NY3BUb1Rvb2wgPSB0cnVlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIE1DUCBjbGllbnRzIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IG1heWJlQ29uZmlnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpc01jcENsaWVudChtYXliZUNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIE1jcENhbGxhYmxlVG9vbC5jcmVhdGUoYXJncywge30pO1xuICAgIH1cbiAgICByZXR1cm4gTWNwQ2FsbGFibGVUb29sLmNyZWF0ZShhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSksIG1heWJlQ29uZmlnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBIYW5kbGVzIGluY29taW5nIG1lc3NhZ2VzIGZyb20gdGhlIFdlYlNvY2tldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcGFyc2luZyBpbmNvbWluZyBtZXNzYWdlcywgdHJhbnNmb3JtaW5nIHRoZW1cbiAqIGludG8gTGl2ZU11c2ljU2VydmVyTWVzc2FnZSwgYW5kIHRoZW4gY2FsbGluZyB0aGUgb25tZXNzYWdlIGNhbGxiYWNrLlxuICogTm90ZSB0aGF0IHRoZSBmaXJzdCBtZXNzYWdlIHdoaWNoIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBhXG4gKiBzZXR1cENvbXBsZXRlIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGFwaUNsaWVudCBUaGUgQXBpQ2xpZW50IGluc3RhbmNlLlxuICogQHBhcmFtIG9ubWVzc2FnZSBUaGUgdXNlci1wcm92aWRlZCBvbm1lc3NhZ2UgY2FsbGJhY2sgKGlmIGFueSkuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIE1lc3NhZ2VFdmVudCBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UkMShhcGlDbGllbnQsIG9ubWVzc2FnZSwgZXZlbnQpIHtcbiAgICBjb25zdCBzZXJ2ZXJNZXNzYWdlID0gbmV3IExpdmVNdXNpY1NlcnZlck1lc3NhZ2UoKTtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgZXZlbnQuZGF0YS50ZXh0KCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gbGl2ZU11c2ljU2VydmVyTWVzc2FnZUZyb21NbGRldihkYXRhKTtcbiAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3BvbnNlKTtcbiAgICBvbm1lc3NhZ2Uoc2VydmVyTWVzc2FnZSk7XG59XG4vKipcbiAgIExpdmVNdXNpYyBjbGFzcyBlbmNhcHN1bGF0ZXMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGxpdmUgbXVzaWNcbiAgIGdlbmVyYXRpb24gdmlhIEx5cmlhIExpdmUgbW9kZWxzLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBMaXZlTXVzaWMge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgYXV0aCwgd2ViU29ja2V0RmFjdG9yeSkge1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgbW9kZWwgYW5kIHJldHVybnMgYVxuICAgICAgIExpdmVNdXNpY1Nlc3Npb24gb2JqZWN0IHJlcHJlc2VudGluZyB0aGF0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICAgQHJlbWFya3NcbiAgXG4gICAgICAgQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uIHRvIHRoZSBtb2RlbC5cbiAgICAgICBAcmV0dXJuIEEgbGl2ZSBzZXNzaW9uLlxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsID0gJ21vZGVscy9seXJpYS1yZWFsdGltZS1leHAnO1xuICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBhaS5saXZlLm11c2ljLmNvbm5lY3Qoe1xuICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgIG9ubWVzc2FnZTogKGU6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlcjogJXNcXG4nLCBkZWJ1ZyhlLmRhdGEpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25lcnJvcjogKGU6IEVycm9yRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3Igb2NjdXJyZWQ6ICVzXFxuJywgZGVidWcoZS5lcnJvcikpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmNsb3NlOiAoZTogQ2xvc2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW9uIGNsb3NlZC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgIH0sXG4gICAgICAgfSk7XG4gICAgICAgYGBgXG4gICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGl2ZSBtdXNpYyBpcyBub3Qgc3VwcG9ydGVkIGZvciBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKCdMaXZlIG11c2ljIGdlbmVyYXRpb24gaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy4nKTtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0QmFzZVVybCA9IHRoaXMuYXBpQ2xpZW50LmdldFdlYnNvY2tldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgYXBpVmVyc2lvbiA9IHRoaXMuYXBpQ2xpZW50LmdldEFwaVZlcnNpb24oKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1hcFRvSGVhZGVycyQxKHRoaXMuYXBpQ2xpZW50LmdldERlZmF1bHRIZWFkZXJzKCkpO1xuICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlLZXkoKTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7d2Vic29ja2V0QmFzZVVybH0vd3MvZ29vZ2xlLmFpLmdlbmVyYXRpdmVsYW5ndWFnZS4ke2FwaVZlcnNpb259LkdlbmVyYXRpdmVTZXJ2aWNlLkJpZGlHZW5lcmF0ZU11c2ljP2tleT0ke2FwaUtleX1gO1xuICAgICAgICBsZXQgb25vcGVuUmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgY29uc3Qgb25vcGVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHBhcmFtcy5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9ub3BlblJlc29sdmUoe30pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0Q2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgb25vcGVuOiBvbm9wZW5Bd2FpdGVkQ2FsbGJhY2ssXG4gICAgICAgICAgICBvbm1lc3NhZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZvaWQgaGFuZGxlV2ViU29ja2V0TWVzc2FnZSQxKGFwaUNsaWVudCwgY2FsbGJhY2tzLm9ubWVzc2FnZSwgZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uZXJyb3I6IChfYSA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbmVycm9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uY2xvc2U6IChfYiA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbmNsb3NlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMud2ViU29ja2V0RmFjdG9yeS5jcmVhdGUodXJsLCBoZWFkZXJzVG9NYXAkMShoZWFkZXJzKSwgd2Vic29ja2V0Q2FsbGJhY2tzKTtcbiAgICAgICAgY29ubi5jb25uZWN0KCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3ZWJzb2NrZXQgdG8gb3BlbiBiZWZvcmUgc2VuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgYXdhaXQgb25vcGVuUHJvbWlzZTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0TW9kZWwodGhpcy5hcGlDbGllbnQsIHBhcmFtcy5tb2RlbCk7XG4gICAgICAgIGNvbnN0IHNldHVwID0gbGl2ZU11c2ljQ2xpZW50U2V0dXBUb01sZGV2KHtcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IGxpdmVNdXNpY0NsaWVudE1lc3NhZ2VUb01sZGV2KHsgc2V0dXAgfSk7XG4gICAgICAgIGNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBuZXcgTGl2ZU11c2ljU2Vzc2lvbihjb25uLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxufVxuLyoqXG4gICBSZXByZXNlbnRzIGEgY29ubmVjdGlvbiB0byB0aGUgQVBJLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBMaXZlTXVzaWNTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2V0cyBpbnB1dHMgdG8gc3RlZXIgbXVzaWMgZ2VuZXJhdGlvbi4gVXBkYXRlcyB0aGUgc2Vzc2lvbidzIGN1cnJlbnRcbiAgICAgIHdlaWdodGVkIHByb21wdHMuXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIG9uZSBwcm9wZXJ0eSwgYHdlaWdodGVkUHJvbXB0c2AuXG4gIFxuICAgICAgICAtIGB3ZWlnaHRlZFByb21wdHNgIHRvIHNlbmQgdG8gdGhlIG1vZGVsOyB3ZWlnaHRzIGFyZSBub3JtYWxpemVkIHRvXG4gICAgICAgICAgc3VtIHRvIDEuMC5cbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgc2V0V2VpZ2h0ZWRQcm9tcHRzKHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy53ZWlnaHRlZFByb21wdHMgfHxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcy53ZWlnaHRlZFByb21wdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWlnaHRlZCBwcm9tcHRzIG11c3QgYmUgc2V0IGFuZCBjb250YWluIGF0IGxlYXN0IG9uZSBlbnRyeS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzID0gbGl2ZU11c2ljU2V0V2VpZ2h0ZWRQcm9tcHRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgY29uc3QgY2xpZW50Q29udGVudCA9IGxpdmVNdXNpY0NsaWVudENvbnRlbnRUb01sZGV2KHNldFdlaWdodGVkUHJvbXB0c1BhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeSh7IGNsaWVudENvbnRlbnQgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNldHMgYSBjb25maWd1cmF0aW9uIHRvIHRoZSBtb2RlbC4gVXBkYXRlcyB0aGUgc2Vzc2lvbidzIGN1cnJlbnRcbiAgICAgIG11c2ljIGdlbmVyYXRpb24gY29uZmlnLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBvbmUgcHJvcGVydHksIGBtdXNpY0dlbmVyYXRpb25Db25maWdgLlxuICBcbiAgICAgICAgLSBgbXVzaWNHZW5lcmF0aW9uQ29uZmlnYCB0byBzZXQgaW4gdGhlIG1vZGVsLiBQYXNzaW5nIGFuIGVtcHR5IG9yXG4gICAgICB1bmRlZmluZWQgY29uZmlnIHRvIHRoZSBtb2RlbCB3aWxsIHJlc2V0IHRoZSBjb25maWcgdG8gZGVmYXVsdHMuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIHNldE11c2ljR2VuZXJhdGlvbkNvbmZpZyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMubXVzaWNHZW5lcmF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICBwYXJhbXMubXVzaWNHZW5lcmF0aW9uQ29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0Q29uZmlnUGFyYW1ldGVycyA9IGxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSBsaXZlTXVzaWNDbGllbnRNZXNzYWdlVG9NbGRldihzZXRDb25maWdQYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZW5kUGxheWJhY2tDb250cm9sKHBsYXliYWNrQ29udHJvbCkge1xuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0gbGl2ZU11c2ljQ2xpZW50TWVzc2FnZVRvTWxkZXYoe1xuICAgICAgICAgICAgcGxheWJhY2tDb250cm9sLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgbXVzaWMgc3RyZWFtLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHBsYXkoKSB7XG4gICAgICAgIHRoaXMuc2VuZFBsYXliYWNrQ29udHJvbChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wuUExBWSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyaWx5IGhhbHQgdGhlIG11c2ljIHN0cmVhbS4gVXNlIGBwbGF5YCB0byByZXN1bWUgZnJvbSB0aGUgY3VycmVudFxuICAgICAqIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlBBVVNFKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgbXVzaWMgc3RyZWFtIGFuZCByZXNldCB0aGUgc3RhdGUuIFJldGFpbnMgdGhlIGN1cnJlbnQgcHJvbXB0c1xuICAgICAqIGFuZCBjb25maWcuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5TVE9QKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBjb250ZXh0IG9mIHRoZSBtdXNpYyBnZW5lcmF0aW9uIHdpdGhvdXQgc3RvcHBpbmcgaXQuXG4gICAgICogUmV0YWlucyB0aGUgY3VycmVudCBwcm9tcHRzIGFuZCBjb25maWcuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgcmVzZXRDb250ZXh0KCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlJFU0VUX0NPTlRFWFQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICBUZXJtaW5hdGVzIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0cyBhbiBoZWFkZXJzIG9iamVjdCB0byBhIFwibWFwXCIgb2JqZWN0IGFzIGV4cGVjdGVkIGJ5IHRoZSBXZWJTb2NrZXRcbi8vIGNvbnN0cnVjdG9yLiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aCBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHNcbi8vIHdoaWxlIHRoZSBXZWJTb2NrZXQgY29uc3RydWN0b3IgdGFrZXMgYSBtYXAuXG5mdW5jdGlvbiBoZWFkZXJzVG9NYXAkMShoZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyTWFwID0ge307XG4gICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlck1hcFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlck1hcDtcbn1cbi8vIENvbnZlcnRzIGEgXCJtYXBcIiBvYmplY3QgdG8gYSBoZWFkZXJzIG9iamVjdC4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGhcbi8vIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0cyB3aGlsZSB0aGUgQVBJIGNsaWVudCBkZWZhdWx0IGhlYWRlcnNcbi8vIHJldHVybnMgYSBtYXAuXG5mdW5jdGlvbiBtYXBUb0hlYWRlcnMkMShtYXApIHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgRlVOQ1RJT05fUkVTUE9OU0VfUkVRVUlSRVNfSUQgPSAnRnVuY3Rpb25SZXNwb25zZSByZXF1ZXN0IG11c3QgaGF2ZSBhbiBgaWRgIGZpZWxkIGZyb20gdGhlIHJlc3BvbnNlIG9mIGEgVG9vbENhbGwuRnVuY3Rpb25hbENhbGxzIGluIEdvb2dsZSBBSS4nO1xuLyoqXG4gKiBIYW5kbGVzIGluY29taW5nIG1lc3NhZ2VzIGZyb20gdGhlIFdlYlNvY2tldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcGFyc2luZyBpbmNvbWluZyBtZXNzYWdlcywgdHJhbnNmb3JtaW5nIHRoZW1cbiAqIGludG8gTGl2ZVNlcnZlck1lc3NhZ2VzLCBhbmQgdGhlbiBjYWxsaW5nIHRoZSBvbm1lc3NhZ2UgY2FsbGJhY2suIE5vdGUgdGhhdFxuICogdGhlIGZpcnN0IG1lc3NhZ2Ugd2hpY2ggaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGlzIGEgc2V0dXBDb21wbGV0ZVxuICogbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gYXBpQ2xpZW50IFRoZSBBcGlDbGllbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0gb25tZXNzYWdlIFRoZSB1c2VyLXByb3ZpZGVkIG9ubWVzc2FnZSBjYWxsYmFjayAoaWYgYW55KS5cbiAqIEBwYXJhbSBldmVudCBUaGUgTWVzc2FnZUV2ZW50IGZyb20gdGhlIFdlYlNvY2tldC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlV2ViU29ja2V0TWVzc2FnZShhcGlDbGllbnQsIG9ubWVzc2FnZSwgZXZlbnQpIHtcbiAgICBjb25zdCBzZXJ2ZXJNZXNzYWdlID0gbmV3IExpdmVTZXJ2ZXJNZXNzYWdlKCk7XG4gICAgbGV0IGpzb25EYXRhO1xuICAgIGlmIChldmVudC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBqc29uRGF0YSA9IGF3YWl0IGV2ZW50LmRhdGEudGV4dCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudC5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAganNvbkRhdGEgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZXZlbnQuZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBqc29uRGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb25EYXRhKTtcbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBjb25zdCByZXNwID0gbGl2ZVNlcnZlck1lc3NhZ2VGcm9tVmVydGV4KGRhdGEpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3ApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbU1sZGV2KGRhdGEpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3ApO1xuICAgIH1cbiAgICBvbm1lc3NhZ2Uoc2VydmVyTWVzc2FnZSk7XG59XG4vKipcbiAgIExpdmUgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBjb25maWd1cmF0aW9uIGZvciBsaXZlIGludGVyYWN0aW9uIHdpdGggdGhlXG4gICBHZW5lcmF0aXZlIExhbmd1YWdlIEFQSS4gSXQgZW1iZWRzIEFwaUNsaWVudCBmb3IgZ2VuZXJhbCBBUEkgc2V0dGluZ3MuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIExpdmUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgYXV0aCwgd2ViU29ja2V0RmFjdG9yeSkge1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5tdXNpYyA9IG5ldyBMaXZlTXVzaWModGhpcy5hcGlDbGllbnQsIHRoaXMuYXV0aCwgdGhpcy53ZWJTb2NrZXRGYWN0b3J5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgbW9kZWwgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgICBjb25maWd1cmF0aW9uIGFuZCByZXR1cm5zIGEgU2Vzc2lvbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoYXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpblxuICAgICAgIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgXG4gICAgICAgQHJlbWFya3NcbiAgXG4gICAgICAgQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uIHRvIHRoZSBtb2RlbC5cbiAgICAgICBAcmV0dXJuIEEgbGl2ZSBzZXNzaW9uLlxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsOiBzdHJpbmc7XG4gICAgICAgaWYgKEdPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUkpIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS0yLjAtZmxhc2gtbGl2ZS1wcmV2aWV3LTA0LTA5JztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLWxpdmUtMi41LWZsYXNoLXByZXZpZXcnO1xuICAgICAgIH1cbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10sXG4gICAgICAgICB9LFxuICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgIG9ub3BlbjogKCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gdGhlIHNvY2tldC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25tZXNzYWdlOiAoZTogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyOiAlc1xcbicsIGRlYnVnKGUuZGF0YSkpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmVycm9yOiAoZTogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvY2N1cnJlZDogJXNcXG4nLCBkZWJ1ZyhlLmVycm9yKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uY2xvc2U6IChlOiBDbG9zZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gY2xvc2VkLicpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgfSxcbiAgICAgICB9KTtcbiAgICAgICBgYGBcbiAgICAgICovXG4gICAgYXN5bmMgY29ubmVjdChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIC8vIFRPRE86IGIvNDA0OTQ2NzQ2IC0gU3VwcG9ydCBwZXIgcmVxdWVzdCBIVFRQIG9wdGlvbnMuXG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmIHBhcmFtcy5jb25maWcuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIExpdmUgbW9kdWxlIGRvZXMgbm90IHN1cHBvcnQgaHR0cE9wdGlvbnMgYXQgcmVxdWVzdC1sZXZlbCBpbicgK1xuICAgICAgICAgICAgICAgICcgTGl2ZUNvbm5lY3RDb25maWcgeWV0LiBQbGVhc2UgdXNlIHRoZSBjbGllbnQtbGV2ZWwgaHR0cE9wdGlvbnMnICtcbiAgICAgICAgICAgICAgICAnIGNvbmZpZ3VyYXRpb24gaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3ZWJzb2NrZXRCYXNlVXJsID0gdGhpcy5hcGlDbGllbnQuZ2V0V2Vic29ja2V0QmFzZVVybCgpO1xuICAgICAgICBjb25zdCBhcGlWZXJzaW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpVmVyc2lvbigpO1xuICAgICAgICBsZXQgdXJsO1xuICAgICAgICBjb25zdCBjbGllbnRIZWFkZXJzID0gdGhpcy5hcGlDbGllbnQuZ2V0SGVhZGVycygpO1xuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJlxuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyAmJlxuICAgICAgICAgICAgaGFzTWNwVG9vbFVzYWdlKHBhcmFtcy5jb25maWcudG9vbHMpKSB7XG4gICAgICAgICAgICBzZXRNY3BVc2FnZUhlYWRlcihjbGllbnRIZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gbWFwVG9IZWFkZXJzKGNsaWVudEhlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuY2xvdWQuYWlwbGF0Zm9ybS4ke2FwaVZlcnNpb259LkxsbUJpZGlTZXJ2aWNlL0JpZGlHZW5lcmF0ZUNvbnRlbnRgO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoLmFkZEF1dGhIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpS2V5KCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gJ0JpZGlHZW5lcmF0ZUNvbnRlbnQnO1xuICAgICAgICAgICAgbGV0IGtleU5hbWUgPSAna2V5JztcbiAgICAgICAgICAgIGlmIChhcGlLZXkgPT09IG51bGwgfHwgYXBpS2V5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcGlLZXkuc3RhcnRzV2l0aCgnYXV0aF90b2tlbnMvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IEVwaGVtZXJhbCB0b2tlbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGFwaVZlcnNpb24gIT09ICd2MWFscGhhJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBUaGUgU0RLJ3MgZXBoZW1lcmFsIHRva2VuIHN1cHBvcnQgaXMgaW4gdjFhbHBoYSBvbmx5LiBQbGVhc2UgdXNlIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6IHRva2VuLm5hbWUsIGh0dHBPcHRpb25zOiB7IGFwaVZlcnNpb246ICd2MWFscGhhJyB9fSk7IGJlZm9yZSBzZXNzaW9uIGNvbm5lY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnQmlkaUdlbmVyYXRlQ29udGVudENvbnN0cmFpbmVkJztcbiAgICAgICAgICAgICAgICBrZXlOYW1lID0gJ2FjY2Vzc190b2tlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuYWkuZ2VuZXJhdGl2ZWxhbmd1YWdlLiR7YXBpVmVyc2lvbn0uR2VuZXJhdGl2ZVNlcnZpY2UuJHttZXRob2R9PyR7a2V5TmFtZX09JHthcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb25vcGVuUmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgY29uc3Qgb25vcGVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHBhcmFtcy5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcyk7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlKHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9ub3Blbjogb25vcGVuQXdhaXRlZENhbGxiYWNrLFxuICAgICAgICAgICAgb25tZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2b2lkIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UoYXBpQ2xpZW50LCBjYWxsYmFja3Mub25tZXNzYWdlLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25lcnJvcjogKF9hID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jbG9zZTogKF9iID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uY2xvc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25uID0gdGhpcy53ZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZSh1cmwsIGhlYWRlcnNUb01hcChoZWFkZXJzKSwgd2Vic29ja2V0Q2FsbGJhY2tzKTtcbiAgICAgICAgY29ubi5jb25uZWN0KCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3ZWJzb2NrZXQgdG8gb3BlbiBiZWZvcmUgc2VuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgYXdhaXQgb25vcGVuUHJvbWlzZTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTW9kZWwgPSB0TW9kZWwodGhpcy5hcGlDbGllbnQsIHBhcmFtcy5tb2RlbCk7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiZcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IHRoaXMuYXBpQ2xpZW50LmdldFByb2plY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwgPVxuICAgICAgICAgICAgICAgIGBwcm9qZWN0cy8ke3Byb2plY3R9L2xvY2F0aW9ucy8ke2xvY2F0aW9ufS9gICsgdHJhbnNmb3JtZWRNb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xpZW50TWVzc2FnZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmXG4gICAgICAgICAgICAoKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc3BvbnNlTW9kYWxpdGllcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2V0IGRlZmF1bHQgdG8gQVVESU8gdG8gYWxpZ24gd2l0aCBNTERldiBBUEkuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZyA9IHsgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnLnJlc3BvbnNlTW9kYWxpdGllcyA9IFtNb2RhbGl0eS5BVURJT107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5nZW5lcmF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICAvLyBSYWlzZSBkZXByZWNhdGlvbiB3YXJuaW5nIGZvciBnZW5lcmF0aW9uQ29uZmlnLlxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdTZXR0aW5nIGBMaXZlQ29ubmVjdENvbmZpZy5nZW5lcmF0aW9uX2NvbmZpZ2AgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHNldCB0aGUgZmllbGRzIG9uIGBMaXZlQ29ubmVjdENvbmZpZ2AgZGlyZWN0bHkuIFRoaXMgd2lsbCBiZWNvbWUgYW4gZXJyb3IgaW4gYSBmdXR1cmUgdmVyc2lvbiAobm90IGJlZm9yZSBRMyAyMDI1KS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFRvb2xzID0gKF9mID0gKF9lID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRvb2xzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBbXTtcbiAgICAgICAgY29uc3QgY29udmVydGVkVG9vbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIGlucHV0VG9vbHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRUb29scy5wdXNoKGF3YWl0IGNhbGxhYmxlVG9vbC50b29sKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udmVydGVkVG9vbHMucHVzaCh0b29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udmVydGVkVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyA9IGNvbnZlcnRlZFRvb2xzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpdmVDb25uZWN0UGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIG1vZGVsOiB0cmFuc2Zvcm1lZE1vZGVsLFxuICAgICAgICAgICAgY29uZmlnOiBwYXJhbXMuY29uZmlnLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBwYXJhbXMuY2FsbGJhY2tzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIGxpdmVDb25uZWN0UGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgY2xpZW50TWVzc2FnZVsnY29uZmlnJ107XG4gICAgICAgIGNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBuZXcgU2Vzc2lvbihjb25uLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxuICAgIC8vIFRPRE86IGIvNDE2MDQxMjI5IC0gQWJzdHJhY3QgdGhpcyBtZXRob2QgdG8gYSBjb21tb24gcGxhY2UuXG4gICAgaXNDYWxsYWJsZVRvb2wodG9vbCkge1xuICAgICAgICByZXR1cm4gJ2NhbGxUb29sJyBpbiB0b29sICYmIHR5cGVvZiB0b29sLmNhbGxUb29sID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyA9IHtcbiAgICB0dXJuQ29tcGxldGU6IHRydWUsXG59O1xuLyoqXG4gICBSZXByZXNlbnRzIGEgY29ubmVjdGlvbiB0byB0aGUgQVBJLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIHRMaXZlQ2xpZW50Q29udGVudChhcGlDbGllbnQsIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnR1cm5zICE9PSBudWxsICYmIHBhcmFtcy50dXJucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgY29udGVudHMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgPSB0Q29udGVudHMocGFyYW1zLnR1cm5zKTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLm1hcCgoaXRlbSkgPT4gY29udGVudFRvVmVydGV4KGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMubWFwKChpdGVtKSA9PiBjb250ZW50VG9NbGRldiQxKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBjbGllbnQgY29udGVudCBcInR1cm5zXCIsIHR5cGU6ICcke3R5cGVvZiBwYXJhbXMudHVybnN9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjbGllbnRDb250ZW50OiB7IHR1cm5zOiBjb250ZW50cywgdHVybkNvbXBsZXRlOiBwYXJhbXMudHVybkNvbXBsZXRlIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRDb250ZW50OiB7IHR1cm5Db21wbGV0ZTogcGFyYW1zLnR1cm5Db21wbGV0ZSB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0TGl2ZUNsaWVudHRUb29sUmVzcG9uc2UoYXBpQ2xpZW50LCBwYXJhbXMpIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2VzID0gW107XG4gICAgICAgIGlmIChwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvblJlc3BvbnNlcyBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzKSkge1xuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZXMgPSBbcGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VzID0gcGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jdGlvblJlc3BvbnNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb25SZXNwb25zZXMgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmdW5jdGlvblJlc3BvbnNlIG9mIGZ1bmN0aW9uUmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICEoJ25hbWUnIGluIGZ1bmN0aW9uUmVzcG9uc2UpIHx8XG4gICAgICAgICAgICAgICAgISgncmVzcG9uc2UnIGluIGZ1bmN0aW9uUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgZnVuY3Rpb24gcmVzcG9uc2UsIHR5cGUgJyR7dHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2V9Jy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXBpQ2xpZW50LmlzVmVydGV4QUkoKSAmJiAhKCdpZCcgaW4gZnVuY3Rpb25SZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRlVOQ1RJT05fUkVTUE9OU0VfUkVRVUlSRVNfSUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0b29sUmVzcG9uc2U6IHsgZnVuY3Rpb25SZXNwb25zZXM6IGZ1bmN0aW9uUmVzcG9uc2VzIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGllbnRNZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNlbmQgYSBtZXNzYWdlIG92ZXIgdGhlIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24uXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIHR3byAqKm9wdGlvbmFsKiogcHJvcGVydGllcywgYHR1cm5zYCBhbmRcbiAgICAgICAgICBgdHVybkNvbXBsZXRlYC5cbiAgXG4gICAgICAgIC0gYHR1cm5zYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBDb250ZW50W11gXG4gICAgICAgIC0gYHR1cm5Db21wbGV0ZTogdHJ1ZWAgW2RlZmF1bHRdIGluZGljYXRlcyB0aGF0IHlvdSBhcmUgZG9uZSBzZW5kaW5nXG4gICAgICAgICAgY29udGVudCBhbmQgZXhwZWN0IGEgcmVzcG9uc2UuIElmIGB0dXJuQ29tcGxldGU6IGZhbHNlYCwgdGhlIHNlcnZlclxuICAgICAgICAgIHdpbGwgd2FpdCBmb3IgYWRkaXRpb25hbCBtZXNzYWdlcyBiZWZvcmUgc3RhcnRpbmcgZ2VuZXJhdGlvbi5cbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgQHJlbWFya3NcbiAgICAgIFRoZXJlIGFyZSB0d28gd2F5cyB0byBzZW5kIG1lc3NhZ2VzIHRvIHRoZSBsaXZlIEFQSTpcbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudGAgYW5kIGBzZW5kUmVhbHRpbWVJbnB1dGAuXG4gIFxuICAgICAgYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlcyBhcmUgYWRkZWQgdG8gdGhlIG1vZGVsIGNvbnRleHQgKippbiBvcmRlcioqLlxuICAgICAgSGF2aW5nIGEgY29udmVyc2F0aW9uIHVzaW5nIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZXMgaXMgcm91Z2hseVxuICAgICAgZXF1aXZhbGVudCB0byB1c2luZyB0aGUgYENoYXQuc2VuZE1lc3NhZ2VTdHJlYW1gLCBleGNlcHQgdGhhdCB0aGUgc3RhdGUgb2ZcbiAgICAgIHRoZSBgY2hhdGAgaGlzdG9yeSBpcyBzdG9yZWQgb24gdGhlIEFQSSBzZXJ2ZXIgaW5zdGVhZCBvZiBsb2NhbGx5LlxuICBcbiAgICAgIEJlY2F1c2Ugb2YgYHNlbmRDbGllbnRDb250ZW50YCdzIG9yZGVyIGd1YXJhbnRlZSwgdGhlIG1vZGVsIGNhbm5vdCByZXNwb25zXG4gICAgICBhcyBxdWlja2x5IHRvIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZXMgYXMgdG8gYHNlbmRSZWFsdGltZUlucHV0YFxuICAgICAgbWVzc2FnZXMuIFRoaXMgbWFrZXMgdGhlIGJpZ2dlc3QgZGlmZmVyZW5jZSB3aGVuIHNlbmRpbmcgb2JqZWN0cyB0aGF0IGhhdmVcbiAgICAgIHNpZ25pZmljYW50IHByZXByb2Nlc3NpbmcgdGltZSAodHlwaWNhbGx5IGltYWdlcykuXG4gIFxuICAgICAgVGhlIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZSBzZW5kcyBhIGBDb250ZW50W11gXG4gICAgICB3aGljaCBoYXMgbW9yZSBvcHRpb25zIHRoYW4gdGhlIGBCbG9iYCBzZW50IGJ5IGBzZW5kUmVhbHRpbWVJbnB1dGAuXG4gIFxuICAgICAgU28gdGhlIG1haW4gdXNlLWNhc2VzIGZvciBgc2VuZENsaWVudENvbnRlbnRgIG92ZXIgYHNlbmRSZWFsdGltZUlucHV0YCBhcmU6XG4gIFxuICAgICAgLSBTZW5kaW5nIGFueXRoaW5nIHRoYXQgY2FuJ3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBgQmxvYmAgKHRleHQsXG4gICAgICBgc2VuZENsaWVudENvbnRlbnQoe3R1cm5zPVwiSGVsbG8/XCJ9YCkpLlxuICAgICAgLSBNYW5hZ2luZyB0dXJucyB3aGVuIG5vdCB1c2luZyBhdWRpbyBpbnB1dCBhbmQgdm9pY2UgYWN0aXZpdHkgZGV0ZWN0aW9uLlxuICAgICAgICAoYHNlbmRDbGllbnRDb250ZW50KHt0dXJuQ29tcGxldGU6dHJ1ZX0pYCBvciB0aGUgc2hvcnQgZm9ybVxuICAgICAgYHNlbmRDbGllbnRDb250ZW50KClgKVxuICAgICAgLSBQcmVmaWxsaW5nIGEgY29udmVyc2F0aW9uIGNvbnRleHRcbiAgICAgICAgYGBgXG4gICAgICAgIHNlbmRDbGllbnRDb250ZW50KHtcbiAgICAgICAgICAgIHR1cm5zOiBbXG4gICAgICAgICAgICAgIENvbnRlbnQoe3JvbGU6dXNlciwgcGFydHM6Li4ufSksXG4gICAgICAgICAgICAgIENvbnRlbnQoe3JvbGU6dXNlciwgcGFydHM6Li4ufSksXG4gICAgICAgICAgICAgIC4uLlxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgICBgYGBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBzZW5kQ2xpZW50Q29udGVudChwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0TGl2ZVNlbmRDbGllbnRDb250ZW50UGFyYW1lcnRlcnMpLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0gdGhpcy50TGl2ZUNsaWVudENvbnRlbnQodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZW5kIGEgcmVhbHRpbWUgbWVzc2FnZSBvdmVyIHRoZSBlc3RhYmxpc2hlZCBjb25uZWN0aW9uLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBvbmUgcHJvcGVydHksIGBtZWRpYWAuXG4gIFxuICAgICAgICAtIGBtZWRpYWAgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgQmxvYmBcbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgQHJlbWFya3NcbiAgICAgIFVzZSBgc2VuZFJlYWx0aW1lSW5wdXRgIGZvciByZWFsdGltZSBhdWRpbyBjaHVua3MgYW5kIHZpZGVvIGZyYW1lcyAoaW1hZ2VzKS5cbiAgXG4gICAgICBXaXRoIGBzZW5kUmVhbHRpbWVJbnB1dGAgdGhlIGFwaSB3aWxsIHJlc3BvbmQgdG8gYXVkaW8gYXV0b21hdGljYWxseVxuICAgICAgYmFzZWQgb24gdm9pY2UgYWN0aXZpdHkgZGV0ZWN0aW9uIChWQUQpLlxuICBcbiAgICAgIGBzZW5kUmVhbHRpbWVJbnB1dGAgaXMgb3B0aW1pemVkIGZvciByZXNwb25zaXZuZXNzIGF0IHRoZSBleHBlbnNlIG9mXG4gICAgICBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIGd1YXJhbnRlZXMuIEF1ZGlvIGFuZCB2aWRlbyB0b2tlbnMgYXJlIHRvIHRoZVxuICAgICAgY29udGV4dCB3aGVuIHRoZXkgYmVjb21lIGF2YWlsYWJsZS5cbiAgXG4gICAgICBOb3RlOiBUaGUgQ2FsbCBzaWduYXR1cmUgZXhwZWN0cyBhIGBCbG9iYCBvYmplY3QsIGJ1dCBvbmx5IGEgc3Vic2V0XG4gICAgICBvZiBhdWRpbyBhbmQgaW1hZ2UgbWltZXR5cGVzIGFyZSBhbGxvd2VkLlxuICAgICAqL1xuICAgIHNlbmRSZWFsdGltZUlucHV0KHBhcmFtcykge1xuICAgICAgICBsZXQgY2xpZW50TWVzc2FnZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICdyZWFsdGltZUlucHV0JzogbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xpZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAncmVhbHRpbWVJbnB1dCc6IGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZW5kIGEgZnVuY3Rpb24gcmVzcG9uc2UgbWVzc2FnZSBvdmVyIHRoZSBlc3RhYmxpc2hlZCBjb25uZWN0aW9uLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBwcm9wZXJ0eSBgZnVuY3Rpb25SZXNwb25zZXNgLlxuICBcbiAgICAgICAgLSBgZnVuY3Rpb25SZXNwb25zZXNgIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYGZ1bmN0aW9uUmVzcG9uc2VzW11gXG4gIFxuICAgICAgQHJlbWFya3NcbiAgICAgIFVzZSBgc2VuZEZ1bmN0aW9uUmVzcG9uc2VgIHRvIHJlcGx5IHRvIGBMaXZlU2VydmVyVG9vbENhbGxgIGZyb20gdGhlIHNlcnZlci5cbiAgXG4gICAgICBVc2Uge0BsaW5rIHR5cGVzLkxpdmVDb25uZWN0Q29uZmlnI3Rvb2xzfSB0byBjb25maWd1cmUgdGhlIGNhbGxhYmxlIGZ1bmN0aW9ucy5cbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgc2VuZFRvb2xSZXNwb25zZShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rvb2wgcmVzcG9uc2UgcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHRoaXMudExpdmVDbGllbnR0VG9vbFJlc3BvbnNlKHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgIFRlcm1pbmF0ZXMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICBcbiAgICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgIEBleGFtcGxlXG4gICAgICAgYGBgdHNcbiAgICAgICBsZXQgbW9kZWw6IHN0cmluZztcbiAgICAgICBpZiAoR09PR0xFX0dFTkFJX1VTRV9WRVJURVhBSSkge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLTIuMC1mbGFzaC1saXZlLXByZXZpZXctMDQtMDknO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICBtb2RlbCA9ICdnZW1pbmktbGl2ZS0yLjUtZmxhc2gtcHJldmlldyc7XG4gICAgICAgfVxuICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBhaS5saXZlLmNvbm5lY3Qoe1xuICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgIHJlc3BvbnNlTW9kYWxpdGllczogW01vZGFsaXR5LkFVRElPXSxcbiAgICAgICAgIH1cbiAgICAgICB9KTtcbiAgXG4gICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgIGBgYFxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0cyBhbiBoZWFkZXJzIG9iamVjdCB0byBhIFwibWFwXCIgb2JqZWN0IGFzIGV4cGVjdGVkIGJ5IHRoZSBXZWJTb2NrZXRcbi8vIGNvbnN0cnVjdG9yLiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aCBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHNcbi8vIHdoaWxlIHRoZSBXZWJTb2NrZXQgY29uc3RydWN0b3IgdGFrZXMgYSBtYXAuXG5mdW5jdGlvbiBoZWFkZXJzVG9NYXAoaGVhZGVycykge1xuICAgIGNvbnN0IGhlYWRlck1hcCA9IHt9O1xuICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoZWFkZXJNYXBba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJNYXA7XG59XG4vLyBDb252ZXJ0cyBhIFwibWFwXCIgb2JqZWN0IHRvIGEgaGVhZGVycyBvYmplY3QuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoXG4vLyBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHMgd2hpbGUgdGhlIEFQSSBjbGllbnQgZGVmYXVsdCBoZWFkZXJzXG4vLyByZXR1cm5zIGEgbWFwLlxuZnVuY3Rpb24gbWFwVG9IZWFkZXJzKG1hcCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1hcCkpIHtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFMgPSAxMDtcbi8qKiBSZXR1cm5zIHdoZXRoZXIgYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgaXMgZGlzYWJsZWQuICovXG5mdW5jdGlvbiBzaG91bGREaXNhYmxlQWZjKGNvbmZpZykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmICgoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzYWJsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGNhbGxhYmxlVG9vbHNQcmVzZW50ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB0b29sIG9mIChfYiA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy50b29scykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICBjYWxsYWJsZVRvb2xzUHJlc2VudCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNhbGxhYmxlVG9vbHNQcmVzZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBtYXhDYWxscyA9IChfYyA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXhpbXVtUmVtb3RlQ2FsbHM7XG4gICAgaWYgKChtYXhDYWxscyAmJiAobWF4Q2FsbHMgPCAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG1heENhbGxzKSkpIHx8XG4gICAgICAgIG1heENhbGxzID09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIG1heGltdW1SZW1vdGVDYWxscyB2YWx1ZSBwcm92aWRlZCBmb3IgYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcuIERpc2FibGVkIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nLiBQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIGludGVnZXIgdmFsdWUgZ3JlYXRlciB0aGFuIDAuIG1heGltdW1SZW1vdGVDYWxscyBwcm92aWRlZDonLCBtYXhDYWxscyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0NhbGxhYmxlVG9vbCh0b29sKSB7XG4gICAgcmV0dXJuICdjYWxsVG9vbCcgaW4gdG9vbCAmJiB0eXBlb2YgdG9vbC5jYWxsVG9vbCA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8vIENoZWNrcyB3aGV0aGVyIHRoZSBsaXN0IG9mIHRvb2xzIGNvbnRhaW5zIGFueSBDYWxsYWJsZVRvb2xzLiBXaWxsIHJldHVybiB0cnVlXG4vLyBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgQ2FsbGFibGVUb29sLlxuZnVuY3Rpb24gaGFzQ2FsbGFibGVUb29scyhwYXJhbXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc29tZSgodG9vbCkgPT4gaXNDYWxsYWJsZVRvb2wodG9vbCkpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZTtcbn1cbi8vIENoZWNrcyB3aGV0aGVyIHRoZSBsaXN0IG9mIHRvb2xzIGNvbnRhaW5zIGFueSBub24tY2FsbGFibGUgdG9vbHMuIFdpbGwgcmV0dXJuXG4vLyB0cnVlIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBub24tQ2FsbGFibGUgdG9vbC5cbmZ1bmN0aW9uIGhhc05vbkNhbGxhYmxlVG9vbHMocGFyYW1zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNvbWUoKHRvb2wpID0+ICFpc0NhbGxhYmxlVG9vbCh0b29sKSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdG8gYXBwZW5kIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIGhpc3RvcnkgdG8gdGhlXG4gKiByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkQXBwZW5kQWZjSGlzdG9yeShjb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlnbm9yZUNhbGxIaXN0b3J5KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTW9kZWxzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYW4gQVBJIHJlcXVlc3QgdG8gZ2VuZXJhdGUgY29udGVudCB3aXRoIGEgZ2l2ZW4gbW9kZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBWZXJ0ZXggQUkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBmdWxsIHJlc291cmNlIG5hbWUgc3RhcnRzIHdpdGggJ3Byb2plY3RzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3Byb2plY3RzL215LXByb2plY3QtaWQvbG9jYXRpb25zL3VzLWNlbnRyYWwxL3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBwYXJ0aWFsIHJlc291cmNlIG5hbWUgd2l0aCAncHVibGlzaGVycy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCcgb3JcbiAgICAgICAgICogICdwdWJsaXNoZXJzL21ldGEvbW9kZWxzL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqIC0gYC9gIHNlcGFyYXRlZCBwdWJsaXNoZXIgYW5kIG1vZGVsIG5hbWUsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAnZ29vZ2xlL2dlbWluaS0yLjAtZmxhc2gnIG9yICdtZXRhL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBHZW1pbmkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICdtb2RlbHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAnbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gRm9yIHR1bmVkIG1vZGVscywgdGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ3R1bmVkTW9kZWxzLycsXG4gICAgICAgICAqIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAndHVuZWRNb2RlbHMvMTIzNDU2Nzg5MDEyMzQ1Njc4OSdcbiAgICAgICAgICpcbiAgICAgICAgICogU29tZSBtb2RlbHMgc3VwcG9ydCBtdWx0aW1vZGFsIGlucHV0IGFuZCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIGdlbmVyYXRpbmcgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAgICAgKiAgIGNvbnRlbnRzOiAnd2h5IGlzIHRoZSBza3kgYmx1ZT8nLFxuICAgICAgICAgKiAgIGNvbmZpZzoge1xuICAgICAgICAgKiAgICAgY2FuZGlkYXRlQ291bnQ6IDIsXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDb250ZW50ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgdGhpcy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5tYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoIWhhc0NhbGxhYmxlVG9vbHMocGFyYW1zKSB8fCBzaG91bGREaXNhYmxlQWZjKHBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc05vbkNhbGxhYmxlVG9vbHMocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgd2l0aCBDYWxsYWJsZVRvb2xzIGFuZCBUb29scyBpcyBub3QgeWV0IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlQ29udGVudDtcbiAgICAgICAgICAgIGNvbnN0IGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkgPSB0Q29udGVudHModHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMpO1xuICAgICAgICAgICAgY29uc3QgbWF4UmVtb3RlQ2FsbHMgPSAoX2MgPSAoX2IgPSAoX2EgPSB0cmFuc2Zvcm1lZFBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhpbXVtUmVtb3RlQ2FsbHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IERFRkFVTFRfTUFYX1JFTU9URV9DQUxMUztcbiAgICAgICAgICAgIGxldCByZW1vdGVDYWxscyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocmVtb3RlQ2FsbHMgPCBtYXhSZW1vdGVDYWxscykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUNvbnRlbnRJbnRlcm5hbCh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5mdW5jdGlvbkNhbGxzIHx8IHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZUNvbnRlbnQgPSByZXNwb25zZS5jYW5kaWRhdGVzWzBdLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25SZXNwb25zZVBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIChfZSA9IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50b29scykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsYWJsZVRvb2wgPSB0b29sO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBhd2FpdCBjYWxsYWJsZVRvb2wuY2FsbFRvb2wocmVzcG9uc2UuZnVuY3Rpb25DYWxscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlUGFydHMucHVzaCguLi5wYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVtb3RlQ2FsbHMrKztcbiAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlQ29udGVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0czogZnVuY3Rpb25SZXNwb25zZVBhcnRzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMgPSB0Q29udGVudHModHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzLnB1c2gocmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cy5wdXNoKGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQXBwZW5kQWZjSGlzdG9yeSh0cmFuc2Zvcm1lZFBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkucHVzaChyZXNwb25zZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5LnB1c2goZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRBcHBlbmRBZmNIaXN0b3J5KHRyYW5zZm9ybWVkUGFyYW1zLmNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2VzIGFuIEFQSSByZXF1ZXN0IHRvIGdlbmVyYXRlIGNvbnRlbnQgd2l0aCBhIGdpdmVuIG1vZGVsIGFuZCB5aWVsZHMgdGhlXG4gICAgICAgICAqIHJlc3BvbnNlIGluIGNodW5rcy5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBgbW9kZWxgIHBhcmFtZXRlciwgc3VwcG9ydGVkIGZvcm1hdHMgZm9yIFZlcnRleCBBSSBBUEkgaW5jbHVkZTpcbiAgICAgICAgICogLSBUaGUgR2VtaW5pIG1vZGVsIElELCBmb3IgZXhhbXBsZTogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIGZ1bGwgcmVzb3VyY2UgbmFtZSBzdGFydHMgd2l0aCAncHJvamVjdHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAncHJvamVjdHMvbXktcHJvamVjdC1pZC9sb2NhdGlvbnMvdXMtY2VudHJhbDEvcHVibGlzaGVycy9nb29nbGUvbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIHBhcnRpYWwgcmVzb3VyY2UgbmFtZSB3aXRoICdwdWJsaXNoZXJzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJyBvclxuICAgICAgICAgKiAgJ3B1Ymxpc2hlcnMvbWV0YS9tb2RlbHMvbGxhbWEtMy4xLTQwNWItaW5zdHJ1Y3QtbWFhcydcbiAgICAgICAgICogLSBgL2Agc2VwYXJhdGVkIHB1Ymxpc2hlciBhbmQgbW9kZWwgbmFtZSwgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICdnb29nbGUvZ2VtaW5pLTIuMC1mbGFzaCcgb3IgJ21ldGEvbGxhbWEtMy4xLTQwNWItaW5zdHJ1Y3QtbWFhcydcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBgbW9kZWxgIHBhcmFtZXRlciwgc3VwcG9ydGVkIGZvcm1hdHMgZm9yIEdlbWluaSBBUEkgaW5jbHVkZTpcbiAgICAgICAgICogLSBUaGUgR2VtaW5pIG1vZGVsIElELCBmb3IgZXhhbXBsZTogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ21vZGVscy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdtb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBGb3IgdHVuZWQgbW9kZWxzLCB0aGUgbW9kZWwgbmFtZSBzdGFydHMgd2l0aCAndHVuZWRNb2RlbHMvJyxcbiAgICAgICAgICogZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAndHVuZWRNb2RlbHMvMTIzNDU2Nzg5MDEyMzQ1Njc4OSdcbiAgICAgICAgICpcbiAgICAgICAgICogU29tZSBtb2RlbHMgc3VwcG9ydCBtdWx0aW1vZGFsIGlucHV0IGFuZCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBjb250ZW50IHdpdGggc3RyZWFtaW5nIHJlc3BvbnNlLlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIGdlbmVyYXRpbmcgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50U3RyZWFtKHtcbiAgICAgICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAgICAgKiAgIGNvbnRlbnRzOiAnd2h5IGlzIHRoZSBza3kgYmx1ZT8nLFxuICAgICAgICAgKiAgIGNvbmZpZzoge1xuICAgICAgICAgKiAgICAgbWF4T3V0cHV0VG9rZW5zOiAyMDAsXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZSkge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGNodW5rKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDb250ZW50U3RyZWFtID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRGlzYWJsZUFmYyhwYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgdGhpcy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb2Nlc3NBZmNTdHJlYW0ocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyBhbiBpbWFnZSBiYXNlZCBvbiBhIHRleHQgZGVzY3JpcHRpb24gYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBpbWFnZXMuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLmdlbmVyYXRlSW1hZ2VzKHtcbiAgICAgICAgICogIG1vZGVsOiAnaW1hZ2VuLTMuMC1nZW5lcmF0ZS0wMDInLFxuICAgICAgICAgKiAgcHJvbXB0OiAnUm9ib3QgaG9sZGluZyBhIHJlZCBza2F0ZWJvYXJkJyxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlSW1hZ2VzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbChwYXJhbXMpLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkSW1hZ2VzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGFwaVJlc3BvbnNlID09PSBudWxsIHx8IGFwaVJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0ZWRJbWFnZSBvZiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRJbWFnZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnZW5lcmF0ZWRJbWFnZSA9PT0gbnVsbCB8fCBnZW5lcmF0ZWRJbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJhdGVkSW1hZ2Uuc2FmZXR5QXR0cmlidXRlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9hID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50VHlwZSkgPT09ICdQb3NpdGl2ZSBQcm9tcHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXMucHVzaChnZW5lcmF0ZWRJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXM6IGdlbmVyYXRlZEltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlczogcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrSHR0cFJlc3BvbnNlOiBhcGlSZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZEltYWdlczogZ2VuZXJhdGVkSW1hZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrSHR0cFJlc3BvbnNlOiBhcGlSZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5QmFzZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25maWcpLCBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb25maWc6IGFjdHVhbENvbmZpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3R1YWxQYXJhbXMuY29uZmlnLnF1ZXJ5QmFzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gYWN0dWFsUGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWx0ZXJpbmcgdHVuZWQgbW9kZWxzIGxpc3QgZm9yIFZlcnRleCBBSSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsUGFyYW1zLmNvbmZpZy5maWx0ZXIgPSAnbGFiZWxzLnR1bmUtdHlwZToqJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fTU9ERUxTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKGFjdHVhbFBhcmFtcyksIGFjdHVhbFBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZGl0cyBhbiBpbWFnZSBiYXNlZCBvbiBhIHByb21wdCwgbGlzdCBvZiByZWZlcmVuY2UgaW1hZ2VzLCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlZGl0aW5nIGFuIGltYWdlLlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50Lm1vZGVscy5lZGl0SW1hZ2Uoe1xuICAgICAgICAgKiAgbW9kZWw6ICdpbWFnZW4tMy4wLWNhcGFiaWxpdHktMDAxJyxcbiAgICAgICAgICogIHByb21wdDogJ0dlbmVyYXRlIGFuIGltYWdlIGNvbnRhaW5pbmcgYSBtdWcgd2l0aCB0aGUgcHJvZHVjdCBsb2dvIFsxXSB2aXNpYmxlIG9uIHRoZSBzaWRlIG9mIHRoZSBtdWcuJyxcbiAgICAgICAgICogIHJlZmVyZW5jZUltYWdlczogW3N1YmplY3RSZWZlcmVuY2VJbWFnZV1cbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXRJbWFnZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtc0ludGVybmFsID0ge1xuICAgICAgICAgICAgICAgIG1vZGVsOiBwYXJhbXMubW9kZWwsXG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwYXJhbXMucHJvbXB0LFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlczogW10sXG4gICAgICAgICAgICAgICAgY29uZmlnOiBwYXJhbXMuY29uZmlnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMucmVmZXJlbmNlSW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5yZWZlcmVuY2VJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zSW50ZXJuYWwucmVmZXJlbmNlSW1hZ2VzID0gcGFyYW1zLnJlZmVyZW5jZUltYWdlcy5tYXAoKGltZykgPT4gaW1nLnRvUmVmZXJlbmNlSW1hZ2VBUEkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZWRpdEltYWdlSW50ZXJuYWwocGFyYW1zSW50ZXJuYWwpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBzY2FsZXMgYW4gaW1hZ2UgYmFzZWQgb24gYW4gaW1hZ2UsIHVwc2NhbGUgZmFjdG9yLCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogT25seSBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJIGN1cnJlbnRseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB1cHNjYWxpbmcgYW4gaW1hZ2UuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLnVwc2NhbGVJbWFnZSh7XG4gICAgICAgICAqICBtb2RlbDogJ2ltYWdlbi0zLjAtZ2VuZXJhdGUtMDAyJyxcbiAgICAgICAgICogIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICogIHVwc2NhbGVGYWN0b3I6ICd4MicsXG4gICAgICAgICAqICBjb25maWc6IHtcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwc2NhbGVJbWFnZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGxldCBhcGlDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICAgICAgICAgICAgbW9kZTogJ3Vwc2NhbGUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgYXBpQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhcGlDb25maWcpLCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgICAgICAgICAgIGltYWdlOiBwYXJhbXMuaW1hZ2UsXG4gICAgICAgICAgICAgICAgdXBzY2FsZUZhY3RvcjogcGFyYW1zLnVwc2NhbGVGYWN0b3IsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBhcGlDb25maWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudXBzY2FsZUltYWdlSW50ZXJuYWwoYXBpUGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBHZW5lcmF0ZXMgdmlkZW9zIGJhc2VkIG9uIGEgdGV4dCBkZXNjcmlwdGlvbiBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIHZpZGVvcy5cbiAgICAgICAgICogQHJldHVybiBBIFByb21pc2U8R2VuZXJhdGVWaWRlb3NPcGVyYXRpb24+IHdoaWNoIGFsbG93cyB5b3UgdG8gdHJhY2sgdGhlIHByb2dyZXNzIGFuZCBldmVudHVhbGx5IHJldHJpZXZlIHRoZSBnZW5lcmF0ZWQgdmlkZW9zIHVzaW5nIHRoZSBvcGVyYXRpb25zLmdldCBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZVZpZGVvcyh7XG4gICAgICAgICAqICBtb2RlbDogJ3Zlby0yLjAtZ2VuZXJhdGUtMDAxJyxcbiAgICAgICAgICogIHByb21wdDogJ0EgbmVvbiBob2xvZ3JhbSBvZiBhIGNhdCBkcml2aW5nIGF0IHRvcCBzcGVlZCcsXG4gICAgICAgICAqICBjb25maWc6IHtcbiAgICAgICAgICogICAgbnVtYmVyT2ZWaWRlb3M6IDFcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHdoaWxlICghb3BlcmF0aW9uLmRvbmUpIHtcbiAgICAgICAgICogICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMDApKTtcbiAgICAgICAgICogICBvcGVyYXRpb24gPSBhd2FpdCBhaS5vcGVyYXRpb25zLmdldFZpZGVvc09wZXJhdGlvbih7b3BlcmF0aW9uOiBvcGVyYXRpb259KTtcbiAgICAgICAgICogfVxuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyhvcGVyYXRpb24ucmVzcG9uc2U/LmdlbmVyYXRlZFZpZGVvcz8uWzBdPy52aWRlbz8udXJpKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlVmlkZW9zID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVWaWRlb3NJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGxvZ2ljIGlzIG5lZWRlZCBmb3IgR2VuZXJhdGVDb250ZW50Q29uZmlnIG9ubHkuXG4gICAgICogUHJldmlvdXNseSB3ZSBtYWRlIEdlbmVyYXRlQ29udGVudENvbmZpZy5yZXNwb25zZVNjaGVtYSBmaWVsZCB0byBhY2NlcHRcbiAgICAgKiB1bmtub3duLiBTaW5jZSB2MS45LjAsIHdlIHN3aXRjaCB0byB1c2UgYmFja2VuZCBKU09OIHNjaGVtYSBzdXBwb3J0LlxuICAgICAqIFRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHdlIG1vdmUgdGhlIGRhdGEgdGhhdCB3YXMgdHJlYXRlZCBhc1xuICAgICAqIEpTT04gc2NoZW1hIGZyb20gdGhlIHJlc3BvbnNlU2NoZW1hIGZpZWxkIHRvIHRoZSByZXNwb25zZUpzb25TY2hlbWEgZmllbGQuXG4gICAgICovXG4gICAgbWF5YmVNb3ZlVG9SZXNwb25zZUpzb25TY2hlbShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5jb25maWcgJiYgcGFyYW1zLmNvbmZpZy5yZXNwb25zZVNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKCFwYXJhbXMuY29uZmlnLnJlc3BvbnNlSnNvblNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMuY29uZmlnLnJlc3BvbnNlU2NoZW1hKS5pbmNsdWRlcygnJHNjaGVtYScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jb25maWcucmVzcG9uc2VKc29uU2NoZW1hID0gcGFyYW1zLmNvbmZpZy5yZXNwb25zZVNjaGVtYTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgQ2FsbGFibGVUb29scyBpbiB0aGUgcGFyYW1ldGVycyB0byBiZSBzaW1wbHkgVG9vbHMsIGl0XG4gICAgICogY29waWVzIHRoZSBwYXJhbXMgaW50byBhIG5ldyBvYmplY3QgYW5kIHJlcGxhY2VzIHRoZSB0b29scywgaXQgZG9lcyBub3RcbiAgICAgKiBtb2RpZnkgdGhlIG9yaWdpbmFsIHBhcmFtcy4gQWxzbyBzZXRzIHRoZSBNQ1AgdXNhZ2UgaGVhZGVyIGlmIHRoZXJlIGFyZVxuICAgICAqIE1DUCB0b29scyBpbiB0aGUgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHRvb2xzID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzO1xuICAgICAgICBpZiAoIXRvb2xzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVG9vbHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0b29scy5tYXAoYXN5bmMgKHRvb2wpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxhYmxlVG9vbCA9IHRvb2w7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNhbGxhYmxlVG9vbC50b29sKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9vbDtcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSB7XG4gICAgICAgICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgICAgICAgY29udGVudHM6IHBhcmFtcy5jb250ZW50cyxcbiAgICAgICAgICAgIGNvbmZpZzogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMuY29uZmlnKSwgeyB0b29sczogdHJhbnNmb3JtZWRUb29scyB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgbmV3UGFyYW1zLmNvbmZpZy50b29scyA9IHRyYW5zZm9ybWVkVG9vbHM7XG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmXG4gICAgICAgICAgICBwYXJhbXMuY29uZmlnLnRvb2xzICYmXG4gICAgICAgICAgICBoYXNNY3BUb29sVXNhZ2UocGFyYW1zLmNvbmZpZy50b29scykpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSAoX2MgPSAoX2IgPSBwYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVhZGVycykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge307XG4gICAgICAgICAgICBsZXQgbmV3SGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld0hlYWRlcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5ld0hlYWRlcnMgPSB0aGlzLmFwaUNsaWVudC5nZXREZWZhdWx0SGVhZGVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TWNwVXNhZ2VIZWFkZXIobmV3SGVhZGVycyk7XG4gICAgICAgICAgICBuZXdQYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMuY29uZmlnLmh0dHBPcHRpb25zKSwgeyBoZWFkZXJzOiBuZXdIZWFkZXJzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgfVxuICAgIGFzeW5jIGluaXRBZmNUb29sc01hcChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGFmY1Rvb2xzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgKF9iID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sRGVjbGFyYXRpb24gPSBhd2FpdCBjYWxsYWJsZVRvb2wudG9vbCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgKF9jID0gdG9vbERlY2xhcmF0aW9uLmZ1bmN0aW9uRGVjbGFyYXRpb25zKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlY2xhcmF0aW9uLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gZGVjbGFyYXRpb24gbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWZjVG9vbHMuaGFzKGRlY2xhcmF0aW9uLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSB0b29sIGRlY2xhcmF0aW9uIG5hbWU6ICR7ZGVjbGFyYXRpb24ubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZmNUb29scy5zZXQoZGVjbGFyYXRpb24ubmFtZSwgY2FsbGFibGVUb29sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFmY1Rvb2xzO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzQWZjU3RyZWFtKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWF4UmVtb3RlQ2FsbHMgPSAoX2MgPSAoX2IgPSAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWF4aW11bVJlbW90ZUNhbGxzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFM7XG4gICAgICAgIGxldCB3ZXJlRnVuY3Rpb25zQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgIGxldCByZW1vdGVDYWxsQ291bnQgPSAwO1xuICAgICAgICBjb25zdCBhZmNUb29sc01hcCA9IGF3YWl0IHRoaXMuaW5pdEFmY1Rvb2xzTWFwKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKG1vZGVscywgYWZjVG9vbHMsIHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2MsIGVfMSwgX2QsIF9lO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZW1vdGVDYWxsQ291bnQgPCBtYXhSZW1vdGVDYWxscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2VyZUZ1bmN0aW9uc0NhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlQ2FsbENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ZXJlRnVuY3Rpb25zQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSB5aWVsZCBfX2F3YWl0KG1vZGVscy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBfX2F3YWl0KG1vZGVscy5nZW5lcmF0ZUNvbnRlbnRTdHJlYW1JbnRlcm5hbCh0cmFuc2Zvcm1lZFBhcmFtcykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvblJlc3BvbnNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZUNvbnRlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IHRydWUsIHJlc3BvbnNlXzEgPSAoZV8xID0gdm9pZCAwLCBfX2FzeW5jVmFsdWVzKHJlc3BvbnNlKSksIHJlc3BvbnNlXzFfMTsgcmVzcG9uc2VfMV8xID0geWllbGQgX19hd2FpdChyZXNwb25zZV8xLm5leHQoKSksIF9jID0gcmVzcG9uc2VfMV8xLmRvbmUsICFfYzsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2UgPSByZXNwb25zZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay5jYW5kaWRhdGVzICYmICgoX2EgPSBjaHVuay5jYW5kaWRhdGVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VDb250ZW50cy5wdXNoKGNodW5rLmNhbmRpZGF0ZXNbMF0uY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiAoX2IgPSBjaHVuay5jYW5kaWRhdGVzWzBdLmNvbnRlbnQucGFydHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3RlQ2FsbENvdW50IDwgbWF4UmVtb3RlQ2FsbHMgJiYgcGFydC5mdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQuZnVuY3Rpb25DYWxsLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsIG5hbWUgd2FzIG5vdCByZXR1cm5lZCBieSB0aGUgbW9kZWwuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWZjVG9vbHMuaGFzKHBhcnQuZnVuY3Rpb25DYWxsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgd2FzIHJlcXVlc3RlZCwgYnV0IG5vdCBhbGwgdGhlIHRvb2xzIHRoZSBtb2RlbCB1c2VkIGltcGxlbWVudCB0aGUgQ2FsbGFibGVUb29sIGludGVyZmFjZS4gQXZhaWxhYmxlIHRvb2xzOiAke2FmY1Rvb2xzLmtleXMoKX0sIG1pc2luZyB0b29sOiAke3BhcnQuZnVuY3Rpb25DYWxsLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVBhcnRzID0geWllbGQgX19hd2FpdChhZmNUb29sc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldChwYXJ0LmZ1bmN0aW9uQ2FsbC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGxUb29sKFtwYXJ0LmZ1bmN0aW9uQ2FsbF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZXMucHVzaCguLi5yZXNwb25zZVBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2YgJiYgIV9jICYmIChfZCA9IHJlc3BvbnNlXzEucmV0dXJuKSkgeWllbGQgX19hd2FpdChfZC5jYWxsKHJlc3BvbnNlXzEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25SZXNwb25zZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VyZUZ1bmN0aW9uc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3BvbnNlQ2h1bmsgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVkUmVzcG9uc2VDaHVuay5jYW5kaWRhdGVzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IGZ1bmN0aW9uUmVzcG9uc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0eXBlZFJlc3BvbnNlQ2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q29udGVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRlbnRzLnB1c2goLi4ucmVzcG9uc2VDb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IGZ1bmN0aW9uUmVzcG9uc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkQ29udGVudHMgPSB0Q29udGVudHMocGFyYW1zLmNvbnRlbnRzKS5jb25jYXQobmV3Q29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmNvbnRlbnRzID0gdXBkYXRlZENvbnRlbnRzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkodGhpcywgYWZjVG9vbHNNYXAsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlQ29udGVudEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmdlbmVyYXRlQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Z2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVDb250ZW50U3RyZWFtSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06c3RyZWFtR2VuZXJhdGVDb250ZW50P2FsdD1zc2UnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXBpQ2xpZW50LnJlcXVlc3RTdHJlYW0oe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKGZ1bmN0aW9uIChhcGlSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBlXzIsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgYXBpUmVzcG9uc2VfMSA9IF9fYXN5bmNWYWx1ZXMoYXBpUmVzcG9uc2UpLCBhcGlSZXNwb25zZV8xXzE7IGFwaVJlc3BvbnNlXzFfMSA9IHlpZWxkIF9fYXdhaXQoYXBpUmVzcG9uc2VfMS5uZXh0KCkpLCBfYSA9IGFwaVJlc3BvbnNlXzFfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gYXBpUmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KCh5aWVsZCBfX2F3YWl0KGNodW5rLmpzb24oKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwWydzZGtIdHRwUmVzcG9uc2UnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogY2h1bmsuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGFwaVJlc3BvbnNlXzEucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGFwaVJlc3BvbnNlXzEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnN0cmVhbUdlbmVyYXRlQ29udGVudD9hbHQ9c3NlJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgICAgICByZXNwb25zZSA9IGFwaUNsaWVudC5yZXF1ZXN0U3RyZWFtKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbihmdW5jdGlvbiAoYXBpUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgZV8zLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGFwaVJlc3BvbnNlXzIgPSBfX2FzeW5jVmFsdWVzKGFwaVJlc3BvbnNlKSwgYXBpUmVzcG9uc2VfMl8xOyBhcGlSZXNwb25zZV8yXzEgPSB5aWVsZCBfX2F3YWl0KGFwaVJlc3BvbnNlXzIubmV4dCgpKSwgX2EgPSBhcGlSZXNwb25zZV8yXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyA9IGFwaVJlc3BvbnNlXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KCh5aWVsZCBfX2F3YWl0KGNodW5rLmpzb24oKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwWydzZGtIdHRwUmVzcG9uc2UnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogY2h1bmsuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHR5cGVkUmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGFwaVJlc3BvbnNlXzIucmV0dXJuKSkgeWllbGQgX19hd2FpdChfYi5jYWxsKGFwaVJlc3BvbnNlXzIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBlbWJlZGRpbmdzIGZvciB0aGUgZ2l2ZW4gY29udGVudHMuIE9ubHkgdGV4dCBpcyBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGVtYmVkZGluZyBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZW1iZWRDb250ZW50KHtcbiAgICAgKiAgbW9kZWw6ICd0ZXh0LWVtYmVkZGluZy0wMDQnLFxuICAgICAqICBjb250ZW50czogW1xuICAgICAqICAgICdXaGF0IGlzIHlvdXIgbmFtZT8nLFxuICAgICAqICAgICdXaGF0IGlzIHlvdXIgZmF2b3JpdGUgY29sb3I/JyxcbiAgICAgKiAgXSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgb3V0cHV0RGltZW5zaW9uYWxpdHk6IDY0LFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBlbWJlZENvbnRlbnQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVtYmVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YmF0Y2hFbWJlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBFbWJlZENvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIGltYWdlIGJhc2VkIG9uIGEgdGV4dCBkZXNjcmlwdGlvbiBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBpbWFnZXMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlSW1hZ2VzKHtcbiAgICAgKiAgbW9kZWw6ICdpbWFnZW4tMy4wLWdlbmVyYXRlLTAwMicsXG4gICAgICogIHByb21wdDogJ1JvYm90IGhvbGRpbmcgYSByZWQgc2thdGVib2FyZCcsXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAqICAgIGluY2x1ZGVSYWlSZWFzb246IHRydWUsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2U/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUltYWdlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZWRpdEltYWdlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlZGl0SW1hZ2VQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGVkaXRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IEVkaXRJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cHNjYWxlSW1hZ2VJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwc2NhbGVJbWFnZUFQSVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdXBzY2FsZUltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgVXBzY2FsZUltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29udGV4dHVhbGl6ZXMgYW4gaW1hZ2UuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdHdvIHR5cGVzIG9mIHJlY29udGV4dHVhbGl6YXRpb24gY3VycmVudGx5IHN1cHBvcnRlZDpcbiAgICAgKiAxKSBJbWFnZW4gUHJvZHVjdCBSZWNvbnRleHQgLSBHZW5lcmF0ZSBpbWFnZXMgb2YgcHJvZHVjdHMgaW4gbmV3IHNjZW5lc1xuICAgICAqICAgIGFuZCBjb250ZXh0cy5cbiAgICAgKiAyKSBWaXJ0dWFsIFRyeS1PbjogR2VuZXJhdGUgaW1hZ2VzIG9mIHBlcnNvbnMgbW9kZWxpbmcgZmFzaGlvbiBwcm9kdWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgcmVjb250ZXh0dWFsaXppbmcgYW4gaW1hZ2UuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlMSA9IGF3YWl0IGFpLm1vZGVscy5yZWNvbnRleHRJbWFnZSh7XG4gICAgICogIG1vZGVsOiAnaW1hZ2VuLXByb2R1Y3QtcmVjb250ZXh0LXByZXZpZXctMDYtMzAnLFxuICAgICAqICBzb3VyY2U6IHtcbiAgICAgKiAgICBwcm9tcHQ6ICdJbiBhIG1vZGVybiBraXRjaGVuIHNldHRpbmcuJyxcbiAgICAgKiAgICBwcm9kdWN0SW1hZ2VzOiBbcHJvZHVjdEltYWdlXSxcbiAgICAgKiAgfSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UxPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAqXG4gICAgICogY29uc3QgcmVzcG9uc2UyID0gYXdhaXQgYWkubW9kZWxzLnJlY29udGV4dEltYWdlKHtcbiAgICAgKiAgbW9kZWw6ICd2aXJ0dWFsLXRyeS1vbi1wcmV2aWV3LTA4LTA0JyxcbiAgICAgKiAgc291cmNlOiB7XG4gICAgICogICAgcGVyc29uSW1hZ2U6IHBlcnNvbkltYWdlLFxuICAgICAqICAgIHByb2R1Y3RJbWFnZXM6IFtwcm9kdWN0SW1hZ2VdLFxuICAgICAqICB9LFxuICAgICAqICBjb25maWc6IHtcbiAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZTI/LmdlbmVyYXRlZEltYWdlcz8uWzBdPy5pbWFnZT8uaW1hZ2VCeXRlcyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgcmVjb250ZXh0SW1hZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSByZWNvbnRleHRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gcmVjb250ZXh0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBSZWNvbnRleHRJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWdtZW50cyBhbiBpbWFnZSwgY3JlYXRpbmcgYSBtYXNrIG9mIGEgc3BlY2lmaWVkIGFyZWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHNlZ21lbnRpbmcgYW4gaW1hZ2UuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLnNlZ21lbnRJbWFnZSh7XG4gICAgICogIG1vZGVsOiAnaW1hZ2Utc2VnbWVudGF0aW9uLTAwMScsXG4gICAgICogIHNvdXJjZToge1xuICAgICAqICAgIGltYWdlOiBpbWFnZSxcbiAgICAgKiAgfSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbW9kZTogJ2ZvcmVncm91bmQnLFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlPy5nZW5lcmF0ZWRNYXNrcz8uWzBdPy5tYXNrPy5pbWFnZUJ5dGVzKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBzZWdtZW50SW1hZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBzZWdtZW50SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHNlZ21lbnRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFNlZ21lbnRJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGluZm9ybWF0aW9uIGFib3V0IGEgbW9kZWwgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBtb2RlbEluZm8gPSBhd2FpdCBhaS5tb2RlbHMuZ2V0KHttb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWxzX3VybH0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RNb2RlbHNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0TW9kZWxzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbHNfdXJsfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdE1vZGVsc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgdHVuZWQgbW9kZWwgYnkgaXRzIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHVwZGF0aW5nIHRoZSBtb2RlbC5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMudXBkYXRlKHtcbiAgICAgKiAgIG1vZGVsOiAndHVuZWQtbW9kZWwtbmFtZScsXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgZGlzcGxheU5hbWU6ICdOZXcgZGlzcGxheSBuYW1lJyxcbiAgICAgKiAgICAgZGVzY3JpcHRpb246ICdOZXcgZGVzY3JpcHRpb24nLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHR1bmVkIG1vZGVsIGJ5IGl0cyBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBkZWxldGluZyB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmRlbGV0ZSh7bW9kZWw6ICd0dW5lZC1tb2RlbC1uYW1lJ30pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tVmVydGV4KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZU1vZGVsUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tTWxkZXYoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlTW9kZWxSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnaXZlbiBjb250ZW50cy4gTXVsdGltb2RhbCBpbnB1dCBpc1xuICAgICAqIHN1cHBvcnRlZCBmb3IgR2VtaW5pIG1vZGVscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY291bnRpbmcgdG9rZW5zLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5jb3VudFRva2Vucyh7XG4gICAgICogIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogIGNvbnRlbnRzOiAnVGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNvdW50VG9rZW5zKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjb3VudFRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y291bnRUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvdW50VG9rZW5zUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmNvdW50VG9rZW5zJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY291bnRUb2tlbnNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvdW50VG9rZW5zUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBjb250ZW50cywgcmV0dXJucyBhIGNvcnJlc3BvbmRpbmcgVG9rZW5zSW5mbyBjb250YWluaW5nXG4gICAgICogdGhlIGxpc3Qgb2YgdG9rZW5zIGFuZCBsaXN0IG9mIHRva2VuIGlkcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjb21wdXRpbmcgdG9rZW5zLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5jb21wdXRlVG9rZW5zKHtcbiAgICAgKiAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgY29udGVudHM6ICdXaGF0IGlzIHlvdXIgbmFtZT8nXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNvbXB1dGVUb2tlbnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjb21wdXRlVG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpjb21wdXRlVG9rZW5zJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY29tcHV0ZVRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENvbXB1dGVUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogIEdlbmVyYXRlcyB2aWRlb3MgYmFzZWQgb24gYSB0ZXh0IGRlc2NyaXB0aW9uIGFuZCBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIHZpZGVvcy5cbiAgICAgKiBAcmV0dXJuIEEgUHJvbWlzZTxHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbj4gd2hpY2ggYWxsb3dzIHlvdSB0byB0cmFjayB0aGUgcHJvZ3Jlc3MgYW5kIGV2ZW50dWFsbHkgcmV0cmlldmUgdGhlIGdlbmVyYXRlZCB2aWRlb3MgdXNpbmcgdGhlIG9wZXJhdGlvbnMuZ2V0IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBvcGVyYXRpb24gPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVWaWRlb3Moe1xuICAgICAqICBtb2RlbDogJ3Zlby0yLjAtZ2VuZXJhdGUtMDAxJyxcbiAgICAgKiAgcHJvbXB0OiAnQSBuZW9uIGhvbG9ncmFtIG9mIGEgY2F0IGRyaXZpbmcgYXQgdG9wIHNwZWVkJyxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbnVtYmVyT2ZWaWRlb3M6IDFcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHdoaWxlICghb3BlcmF0aW9uLmRvbmUpIHtcbiAgICAgKiAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwMCkpO1xuICAgICAqICAgb3BlcmF0aW9uID0gYXdhaXQgYWkub3BlcmF0aW9ucy5nZXRWaWRlb3NPcGVyYXRpb24oe29wZXJhdGlvbjogb3BlcmF0aW9ufSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob3BlcmF0aW9uLnJlc3BvbnNlPy5nZW5lcmF0ZWRWaWRlb3M/LlswXT8udmlkZW8/LnVyaSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVWaWRlb3NJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3RMb25nUnVubmluZycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3RMb25nUnVubmluZycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3BlcmF0aW9uTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ29wZXJhdGlvbk5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3BlcmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnb3BlcmF0aW9uTmFtZSddLCBmcm9tT3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PcGVyYXRpb25OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3BlcmF0aW9uTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PcGVyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdvcGVyYXRpb25OYW1lJ10sIGZyb21PcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGZyb21Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmZXRjaFByZWRpY3RPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU9wZXJhdGlvbk5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9wZXJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvcGVyYXRpb25OYW1lJ10sIGZyb21PcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc291cmNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzb3VyY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tUmVzb3VyY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdyZXNvdXJjZU5hbWUnXSwgZnJvbVJlc291cmNlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBPcGVyYXRpb25zIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0dXMgb2YgYSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgb3BlcmF0aW9uIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgdXBkYXRlZCBPcGVyYXRpb24gb2JqZWN0LCB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIG9yIHJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRWaWRlb3NPcGVyYXRpb24ocGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBwYXJhbWV0ZXJzLm9wZXJhdGlvbjtcbiAgICAgICAgY29uc3QgY29uZmlnID0gcGFyYW1ldGVycy5jb25maWc7XG4gICAgICAgIGlmIChvcGVyYXRpb24ubmFtZSA9PT0gdW5kZWZpbmVkIHx8IG9wZXJhdGlvbi5uYW1lID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZU5hbWUgPSBvcGVyYXRpb24ubmFtZS5zcGxpdCgnL29wZXJhdGlvbnMvJylbMF07XG4gICAgICAgICAgICBsZXQgaHR0cE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29uZmlnICYmICdodHRwT3B0aW9ucycgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWcuaHR0cE9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICByZXNvdXJjZU5hbWU6IHJlc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHsgaHR0cE9wdGlvbnM6IGh0dHBPcHRpb25zIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uX2Zyb21BUElSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgYXBpUmVzcG9uc2U6IHJhd09wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBpc1ZlcnRleEFJOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIGlzVmVydGV4QUk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdHVzIG9mIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IG9wZXJhdGlvbiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIHVwZGF0ZWQgT3BlcmF0aW9uIG9iamVjdCwgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBvciByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtZXRlcnMpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gcGFyYW1ldGVycy5vcGVyYXRpb247XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHBhcmFtZXRlcnMuY29uZmlnO1xuICAgICAgICBpZiAob3BlcmF0aW9uLm5hbWUgPT09IHVuZGVmaW5lZCB8fCBvcGVyYXRpb24ubmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVzb3VyY2VOYW1lID0gb3BlcmF0aW9uLm5hbWUuc3BsaXQoJy9vcGVyYXRpb25zLycpWzBdO1xuICAgICAgICAgICAgbGV0IGh0dHBPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGNvbmZpZyAmJiAnaHR0cE9wdGlvbnMnIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zID0gY29uZmlnLmh0dHBPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3T3BlcmF0aW9uID0gYXdhaXQgdGhpcy5mZXRjaFByZWRpY3RWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VOYW1lOiByZXNvdXJjZU5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiB7IGh0dHBPcHRpb25zOiBodHRwT3B0aW9ucyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLl9mcm9tQVBJUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlOiByYXdPcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgaXNWZXJ0ZXhBSTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmF3T3BlcmF0aW9uID0gYXdhaXQgdGhpcy5nZXRWaWRlb3NPcGVyYXRpb25JbnRlcm5hbCh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uX2Zyb21BUElSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgYXBpUmVzcG9uc2U6IHJhd09wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBpc1ZlcnRleEFJOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tvcGVyYXRpb25OYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne29wZXJhdGlvbk5hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZmV0Y2hQcmVkaWN0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7cmVzb3VyY2VOYW1lfTpmZXRjaFByZWRpY3RPcGVyYXRpb24nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZU5hbWUnXSk7XG4gICAgaWYgKGZyb21Wb2ljZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZU5hbWUnXSwgZnJvbVZvaWNlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWJ1aWx0Vm9pY2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWJ1aWx0Vm9pY2VDb25maWcnXSwgcHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3BlYWtlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlYWtlciddKTtcbiAgICBpZiAoZnJvbVNwZWFrZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVha2VyJ10sIGZyb21TcGVha2VyKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2KGZyb21Wb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzcGVha2VyVm9pY2VDb25maWdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWFrZXJWb2ljZUNvbmZpZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlZWNoQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvTWxkZXYoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSwgbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2KGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhVG9NbGRldihmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZyb21GdW5jdGlvbkNhbGwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmVoYXZpb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pO1xuICAgIGlmIChmcm9tQmVoYXZpb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiZWhhdmlvciddLCBmcm9tQmVoYXZpb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGludGVydmFsVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGludGVydmFsVG9NbGRldihmcm9tVGltZVJhbmdlRmlsdGVyKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR5bmFtaWNUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljVGhyZXNob2xkJ10sIGZyb21EeW5hbWljVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dFRvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sQ29tcHV0ZXJVc2VUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbnZpcm9ubWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW52aXJvbm1lbnQnXSk7XG4gICAgaWYgKGZyb21FbnZpcm9ubWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vudmlyb25tZW50J10sIGZyb21FbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2KGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldihmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudGVycHJpc2VXZWJTZWFyY2ggcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ29vZ2xlTWFwcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIHVybENvbnRleHRUb01sZGV2KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCB0b29sQ29tcHV0ZXJVc2VUb01sZGV2KGZyb21Db21wdXRlclVzZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaGFuZGxlJ10pO1xuICAgIGlmIChmcm9tSGFuZGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaGFuZGxlJ10sIGZyb21IYW5kbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cmFuc3BhcmVudCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNwYXJlbnQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9NbGRldigpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzYWJsZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc2FibGVkJ10pO1xuICAgIGlmIChmcm9tRGlzYWJsZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNhYmxlZCddLCBmcm9tRGlzYWJsZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSddLCBmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmRPZlNwZWVjaFNlbnNpdGl2aXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZlNwZWVjaFNlbnNpdGl2aXR5J10sIGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZWZpeFBhZGRpbmdNcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWZpeFBhZGRpbmdNcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVmaXhQYWRkaW5nTXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVmaXhQYWRkaW5nTXMnXSwgZnJvbVByZWZpeFBhZGRpbmdNcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaWxlbmNlRHVyYXRpb25NcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NpbGVuY2VEdXJhdGlvbk1zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNpbGVuY2VEdXJhdGlvbk1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2lsZW5jZUR1cmF0aW9uTXMnXSwgZnJvbVNpbGVuY2VEdXJhdGlvbk1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVhbHRpbWVJbnB1dENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiddLCBhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvTWxkZXYoZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUhhbmRsaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWN0aXZpdHlIYW5kbGluZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUhhbmRsaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlIYW5kbGluZyddLCBmcm9tQWN0aXZpdHlIYW5kbGluZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ292ZXJhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1cm5Db3ZlcmFnZSddKTtcbiAgICBpZiAoZnJvbVR1cm5Db3ZlcmFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db3ZlcmFnZSddLCBmcm9tVHVybkNvdmVyYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2xpZGluZ1dpbmRvd1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhcmdldFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFyZ2V0VG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVGFyZ2V0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGFyZ2V0VG9rZW5zJ10sIGZyb21UYXJnZXRUb2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UcmlnZ2VyVG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHJpZ2dlclRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UcmlnZ2VyVG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHJpZ2dlclRva2VucyddLCBmcm9tVHJpZ2dlclRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TbGlkaW5nV2luZG93ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2xpZGluZ1dpbmRvdycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TbGlkaW5nV2luZG93ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2xpZGluZ1dpbmRvdyddLCBzbGlkaW5nV2luZG93VG9NbGRldihmcm9tU2xpZGluZ1dpbmRvdykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcm9hY3Rpdml0eUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb2FjdGl2ZUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvYWN0aXZlQXVkaW8nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvYWN0aXZlQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9hY3RpdmVBdWRpbyddLCBmcm9tUHJvYWN0aXZlQXVkaW8pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21HZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc3BlZWNoQ29uZmlnJ10sIHNwZWVjaENvbmZpZ1RvTWxkZXYodExpdmVTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2KHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2KHRUb29sKGl0ZW0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2Vzc2lvblJlc3VtcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXNzaW9uUmVzdW1wdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZXNzaW9uUmVzdW1wdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzZXNzaW9uUmVzdW1wdGlvbiddLCBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYoZnJvbVNlc3Npb25SZXN1bXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvTWxkZXYoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JlYWx0aW1lSW5wdXRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdyZWFsdGltZUlucHV0Q29uZmlnJ10sIHJlYWx0aW1lSW5wdXRDb25maWdUb01sZGV2KGZyb21SZWFsdGltZUlucHV0Q29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbiddLCBjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb01sZGV2KGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2FjdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9hY3Rpdml0eSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2FjdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Byb2FjdGl2aXR5J10sIHByb2FjdGl2aXR5Q29uZmlnVG9NbGRldihmcm9tUHJvYWN0aXZpdHkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZUNvbm5lY3RDb25zdHJhaW50c1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVBdXRoVG9rZW5Db25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwaXJlVGltZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUV4cGlyZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OZXdTZXNzaW9uRXhwaXJlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25ld1Nlc3Npb25FeHBpcmVUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU5ld1Nlc3Npb25FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ25ld1Nlc3Npb25FeHBpcmVUaW1lJ10sIGZyb21OZXdTZXNzaW9uRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1c2VzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVXNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd1c2VzJ10sIGZyb21Vc2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxpdmVDb25uZWN0Q29uc3RyYWludHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsaXZlQ29ubmVjdENvbnN0cmFpbnRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxpdmVDb25uZWN0Q29uc3RyYWludHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnYmlkaUdlbmVyYXRlQ29udGVudFNldHVwJ10sIGxpdmVDb25uZWN0Q29uc3RyYWludHNUb01sZGV2KGFwaUNsaWVudCwgZnJvbUxpdmVDb25uZWN0Q29uc3RyYWludHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvY2tBZGRpdGlvbmFsRmllbGRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbG9ja0FkZGl0aW9uYWxGaWVsZHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZmllbGRNYXNrJ10sIGZyb21Mb2NrQWRkaXRpb25hbEZpZWxkcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUF1dGhUb2tlblBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGNyZWF0ZUF1dGhUb2tlbkNvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdXRoVG9rZW5Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZmllbGQgbWFza3MgZnJvbSBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gc2V0dXAgVGhlIG9iamVjdCB0byBleHRyYWN0IGZpZWxkIG1hc2tzIGZyb20uXG4gKiBAcmV0dXJuIEEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZmllbGQgbWFza3MuXG4gKi9cbmZ1bmN0aW9uIGdldEZpZWxkTWFza3Moc2V0dXApIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzZXR1cCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNldHVwLCBrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNldHVwW2tleV07XG4gICAgICAgICAgICAvLyAybmQgbGF5ZXIsIHJlY3Vyc2l2ZWx5IGdldCBmaWVsZCBtYXNrcyBzZWUgVE9ETyhiLzQxODI5MDEwMClcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKChraykgPT4gYCR7a2V5fS4ke2trfWApO1xuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKC4uLmZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKGtleSk7IC8vIDFzdCBsYXllclxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHMuam9pbignLCcpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAuXG4gKiBAcGFyYW0gcmVxdWVzdERpY3QgLSBUaGUgcmVxdWVzdCBkaWN0aW9uYXJ5LlxuICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqIEByZXR1cm4gLSBUaGUgbW9kaWZpZWQgcmVxdWVzdCBkaWN0aW9uYXJ5LlxuICovXG5mdW5jdGlvbiBjb252ZXJ0QmlkaVNldHVwVG9Ub2tlblNldHVwKHJlcXVlc3REaWN0LCBjb25maWcpIHtcbiAgICAvLyBDb252ZXJ0IGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCBmcm9tIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cC5zZXR1cC5cbiAgICBsZXQgc2V0dXBGb3JNYXNrR2VuZXJhdGlvbiA9IG51bGw7XG4gICAgY29uc3QgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgPSByZXF1ZXN0RGljdFsnYmlkaUdlbmVyYXRlQ29udGVudFNldHVwJ107XG4gICAgaWYgKHR5cGVvZiBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgJ3NldHVwJyBpbiBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSkge1xuICAgICAgICAvLyBOb3cgd2Uga25vdyBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZSBpcyBhbiBvYmplY3QgYW5kIGhhcyBhICdzZXR1cCdcbiAgICAgICAgLy8gcHJvcGVydHkuXG4gICAgICAgIGNvbnN0IGlubmVyU2V0dXAgPSBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZVxuICAgICAgICAgICAgLnNldHVwO1xuICAgICAgICBpZiAodHlwZW9mIGlubmVyU2V0dXAgPT09ICdvYmplY3QnICYmIGlubmVyU2V0dXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFZhbGlkIGlubmVyIHNldHVwIGZvdW5kLlxuICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddID0gaW5uZXJTZXR1cDtcbiAgICAgICAgICAgIHNldHVwRm9yTWFza0dlbmVyYXRpb24gPSBpbm5lclNldHVwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlLnNldHVwYCBpcyBub3QgYSB2YWxpZCBvYmplY3Q7IHRyZWF0IGFzXG4gICAgICAgICAgICAvLyBpZiBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAgaXMgaW52YWxpZC5cbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnYmlkaUdlbmVyYXRlQ29udGVudFNldHVwJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwYCBleGlzdHMgYnV0IG5vdCBpbiB0aGUgZXhwZWN0ZWRcbiAgICAgICAgLy8gc2hhcGUge3NldHVwOiB7Li4ufX07IHRyZWF0IGFzIGludmFsaWQuXG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnYmlkaUdlbmVyYXRlQ29udGVudFNldHVwJ107XG4gICAgfVxuICAgIGNvbnN0IHByZUV4aXN0aW5nRmllbGRNYXNrID0gcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddO1xuICAgIC8vIEhhbmRsZSBtYXNrIGdlbmVyYXRpb24gc2V0dXAuXG4gICAgaWYgKHNldHVwRm9yTWFza0dlbmVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkTWFza0Zyb21CaWRpID0gZ2V0RmllbGRNYXNrcyhzZXR1cEZvck1hc2tHZW5lcmF0aW9uKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzKSAmJlxuICAgICAgICAgICAgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkcy5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBDYXNlIDE6IGxvY2tBZGRpdGlvbmFsRmllbGRzIGlzIGFuIGVtcHR5IGFycmF5LiBMb2NrIG9ubHkgZmllbGRzIGZyb21cbiAgICAgICAgICAgIC8vIGJpZGkgc2V0dXAuXG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVkTWFza0Zyb21CaWRpKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gaWYgbWFzayBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ10gPSBnZW5lcmF0ZWRNYXNrRnJvbUJpZGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddOyAvLyBJZiBtYXNrIGlzIGVtcHR5LCBlZmZlY3RpdmVseSBub1xuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIGZpZWxkcyBsb2NrZWQgYnkgYmlkaVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHMpICYmXG4gICAgICAgICAgICBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgcHJlRXhpc3RpbmdGaWVsZE1hc2sgIT09IG51bGwgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlRXhpc3RpbmdGaWVsZE1hc2spICYmXG4gICAgICAgICAgICBwcmVFeGlzdGluZ0ZpZWxkTWFzay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBDYXNlIDI6IExvY2sgZmllbGRzIGZyb20gYmlkaSBzZXR1cCArIGFkZGl0aW9uYWwgZmllbGRzXG4gICAgICAgICAgICAvLyAocHJlRXhpc3RpbmdGaWVsZE1hc2spLlxuICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGlvbkNvbmZpZ0ZpZWxkcyA9IFtcbiAgICAgICAgICAgICAgICAndGVtcGVyYXR1cmUnLFxuICAgICAgICAgICAgICAgICd0b3BLJyxcbiAgICAgICAgICAgICAgICAndG9wUCcsXG4gICAgICAgICAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgICAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgICAgICAgICAgICAgJ3NlZWQnLFxuICAgICAgICAgICAgICAgICdzcGVlY2hDb25maWcnLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmcgPSBbXTtcbiAgICAgICAgICAgIGlmIChwcmVFeGlzdGluZ0ZpZWxkTWFzay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nID0gcHJlRXhpc3RpbmdGaWVsZE1hc2subWFwKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGlvbkNvbmZpZ0ZpZWxkcy5pbmNsdWRlcyhmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBgZ2VuZXJhdGlvbkNvbmZpZy4ke2ZpZWxkfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkOyAvLyBLZWVwIG9yaWdpbmFsIGZpZWxkIG5hbWUgaWYgbm90IGluXG4gICAgICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRpb25Db25maWdGaWVsZHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFza1BhcnRzID0gW107XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVkTWFza0Zyb21CaWRpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxNYXNrUGFydHMucHVzaChnZW5lcmF0ZWRNYXNrRnJvbUJpZGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZmluYWxNYXNrUGFydHMucHVzaCguLi5tYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbmFsTWFza1BhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ10gPSBmaW5hbE1hc2tQYXJ0cy5qb2luKCcsJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBmaWVsZHMgZnJvbSBiaWRpIGFuZCBubyB2YWxpZCBhZGRpdGlvbmFsIGZpZWxkcyBmcm9tXG4gICAgICAgICAgICAgICAgLy8gcHJlLWV4aXN0aW5nIG1hc2suXG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhc2UgMzogXCJMb2NrIGFsbCBmaWVsZHNcIiAobWVhbmluZywgZG9uJ3Qgc2VuZCBhIGZpZWxkX21hc2ssIGxldCBzZXJ2ZXJcbiAgICAgICAgICAgIC8vIGRlZmF1bHRzIGFwcGx5IG9yIGFsbCBhcmUgbXV0YWJsZSkuIFRoaXMgaXMgaGl0IGlmOlxuICAgICAgICAgICAgLy8gIC0gYGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkc2AgaXMgdW5kZWZpbmVkLlxuICAgICAgICAgICAgLy8gIC0gYGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkc2AgaXMgbm9uLWVtcHR5LCBCVVRcbiAgICAgICAgICAgIC8vICBgcHJlRXhpc3RpbmdGaWVsZE1hc2tgIGlzIG51bGwsIG5vdCBhIHN0cmluZywgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTm8gdmFsaWQgYGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cGAgd2FzIGZvdW5kIG9yIGV4dHJhY3RlZC5cbiAgICAgICAgLy8gXCJMb2NrIGFkZGl0aW9uYWwgbnVsbCBmaWVsZHMgaWYgYW55XCIuXG4gICAgICAgIGlmIChwcmVFeGlzdGluZ0ZpZWxkTWFzayAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShwcmVFeGlzdGluZ0ZpZWxkTWFzaykgJiZcbiAgICAgICAgICAgIHByZUV4aXN0aW5nRmllbGRNYXNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBwcmUtZXhpc3RpbmcgZmllbGQgbWFzaywgaXQncyBhIHN0cmluZywgYW5kIGl0J3Mgbm90XG4gICAgICAgICAgICAvLyBlbXB0eSwgdGhlbiB3ZSBzaG91bGQgbG9jayBhbGwgZmllbGRzLlxuICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gcHJlRXhpc3RpbmdGaWVsZE1hc2suam9pbignLCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdERpY3Q7XG59XG5jbGFzcyBUb2tlbnMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZXBoZW1lcmFsIGF1dGggdG9rZW4gcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIEVwaGVtZXJhbCBhdXRoIHRva2VucyBpcyBvbmx5IHN1cHBvcnRlZCBpbiB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuXG4gICAgICogSXQgY2FuIGJlIHVzZWQgZm9yIHRoZSBzZXNzaW9uIGNvbm5lY3Rpb24gdG8gdGhlIExpdmUgY29uc3RyYWluZWQgQVBJLlxuICAgICAqIFN1cHBvcnQgaW4gdjFhbHBoYSBvbmx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgY3JlYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBhdXRoIHRva2VuLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHtcbiAgICAgKiAgICAgYXBpS2V5OiB0b2tlbi5uYW1lLFxuICAgICAqICAgICBodHRwT3B0aW9uczogeyBhcGlWZXJzaW9uOiAndjFhbHBoYScgfSAgLy8gU3VwcG9ydCBpbiB2MWFscGhhIG9ubHkuXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDE6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHVuc2V0LCB1bmxvY2sgTGl2ZUNvbm5lY3RDb25maWdcbiAgICAgKiAvLyB3aGVuIHVzaW5nIHRoZSB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy4gRWFjaCBzZXNzaW9uIGNvbm5lY3Rpb24gY2FuXG4gICAgICogLy8gdXNlIGEgZGlmZmVyZW50IGNvbmZpZ3VyYXRpb24uXG4gICAgICogY29uc3QgY29uZmlnOiBDcmVhdGVBdXRoVG9rZW5Db25maWcgPSB7XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogfVxuICAgICAqIGNvbnN0IHRva2VuID0gYXdhaXQgYWkudG9rZW5zLmNyZWF0ZShjb25maWcpO1xuICAgICAqXG4gICAgICogLy8gQ2FzZSAyOiBJZiBMaXZlRXBoZW1lcmFsUGFyYW1ldGVycyBpcyBzZXQsIGxvY2sgYWxsIGZpZWxkcyBpblxuICAgICAqIC8vIExpdmVDb25uZWN0Q29uZmlnIHdoZW4gdXNpbmcgdGhlIHRva2VuIGluIExpdmUgQVBJIHNlc3Npb25zLiBGb3JcbiAgICAgKiAvLyBleGFtcGxlLCBjaGFuZ2luZyBgb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uYCBpbiB0aGUgTGl2ZSBBUElcbiAgICAgKiAvLyBjb25uZWN0aW9uIHdpbGwgYmUgaWdub3JlZCBieSB0aGUgQVBJLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID1cbiAgICAgKiAgICAgdXNlczogMyxcbiAgICAgKiAgICAgZXhwaXJlVGltZTogJzIwMjUtMDUtMDFUMDA6MDA6MDBaJyxcbiAgICAgKiAgICAgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnM6IHtcbiAgICAgKiAgICAgICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICAgICAgIGNvbmZpZzoge1xuICAgICAqICAgICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJzogWydBVURJTyddLFxuICAgICAqICAgICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnQWx3YXlzIGFuc3dlciBpbiBFbmdsaXNoLicsXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgfVxuICAgICAqIH1cbiAgICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGFpLnRva2Vucy5jcmVhdGUoY29uZmlnKTtcbiAgICAgKlxuICAgICAqIC8vIENhc2UgMzogSWYgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnMgaXMgc2V0IGFuZCBsb2NrQWRkaXRpb25hbEZpZWxkcyBpc1xuICAgICAqIC8vIHNldCwgbG9jayBMaXZlQ29ubmVjdENvbmZpZyB3aXRoIHNldCBhbmQgYWRkaXRpb25hbCBmaWVsZHMgKGUuZy5cbiAgICAgKiAvLyByZXNwb25zZU1vZGFsaXRpZXMsIHN5c3RlbUluc3RydWN0aW9uLCB0ZW1wZXJhdHVyZSBpbiB0aGlzIGV4YW1wbGUpIHdoZW5cbiAgICAgKiAvLyB1c2luZyB0aGUgdG9rZW4gaW4gTGl2ZSBBUEkgc2Vzc2lvbnMuXG4gICAgICogY29uc3QgY29uZmlnOiBDcmVhdGVBdXRoVG9rZW5Db25maWcgPVxuICAgICAqICAgICB1c2VzOiAzLFxuICAgICAqICAgICBleHBpcmVUaW1lOiAnMjAyNS0wNS0wMVQwMDowMDowMFonLFxuICAgICAqICAgICBMaXZlRXBoZW1lcmFsUGFyYW1ldGVyczoge1xuICAgICAqICAgICAgICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gtMDAxJyxcbiAgICAgKiAgICAgICAgY29uZmlnOiB7XG4gICAgICogICAgICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnOiBbJ0FVRElPJ10sXG4gICAgICogICAgICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbic6ICdBbHdheXMgYW5zd2VyIGluIEVuZ2xpc2guJyxcbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICB9LFxuICAgICAqICAgICBsb2NrQWRkaXRpb25hbEZpZWxkczogWyd0ZW1wZXJhdHVyZSddLFxuICAgICAqIH1cbiAgICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGFpLnRva2Vucy5jcmVhdGUoY29uZmlnKTtcbiAgICAgKlxuICAgICAqIC8vIENhc2UgNDogSWYgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnMgaXMgc2V0IGFuZCBsb2NrQWRkaXRpb25hbEZpZWxkcyBpc1xuICAgICAqIC8vIGVtcHR5IGFycmF5LCBsb2NrIExpdmVDb25uZWN0Q29uZmlnIHdpdGggc2V0IGZpZWxkcyAoZS5nLlxuICAgICAqIC8vIHJlc3BvbnNlTW9kYWxpdGllcywgc3lzdGVtSW5zdHJ1Y3Rpb24gaW4gdGhpcyBleGFtcGxlKSB3aGVuIHVzaW5nIHRoZVxuICAgICAqIC8vIHRva2VuIGluIExpdmUgQVBJIHNlc3Npb25zLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID1cbiAgICAgKiAgICAgdXNlczogMyxcbiAgICAgKiAgICAgZXhwaXJlVGltZTogJzIwMjUtMDUtMDFUMDA6MDA6MDBaJyxcbiAgICAgKiAgICAgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnM6IHtcbiAgICAgKiAgICAgICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICAgICAgIGNvbmZpZzoge1xuICAgICAqICAgICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJzogWydBVURJTyddLFxuICAgICAqICAgICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnQWx3YXlzIGFuc3dlciBpbiBFbmdsaXNoLicsXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbG9ja0FkZGl0aW9uYWxGaWVsZHM6IFtdLFxuICAgICAqIH1cbiAgICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGFpLnRva2Vucy5jcmVhdGUoY29uZmlnKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNsaWVudC50b2tlbnMuY3JlYXRlIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQXV0aFRva2VuUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdhdXRoX3Rva2VucycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkQm9keSA9IGNvbnZlcnRCaWRpU2V0dXBUb1Rva2VuU2V0dXAoYm9keSwgcGFyYW1zLmNvbmZpZyk7XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRyYW5zZm9ybWVkQm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYXV0aFRva2VuRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBHT09HTEVfQVBJX0tFWV9IRUFERVIgPSAneC1nb29nLWFwaS1rZXknO1xuY29uc3QgUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvY2xvdWQtcGxhdGZvcm0nO1xuY2xhc3MgTm9kZUF1dGgge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMuYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYXBpS2V5ID0gb3B0cy5hcGlLZXk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVydGV4QXV0aE9wdGlvbnMgPSBidWlsZEdvb2dsZUF1dGhPcHRpb25zKG9wdHMuZ29vZ2xlQXV0aE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdvb2dsZUF1dGggPSBuZXcgR29vZ2xlQXV0aCh2ZXJ0ZXhBdXRoT3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEF1dGhIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUtleS5zdGFydHNXaXRoKCdhdXRoX3Rva2Vucy8nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXBoZW1lcmFsIHRva2VucyBhcmUgb25seSBzdXBwb3J0ZWQgYnkgdGhlIGxpdmUgQVBJLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRLZXlIZWFkZXIoaGVhZGVycyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkR29vZ2xlQXV0aEhlYWRlcnMoaGVhZGVycyk7XG4gICAgfVxuICAgIGFkZEtleUhlYWRlcihoZWFkZXJzKSB7XG4gICAgICAgIGlmIChoZWFkZXJzLmdldChHT09HTEVfQVBJX0tFWV9IRUFERVIpICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgdGhpcyBtZXRob2QgaXMgb25seSBjYWxsZWRcbiAgICAgICAgICAgIC8vIHdoZW4gYXBpS2V5IGlzIHNldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHNldCBBUEkga2V5IGhlYWRlciBidXQgYXBpS2V5IGlzIG5vdCBzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzLmFwcGVuZChHT09HTEVfQVBJX0tFWV9IRUFERVIsIHRoaXMuYXBpS2V5KTtcbiAgICB9XG4gICAgYXN5bmMgYWRkR29vZ2xlQXV0aEhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICBpZiAodGhpcy5nb29nbGVBdXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYWRkR29vZ2xlQXV0aEhlYWRlcnMgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFwaUtleSBzZXQgYW5kIGluIHRoZXNlIGNhc2VzIGdvb2dsZUF1dGhcbiAgICAgICAgICAgIC8vIGlzIHNldC5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIHNldCBnb29nbGUtYXV0aCBoZWFkZXJzIGJ1dCBnb29nbGVBdXRoIGlzIHVuc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXV0aEhlYWRlcnMgPSBhd2FpdCB0aGlzLmdvb2dsZUF1dGguZ2V0UmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXV0aEhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzLmdldChrZXkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIGF1dGhIZWFkZXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRHb29nbGVBdXRoT3B0aW9ucyhnb29nbGVBdXRoT3B0aW9ucykge1xuICAgIGxldCBhdXRoT3B0aW9ucztcbiAgICBpZiAoIWdvb2dsZUF1dGhPcHRpb25zKSB7XG4gICAgICAgIGF1dGhPcHRpb25zID0ge1xuICAgICAgICAgICAgc2NvcGVzOiBbUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF1dGhPcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXV0aE9wdGlvbnMgPSBnb29nbGVBdXRoT3B0aW9ucztcbiAgICAgICAgaWYgKCFhdXRoT3B0aW9ucy5zY29wZXMpIHtcbiAgICAgICAgICAgIGF1dGhPcHRpb25zLnNjb3BlcyA9IFtSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEVdO1xuICAgICAgICAgICAgcmV0dXJuIGF1dGhPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCh0eXBlb2YgYXV0aE9wdGlvbnMuc2NvcGVzID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgYXV0aE9wdGlvbnMuc2NvcGVzICE9PSBSRVFVSVJFRF9WRVJURVhfQUlfU0NPUEUpIHx8XG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheShhdXRoT3B0aW9ucy5zY29wZXMpICYmXG4gICAgICAgICAgICAgICAgYXV0aE9wdGlvbnMuc2NvcGVzLmluZGV4T2YoUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFKSA8IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXV0aCBzY29wZXMuIFNjb3BlcyBtdXN0IGluY2x1ZGU6ICR7UkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdXRoT3B0aW9ucztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIE5vZGVEb3dubG9hZGVyIHtcbiAgICBhc3luYyBkb3dubG9hZChwYXJhbXMsIGFwaUNsaWVudCkge1xuICAgICAgICBpZiAocGFyYW1zLmRvd25sb2FkUGF0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkb3dubG9hZEZpbGUocGFyYW1zLCBhcGlDbGllbnQpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gY3JlYXRlV3JpdGVTdHJlYW0ocGFyYW1zLmRvd25sb2FkUGF0aCk7XG4gICAgICAgICAgICAgICAgUmVhZGFibGUuZnJvbVdlYihyZXNwb25zZS5yZXNwb25zZUludGVybmFsLmJvZHkpLnBpcGUod3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyaXRlRmlsZShwYXJhbXMuZG93bmxvYWRQYXRoLCByZXNwb25zZSwgeyBlbmNvZGluZzogJ2Jhc2U2NCcgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gd3JpdGUgZmlsZSB0byAke3BhcmFtcy5kb3dubG9hZFBhdGh9OiAke2Vycm9yfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUocGFyYW1zLCBhcGlDbGllbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBuYW1lID0gdEZpbGVOYW1lKHBhcmFtcy5maWxlKTtcbiAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBhcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICBwYXRoOiBgZmlsZXMvJHtuYW1lfTpkb3dubG9hZGAsXG4gICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgJ2FsdCc6ICdtZWRpYScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0dlbmVyYXRlZFZpZGVvKHBhcmFtcy5maWxlKSkge1xuICAgICAgICBjb25zdCB2aWRlb0J5dGVzID0gKF9jID0gcGFyYW1zLmZpbGUudmlkZW8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy52aWRlb0J5dGVzO1xuICAgICAgICBpZiAodHlwZW9mIHZpZGVvQnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlkZW9CeXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRvd25sb2FkIGdlbmVyYXRlZCB2aWRlbywgVXJpIG9yIHZpZGVvQnl0ZXMgbm90IGZvdW5kLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVmlkZW8ocGFyYW1zLmZpbGUpKSB7XG4gICAgICAgIGNvbnN0IHZpZGVvQnl0ZXMgPSBwYXJhbXMuZmlsZS52aWRlb0J5dGVzO1xuICAgICAgICBpZiAodHlwZW9mIHZpZGVvQnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlkZW9CeXRlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRvd25sb2FkIHZpZGVvLCBVcmkgb3IgdmlkZW9CeXRlcyBub3QgZm91bmQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgZmlsZSB0eXBlJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBOb2RlV2ViU29ja2V0RmFjdG9yeSB7XG4gICAgY3JlYXRlKHVybCwgaGVhZGVycywgY2FsbGJhY2tzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVdlYlNvY2tldCh1cmwsIGhlYWRlcnMsIGNhbGxiYWNrcyk7XG4gICAgfVxufVxuY2xhc3MgTm9kZVdlYlNvY2tldCB7XG4gICAgY29uc3RydWN0b3IodXJsLCBoZWFkZXJzLCBjYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLndzID0gbmV3IE5vZGVXcy5XZWJTb2NrZXQodGhpcy51cmwsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9IHRoaXMuY2FsbGJhY2tzLm9ub3BlbjtcbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gdGhpcy5jYWxsYmFja3Mub25lcnJvcjtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gdGhpcy5jYWxsYmFja3Mub25jbG9zZTtcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSB0aGlzLmNhbGxiYWNrcy5vbm1lc3NhZ2U7XG4gICAgfVxuICAgIHNlbmQobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy53cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3QgY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5zZW5kKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMud3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nRXhhbXBsZVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRleHRJbnB1dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dElucHV0J10pO1xuICAgIGlmIChmcm9tVGV4dElucHV0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dElucHV0J10sIGZyb21UZXh0SW5wdXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXQnXSk7XG4gICAgaWYgKGZyb21PdXRwdXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvdXRwdXQnXSwgZnJvbU91dHB1dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0RhdGFzZXRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZlcnRleERhdGFzZXRSZXNvdXJjZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVydGV4RGF0YXNldFJlc291cmNlIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGFtcGxlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZXMnXSk7XG4gICAgaWYgKGZyb21FeGFtcGxlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRXhhbXBsZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nRXhhbXBsZVRvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGFtcGxlcycsICdleGFtcGxlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmFsaWRhdGlvbkRhdGFzZXQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbGlkYXRpb25EYXRhc2V0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzY3JpcHRpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVwb2NoQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vwb2NoQ291bnQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FcG9jaENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2Vwb2NoQ291bnQnXSwgZnJvbUVwb2NoQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAnaHlwZXJwYXJhbWV0ZXJzJywgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInXSwgZnJvbUxlYXJuaW5nUmF0ZU11bHRpcGxpZXIpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkYXB0ZXJTaXplJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGFwdGVyU2l6ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmF0Y2hTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXRjaFNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21CYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnYmF0Y2hTaXplJ10sIGZyb21CYXRjaFNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsZWFybmluZ1JhdGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MZWFybmluZ1JhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlJ10sIGZyb21MZWFybmluZ1JhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZVR1bmVkTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWwnXSwgZnJvbVByZVR1bmVkTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhaW5pbmdEYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHJhaW5pbmdEYXRhc2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyYWluaW5nRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAndHJhaW5pbmdEYXRhJ10sIHR1bmluZ0RhdGFzZXRUb01sZGV2KGZyb21UcmFpbmluZ0RhdGFzZXQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBmcm9tQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb25maWcnXSwgbGlzdFR1bmluZ0pvYnNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdEYXRhc2V0VG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmVydGV4RGF0YXNldFJlc291cmNlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICd0cmFpbmluZ0RhdGFzZXRVcmknXSwgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4YW1wbGVzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGFtcGxlcyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWxpZGF0aW9uRGF0YXNldFVyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZlcnRleERhdGFzZXRSZXNvdXJjZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAndHJhaW5pbmdEYXRhc2V0VXJpJ10sIGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WYWxpZGF0aW9uRGF0YXNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZhbGlkYXRpb25EYXRhc2V0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZhbGlkYXRpb25EYXRhc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJ10sIHR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgoZnJvbVZhbGlkYXRpb25EYXRhc2V0LCB0b09iamVjdCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuZWRNb2RlbERpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dW5lZE1vZGVsRGlzcGxheU5hbWUnXSwgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2hDb3VudCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVwb2NoQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2Vwb2NoQ291bnQnXSwgZnJvbUVwb2NoQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xlYXJuaW5nUmF0ZU11bHRpcGxpZXInLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlTXVsdGlwbGllciddLCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleHBvcnRMYXN0Q2hlY2twb2ludE9ubHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSddLCBmcm9tRXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZVR1bmVkTW9kZWxDaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZVR1bmVkTW9kZWxDaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVUdW5lZE1vZGVsJywgJ2NoZWNrcG9pbnRJZCddLCBmcm9tUHJlVHVuZWRNb2RlbENoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BZGFwdGVyU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRhcHRlclNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGFwdGVyU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnYWRhcHRlclNpemUnXSwgZnJvbUFkYXB0ZXJTaXplKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmF0Y2hTaXplJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXRjaFNpemUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsZWFybmluZ1JhdGUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xlYXJuaW5nUmF0ZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZVR1bmVkTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWwnXSwgZnJvbVByZVR1bmVkTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhaW5pbmdEYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHJhaW5pbmdEYXRhc2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyYWluaW5nRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ3RyYWluaW5nRGF0YXNldFVyaSddLCB0dW5pbmdEYXRhc2V0VG9WZXJ0ZXgoZnJvbVRyYWluaW5nRGF0YXNldCwgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kcG9pbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21FbmRwb2ludCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZHBvaW50J10sIGZyb21FbmRwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0pvYkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRUdW5pbmdKb2JTdGF0dXMoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuaW5nVGFzaycsXG4gICAgICAgICdzdGFydFRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmluZ1Rhc2snLFxuICAgICAgICAnY29tcGxldGVUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWwnXSwgdHVuZWRNb2RlbEZyb21NbGRldihmcm9tVHVuZWRNb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3VzdG9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY3VzdG9tQmFzZU1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUN1c3RvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2N1c3RvbUJhc2VNb2RlbCddLCBmcm9tQ3VzdG9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGVyaW1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGVyaW1lbnQnXSk7XG4gICAgaWYgKGZyb21FeHBlcmltZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhwZXJpbWVudCddLCBmcm9tRXhwZXJpbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAoZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dFVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0VXJpJ10pO1xuICAgIGlmIChmcm9tT3V0cHV0VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VXJpJ10sIGZyb21PdXRwdXRVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGlwZWxpbmVKb2IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BpcGVsaW5lSm9iJ10pO1xuICAgIGlmIChmcm9tUGlwZWxpbmVKb2IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwaXBlbGluZUpvYiddLCBmcm9tUGlwZWxpbmVKb2IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmljZUFjY291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2aWNlQWNjb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXJ2aWNlQWNjb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZpY2VBY2NvdW50J10sIGZyb21TZXJ2aWNlQWNjb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbERpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuaW5nSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVuZWRNb2RlbHMnXSk7XG4gICAgaWYgKGZyb21UdW5pbmdKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21UdW5pbmdKb2JzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmluZ0pvYkZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ0pvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nT3BlcmF0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxDaGVja3BvaW50RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2hlY2twb2ludElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaGVja3BvaW50SWQnXSk7XG4gICAgaWYgKGZyb21DaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaGVja3BvaW50SWQnXSwgZnJvbUNoZWNrcG9pbnRJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcG9jaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2gnXSk7XG4gICAgaWYgKGZyb21FcG9jaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vwb2NoJ10sIGZyb21FcG9jaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGVwID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGVwJ10pO1xuICAgIGlmIChmcm9tU3RlcCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0ZXAnXSwgZnJvbVN0ZXApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kcG9pbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZHBvaW50J10pO1xuICAgIGlmIChmcm9tRW5kcG9pbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludCddLCBmcm9tRW5kcG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5lZE1vZGVsRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kcG9pbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZHBvaW50J10pO1xuICAgIGlmIChmcm9tRW5kcG9pbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRwb2ludCddLCBmcm9tRW5kcG9pbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2hlY2twb2ludHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NoZWNrcG9pbnRzJ10pO1xuICAgIGlmIChmcm9tQ2hlY2twb2ludHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNoZWNrcG9pbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR1bmVkTW9kZWxDaGVja3BvaW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NoZWNrcG9pbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0pvYkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCB0VHVuaW5nSm9iU3RhdHVzKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1bmVkTW9kZWwnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbCddLCB0dW5lZE1vZGVsRnJvbVZlcnRleChmcm9tVHVuZWRNb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZVR1bmVkTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWwnXSwgZnJvbVByZVR1bmVkTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdXBlcnZpc2VkVHVuaW5nU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdXBlcnZpc2VkVHVuaW5nU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJ10sIGZyb21TdXBlcnZpc2VkVHVuaW5nU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5pbmdEYXRhU3RhdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5pbmdEYXRhU3RhdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVuaW5nRGF0YVN0YXRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nRGF0YVN0YXRzJ10sIGZyb21UdW5pbmdEYXRhU3RhdHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5jcnlwdGlvblNwZWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmNyeXB0aW9uU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmNyeXB0aW9uU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuY3J5cHRpb25TcGVjJ10sIGZyb21FbmNyeXB0aW9uU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFydG5lck1vZGVsVHVuaW5nU3BlYycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydG5lck1vZGVsVHVuaW5nU3BlYyddLCBmcm9tUGFydG5lck1vZGVsVHVuaW5nU3BlYyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DdXN0b21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjdXN0b21CYXNlTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ3VzdG9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3VzdG9tQmFzZU1vZGVsJ10sIGZyb21DdXN0b21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwZXJpbWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhwZXJpbWVudCddKTtcbiAgICBpZiAoZnJvbUV4cGVyaW1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleHBlcmltZW50J10sIGZyb21FeHBlcmltZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0VXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRVcmknXSk7XG4gICAgaWYgKGZyb21PdXRwdXRVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvdXRwdXRVcmknXSwgZnJvbU91dHB1dFVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QaXBlbGluZUpvYiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGlwZWxpbmVKb2InXSk7XG4gICAgaWYgKGZyb21QaXBlbGluZUpvYiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BpcGVsaW5lSm9iJ10sIGZyb21QaXBlbGluZUpvYik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXJ2aWNlQWNjb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlcnZpY2VBY2NvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlcnZpY2VBY2NvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VydmljZUFjY291bnQnXSwgZnJvbVNlcnZpY2VBY2NvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5lZE1vZGVsRGlzcGxheU5hbWUnXSwgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuaW5nSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVuaW5nSm9icyddKTtcbiAgICBpZiAoZnJvbVR1bmluZ0pvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVR1bmluZ0pvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nSm9iRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ0pvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBUdW5pbmdzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhIFR1bmluZ0pvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgcmVzb3VyY2UgbmFtZSBvZiB0aGUgdHVuaW5nIGpvYi5cbiAgICAgICAgICogQHJldHVybiAtIEEgVHVuaW5nSm9iIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbCAtIFRoZSBTREsncyB0dW5pbmcgaW1wbGVtZW50YXRpb24gaXMgZXhwZXJpbWVudGFsLCBhbmQgbWF5XG4gICAgICAgICAqIGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldCA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEludGVybmFsKHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0cyB0dW5pbmcgam9icy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgbGlzdCByZXF1ZXN0LlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBsaXN0IG9mIHR1bmluZyBqb2JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsIC0gVGhlIFNESydzIHR1bmluZyBpbXBsZW1lbnRhdGlvbiBpcyBleHBlcmltZW50YWwsIGFuZCBtYXlcbiAgICAgICAgICogY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGlzdCA9IGFzeW5jIChwYXJhbXMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYWdlcihQYWdlZEl0ZW0uUEFHRURfSVRFTV9UVU5JTkdfSk9CUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHN1cGVydmlzZWQgZmluZS10dW5pbmcgam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSB0dW5pbmcgam9iLlxuICAgICAgICAgKiBAcmV0dXJuIC0gQSBUdW5pbmdKb2Igb3BlcmF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsIC0gVGhlIFNESydzIHR1bmluZyBpbXBsZW1lbnRhdGlvbiBpcyBleHBlcmltZW50YWwsIGFuZCBtYXlcbiAgICAgICAgICogY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHVuZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJhc2VNb2RlbC5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVUdW5lZE1vZGVsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHVuZWRNb2RlbE5hbWU6IHBhcmFtcy5iYXNlTW9kZWwsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1ByaXZhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgcHJlVHVuZWRNb2RlbDogcHJlVHVuZWRNb2RlbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zUHJpdmF0ZS5iYXNlTW9kZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnR1bmVJbnRlcm5hbChwYXJhbXNQcml2YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1ByaXZhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50dW5lSW50ZXJuYWwocGFyYW1zUHJpdmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zUHJpdmF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gYXdhaXQgdGhpcy50dW5lTWxkZXZJbnRlcm5hbChwYXJhbXNQcml2YXRlKTtcbiAgICAgICAgICAgICAgICBsZXQgdHVuZWRNb2RlbE5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uWydtZXRhZGF0YSddICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uWydtZXRhZGF0YSddWyd0dW5lZE1vZGVsJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0dW5lZE1vZGVsTmFtZSA9IG9wZXJhdGlvblsnbWV0YWRhdGEnXVsndHVuZWRNb2RlbCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb25bJ25hbWUnXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblsnbmFtZSddLmluY2x1ZGVzKCcvb3BlcmF0aW9ucy8nKSkge1xuICAgICAgICAgICAgICAgICAgICB0dW5lZE1vZGVsTmFtZSA9IG9wZXJhdGlvblsnbmFtZSddLnNwbGl0KCcvb3BlcmF0aW9ucy8nKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHVuaW5nSm9iID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0dW5lZE1vZGVsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IEpvYlN0YXRlLkpPQl9TVEFURV9RVUVVRUQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nSm9iO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ0pvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmluZ0pvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndHVuZWRNb2RlbHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB0dW5lSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5pbmdKb2JzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB0dW5lTWxkZXZJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd0dW5lZE1vZGVscycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ2NvbmZpZyddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ09wZXJhdGlvbkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgTUFYX0NIVU5LX1NJWkUgPSAxMDI0ICogMTAyNCAqIDg7IC8vIGJ5dGVzXG5jb25zdCBNQVhfUkVUUllfQ09VTlQgPSAzO1xuY29uc3QgSU5JVElBTF9SRVRSWV9ERUxBWV9NUyA9IDEwMDA7XG5jb25zdCBERUxBWV9NVUxUSVBMSUVSID0gMjtcbmNvbnN0IFhfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRCA9ICd4LWdvb2ctdXBsb2FkLXN0YXR1cyc7XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRCbG9iKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgbGV0IGZpbGVTaXplID0gMDtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBsZXQgcmVzcG9uc2UgPSBuZXcgSHR0cFJlc3BvbnNlKG5ldyBSZXNwb25zZSgpKTtcbiAgICBsZXQgdXBsb2FkQ29tbWFuZCA9ICd1cGxvYWQnO1xuICAgIGZpbGVTaXplID0gZmlsZS5zaXplO1xuICAgIHdoaWxlIChvZmZzZXQgPCBmaWxlU2l6ZSkge1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSBNYXRoLm1pbihNQVhfQ0hVTktfU0laRSwgZmlsZVNpemUgLSBvZmZzZXQpO1xuICAgICAgICBjb25zdCBjaHVuayA9IGZpbGUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBjaHVua1NpemUpO1xuICAgICAgICBpZiAob2Zmc2V0ICsgY2h1bmtTaXplID49IGZpbGVTaXplKSB7XG4gICAgICAgICAgICB1cGxvYWRDb21tYW5kICs9ICcsIGZpbmFsaXplJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50RGVsYXlNcyA9IElOSVRJQUxfUkVUUllfREVMQVlfTVM7XG4gICAgICAgIHdoaWxlIChyZXRyeUNvdW50IDwgTUFYX1JFVFJZX0NPVU5UKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnJyxcbiAgICAgICAgICAgICAgICBib2R5OiBjaHVuayxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXBpVmVyc2lvbjogJycsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VVcmw6IHVwbG9hZFVybCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6IHVwbG9hZENvbW1hbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1PZmZzZXQnOiBTdHJpbmcob2Zmc2V0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IFN0cmluZyhjaHVua1NpemUpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKGN1cnJlbnREZWxheU1zKTtcbiAgICAgICAgICAgIGN1cnJlbnREZWxheU1zID0gY3VycmVudERlbGF5TXMgKiBERUxBWV9NVUxUSVBMSUVSO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICAgIC8vIFRoZSBgeC1nb29nLXVwbG9hZC1zdGF0dXNgIGhlYWRlciBmaWVsZCBjYW4gYmUgYGFjdGl2ZWAsIGBmaW5hbGAgYW5kXG4gICAgICAgIC8vYGNhbmNlbGxlZGAgaW4gcmVzcG9zbmUuXG4gICAgICAgIGlmICgoKF9iID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oYi80MDEzOTE0MzApIEludmVzdGlnYXRlIHdoeSB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkXG4gICAgICAgIC8vIGV2ZW4gdGhvdWdoIGFsbCBjb250ZW50IGhhcyBiZWVuIHVwbG9hZGVkLlxuICAgICAgICBpZiAoZmlsZVNpemUgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBjb250ZW50IGhhcyBiZWVuIHVwbG9hZGVkLCBidXQgdGhlIHVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXNwb25zZUpzb24gPSAoYXdhaXQgKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5qc29uKCkpKTtcbiAgICBpZiAoKChfYyA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdmaW5hbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIGZpbGU6IFVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlSnNvblsnZmlsZSddO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QmxvYlN0YXQoZmlsZSkge1xuICAgIGNvbnN0IGZpbGVTdGF0ID0geyBzaXplOiBmaWxlLnNpemUsIHR5cGU6IGZpbGUudHlwZSB9O1xuICAgIHJldHVybiBmaWxlU3RhdDtcbn1cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlUHJvbWlzZSkgPT4gc2V0VGltZW91dChyZXNvbHZlUHJvbWlzZSwgbXMpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTm9kZVVwbG9hZGVyIHtcbiAgICBhc3luYyBzdGF0KGZpbGUpIHtcbiAgICAgICAgY29uc3QgZmlsZVN0YXQgPSB7IHNpemU6IDAsIHR5cGU6IHVuZGVmaW5lZCB9O1xuICAgICAgICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0YXQgPSBhd2FpdCBmcy5zdGF0KGZpbGUpO1xuICAgICAgICAgICAgZmlsZVN0YXQuc2l6ZSA9IG9yaWdpbmFsU3RhdC5zaXplO1xuICAgICAgICAgICAgZmlsZVN0YXQudHlwZSA9IHRoaXMuaW5mZXJNaW1lVHlwZShmaWxlKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlU3RhdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBnZXRCbG9iU3RhdChmaWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGxvYWQoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudXBsb2FkRmlsZUZyb21QYXRoKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWRCbG9iKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmZlcnMgdGhlIE1JTUUgdHlwZSBvZiBhIGZpbGUgYmFzZWQgb24gaXRzIGV4dGVuc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCBUaGUgcGF0aCB0byB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgTUlNRSB0eXBlIG9mIHRoZSBmaWxlLCBvciB1bmRlZmluZWQgaWYgaXQgY2Fubm90IGJlIGluZmVycmVkLlxuICAgICAqL1xuICAgIGluZmVyTWltZVR5cGUoZmlsZVBhdGgpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBmaWxlIGV4dGVuc2lvbi5cbiAgICAgICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IGZpbGVQYXRoLnNsaWNlKGZpbGVQYXRoLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbWFwIG9mIGZpbGUgZXh0ZW5zaW9ucyB0byBNSU1FIHR5cGVzLlxuICAgICAgICBjb25zdCBtaW1lVHlwZXMgPSB7XG4gICAgICAgICAgICAnYWFjJzogJ2F1ZGlvL2FhYycsXG4gICAgICAgICAgICAnYWJ3JzogJ2FwcGxpY2F0aW9uL3gtYWJpd29yZCcsXG4gICAgICAgICAgICAnYXJjJzogJ2FwcGxpY2F0aW9uL3gtZnJlZWFyYycsXG4gICAgICAgICAgICAnYXZpJzogJ3ZpZGVvL3gtbXN2aWRlbycsXG4gICAgICAgICAgICAnYXp3JzogJ2FwcGxpY2F0aW9uL3ZuZC5hbWF6b24uZWJvb2snLFxuICAgICAgICAgICAgJ2Jpbic6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICAgICAgJ2JtcCc6ICdpbWFnZS9ibXAnLFxuICAgICAgICAgICAgJ2J6JzogJ2FwcGxpY2F0aW9uL3gtYnppcCcsXG4gICAgICAgICAgICAnYnoyJzogJ2FwcGxpY2F0aW9uL3gtYnppcDInLFxuICAgICAgICAgICAgJ2NzaCc6ICdhcHBsaWNhdGlvbi94LWNzaCcsXG4gICAgICAgICAgICAnY3NzJzogJ3RleHQvY3NzJyxcbiAgICAgICAgICAgICdjc3YnOiAndGV4dC9jc3YnLFxuICAgICAgICAgICAgJ2RvYyc6ICdhcHBsaWNhdGlvbi9tc3dvcmQnLFxuICAgICAgICAgICAgJ2RvY3gnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICAgICAgICAgICAgJ2VvdCc6ICdhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdCcsXG4gICAgICAgICAgICAnZXB1Yic6ICdhcHBsaWNhdGlvbi9lcHViK3ppcCcsXG4gICAgICAgICAgICAnZ3onOiAnYXBwbGljYXRpb24vZ3ppcCcsXG4gICAgICAgICAgICAnZ2lmJzogJ2ltYWdlL2dpZicsXG4gICAgICAgICAgICAnaHRtJzogJ3RleHQvaHRtbCcsXG4gICAgICAgICAgICAnaHRtbCc6ICd0ZXh0L2h0bWwnLFxuICAgICAgICAgICAgJ2ljbyc6ICdpbWFnZS92bmQubWljcm9zb2Z0Lmljb24nLFxuICAgICAgICAgICAgJ2ljcyc6ICd0ZXh0L2NhbGVuZGFyJyxcbiAgICAgICAgICAgICdqYXInOiAnYXBwbGljYXRpb24vamF2YS1hcmNoaXZlJyxcbiAgICAgICAgICAgICdqcGVnJzogJ2ltYWdlL2pwZWcnLFxuICAgICAgICAgICAgJ2pwZyc6ICdpbWFnZS9qcGVnJyxcbiAgICAgICAgICAgICdqcyc6ICd0ZXh0L2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgJ2pzb24nOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnanNvbmxkJzogJ2FwcGxpY2F0aW9uL2xkK2pzb24nLFxuICAgICAgICAgICAgJ2ttbCc6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttbCt4bWwnLFxuICAgICAgICAgICAgJ2tteic6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmtteit4bWwnLFxuICAgICAgICAgICAgJ21qcyc6ICd0ZXh0L2phdmFzY3JpcHQnLFxuICAgICAgICAgICAgJ21wMyc6ICdhdWRpby9tcGVnJyxcbiAgICAgICAgICAgICdtcDQnOiAndmlkZW8vbXA0JyxcbiAgICAgICAgICAgICdtcGVnJzogJ3ZpZGVvL21wZWcnLFxuICAgICAgICAgICAgJ21wa2cnOiAnYXBwbGljYXRpb24vdm5kLmFwcGxlLmluc3RhbGxlcit4bWwnLFxuICAgICAgICAgICAgJ29kdCc6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQnLFxuICAgICAgICAgICAgJ29nYSc6ICdhdWRpby9vZ2cnLFxuICAgICAgICAgICAgJ29ndic6ICd2aWRlby9vZ2cnLFxuICAgICAgICAgICAgJ29neCc6ICdhcHBsaWNhdGlvbi9vZ2cnLFxuICAgICAgICAgICAgJ29wdXMnOiAnYXVkaW8vb3B1cycsXG4gICAgICAgICAgICAnb3RmJzogJ2ZvbnQvb3RmJyxcbiAgICAgICAgICAgICdwbmcnOiAnaW1hZ2UvcG5nJyxcbiAgICAgICAgICAgICdwZGYnOiAnYXBwbGljYXRpb24vcGRmJyxcbiAgICAgICAgICAgICdwaHAnOiAnYXBwbGljYXRpb24veC1odHRwZC1waHAnLFxuICAgICAgICAgICAgJ3BwdCc6ICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludCcsXG4gICAgICAgICAgICAncHB0eCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgICdyYXInOiAnYXBwbGljYXRpb24vdm5kLnJhcicsXG4gICAgICAgICAgICAncnRmJzogJ2FwcGxpY2F0aW9uL3J0ZicsXG4gICAgICAgICAgICAnc2gnOiAnYXBwbGljYXRpb24veC1zaCcsXG4gICAgICAgICAgICAnc3ZnJzogJ2ltYWdlL3N2Zyt4bWwnLFxuICAgICAgICAgICAgJ3N3Zic6ICdhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCcsXG4gICAgICAgICAgICAndGFyJzogJ2FwcGxpY2F0aW9uL3gtdGFyJyxcbiAgICAgICAgICAgICd0aWYnOiAnaW1hZ2UvdGlmZicsXG4gICAgICAgICAgICAndGlmZic6ICdpbWFnZS90aWZmJyxcbiAgICAgICAgICAgICd0cyc6ICd2aWRlby9tcDJ0JyxcbiAgICAgICAgICAgICd0dGYnOiAnZm9udC90dGYnLFxuICAgICAgICAgICAgJ3R4dCc6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICAgICd2c2QnOiAnYXBwbGljYXRpb24vdm5kLnZpc2lvJyxcbiAgICAgICAgICAgICd3YXYnOiAnYXVkaW8vd2F2JyxcbiAgICAgICAgICAgICd3ZWJhJzogJ2F1ZGlvL3dlYm0nLFxuICAgICAgICAgICAgJ3dlYm0nOiAndmlkZW8vd2VibScsXG4gICAgICAgICAgICAnd2VicCc6ICdpbWFnZS93ZWJwJyxcbiAgICAgICAgICAgICd3b2ZmJzogJ2ZvbnQvd29mZicsXG4gICAgICAgICAgICAnd29mZjInOiAnZm9udC93b2ZmMicsXG4gICAgICAgICAgICAneGh0bWwnOiAnYXBwbGljYXRpb24veGh0bWwreG1sJyxcbiAgICAgICAgICAgICd4bHMnOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJyxcbiAgICAgICAgICAgICd4bHN4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0JyxcbiAgICAgICAgICAgICd4bWwnOiAnYXBwbGljYXRpb24veG1sJyxcbiAgICAgICAgICAgICd4dWwnOiAnYXBwbGljYXRpb24vdm5kLm1vemlsbGEueHVsK3htbCcsXG4gICAgICAgICAgICAnemlwJzogJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICAgICAgICAgICAnM2dwJzogJ3ZpZGVvLzNncHAnLFxuICAgICAgICAgICAgJzNnMic6ICd2aWRlby8zZ3BwMicsXG4gICAgICAgICAgICAnN3onOiAnYXBwbGljYXRpb24veC03ei1jb21wcmVzc2VkJyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgTUlNRSB0eXBlIGJhc2VkIG9uIHRoZSBmaWxlIGV4dGVuc2lvbi5cbiAgICAgICAgY29uc3QgbWltZVR5cGUgPSBtaW1lVHlwZXNbZmlsZUV4dGVuc2lvbi50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgLy8gUmV0dXJuIHRoZSBNSU1FIHR5cGUuXG4gICAgICAgIHJldHVybiBtaW1lVHlwZTtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkRmlsZUZyb21QYXRoKGZpbGUsIHVwbG9hZFVybCwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgZmlsZVNpemUgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gbmV3IEh0dHBSZXNwb25zZShuZXcgUmVzcG9uc2UoKSk7XG4gICAgICAgIGxldCB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XG4gICAgICAgIGxldCBmaWxlSGFuZGxlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmlsZUhhbmRsZSA9IGF3YWl0IGZzLm9wZW4oZmlsZSwgJ3InKTtcbiAgICAgICAgICAgIGlmICghZmlsZUhhbmRsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIG9wZW4gZmlsZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZVNpemUgPSAoYXdhaXQgZmlsZUhhbmRsZS5zdGF0KCkpLnNpemU7XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgZmlsZVNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1NpemUgPSBNYXRoLm1pbihNQVhfQ0hVTktfU0laRSwgZmlsZVNpemUgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgKyBjaHVua1NpemUgPj0gZmlsZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkQ29tbWFuZCArPSAnLCBmaW5hbGl6ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBieXRlc1JlYWQ6IGJ5dGVzUmVhZCB9ID0gYXdhaXQgZmlsZUhhbmRsZS5yZWFkKGJ1ZmZlciwgMCwgY2h1bmtTaXplLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChieXRlc1JlYWQgIT09IGNodW5rU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZWFkICR7Y2h1bmtTaXplfSBieXRlcyBmcm9tIGZpbGUgYXQgb2Zmc2V0ICR7b2Zmc2V0fS4gYnl0ZXMgYWN0dWFsbHkgcmVhZDogJHtieXRlc1JlYWR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gbmV3IEJsb2IoW2J1ZmZlcl0pO1xuICAgICAgICAgICAgICAgIGxldCByZXRyeUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudERlbGF5TXMgPSBJTklUSUFMX1JFVFJZX0RFTEFZX01TO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZXRyeUNvdW50IDwgTUFYX1JFVFJZX0NPVU5UKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpVmVyc2lvbjogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybDogdXBsb2FkVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6IHVwbG9hZENvbW1hbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IFN0cmluZyhvZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBTdHJpbmcoYnl0ZXNSZWFkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoY3VycmVudERlbGF5TXMpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGVsYXlNcyA9IGN1cnJlbnREZWxheU1zICogREVMQVlfTVVMVElQTElFUjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGJ5dGVzUmVhZDtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYHgtZ29vZy11cGxvYWQtc3RhdHVzYCBoZWFkZXIgZmllbGQgY2FuIGJlIGBhY3RpdmVgLCBgZmluYWxgIGFuZFxuICAgICAgICAgICAgICAgIC8vYGNhbmNlbGxlZGAgaW4gcmVzcG9zbmUuXG4gICAgICAgICAgICAgICAgaWYgKCgoX2IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVTaXplIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCBjb250ZW50IGhhcyBiZWVuIHVwbG9hZGVkLCBidXQgdGhlIHVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUpzb24gPSAoYXdhaXQgKHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5qc29uKCkpKTtcbiAgICAgICAgICAgIGlmICgoKF9jID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1tYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2ZpbmFsJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHVwbG9hZCBmaWxlOiBVcGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VKc29uWydmaWxlJ107XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGZpbGUgaGFuZGxlIGlzIGFsd2F5cyBjbG9zZWRcbiAgICAgICAgICAgIGlmIChmaWxlSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmlsZUhhbmRsZS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBMQU5HVUFHRV9MQUJFTF9QUkVGSVggPSAnZ2wtbm9kZS8nO1xuLyoqXG4gKiBUaGUgR29vZ2xlIEdlbkFJIFNESy5cbiAqXG4gKiBAcmVtYXJrc1xuICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBHZW5BSSBmZWF0dXJlcyB0aHJvdWdoIGVpdGhlciB0aGUge0BsaW5rXG4gKiBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2RvY3MvcmVmZXJlbmNlL3Jlc3QgfCBHZW1pbmkgQVBJfSBvclxuICogdGhlIHtAbGluayBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vdmVydGV4LWFpL2RvY3MvcmVmZXJlbmNlL3Jlc3QgfCBWZXJ0ZXggQUlcbiAqIEFQSX0uXG4gKlxuICogVGhlIHtAbGluayBHb29nbGVHZW5BSU9wdGlvbnMudmVydGV4YWl9IHZhbHVlIGRldGVybWluZXMgd2hpY2ggb2YgdGhlIEFQSVxuICogc2VydmljZXMgdG8gdXNlLlxuICpcbiAqIFdoZW4gdXNpbmcgdGhlIEdlbWluaSBBUEksIGEge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9ucy5hcGlLZXl9IG11c3QgYWxzbyBiZVxuICogc2V0LiBXaGVuIHVzaW5nIFZlcnRleCBBSSwgYm90aCB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLnByb2plY3R9IGFuZCB7QGxpbmtcbiAqIEdvb2dsZUdlbkFJT3B0aW9ucy5sb2NhdGlvbn0gbXVzdCBiZSBzZXQsIG9yIGEge0BsaW5rXG4gKiBHb29nbGVHZW5BSU9wdGlvbnMuYXBpS2V5fSBtdXN0IGJlIHNldCB3aGVuIHVzaW5nIEV4cHJlc3MgTW9kZS5cbiAqXG4gKiBFeHBsaWNpdGx5IHBhc3NlZCBpbiB2YWx1ZXMgaW4ge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9uc30gd2lsbCBhbHdheXMgdGFrZVxuICogcHJlY2VkZW5jZSBvdmVyIGVudmlyb25tZW50IHZhcmlhYmxlcy4gSWYgYm90aCBwcm9qZWN0L2xvY2F0aW9uIGFuZCBhcGlfa2V5XG4gKiBleGlzdCBpbiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLCB0aGUgcHJvamVjdC9sb2NhdGlvbiB3aWxsIGJlIHVzZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIEluaXRpYWxpemluZyB0aGUgU0RLIGZvciB1c2luZyB0aGUgR2VtaW5pIEFQSTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6ICdHRU1JTklfQVBJX0tFWSd9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBJbml0aWFsaXppbmcgdGhlIFNESyBmb3IgdXNpbmcgdGhlIFZlcnRleCBBSSBBUEk6XG4gKiBgYGB0c1xuICogaW1wb3J0IHtHb29nbGVHZW5BSX0gZnJvbSAnQGdvb2dsZS9nZW5haSc7XG4gKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7XG4gKiAgIHZlcnRleGFpOiB0cnVlLFxuICogICBwcm9qZWN0OiAnUFJPSkVDVF9JRCcsXG4gKiAgIGxvY2F0aW9uOiAnUFJPSkVDVF9MT0NBVElPTidcbiAqIH0pO1xuICogYGBgXG4gKlxuICovXG5jbGFzcyBHb29nbGVHZW5BSSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgLy8gVmFsaWRhdGUgZXhwbGljaXRseSBzZXQgaW5pdGlhbGl6ZXIgdmFsdWVzLlxuICAgICAgICBpZiAoKG9wdGlvbnMucHJvamVjdCB8fCBvcHRpb25zLmxvY2F0aW9uKSAmJiBvcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0L2xvY2F0aW9uIGFuZCBBUEkga2V5IGFyZSBtdXR1YWxseSBleGNsdXNpdmUgaW4gdGhlIGNsaWVudCBpbml0aWFsaXplci4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnRleGFpID1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IG9wdGlvbnMudmVydGV4YWkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGdldEJvb2xlYW5FbnYoJ0dPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUknKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIGNvbnN0IGVudkFwaUtleSA9IGdldEFwaUtleUZyb21FbnYoKTtcbiAgICAgICAgY29uc3QgZW52UHJvamVjdCA9IGdldEVudignR09PR0xFX0NMT1VEX1BST0pFQ1QnKTtcbiAgICAgICAgY29uc3QgZW52TG9jYXRpb24gPSBnZXRFbnYoJ0dPT0dMRV9DTE9VRF9MT0NBVElPTicpO1xuICAgICAgICB0aGlzLmFwaUtleSA9IChfYyA9IG9wdGlvbnMuYXBpS2V5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBlbnZBcGlLZXk7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IChfZCA9IG9wdGlvbnMucHJvamVjdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZW52UHJvamVjdDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IChfZSA9IG9wdGlvbnMubG9jYXRpb24pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGVudkxvY2F0aW9uO1xuICAgICAgICAvLyBIYW5kbGUgd2hlbiB0byB1c2UgVmVydGV4IEFJIGluIGV4cHJlc3MgbW9kZSAoYXBpIGtleSlcbiAgICAgICAgaWYgKG9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIGlmICgoX2YgPSBvcHRpb25zLmdvb2dsZUF1dGhPcHRpb25zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBjcmVkZW50aWFscyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBpbXBsaWNpdCBhcGlfa2V5LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1RoZSB1c2VyIHByb3ZpZGVkIEdvb2dsZSBDbG91ZCBjcmVkZW50aWFscyB3aWxsIHRha2UgcHJlY2VkZW5jZScgK1xuICAgICAgICAgICAgICAgICAgICAnIG92ZXIgdGhlIEFQSSBrZXkgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCBhcGlfa2V5IGFuZCBleHBsaWNpdCBwcm9qZWN0L2xvY2F0aW9uIGFscmVhZHkgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgICAgIGlmICgoZW52UHJvamVjdCB8fCBlbnZMb2NhdGlvbikgJiYgb3B0aW9ucy5hcGlLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBhcGlfa2V5IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBpbXBsaWNpdCBwcm9qZWN0L2xvY2F0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1RoZSB1c2VyIHByb3ZpZGVkIFZlcnRleCBBSSBBUEkga2V5IHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXInICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aGUgcHJvamVjdC9sb2NhdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgob3B0aW9ucy5wcm9qZWN0IHx8IG9wdGlvbnMubG9jYXRpb24pICYmIGVudkFwaUtleSkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IHByb2plY3QvbG9jYXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IGFwaV9rZXkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHVzZXIgcHJvdmlkZWQgcHJvamVjdC9sb2NhdGlvbiB3aWxsIHRha2UgcHJlY2VkZW5jZSBvdmVyJyArXG4gICAgICAgICAgICAgICAgICAgICcgdGhlIEFQSSBrZXkgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBpS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGVudlByb2plY3QgfHwgZW52TG9jYXRpb24pICYmIGVudkFwaUtleSkge1xuICAgICAgICAgICAgICAgIC8vIEltcGxpY2l0IHByb2plY3QvbG9jYXRpb24gdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IGFwaV9rZXkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHByb2plY3QvbG9jYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIHdpbGwgdGFrZScgK1xuICAgICAgICAgICAgICAgICAgICAnIHByZWNlZGVuY2Ugb3ZlciB0aGUgQVBJIGtleSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwob3B0aW9ucy5odHRwT3B0aW9ucywgb3B0aW9ucy52ZXJ0ZXhhaSwgZ2V0RW52KCdHT09HTEVfVkVSVEVYX0JBU0VfVVJMJyksIGdldEVudignR09PR0xFX0dFTUlOSV9CQVNFX1VSTCcpKTtcbiAgICAgICAgaWYgKGJhc2VVcmwpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5odHRwT3B0aW9ucy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaHR0cE9wdGlvbnMgPSB7IGJhc2VVcmw6IGJhc2VVcmwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaVZlcnNpb24gPSBvcHRpb25zLmFwaVZlcnNpb247XG4gICAgICAgIGNvbnN0IGF1dGggPSBuZXcgTm9kZUF1dGgoe1xuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIGdvb2dsZUF1dGhPcHRpb25zOiBvcHRpb25zLmdvb2dsZUF1dGhPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgQXBpQ2xpZW50KHtcbiAgICAgICAgICAgIGF1dGg6IGF1dGgsXG4gICAgICAgICAgICBwcm9qZWN0OiB0aGlzLnByb2plY3QsXG4gICAgICAgICAgICBsb2NhdGlvbjogdGhpcy5sb2NhdGlvbixcbiAgICAgICAgICAgIGFwaVZlcnNpb246IHRoaXMuYXBpVmVyc2lvbixcbiAgICAgICAgICAgIGFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICB2ZXJ0ZXhhaTogdGhpcy52ZXJ0ZXhhaSxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zOiBvcHRpb25zLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgdXNlckFnZW50RXh0cmE6IExBTkdVQUdFX0xBQkVMX1BSRUZJWCArIHByb2Nlc3MudmVyc2lvbixcbiAgICAgICAgICAgIHVwbG9hZGVyOiBuZXcgTm9kZVVwbG9hZGVyKCksXG4gICAgICAgICAgICBkb3dubG9hZGVyOiBuZXcgTm9kZURvd25sb2FkZXIoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWxzID0gbmV3IE1vZGVscyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMubGl2ZSA9IG5ldyBMaXZlKHRoaXMuYXBpQ2xpZW50LCBhdXRoLCBuZXcgTm9kZVdlYlNvY2tldEZhY3RvcnkoKSk7XG4gICAgICAgIHRoaXMuYmF0Y2hlcyA9IG5ldyBCYXRjaGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5jaGF0cyA9IG5ldyBDaGF0cyh0aGlzLm1vZGVscywgdGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmNhY2hlcyA9IG5ldyBDYWNoZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmZpbGVzID0gbmV3IEZpbGVzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zID0gbmV3IE9wZXJhdGlvbnModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmF1dGhUb2tlbnMgPSBuZXcgVG9rZW5zKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy50dW5pbmdzID0gbmV3IFR1bmluZ3ModGhpcy5hcGlDbGllbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVudihlbnYpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLmVudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Vudl0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50cmltKCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEJvb2xlYW5FbnYoZW52KSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvQm9vbGVhbihnZXRFbnYoZW52KSk7XG59XG5mdW5jdGlvbiBzdHJpbmdUb0Jvb2xlYW4oc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG5mdW5jdGlvbiBnZXRBcGlLZXlGcm9tRW52KCkge1xuICAgIGNvbnN0IGVudkdvb2dsZUFwaUtleSA9IGdldEVudignR09PR0xFX0FQSV9LRVknKTtcbiAgICBjb25zdCBlbnZHZW1pbmlBcGlLZXkgPSBnZXRFbnYoJ0dFTUlOSV9BUElfS0VZJyk7XG4gICAgaWYgKGVudkdvb2dsZUFwaUtleSAmJiBlbnZHZW1pbmlBcGlLZXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdCb3RoIEdPT0dMRV9BUElfS0VZIGFuZCBHRU1JTklfQVBJX0tFWSBhcmUgc2V0LiBVc2luZyBHT09HTEVfQVBJX0tFWS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudkdvb2dsZUFwaUtleSB8fCBlbnZHZW1pbmlBcGlLZXk7XG59XG5cbmV4cG9ydCB7IEFjdGl2aXR5SGFuZGxpbmcsIEFkYXB0ZXJTaXplLCBBcGlFcnJvciwgQXBpU3BlYywgQXV0aFR5cGUsIEJhdGNoZXMsIEJlaGF2aW9yLCBCbG9ja2VkUmVhc29uLCBDYWNoZXMsIENoYXQsIENoYXRzLCBDb21wdXRlVG9rZW5zUmVzcG9uc2UsIENvbnRyb2xSZWZlcmVuY2VJbWFnZSwgQ29udHJvbFJlZmVyZW5jZVR5cGUsIENvdW50VG9rZW5zUmVzcG9uc2UsIENyZWF0ZUZpbGVSZXNwb25zZSwgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlLCBEZWxldGVGaWxlUmVzcG9uc2UsIERlbGV0ZU1vZGVsUmVzcG9uc2UsIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlLCBFZGl0SW1hZ2VSZXNwb25zZSwgRWRpdE1vZGUsIEVtYmVkQ29udGVudFJlc3BvbnNlLCBFbmRTZW5zaXRpdml0eSwgRW52aXJvbm1lbnQsIEZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlLCBGaWxlU291cmNlLCBGaWxlU3RhdGUsIEZpbGVzLCBGaW5pc2hSZWFzb24sIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUsIEZ1bmN0aW9uUmVzcG9uc2UsIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nLCBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSwgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VQcm9tcHRGZWVkYmFjaywgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VVc2FnZU1ldGFkYXRhLCBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlLCBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbiwgR2VuZXJhdGVWaWRlb3NSZXNwb25zZSwgR29vZ2xlR2VuQUksIEhhcm1CbG9ja01ldGhvZCwgSGFybUJsb2NrVGhyZXNob2xkLCBIYXJtQ2F0ZWdvcnksIEhhcm1Qcm9iYWJpbGl0eSwgSGFybVNldmVyaXR5LCBIdHRwUmVzcG9uc2UsIEltYWdlUHJvbXB0TGFuZ3VhZ2UsIElubGluZWRSZXNwb25zZSwgSm9iU3RhdGUsIExhbmd1YWdlLCBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UsIExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlLCBMaXN0RmlsZXNSZXNwb25zZSwgTGlzdE1vZGVsc1Jlc3BvbnNlLCBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlLCBMaXZlLCBMaXZlQ2xpZW50VG9vbFJlc3BvbnNlLCBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wsIExpdmVNdXNpY1NlcnZlck1lc3NhZ2UsIExpdmVTZW5kVG9vbFJlc3BvbnNlUGFyYW1ldGVycywgTGl2ZVNlcnZlck1lc3NhZ2UsIE1hc2tSZWZlcmVuY2VJbWFnZSwgTWFza1JlZmVyZW5jZU1vZGUsIE1lZGlhTW9kYWxpdHksIE1lZGlhUmVzb2x1dGlvbiwgTW9kYWxpdHksIE1vZGUsIE1vZGVscywgTXVzaWNHZW5lcmF0aW9uTW9kZSwgT3BlcmF0aW9ucywgT3V0Y29tZSwgUGFnZWRJdGVtLCBQYWdlciwgUGVyc29uR2VuZXJhdGlvbiwgUmF3UmVmZXJlbmNlSW1hZ2UsIFJlY29udGV4dEltYWdlUmVzcG9uc2UsIFJlcGxheVJlc3BvbnNlLCBTYWZldHlGaWx0ZXJMZXZlbCwgU2NhbGUsIFNlZ21lbnRJbWFnZVJlc3BvbnNlLCBTZWdtZW50TW9kZSwgU2Vzc2lvbiwgU3RhcnRTZW5zaXRpdml0eSwgU3R5bGVSZWZlcmVuY2VJbWFnZSwgU3ViamVjdFJlZmVyZW5jZUltYWdlLCBTdWJqZWN0UmVmZXJlbmNlVHlwZSwgVG9rZW5zLCBUcmFmZmljVHlwZSwgVHVuaW5nTW9kZSwgVHVybkNvdmVyYWdlLCBUeXBlLCBVcHNjYWxlSW1hZ2VSZXNwb25zZSwgVXJsUmV0cmlldmFsU3RhdHVzLCBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eSwgY3JlYXRlTW9kZWxDb250ZW50LCBjcmVhdGVQYXJ0RnJvbUJhc2U2NCwgY3JlYXRlUGFydEZyb21Db2RlRXhlY3V0aW9uUmVzdWx0LCBjcmVhdGVQYXJ0RnJvbUV4ZWN1dGFibGVDb2RlLCBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uQ2FsbCwgY3JlYXRlUGFydEZyb21GdW5jdGlvblJlc3BvbnNlLCBjcmVhdGVQYXJ0RnJvbVRleHQsIGNyZWF0ZVBhcnRGcm9tVXJpLCBjcmVhdGVVc2VyQ29udGVudCwgbWNwVG9Ub29sLCBzZXREZWZhdWx0QmFzZVVybHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJHb29nbGVBdXRoIiwiY3JlYXRlV3JpdGVTdHJlYW0iLCJ3cml0ZUZpbGUiLCJSZWFkYWJsZSIsIk5vZGVXcyIsImZzIiwiX2RlZmF1bHRCYXNlR2VtaW5pVXJsIiwidW5kZWZpbmVkIiwiX2RlZmF1bHRCYXNlVmVydGV4VXJsIiwic2V0RGVmYXVsdEJhc2VVcmxzIiwiYmFzZVVybFBhcmFtcyIsImdlbWluaVVybCIsInZlcnRleFVybCIsImdldERlZmF1bHRCYXNlVXJscyIsImdldEJhc2VVcmwiLCJodHRwT3B0aW9ucyIsInZlcnRleGFpIiwidmVydGV4QmFzZVVybEZyb21FbnYiLCJnZW1pbmlCYXNlVXJsRnJvbUVudiIsIl9hIiwiX2IiLCJiYXNlVXJsIiwiZGVmYXVsdEJhc2VVcmxzIiwiQmFzZU1vZHVsZSIsImZvcm1hdE1hcCIsInRlbXBsYXRlU3RyaW5nIiwidmFsdWVNYXAiLCJyZWdleCIsInJlcGxhY2UiLCJtYXRjaCIsImtleSIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsInZhbHVlIiwiU3RyaW5nIiwiRXJyb3IiLCJzZXRWYWx1ZUJ5UGF0aCIsImRhdGEiLCJrZXlzIiwiaSIsImxlbmd0aCIsImVuZHNXaXRoIiwia2V5TmFtZSIsInNsaWNlIiwiQXJyYXkiLCJpc0FycmF5IiwiZnJvbSIsImFycmF5RGF0YSIsImoiLCJlbnRyeSIsImQiLCJrZXlUb1NldCIsImV4aXN0aW5nRGF0YSIsImFzc2lnbiIsImdldFZhbHVlQnlQYXRoIiwibWFwIiwiZXJyb3IiLCJUeXBlRXJyb3IiLCJ0Qnl0ZXMkMSIsImZyb21CeXRlcyIsIk91dGNvbWUiLCJMYW5ndWFnZSIsIlR5cGUiLCJIYXJtQ2F0ZWdvcnkiLCJIYXJtQmxvY2tNZXRob2QiLCJIYXJtQmxvY2tUaHJlc2hvbGQiLCJNb2RlIiwiQXV0aFR5cGUiLCJBcGlTcGVjIiwiVXJsUmV0cmlldmFsU3RhdHVzIiwiRmluaXNoUmVhc29uIiwiSGFybVByb2JhYmlsaXR5IiwiSGFybVNldmVyaXR5IiwiQmxvY2tlZFJlYXNvbiIsIlRyYWZmaWNUeXBlIiwiTW9kYWxpdHkiLCJNZWRpYVJlc29sdXRpb24iLCJKb2JTdGF0ZSIsIlR1bmluZ01vZGUiLCJBZGFwdGVyU2l6ZSIsIkZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlIiwiQmVoYXZpb3IiLCJEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSIsIkVudmlyb25tZW50IiwiRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSIsIlNhZmV0eUZpbHRlckxldmVsIiwiUGVyc29uR2VuZXJhdGlvbiIsIkltYWdlUHJvbXB0TGFuZ3VhZ2UiLCJNYXNrUmVmZXJlbmNlTW9kZSIsIkNvbnRyb2xSZWZlcmVuY2VUeXBlIiwiU3ViamVjdFJlZmVyZW5jZVR5cGUiLCJFZGl0TW9kZSIsIlNlZ21lbnRNb2RlIiwiVmlkZW9Db21wcmVzc2lvblF1YWxpdHkiLCJGaWxlU3RhdGUiLCJGaWxlU291cmNlIiwiTWVkaWFNb2RhbGl0eSIsIlN0YXJ0U2Vuc2l0aXZpdHkiLCJFbmRTZW5zaXRpdml0eSIsIkFjdGl2aXR5SGFuZGxpbmciLCJUdXJuQ292ZXJhZ2UiLCJGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZyIsIlNjYWxlIiwiTXVzaWNHZW5lcmF0aW9uTW9kZSIsIkxpdmVNdXNpY1BsYXliYWNrQ29udHJvbCIsIkZ1bmN0aW9uUmVzcG9uc2UiLCJjcmVhdGVQYXJ0RnJvbVVyaSIsInVyaSIsIm1pbWVUeXBlIiwiZmlsZURhdGEiLCJmaWxlVXJpIiwiY3JlYXRlUGFydEZyb21UZXh0IiwidGV4dCIsImNyZWF0ZVBhcnRGcm9tRnVuY3Rpb25DYWxsIiwibmFtZSIsImFyZ3MiLCJmdW5jdGlvbkNhbGwiLCJjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uUmVzcG9uc2UiLCJpZCIsInJlc3BvbnNlIiwiZnVuY3Rpb25SZXNwb25zZSIsImNyZWF0ZVBhcnRGcm9tQmFzZTY0IiwiaW5saW5lRGF0YSIsImNyZWF0ZVBhcnRGcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCIsIm91dGNvbWUiLCJvdXRwdXQiLCJjb2RlRXhlY3V0aW9uUmVzdWx0IiwiY3JlYXRlUGFydEZyb21FeGVjdXRhYmxlQ29kZSIsImNvZGUiLCJsYW5ndWFnZSIsImV4ZWN1dGFibGVDb2RlIiwiX2lzUGFydCIsIm9iaiIsIl90b1BhcnRzIiwicGFydE9yU3RyaW5nIiwicGFydHMiLCJwdXNoIiwicGFydCIsImNyZWF0ZVVzZXJDb250ZW50Iiwicm9sZSIsImNyZWF0ZU1vZGVsQ29udGVudCIsIkh0dHBSZXNwb25zZSIsImNvbnN0cnVjdG9yIiwiaGVhZGVycyIsInBhaXIiLCJlbnRyaWVzIiwicmVzcG9uc2VJbnRlcm5hbCIsImpzb24iLCJHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVByb21wdEZlZWRiYWNrIiwiR2VuZXJhdGVDb250ZW50UmVzcG9uc2VVc2FnZU1ldGFkYXRhIiwiR2VuZXJhdGVDb250ZW50UmVzcG9uc2UiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJjYW5kaWRhdGVzIiwiY29udGVudCIsImNvbnNvbGUiLCJ3YXJuIiwiYW55VGV4dFBhcnRUZXh0Iiwibm9uVGV4dFBhcnRzIiwiZmllbGROYW1lIiwiZmllbGRWYWx1ZSIsInRob3VnaHQiLCJub25EYXRhUGFydHMiLCJhdG9iIiwiYnRvYSIsImZ1bmN0aW9uQ2FsbHMiLCJmaWx0ZXIiLCJfaiIsIkVtYmVkQ29udGVudFJlc3BvbnNlIiwiR2VuZXJhdGVJbWFnZXNSZXNwb25zZSIsIkVkaXRJbWFnZVJlc3BvbnNlIiwiVXBzY2FsZUltYWdlUmVzcG9uc2UiLCJSZWNvbnRleHRJbWFnZVJlc3BvbnNlIiwiU2VnbWVudEltYWdlUmVzcG9uc2UiLCJMaXN0TW9kZWxzUmVzcG9uc2UiLCJEZWxldGVNb2RlbFJlc3BvbnNlIiwiQ291bnRUb2tlbnNSZXNwb25zZSIsIkNvbXB1dGVUb2tlbnNSZXNwb25zZSIsIkdlbmVyYXRlVmlkZW9zUmVzcG9uc2UiLCJMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlIiwiRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlIiwiTGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2UiLCJMaXN0RmlsZXNSZXNwb25zZSIsIkNyZWF0ZUZpbGVSZXNwb25zZSIsIkRlbGV0ZUZpbGVSZXNwb25zZSIsIklubGluZWRSZXNwb25zZSIsIkxpc3RCYXRjaEpvYnNSZXNwb25zZSIsIlJlcGxheVJlc3BvbnNlIiwiUmF3UmVmZXJlbmNlSW1hZ2UiLCJ0b1JlZmVyZW5jZUltYWdlQVBJIiwicmVmZXJlbmNlSW1hZ2VBUEkiLCJyZWZlcmVuY2VUeXBlIiwicmVmZXJlbmNlSW1hZ2UiLCJyZWZlcmVuY2VJZCIsIk1hc2tSZWZlcmVuY2VJbWFnZSIsIm1hc2tJbWFnZUNvbmZpZyIsImNvbmZpZyIsIkNvbnRyb2xSZWZlcmVuY2VJbWFnZSIsImNvbnRyb2xJbWFnZUNvbmZpZyIsIlN0eWxlUmVmZXJlbmNlSW1hZ2UiLCJzdHlsZUltYWdlQ29uZmlnIiwiU3ViamVjdFJlZmVyZW5jZUltYWdlIiwic3ViamVjdEltYWdlQ29uZmlnIiwiTGl2ZVNlcnZlck1lc3NhZ2UiLCJhbnlUZXh0UGFydEZvdW5kIiwic2VydmVyQ29udGVudCIsIm1vZGVsVHVybiIsIkdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uIiwiX2Zyb21BUElSZXNwb25zZSIsImFwaVJlc3BvbnNlIiwiaXNWZXJ0ZXhBSSIsIm9wZXJhdGlvbiIsIm1ldGFkYXRhIiwiZG9uZSIsIm9wZXJhdGlvblJlc3BvbnNlIiwicmVzcG9uc2VWaWRlb3MiLCJnZW5lcmF0ZWRWaWRlb3MiLCJnZW5lcmF0ZWRWaWRlbyIsInZpZGVvIiwidmlkZW9CeXRlcyIsInJhaU1lZGlhRmlsdGVyZWRDb3VudCIsInJhaU1lZGlhRmlsdGVyZWRSZWFzb25zIiwiZ2VuZXJhdGVkVmlkZW9SZXNwb25zZSIsIkxpdmVDbGllbnRUb29sUmVzcG9uc2UiLCJMaXZlU2VuZFRvb2xSZXNwb25zZVBhcmFtZXRlcnMiLCJmdW5jdGlvblJlc3BvbnNlcyIsIkxpdmVNdXNpY1NlcnZlck1lc3NhZ2UiLCJhdWRpb0NodW5rIiwiYXVkaW9DaHVua3MiLCJ0TW9kZWwiLCJhcGlDbGllbnQiLCJtb2RlbCIsInN0YXJ0c1dpdGgiLCJpbmRleE9mIiwic3BsaXQiLCJ0Q2FjaGVzTW9kZWwiLCJ0cmFuc2Zvcm1lZE1vZGVsIiwiZ2V0UHJvamVjdCIsImdldExvY2F0aW9uIiwidEJsb2JzIiwiYmxvYnMiLCJibG9iIiwidEJsb2IiLCJ0SW1hZ2VCbG9iIiwidHJhbnNmb3JtZWRCbG9iIiwidEF1ZGlvQmxvYiIsInRQYXJ0Iiwib3JpZ2luIiwidFBhcnRzIiwiaXRlbSIsIl9pc0NvbnRlbnQiLCJfaXNGdW5jdGlvbkNhbGxQYXJ0IiwiX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQiLCJ0Q29udGVudCIsInRDb250ZW50c0ZvckVtYmVkIiwiZmxhdE1hcCIsInRDb250ZW50cyIsInJlc3VsdCIsImFjY3VtdWxhdGVkUGFydHMiLCJpc0NvbnRlbnRBcnJheSIsImlzQ29udGVudCIsImZsYXR0ZW5UeXBlQXJyYXlUb0FueU9mIiwidHlwZUxpc3QiLCJyZXN1bHRpbmdTY2hlbWEiLCJpbmNsdWRlcyIsImxpc3RXaXRob3V0TnVsbCIsInR5cGUiLCJ2YWx1ZXMiLCJ0b1VwcGVyQ2FzZSIsIlRZUEVfVU5TUEVDSUZJRUQiLCJwcm9jZXNzSnNvblNjaGVtYSIsIl9qc29uU2NoZW1hIiwiZ2VuQUlTY2hlbWEiLCJzY2hlbWFGaWVsZE5hbWVzIiwibGlzdFNjaGVtYUZpZWxkTmFtZXMiLCJkaWN0U2NoZW1hRmllbGROYW1lcyIsImluY29taW5nQW55T2YiLCJsaXN0U2NoZW1hRmllbGRWYWx1ZSIsImRpY3RTY2hlbWFGaWVsZFZhbHVlIiwidFNjaGVtYSIsInNjaGVtYSIsInRTcGVlY2hDb25maWciLCJzcGVlY2hDb25maWciLCJ2b2ljZUNvbmZpZyIsInByZWJ1aWx0Vm9pY2VDb25maWciLCJ2b2ljZU5hbWUiLCJ0TGl2ZVNwZWVjaENvbmZpZyIsInRUb29sIiwidG9vbCIsImZ1bmN0aW9uRGVjbGFyYXRpb25zIiwiZnVuY3Rpb25EZWNsYXJhdGlvbiIsInBhcmFtZXRlcnMiLCJwYXJhbWV0ZXJzSnNvblNjaGVtYSIsInJlc3BvbnNlSnNvblNjaGVtYSIsInRUb29scyIsInRvb2xzIiwicmVzb3VyY2VOYW1lIiwiY2xpZW50IiwicmVzb3VyY2VQcmVmaXgiLCJzcGxpdHNBZnRlclByZWZpeCIsInNob3VsZEFwcGVuZFByZWZpeCIsInRDYWNoZWRDb250ZW50TmFtZSIsInRUdW5pbmdKb2JTdGF0dXMiLCJzdGF0dXMiLCJ0Qnl0ZXMiLCJmcm9tSW1hZ2VCeXRlcyIsIl9pc0ZpbGUiLCJpc0dlbmVyYXRlZFZpZGVvIiwiaXNWaWRlbyIsInRGaWxlTmFtZSIsImZyb21OYW1lIiwic3VmZml4IiwidE1vZGVsc1VybCIsImJhc2VNb2RlbHMiLCJyZXMiLCJ0RXh0cmFjdE1vZGVscyIsImhhc0ZpZWxkIiwibWNwVG9HZW1pbmlUb29sIiwibWNwVG9vbCIsIm1jcFRvb2xTY2hlbWEiLCJkZXNjcmlwdGlvbiIsImJlaGF2aW9yIiwiZ2VtaW5pVG9vbCIsIm1jcFRvb2xzVG9HZW1pbmlUb29sIiwibWNwVG9vbHMiLCJ0b29sTmFtZXMiLCJTZXQiLCJtY3BUb29sTmFtZSIsImhhcyIsImFkZCIsInRCYXRjaEpvYlNvdXJjZSIsInNyYyIsImdjc1VyaSIsImJpZ3F1ZXJ5VXJpIiwiaW5saW5lZFJlcXVlc3RzIiwiZmlsZU5hbWUiLCJmb3JtYXQiLCJ0QmF0Y2hKb2JEZXN0aW5hdGlvbiIsImRlc3QiLCJkZXN0U3RyaW5nIiwidEJhdGNoSm9iTmFtZSIsIm5hbWVTdHJpbmciLCJtbGRldlBhdHRlcm4iLCJ0ZXN0IiwicG9wIiwidmVydGV4UGF0dGVybiIsInRKb2JTdGF0ZSIsInN0YXRlIiwic3RhdGVTdHJpbmciLCJ2aWRlb01ldGFkYXRhVG9NbGRldiQ0IiwiZnJvbU9iamVjdCIsInRvT2JqZWN0IiwiZnJvbUZwcyIsImZyb21FbmRPZmZzZXQiLCJmcm9tU3RhcnRPZmZzZXQiLCJibG9iVG9NbGRldiQ0IiwiZnJvbURhdGEiLCJmcm9tTWltZVR5cGUiLCJmaWxlRGF0YVRvTWxkZXYkNCIsImZyb21GaWxlVXJpIiwicGFydFRvTWxkZXYkNCIsImZyb21WaWRlb01ldGFkYXRhIiwiZnJvbVRob3VnaHQiLCJmcm9tSW5saW5lRGF0YSIsImZyb21GaWxlRGF0YSIsImZyb21UaG91Z2h0U2lnbmF0dXJlIiwiZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQiLCJmcm9tRXhlY3V0YWJsZUNvZGUiLCJmcm9tRnVuY3Rpb25DYWxsIiwiZnJvbUZ1bmN0aW9uUmVzcG9uc2UiLCJmcm9tVGV4dCIsImNvbnRlbnRUb01sZGV2JDQiLCJmcm9tUGFydHMiLCJ0cmFuc2Zvcm1lZExpc3QiLCJmcm9tUm9sZSIsInNjaGVtYVRvTWxkZXYkMSIsImZyb21BbnlPZiIsImZyb21EZWZhdWx0IiwiZnJvbURlc2NyaXB0aW9uIiwiZnJvbUVudW0iLCJmcm9tRXhhbXBsZSIsImZyb21Gb3JtYXQiLCJmcm9tSXRlbXMiLCJmcm9tTWF4SXRlbXMiLCJmcm9tTWF4TGVuZ3RoIiwiZnJvbU1heFByb3BlcnRpZXMiLCJmcm9tTWF4aW11bSIsImZyb21NaW5JdGVtcyIsImZyb21NaW5MZW5ndGgiLCJmcm9tTWluUHJvcGVydGllcyIsImZyb21NaW5pbXVtIiwiZnJvbU51bGxhYmxlIiwiZnJvbVBhdHRlcm4iLCJmcm9tUHJvcGVydGllcyIsImZyb21Qcm9wZXJ0eU9yZGVyaW5nIiwiZnJvbVJlcXVpcmVkIiwiZnJvbVRpdGxlIiwiZnJvbVR5cGUiLCJzYWZldHlTZXR0aW5nVG9NbGRldiQxIiwiZnJvbUNhdGVnb3J5IiwiZnJvbVRocmVzaG9sZCIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDQiLCJmcm9tQmVoYXZpb3IiLCJmcm9tUGFyYW1ldGVycyIsImZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSIsImZyb21SZXNwb25zZSIsImZyb21SZXNwb25zZUpzb25TY2hlbWEiLCJpbnRlcnZhbFRvTWxkZXYkNCIsImZyb21TdGFydFRpbWUiLCJmcm9tRW5kVGltZSIsImdvb2dsZVNlYXJjaFRvTWxkZXYkNCIsImZyb21UaW1lUmFuZ2VGaWx0ZXIiLCJkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQ0IiwiZnJvbU1vZGUiLCJmcm9tRHluYW1pY1RocmVzaG9sZCIsImdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkNCIsImZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnIiwidXJsQ29udGV4dFRvTWxkZXYkNCIsInRvb2xDb21wdXRlclVzZVRvTWxkZXYkNCIsImZyb21FbnZpcm9ubWVudCIsInRvb2xUb01sZGV2JDQiLCJmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMiLCJmcm9tR29vZ2xlU2VhcmNoIiwiZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCIsImZyb21VcmxDb250ZXh0IiwiZnJvbUNvbXB1dGVyVXNlIiwiZnJvbUNvZGVFeGVjdXRpb24iLCJmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDIiLCJmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMiLCJsYXRMbmdUb01sZGV2JDIiLCJmcm9tTGF0aXR1ZGUiLCJmcm9tTG9uZ2l0dWRlIiwicmV0cmlldmFsQ29uZmlnVG9NbGRldiQyIiwiZnJvbUxhdExuZyIsImZyb21MYW5ndWFnZUNvZGUiLCJ0b29sQ29uZmlnVG9NbGRldiQyIiwiZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyIsImZyb21SZXRyaWV2YWxDb25maWciLCJwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQzIiwiZnJvbVZvaWNlTmFtZSIsInZvaWNlQ29uZmlnVG9NbGRldiQzIiwiZnJvbVByZWJ1aWx0Vm9pY2VDb25maWciLCJzcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDMiLCJmcm9tU3BlYWtlciIsImZyb21Wb2ljZUNvbmZpZyIsIm11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQzIiwiZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MiLCJzcGVlY2hDb25maWdUb01sZGV2JDMiLCJmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWciLCJ0aGlua2luZ0NvbmZpZ1RvTWxkZXYkMSIsImZyb21JbmNsdWRlVGhvdWdodHMiLCJmcm9tVGhpbmtpbmdCdWRnZXQiLCJnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2JDEiLCJwYXJlbnRPYmplY3QiLCJmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24iLCJmcm9tVGVtcGVyYXR1cmUiLCJmcm9tVG9wUCIsImZyb21Ub3BLIiwiZnJvbUNhbmRpZGF0ZUNvdW50IiwiZnJvbU1heE91dHB1dFRva2VucyIsImZyb21TdG9wU2VxdWVuY2VzIiwiZnJvbVJlc3BvbnNlTG9ncHJvYnMiLCJmcm9tTG9ncHJvYnMiLCJmcm9tUHJlc2VuY2VQZW5hbHR5IiwiZnJvbUZyZXF1ZW5jeVBlbmFsdHkiLCJmcm9tU2VlZCIsImZyb21SZXNwb25zZU1pbWVUeXBlIiwiZnJvbVJlc3BvbnNlU2NoZW1hIiwiZnJvbVNhZmV0eVNldHRpbmdzIiwiZnJvbVRvb2xzIiwiZnJvbVRvb2xDb25maWciLCJmcm9tQ2FjaGVkQ29udGVudCIsImZyb21SZXNwb25zZU1vZGFsaXRpZXMiLCJmcm9tTWVkaWFSZXNvbHV0aW9uIiwiZnJvbVNwZWVjaENvbmZpZyIsImZyb21UaGlua2luZ0NvbmZpZyIsImlubGluZWRSZXF1ZXN0VG9NbGRldiIsImZyb21Nb2RlbCIsImZyb21Db250ZW50cyIsImZyb21Db25maWciLCJiYXRjaEpvYlNvdXJjZVRvTWxkZXYiLCJmcm9tRmlsZU5hbWUiLCJmcm9tSW5saW5lZFJlcXVlc3RzIiwiY3JlYXRlQmF0Y2hKb2JDb25maWdUb01sZGV2IiwiZnJvbURpc3BsYXlOYW1lIiwiY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21TcmMiLCJnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2IiwiY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldiIsImxpc3RCYXRjaEpvYnNDb25maWdUb01sZGV2IiwiZnJvbVBhZ2VTaXplIiwiZnJvbVBhZ2VUb2tlbiIsImxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9NbGRldiIsImRlbGV0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYiLCJiYXRjaEpvYlNvdXJjZVRvVmVydGV4IiwiZnJvbUdjc1VyaSIsImZyb21CaWdxdWVyeVVyaSIsImJhdGNoSm9iRGVzdGluYXRpb25Ub1ZlcnRleCIsImNyZWF0ZUJhdGNoSm9iQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRGVzdCIsImNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4IiwiZ2V0QmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJjYW5jZWxCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCIsImxpc3RCYXRjaEpvYnNDb25maWdUb1ZlcnRleCIsImZyb21GaWx0ZXIiLCJsaXN0QmF0Y2hKb2JzUGFyYW1ldGVyc1RvVmVydGV4IiwiZGVsZXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ2aWRlb01ldGFkYXRhRnJvbU1sZGV2JDIiLCJibG9iRnJvbU1sZGV2JDIiLCJmaWxlRGF0YUZyb21NbGRldiQyIiwicGFydEZyb21NbGRldiQyIiwiY29udGVudEZyb21NbGRldiQyIiwiY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxIiwiZnJvbUNpdGF0aW9ucyIsInVybE1ldGFkYXRhRnJvbU1sZGV2JDIiLCJmcm9tUmV0cmlldmVkVXJsIiwiZnJvbVVybFJldHJpZXZhbFN0YXR1cyIsInVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldiQyIiwiZnJvbVVybE1ldGFkYXRhIiwiY2FuZGlkYXRlRnJvbU1sZGV2JDEiLCJmcm9tQ29udGVudCIsImZyb21DaXRhdGlvbk1ldGFkYXRhIiwiZnJvbVRva2VuQ291bnQiLCJmcm9tRmluaXNoUmVhc29uIiwiZnJvbVVybENvbnRleHRNZXRhZGF0YSIsImZyb21BdmdMb2dwcm9icyIsImZyb21Hcm91bmRpbmdNZXRhZGF0YSIsImZyb21JbmRleCIsImZyb21Mb2dwcm9ic1Jlc3VsdCIsImZyb21TYWZldHlSYXRpbmdzIiwiZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYkMSIsImZyb21TZGtIdHRwUmVzcG9uc2UiLCJmcm9tQ2FuZGlkYXRlcyIsImZyb21Nb2RlbFZlcnNpb24iLCJmcm9tUHJvbXB0RmVlZGJhY2siLCJmcm9tUmVzcG9uc2VJZCIsImZyb21Vc2FnZU1ldGFkYXRhIiwiam9iRXJyb3JGcm9tTWxkZXYiLCJmcm9tRGV0YWlscyIsImZyb21Db2RlIiwiZnJvbU1lc3NhZ2UiLCJpbmxpbmVkUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tRXJyb3IiLCJiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbU1sZGV2IiwiZnJvbUlubGluZWRSZXNwb25zZXMiLCJiYXRjaEpvYkZyb21NbGRldiIsImZyb21TdGF0ZSIsImZyb21DcmVhdGVUaW1lIiwiZnJvbVVwZGF0ZVRpbWUiLCJsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tTmV4dFBhZ2VUb2tlbiIsImZyb21CYXRjaEpvYnMiLCJkZWxldGVSZXNvdXJjZUpvYkZyb21NbGRldiIsImZyb21Eb25lIiwiam9iRXJyb3JGcm9tVmVydGV4IiwiYmF0Y2hKb2JTb3VyY2VGcm9tVmVydGV4IiwiYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21WZXJ0ZXgiLCJiYXRjaEpvYkZyb21WZXJ0ZXgiLCJsaXN0QmF0Y2hKb2JzUmVzcG9uc2VGcm9tVmVydGV4IiwiZGVsZXRlUmVzb3VyY2VKb2JGcm9tVmVydGV4IiwiUGFnZWRJdGVtIiwiUGFnZXIiLCJyZXF1ZXN0IiwicGFyYW1zIiwicGFnZUludGVybmFsIiwicGFyYW1zSW50ZXJuYWwiLCJyZXF1ZXN0SW50ZXJuYWwiLCJpbml0IiwibmFtZUludGVybmFsIiwic2RrSHR0cFJlc3BvbnNlSW50ZXJuYWwiLCJzZGtIdHRwUmVzcG9uc2UiLCJpZHhJbnRlcm5hbCIsInJlcXVlc3RQYXJhbXMiLCJwYWdlSW50ZXJuYWxTaXplIiwiaW5pdE5leHRQYWdlIiwicGFnZSIsInBhZ2VTaXplIiwicGFnZUxlbmd0aCIsImdldEl0ZW0iLCJpbmRleCIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJuZXh0IiwiaGFzTmV4dFBhZ2UiLCJuZXh0UGFnZSIsInJldHVybiIsIkJhdGNoZXMiLCJjcmVhdGUiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwidGltZXN0YW1wU3RyIiwidG9TdHJpbmciLCJkaXNwbGF5TmFtZSIsInBhdGgiLCJxdWVyeVBhcmFtcyIsImJvZHkiLCJiYXRjaCIsImlucHV0Q29uZmlnIiwicmVxdWVzdHNXcmFwcGVyIiwicmVxdWVzdHMiLCJuZXdSZXF1ZXN0cyIsInJlcXVlc3REaWN0Iiwic3lzdGVtSW5zdHJ1Y3Rpb25WYWx1ZSIsInJlcXVlc3RDb250ZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsImh0dHBNZXRob2QiLCJhYm9ydFNpZ25hbCIsInRoZW4iLCJodHRwUmVzcG9uc2UiLCJyZXNwIiwiY3JlYXRlSW50ZXJuYWwiLCJsaXN0IiwiUEFHRURfSVRFTV9CQVRDSF9KT0JTIiwieCIsImxpc3RJbnRlcm5hbCIsImdldCIsImNhbmNlbCIsImpzb25SZXNwb25zZSIsInR5cGVkUmVzcCIsImRlbGV0ZSIsInZpZGVvTWV0YWRhdGFUb01sZGV2JDMiLCJibG9iVG9NbGRldiQzIiwiZmlsZURhdGFUb01sZGV2JDMiLCJwYXJ0VG9NbGRldiQzIiwiY29udGVudFRvTWxkZXYkMyIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDMiLCJpbnRlcnZhbFRvTWxkZXYkMyIsImdvb2dsZVNlYXJjaFRvTWxkZXYkMyIsImR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDMiLCJnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDMiLCJ1cmxDb250ZXh0VG9NbGRldiQzIiwidG9vbENvbXB1dGVyVXNlVG9NbGRldiQzIiwidG9vbFRvTWxkZXYkMyIsImZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMSIsImxhdExuZ1RvTWxkZXYkMSIsInJldHJpZXZhbENvbmZpZ1RvTWxkZXYkMSIsInRvb2xDb25maWdUb01sZGV2JDEiLCJjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldiIsImZyb21UdGwiLCJmcm9tRXhwaXJlVGltZSIsImNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsImdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsImRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldiIsInVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2IiwidXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwibGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9NbGRldiIsImxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb01sZGV2IiwidmlkZW9NZXRhZGF0YVRvVmVydGV4JDIiLCJibG9iVG9WZXJ0ZXgkMiIsImZpbGVEYXRhVG9WZXJ0ZXgkMiIsInBhcnRUb1ZlcnRleCQyIiwiY29udGVudFRvVmVydGV4JDIiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMiIsImludGVydmFsVG9WZXJ0ZXgkMiIsImdvb2dsZVNlYXJjaFRvVmVydGV4JDIiLCJmcm9tRXhjbHVkZURvbWFpbnMiLCJkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMiIsImdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4JDIiLCJlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgkMiIsImFwaUtleUNvbmZpZ1RvVmVydGV4JDIiLCJmcm9tQXBpS2V5U3RyaW5nIiwiYXV0aENvbmZpZ1RvVmVydGV4JDIiLCJmcm9tQXBpS2V5Q29uZmlnIiwiZnJvbUF1dGhUeXBlIiwiZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnIiwiZnJvbUh0dHBCYXNpY0F1dGhDb25maWciLCJmcm9tT2F1dGhDb25maWciLCJmcm9tT2lkY0NvbmZpZyIsImdvb2dsZU1hcHNUb1ZlcnRleCQyIiwiZnJvbUF1dGhDb25maWciLCJ1cmxDb250ZXh0VG9WZXJ0ZXgkMiIsInRvb2xDb21wdXRlclVzZVRvVmVydGV4JDIiLCJ0b29sVG9WZXJ0ZXgkMiIsImZyb21SZXRyaWV2YWwiLCJmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCIsImZyb21Hb29nbGVNYXBzIiwiZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9WZXJ0ZXgkMSIsImxhdExuZ1RvVmVydGV4JDEiLCJyZXRyaWV2YWxDb25maWdUb1ZlcnRleCQxIiwidG9vbENvbmZpZ1RvVmVydGV4JDEiLCJjcmVhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgiLCJmcm9tS21zS2V5TmFtZSIsImNyZWF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4IiwiZGVsZXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsInVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleCIsInVwZGF0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb1ZlcnRleCIsImxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb1ZlcnRleCIsImNhY2hlZENvbnRlbnRGcm9tTWxkZXYiLCJkZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYiLCJsaXN0Q2FjaGVkQ29udGVudHNSZXNwb25zZUZyb21NbGRldiIsImZyb21DYWNoZWRDb250ZW50cyIsImNhY2hlZENvbnRlbnRGcm9tVmVydGV4IiwiZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCIsImxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbVZlcnRleCIsIkNhY2hlcyIsIlBBR0VEX0lURU1fQ0FDSEVEX0NPTlRFTlRTIiwidXBkYXRlIiwiX192YWx1ZXMiLCJvIiwicyIsIml0ZXJhdG9yIiwibSIsIl9fYXdhaXQiLCJ2IiwiX19hc3luY0dlbmVyYXRvciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiZ2VuZXJhdG9yIiwiZyIsImFwcGx5IiwicSIsIkFzeW5jSXRlcmF0b3IiLCJ2ZXJiIiwiYXdhaXRSZXR1cm4iLCJmIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJuIiwiYSIsImIiLCJyZXN1bWUiLCJzdGVwIiwiZSIsInNldHRsZSIsInIiLCJmdWxmaWxsIiwic2hpZnQiLCJfX2FzeW5jVmFsdWVzIiwiU3VwcHJlc3NlZEVycm9yIiwic3VwcHJlc3NlZCIsIm1lc3NhZ2UiLCJpc1ZhbGlkUmVzcG9uc2UiLCJpc1ZhbGlkQ29udGVudCIsInZhbGlkYXRlSGlzdG9yeSIsImhpc3RvcnkiLCJleHRyYWN0Q3VyYXRlZEhpc3RvcnkiLCJjb21wcmVoZW5zaXZlSGlzdG9yeSIsImN1cmF0ZWRIaXN0b3J5IiwibW9kZWxPdXRwdXQiLCJpc1ZhbGlkIiwiQ2hhdHMiLCJtb2RlbHNNb2R1bGUiLCJDaGF0Iiwic3RydWN0dXJlZENsb25lIiwic2VuZFByb21pc2UiLCJzZW5kTWVzc2FnZSIsImlucHV0Q29udGVudCIsInJlc3BvbnNlUHJvbWlzZSIsImdlbmVyYXRlQ29udGVudCIsImNvbnRlbnRzIiwiZ2V0SGlzdG9yeSIsImNvbmNhdCIsIm91dHB1dENvbnRlbnQiLCJmdWxsQXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSIsImF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkiLCJyZWNvcmRIaXN0b3J5IiwiY2F0Y2giLCJzZW5kTWVzc2FnZVN0cmVhbSIsInN0cmVhbVJlc3BvbnNlIiwiZ2VuZXJhdGVDb250ZW50U3RyZWFtIiwicHJvY2Vzc1N0cmVhbVJlc3BvbnNlIiwiY3VyYXRlZCIsImFyZ3VtZW50cyIsInByb2Nlc3NTdHJlYW1SZXNwb25zZV8xIiwiZV8xIiwic3RyZWFtUmVzcG9uc2VfMSIsInN0cmVhbVJlc3BvbnNlXzFfMSIsImNodW5rIiwiZV8xXzEiLCJ1c2VySW5wdXQiLCJvdXRwdXRDb250ZW50cyIsImV2ZXJ5IiwiQXBpRXJyb3IiLCJvcHRpb25zIiwic2V0UHJvdG90eXBlT2YiLCJsaXN0RmlsZXNDb25maWdUb01sZGV2IiwibGlzdEZpbGVzUGFyYW1ldGVyc1RvTWxkZXYiLCJmaWxlU3RhdHVzVG9NbGRldiIsImZpbGVUb01sZGV2IiwiZnJvbVNpemVCeXRlcyIsImZyb21FeHBpcmF0aW9uVGltZSIsImZyb21TaGEyNTZIYXNoIiwiZnJvbVVyaSIsImZyb21Eb3dubG9hZFVyaSIsImZyb21Tb3VyY2UiLCJjcmVhdGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tRmlsZSIsImdldEZpbGVQYXJhbWV0ZXJzVG9NbGRldiIsImRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldiIsImZpbGVTdGF0dXNGcm9tTWxkZXYiLCJmaWxlRnJvbU1sZGV2IiwibGlzdEZpbGVzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tRmlsZXMiLCJjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYiLCJkZWxldGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYiLCJGaWxlcyIsIlBBR0VEX0lURU1fRklMRVMiLCJ1cGxvYWQiLCJ1cGxvYWRGaWxlIiwiZmlsZSIsImRvd25sb2FkIiwiZG93bmxvYWRGaWxlIiwicHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYkMiIsInZvaWNlQ29uZmlnVG9NbGRldiQyIiwic3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQyIiwibXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDIiLCJzcGVlY2hDb25maWdUb01sZGV2JDIiLCJ2aWRlb01ldGFkYXRhVG9NbGRldiQyIiwiYmxvYlRvTWxkZXYkMiIsImZpbGVEYXRhVG9NbGRldiQyIiwicGFydFRvTWxkZXYkMiIsImNvbnRlbnRUb01sZGV2JDIiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQyIiwiaW50ZXJ2YWxUb01sZGV2JDIiLCJnb29nbGVTZWFyY2hUb01sZGV2JDIiLCJkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQyIiwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQyIiwidXJsQ29udGV4dFRvTWxkZXYkMiIsInRvb2xDb21wdXRlclVzZVRvTWxkZXYkMiIsInRvb2xUb01sZGV2JDIiLCJzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYkMSIsImZyb21IYW5kbGUiLCJhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2JDEiLCJhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvblRvTWxkZXYkMSIsImZyb21EaXNhYmxlZCIsImZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkiLCJmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSIsImZyb21QcmVmaXhQYWRkaW5nTXMiLCJmcm9tU2lsZW5jZUR1cmF0aW9uTXMiLCJyZWFsdGltZUlucHV0Q29uZmlnVG9NbGRldiQxIiwiZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uIiwiZnJvbUFjdGl2aXR5SGFuZGxpbmciLCJmcm9tVHVybkNvdmVyYWdlIiwic2xpZGluZ1dpbmRvd1RvTWxkZXYkMSIsImZyb21UYXJnZXRUb2tlbnMiLCJjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb01sZGV2JDEiLCJmcm9tVHJpZ2dlclRva2VucyIsImZyb21TbGlkaW5nV2luZG93IiwicHJvYWN0aXZpdHlDb25maWdUb01sZGV2JDEiLCJmcm9tUHJvYWN0aXZlQXVkaW8iLCJsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYkMSIsImZyb21HZW5lcmF0aW9uQ29uZmlnIiwiZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyIsImZyb21TZXNzaW9uUmVzdW1wdGlvbiIsImZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiIsImZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24iLCJmcm9tUmVhbHRpbWVJbnB1dENvbmZpZyIsImZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24iLCJmcm9tUHJvYWN0aXZpdHkiLCJsaXZlQ29ubmVjdFBhcmFtZXRlcnNUb01sZGV2IiwiYWN0aXZpdHlTdGFydFRvTWxkZXYiLCJhY3Rpdml0eUVuZFRvTWxkZXYiLCJsaXZlU2VuZFJlYWx0aW1lSW5wdXRQYXJhbWV0ZXJzVG9NbGRldiIsImZyb21NZWRpYSIsImZyb21BdWRpbyIsImZyb21BdWRpb1N0cmVhbUVuZCIsImZyb21WaWRlbyIsImZyb21BY3Rpdml0eVN0YXJ0IiwiZnJvbUFjdGl2aXR5RW5kIiwid2VpZ2h0ZWRQcm9tcHRUb01sZGV2IiwiZnJvbVdlaWdodCIsImxpdmVNdXNpY1NldFdlaWdodGVkUHJvbXB0c1BhcmFtZXRlcnNUb01sZGV2IiwiZnJvbVdlaWdodGVkUHJvbXB0cyIsImxpdmVNdXNpY0dlbmVyYXRpb25Db25maWdUb01sZGV2IiwiZnJvbUd1aWRhbmNlIiwiZnJvbUJwbSIsImZyb21EZW5zaXR5IiwiZnJvbUJyaWdodG5lc3MiLCJmcm9tU2NhbGUiLCJmcm9tTXV0ZUJhc3MiLCJmcm9tTXV0ZURydW1zIiwiZnJvbU9ubHlCYXNzQW5kRHJ1bXMiLCJmcm9tTXVzaWNHZW5lcmF0aW9uTW9kZSIsImxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2IiwiZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyIsImxpdmVNdXNpY0NsaWVudFNldHVwVG9NbGRldiIsImxpdmVNdXNpY0NsaWVudENvbnRlbnRUb01sZGV2IiwibGl2ZU11c2ljQ2xpZW50TWVzc2FnZVRvTWxkZXYiLCJmcm9tU2V0dXAiLCJmcm9tQ2xpZW50Q29udGVudCIsImZyb21QbGF5YmFja0NvbnRyb2wiLCJwcmVidWlsdFZvaWNlQ29uZmlnVG9WZXJ0ZXgkMSIsInZvaWNlQ29uZmlnVG9WZXJ0ZXgkMSIsInNwZWVjaENvbmZpZ1RvVmVydGV4JDEiLCJ2aWRlb01ldGFkYXRhVG9WZXJ0ZXgkMSIsImJsb2JUb1ZlcnRleCQxIiwiZmlsZURhdGFUb1ZlcnRleCQxIiwicGFydFRvVmVydGV4JDEiLCJjb250ZW50VG9WZXJ0ZXgkMSIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQxIiwiaW50ZXJ2YWxUb1ZlcnRleCQxIiwiZ29vZ2xlU2VhcmNoVG9WZXJ0ZXgkMSIsImR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleCQxIiwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9WZXJ0ZXgkMSIsImVudGVycHJpc2VXZWJTZWFyY2hUb1ZlcnRleCQxIiwiYXBpS2V5Q29uZmlnVG9WZXJ0ZXgkMSIsImF1dGhDb25maWdUb1ZlcnRleCQxIiwiZ29vZ2xlTWFwc1RvVmVydGV4JDEiLCJ1cmxDb250ZXh0VG9WZXJ0ZXgkMSIsInRvb2xDb21wdXRlclVzZVRvVmVydGV4JDEiLCJ0b29sVG9WZXJ0ZXgkMSIsInNlc3Npb25SZXN1bXB0aW9uQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tVHJhbnNwYXJlbnQiLCJhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb1ZlcnRleCIsImF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9WZXJ0ZXgiLCJyZWFsdGltZUlucHV0Q29uZmlnVG9WZXJ0ZXgiLCJzbGlkaW5nV2luZG93VG9WZXJ0ZXgiLCJjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb1ZlcnRleCIsInByb2FjdGl2aXR5Q29uZmlnVG9WZXJ0ZXgiLCJsaXZlQ29ubmVjdENvbmZpZ1RvVmVydGV4IiwibGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJhY3Rpdml0eVN0YXJ0VG9WZXJ0ZXgiLCJhY3Rpdml0eUVuZFRvVmVydGV4IiwibGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvVmVydGV4IiwibGl2ZVNlcnZlclNldHVwQ29tcGxldGVGcm9tTWxkZXYiLCJ2aWRlb01ldGFkYXRhRnJvbU1sZGV2JDEiLCJibG9iRnJvbU1sZGV2JDEiLCJmaWxlRGF0YUZyb21NbGRldiQxIiwicGFydEZyb21NbGRldiQxIiwiY29udGVudEZyb21NbGRldiQxIiwidHJhbnNjcmlwdGlvbkZyb21NbGRldiIsImZyb21GaW5pc2hlZCIsInVybE1ldGFkYXRhRnJvbU1sZGV2JDEiLCJ1cmxDb250ZXh0TWV0YWRhdGFGcm9tTWxkZXYkMSIsImxpdmVTZXJ2ZXJDb250ZW50RnJvbU1sZGV2IiwiZnJvbU1vZGVsVHVybiIsImZyb21UdXJuQ29tcGxldGUiLCJmcm9tSW50ZXJydXB0ZWQiLCJmcm9tR2VuZXJhdGlvbkNvbXBsZXRlIiwiZnJvbUlucHV0VHJhbnNjcmlwdGlvbiIsImZyb21PdXRwdXRUcmFuc2NyaXB0aW9uIiwiZnVuY3Rpb25DYWxsRnJvbU1sZGV2IiwiZnJvbUlkIiwiZnJvbUFyZ3MiLCJsaXZlU2VydmVyVG9vbENhbGxGcm9tTWxkZXYiLCJmcm9tRnVuY3Rpb25DYWxscyIsImxpdmVTZXJ2ZXJUb29sQ2FsbENhbmNlbGxhdGlvbkZyb21NbGRldiIsImZyb21JZHMiLCJtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYiLCJmcm9tTW9kYWxpdHkiLCJ1c2FnZU1ldGFkYXRhRnJvbU1sZGV2IiwiZnJvbVByb21wdFRva2VuQ291bnQiLCJmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQiLCJmcm9tUmVzcG9uc2VUb2tlbkNvdW50IiwiZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50IiwiZnJvbVRob3VnaHRzVG9rZW5Db3VudCIsImZyb21Ub3RhbFRva2VuQ291bnQiLCJmcm9tUHJvbXB0VG9rZW5zRGV0YWlscyIsImZyb21DYWNoZVRva2Vuc0RldGFpbHMiLCJmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzIiwiZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzIiwibGl2ZVNlcnZlckdvQXdheUZyb21NbGRldiIsImZyb21UaW1lTGVmdCIsImxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21NbGRldiIsImZyb21OZXdIYW5kbGUiLCJmcm9tUmVzdW1hYmxlIiwiZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCIsImxpdmVTZXJ2ZXJNZXNzYWdlRnJvbU1sZGV2IiwiZnJvbVNldHVwQ29tcGxldGUiLCJmcm9tU2VydmVyQ29udGVudCIsImZyb21Ub29sQ2FsbCIsImZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiIsImZyb21Hb0F3YXkiLCJmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUiLCJsaXZlTXVzaWNTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbU1sZGV2Iiwid2VpZ2h0ZWRQcm9tcHRGcm9tTWxkZXYiLCJsaXZlTXVzaWNDbGllbnRDb250ZW50RnJvbU1sZGV2IiwibGl2ZU11c2ljR2VuZXJhdGlvbkNvbmZpZ0Zyb21NbGRldiIsImxpdmVNdXNpY1NvdXJjZU1ldGFkYXRhRnJvbU1sZGV2IiwiYXVkaW9DaHVua0Zyb21NbGRldiIsImZyb21Tb3VyY2VNZXRhZGF0YSIsImxpdmVNdXNpY1NlcnZlckNvbnRlbnRGcm9tTWxkZXYiLCJmcm9tQXVkaW9DaHVua3MiLCJsaXZlTXVzaWNGaWx0ZXJlZFByb21wdEZyb21NbGRldiIsImZyb21GaWx0ZXJlZFJlYXNvbiIsImxpdmVNdXNpY1NlcnZlck1lc3NhZ2VGcm9tTWxkZXYiLCJmcm9tRmlsdGVyZWRQcm9tcHQiLCJsaXZlU2VydmVyU2V0dXBDb21wbGV0ZUZyb21WZXJ0ZXgiLCJmcm9tU2Vzc2lvbklkIiwidmlkZW9NZXRhZGF0YUZyb21WZXJ0ZXgkMSIsImJsb2JGcm9tVmVydGV4JDEiLCJmaWxlRGF0YUZyb21WZXJ0ZXgkMSIsInBhcnRGcm9tVmVydGV4JDEiLCJjb250ZW50RnJvbVZlcnRleCQxIiwidHJhbnNjcmlwdGlvbkZyb21WZXJ0ZXgiLCJsaXZlU2VydmVyQ29udGVudEZyb21WZXJ0ZXgiLCJmdW5jdGlvbkNhbGxGcm9tVmVydGV4IiwibGl2ZVNlcnZlclRvb2xDYWxsRnJvbVZlcnRleCIsImxpdmVTZXJ2ZXJUb29sQ2FsbENhbmNlbGxhdGlvbkZyb21WZXJ0ZXgiLCJtb2RhbGl0eVRva2VuQ291bnRGcm9tVmVydGV4IiwidXNhZ2VNZXRhZGF0YUZyb21WZXJ0ZXgiLCJmcm9tVHJhZmZpY1R5cGUiLCJsaXZlU2VydmVyR29Bd2F5RnJvbVZlcnRleCIsImxpdmVTZXJ2ZXJTZXNzaW9uUmVzdW1wdGlvblVwZGF0ZUZyb21WZXJ0ZXgiLCJsaXZlU2VydmVyTWVzc2FnZUZyb21WZXJ0ZXgiLCJ2aWRlb01ldGFkYXRhVG9NbGRldiQxIiwiYmxvYlRvTWxkZXYkMSIsImZpbGVEYXRhVG9NbGRldiQxIiwicGFydFRvTWxkZXYkMSIsImNvbnRlbnRUb01sZGV2JDEiLCJzY2hlbWFUb01sZGV2Iiwic2FmZXR5U2V0dGluZ1RvTWxkZXYiLCJmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQxIiwiaW50ZXJ2YWxUb01sZGV2JDEiLCJnb29nbGVTZWFyY2hUb01sZGV2JDEiLCJkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQxIiwiZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQxIiwidXJsQ29udGV4dFRvTWxkZXYkMSIsInRvb2xDb21wdXRlclVzZVRvTWxkZXYkMSIsInRvb2xUb01sZGV2JDEiLCJmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2IiwibGF0TG5nVG9NbGRldiIsInJldHJpZXZhbENvbmZpZ1RvTWxkZXYiLCJ0b29sQ29uZmlnVG9NbGRldiIsInByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2JDEiLCJ2b2ljZUNvbmZpZ1RvTWxkZXYkMSIsInNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMSIsIm11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQxIiwic3BlZWNoQ29uZmlnVG9NbGRldiQxIiwidGhpbmtpbmdDb25maWdUb01sZGV2IiwiZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiIsImdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwiZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldiIsImZyb21UYXNrVHlwZSIsImZyb21PdXRwdXREaW1lbnNpb25hbGl0eSIsImVtYmVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbU1vZGVsRm9yRW1iZWRDb250ZW50IiwiZ2VuZXJhdGVJbWFnZXNDb25maWdUb01sZGV2IiwiZnJvbU51bWJlck9mSW1hZ2VzIiwiZnJvbUFzcGVjdFJhdGlvIiwiZnJvbUd1aWRhbmNlU2NhbGUiLCJmcm9tU2FmZXR5RmlsdGVyTGV2ZWwiLCJmcm9tUGVyc29uR2VuZXJhdGlvbiIsImZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyIsImZyb21JbmNsdWRlUmFpUmVhc29uIiwiZnJvbUxhbmd1YWdlIiwiZnJvbU91dHB1dE1pbWVUeXBlIiwiZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSIsImZyb21JbWFnZVNpemUiLCJnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb01sZGV2IiwiZnJvbVByb21wdCIsImdldE1vZGVsUGFyYW1ldGVyc1RvTWxkZXYiLCJsaXN0TW9kZWxzQ29uZmlnVG9NbGRldiIsImZyb21RdWVyeUJhc2UiLCJsaXN0TW9kZWxzUGFyYW1ldGVyc1RvTWxkZXYiLCJ1cGRhdGVNb2RlbENvbmZpZ1RvTWxkZXYiLCJmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCIsInVwZGF0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYiLCJkZWxldGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2IiwiY291bnRUb2tlbnNDb25maWdUb01sZGV2IiwiY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9NbGRldiIsImltYWdlVG9NbGRldiIsImdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldiIsImZyb21OdW1iZXJPZlZpZGVvcyIsImZyb21EdXJhdGlvblNlY29uZHMiLCJmcm9tTmVnYXRpdmVQcm9tcHQiLCJmcm9tRW5oYW5jZVByb21wdCIsImdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYiLCJmcm9tSW1hZ2UiLCJ2aWRlb01ldGFkYXRhVG9WZXJ0ZXgiLCJibG9iVG9WZXJ0ZXgiLCJmaWxlRGF0YVRvVmVydGV4IiwicGFydFRvVmVydGV4IiwiY29udGVudFRvVmVydGV4Iiwic2NoZW1hVG9WZXJ0ZXgiLCJtb2RlbFNlbGVjdGlvbkNvbmZpZ1RvVmVydGV4IiwiZnJvbUZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlIiwic2FmZXR5U2V0dGluZ1RvVmVydGV4IiwiZnJvbU1ldGhvZCIsImZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCIsImludGVydmFsVG9WZXJ0ZXgiLCJnb29nbGVTZWFyY2hUb1ZlcnRleCIsImR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleCIsImdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4IiwiZW50ZXJwcmlzZVdlYlNlYXJjaFRvVmVydGV4IiwiYXBpS2V5Q29uZmlnVG9WZXJ0ZXgiLCJhdXRoQ29uZmlnVG9WZXJ0ZXgiLCJnb29nbGVNYXBzVG9WZXJ0ZXgiLCJ1cmxDb250ZXh0VG9WZXJ0ZXgiLCJ0b29sQ29tcHV0ZXJVc2VUb1ZlcnRleCIsInRvb2xUb1ZlcnRleCIsImZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvVmVydGV4IiwibGF0TG5nVG9WZXJ0ZXgiLCJyZXRyaWV2YWxDb25maWdUb1ZlcnRleCIsInRvb2xDb25maWdUb1ZlcnRleCIsInByZWJ1aWx0Vm9pY2VDb25maWdUb1ZlcnRleCIsInZvaWNlQ29uZmlnVG9WZXJ0ZXgiLCJzcGVlY2hDb25maWdUb1ZlcnRleCIsInRoaW5raW5nQ29uZmlnVG9WZXJ0ZXgiLCJnZW5lcmF0ZUNvbnRlbnRDb25maWdUb1ZlcnRleCIsImZyb21Sb3V0aW5nQ29uZmlnIiwiZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnIiwiZnJvbUxhYmVscyIsImZyb21BdWRpb1RpbWVzdGFtcCIsImdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImVtYmVkQ29udGVudENvbmZpZ1RvVmVydGV4IiwiZnJvbUF1dG9UcnVuY2F0ZSIsImVtYmVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCIsImdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tT3V0cHV0R2NzVXJpIiwiZnJvbUFkZFdhdGVybWFyayIsImdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvVmVydGV4IiwiaW1hZ2VUb1ZlcnRleCIsIm1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsImZyb21NYXNrTW9kZSIsImZyb21TZWdtZW50YXRpb25DbGFzc2VzIiwiZnJvbU1hc2tEaWxhdGlvbiIsImNvbnRyb2xSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsImZyb21Db250cm9sVHlwZSIsImZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiIsInN0eWxlUmVmZXJlbmNlQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tU3R5bGVEZXNjcmlwdGlvbiIsInN1YmplY3RSZWZlcmVuY2VDb25maWdUb1ZlcnRleCIsImZyb21TdWJqZWN0VHlwZSIsImZyb21TdWJqZWN0RGVzY3JpcHRpb24iLCJyZWZlcmVuY2VJbWFnZUFQSUludGVybmFsVG9WZXJ0ZXgiLCJmcm9tUmVmZXJlbmNlSW1hZ2UiLCJmcm9tUmVmZXJlbmNlSWQiLCJmcm9tUmVmZXJlbmNlVHlwZSIsImZyb21NYXNrSW1hZ2VDb25maWciLCJmcm9tQ29udHJvbEltYWdlQ29uZmlnIiwiZnJvbVN0eWxlSW1hZ2VDb25maWciLCJmcm9tU3ViamVjdEltYWdlQ29uZmlnIiwiZWRpdEltYWdlQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tRWRpdE1vZGUiLCJmcm9tQmFzZVN0ZXBzIiwiZWRpdEltYWdlUGFyYW1ldGVyc0ludGVybmFsVG9WZXJ0ZXgiLCJmcm9tUmVmZXJlbmNlSW1hZ2VzIiwidXBzY2FsZUltYWdlQVBJQ29uZmlnSW50ZXJuYWxUb1ZlcnRleCIsImZyb21FbmhhbmNlSW5wdXRJbWFnZSIsImZyb21JbWFnZVByZXNlcnZhdGlvbkZhY3RvciIsInVwc2NhbGVJbWFnZUFQSVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4IiwiZnJvbVVwc2NhbGVGYWN0b3IiLCJwcm9kdWN0SW1hZ2VUb1ZlcnRleCIsImZyb21Qcm9kdWN0SW1hZ2UiLCJyZWNvbnRleHRJbWFnZVNvdXJjZVRvVmVydGV4IiwiZnJvbVBlcnNvbkltYWdlIiwiZnJvbVByb2R1Y3RJbWFnZXMiLCJyZWNvbnRleHRJbWFnZUNvbmZpZ1RvVmVydGV4IiwicmVjb250ZXh0SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJzY3JpYmJsZUltYWdlVG9WZXJ0ZXgiLCJzZWdtZW50SW1hZ2VTb3VyY2VUb1ZlcnRleCIsImZyb21TY3JpYmJsZUltYWdlIiwic2VnbWVudEltYWdlQ29uZmlnVG9WZXJ0ZXgiLCJmcm9tTWF4UHJlZGljdGlvbnMiLCJmcm9tQ29uZmlkZW5jZVRocmVzaG9sZCIsImZyb21CaW5hcnlDb2xvclRocmVzaG9sZCIsInNlZ21lbnRJbWFnZVBhcmFtZXRlcnNUb1ZlcnRleCIsImdldE1vZGVsUGFyYW1ldGVyc1RvVmVydGV4IiwibGlzdE1vZGVsc0NvbmZpZ1RvVmVydGV4IiwibGlzdE1vZGVsc1BhcmFtZXRlcnNUb1ZlcnRleCIsInVwZGF0ZU1vZGVsQ29uZmlnVG9WZXJ0ZXgiLCJ1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCIsImRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4IiwiY291bnRUb2tlbnNDb25maWdUb1ZlcnRleCIsImNvdW50VG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4IiwiY29tcHV0ZVRva2Vuc1BhcmFtZXRlcnNUb1ZlcnRleCIsInZpZGVvVG9WZXJ0ZXgiLCJmcm9tVmlkZW9CeXRlcyIsInZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9WZXJ0ZXgiLCJnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvVmVydGV4IiwiZnJvbVJlc29sdXRpb24iLCJmcm9tUHVic3ViVG9waWMiLCJmcm9tR2VuZXJhdGVBdWRpbyIsImZyb21MYXN0RnJhbWUiLCJmcm9tQ29tcHJlc3Npb25RdWFsaXR5IiwiZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJ2aWRlb01ldGFkYXRhRnJvbU1sZGV2IiwiYmxvYkZyb21NbGRldiIsImZpbGVEYXRhRnJvbU1sZGV2IiwicGFydEZyb21NbGRldiIsImNvbnRlbnRGcm9tTWxkZXYiLCJjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2IiwidXJsTWV0YWRhdGFGcm9tTWxkZXYiLCJ1cmxDb250ZXh0TWV0YWRhdGFGcm9tTWxkZXYiLCJjYW5kaWRhdGVGcm9tTWxkZXYiLCJnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldiIsImNvbnRlbnRFbWJlZGRpbmdGcm9tTWxkZXYiLCJmcm9tVmFsdWVzIiwiZW1iZWRDb250ZW50TWV0YWRhdGFGcm9tTWxkZXYiLCJlbWJlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldiIsImZyb21FbWJlZGRpbmdzIiwiZnJvbU1ldGFkYXRhIiwiaW1hZ2VGcm9tTWxkZXYiLCJzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2IiwiZnJvbUNhdGVnb3JpZXMiLCJmcm9tU2NvcmVzIiwiZnJvbUNvbnRlbnRUeXBlIiwiZ2VuZXJhdGVkSW1hZ2VGcm9tTWxkZXYiLCJmcm9tUmFpRmlsdGVyZWRSZWFzb24iLCJmcm9tU2FmZXR5QXR0cmlidXRlcyIsImdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYiLCJmcm9tR2VuZXJhdGVkSW1hZ2VzIiwiZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyIsInR1bmVkTW9kZWxJbmZvRnJvbU1sZGV2IiwiZnJvbUJhc2VNb2RlbCIsIm1vZGVsRnJvbU1sZGV2IiwiZnJvbVZlcnNpb24iLCJmcm9tVHVuZWRNb2RlbEluZm8iLCJmcm9tSW5wdXRUb2tlbkxpbWl0IiwiZnJvbU91dHB1dFRva2VuTGltaXQiLCJmcm9tU3VwcG9ydGVkQWN0aW9ucyIsImxpc3RNb2RlbHNSZXNwb25zZUZyb21NbGRldiIsImZyb21Nb2RlbHMiLCJkZWxldGVNb2RlbFJlc3BvbnNlRnJvbU1sZGV2IiwiY291bnRUb2tlbnNSZXNwb25zZUZyb21NbGRldiIsImZyb21Ub3RhbFRva2VucyIsInZpZGVvRnJvbU1sZGV2IiwiZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYiLCJnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2IiwiZnJvbUdlbmVyYXRlZFZpZGVvcyIsImZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQiLCJmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMiLCJnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiIsInZpZGVvTWV0YWRhdGFGcm9tVmVydGV4IiwiYmxvYkZyb21WZXJ0ZXgiLCJmaWxlRGF0YUZyb21WZXJ0ZXgiLCJwYXJ0RnJvbVZlcnRleCIsImNvbnRlbnRGcm9tVmVydGV4IiwiY2l0YXRpb25NZXRhZGF0YUZyb21WZXJ0ZXgiLCJ1cmxNZXRhZGF0YUZyb21WZXJ0ZXgiLCJ1cmxDb250ZXh0TWV0YWRhdGFGcm9tVmVydGV4IiwiY2FuZGlkYXRlRnJvbVZlcnRleCIsImZyb21GaW5pc2hNZXNzYWdlIiwiZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4IiwiY29udGVudEVtYmVkZGluZ1N0YXRpc3RpY3NGcm9tVmVydGV4IiwiZnJvbVRydW5jYXRlZCIsImNvbnRlbnRFbWJlZGRpbmdGcm9tVmVydGV4IiwiZnJvbVN0YXRpc3RpY3MiLCJlbWJlZENvbnRlbnRNZXRhZGF0YUZyb21WZXJ0ZXgiLCJmcm9tQmlsbGFibGVDaGFyYWN0ZXJDb3VudCIsImVtYmVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCIsImltYWdlRnJvbVZlcnRleCIsInNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4IiwiZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4IiwiZnJvbUVuaGFuY2VkUHJvbXB0IiwiZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgiLCJlZGl0SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgiLCJ1cHNjYWxlSW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgiLCJyZWNvbnRleHRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImVudGl0eUxhYmVsRnJvbVZlcnRleCIsImZyb21MYWJlbCIsImZyb21TY29yZSIsImdlbmVyYXRlZEltYWdlTWFza0Zyb21WZXJ0ZXgiLCJmcm9tTWFzayIsInNlZ21lbnRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleCIsImZyb21HZW5lcmF0ZWRNYXNrcyIsImVuZHBvaW50RnJvbVZlcnRleCIsImZyb21EZXBsb3llZE1vZGVsSWQiLCJ0dW5lZE1vZGVsSW5mb0Zyb21WZXJ0ZXgiLCJjaGVja3BvaW50RnJvbVZlcnRleCIsImZyb21DaGVja3BvaW50SWQiLCJmcm9tRXBvY2giLCJmcm9tU3RlcCIsIm1vZGVsRnJvbVZlcnRleCIsImZyb21FbmRwb2ludHMiLCJmcm9tQ2hlY2twb2ludHMiLCJsaXN0TW9kZWxzUmVzcG9uc2VGcm9tVmVydGV4IiwiZGVsZXRlTW9kZWxSZXNwb25zZUZyb21WZXJ0ZXgiLCJjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleCIsImNvbXB1dGVUb2tlbnNSZXNwb25zZUZyb21WZXJ0ZXgiLCJmcm9tVG9rZW5zSW5mbyIsInZpZGVvRnJvbVZlcnRleCIsImdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCIsImdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4IiwiZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4IiwiQ09OVEVOVF9UWVBFX0hFQURFUiIsIlNFUlZFUl9USU1FT1VUX0hFQURFUiIsIlVTRVJfQUdFTlRfSEVBREVSIiwiR09PR0xFX0FQSV9DTElFTlRfSEVBREVSIiwiU0RLX1ZFUlNJT04iLCJMSUJSQVJZX0xBQkVMIiwiVkVSVEVYX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT04iLCJHT09HTEVfQUlfQVBJX0RFRkFVTFRfVkVSU0lPTiIsInJlc3BvbnNlTGluZVJFIiwiQXBpQ2xpZW50Iiwib3B0cyIsImNsaWVudE9wdGlvbnMiLCJwcm9qZWN0IiwibG9jYXRpb24iLCJhcGlLZXkiLCJpbml0SHR0cE9wdGlvbnMiLCJhcGlWZXJzaW9uIiwiYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24iLCJub3JtYWxpemVBdXRoUGFyYW1ldGVycyIsImdldERlZmF1bHRIZWFkZXJzIiwicGF0Y2hIdHRwT3B0aW9ucyIsImdldEFwaVZlcnNpb24iLCJnZXRSZXF1ZXN0VXJsIiwiZ2V0UmVxdWVzdFVybEludGVybmFsIiwiZ2V0SGVhZGVycyIsInVybEVsZW1lbnQiLCJqb2luIiwiZ2V0QmFzZVJlc291cmNlUGF0aCIsImdldEFwaUtleSIsImdldFdlYnNvY2tldEJhc2VVcmwiLCJ1cmxQYXJ0cyIsIlVSTCIsInByb3RvY29sIiwic2V0QmFzZVVybCIsInVybCIsImNvbnN0cnVjdFVybCIsInByZXBlbmRQcm9qZWN0TG9jYXRpb24iLCJzaG91bGRQcmVwZW5kVmVydGV4UHJvamVjdFBhdGgiLCJwYXRjaGVkSHR0cE9wdGlvbnMiLCJzZWFyY2hQYXJhbXMiLCJhcHBlbmQiLCJyZXF1ZXN0SW5pdCIsImluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdCIsInVuYXJ5QXBpQ2FsbCIsImJhc2VIdHRwT3B0aW9ucyIsInJlcXVlc3RIdHRwT3B0aW9ucyIsInBhcnNlIiwicmVxdWVzdFN0cmVhbSIsInNldCIsInN0cmVhbUFwaUNhbGwiLCJ0aW1lb3V0IiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwic2lnbmFsIiwidGltZW91dEhhbmRsZSIsInNldFRpbWVvdXQiLCJhYm9ydCIsInVucmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV4dHJhQm9keSIsImluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0IiwiZ2V0SGVhZGVyc0ludGVybmFsIiwiYXBpQ2FsbCIsIm1ldGhvZCIsInRocm93RXJyb3JJZk5vdE9LIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiYnVmZmVyIiwicmVhZCIsInRyaW0iLCJjaHVua1N0cmluZyIsImRlY29kZSIsInN0cmVhbSIsImNodW5rSnNvbiIsImVycm9ySnNvbiIsImVycm9yTWVzc2FnZSIsImFwaUVycm9yIiwicHJvY2Vzc2VkQ2h1bmtTdHJpbmciLCJwYXJ0aWFsUmVzcG9uc2UiLCJSZXNwb25zZSIsInN0YXR1c1RleHQiLCJyZWxlYXNlTG9jayIsImZldGNoIiwidmVyc2lvbkhlYWRlclZhbHVlIiwidXNlckFnZW50RXh0cmEiLCJIZWFkZXJzIiwiTWF0aCIsImNlaWwiLCJhdXRoIiwiYWRkQXV0aEhlYWRlcnMiLCJmaWxlVG9VcGxvYWQiLCJ1cGxvYWRlciIsImZpbGVTdGF0Iiwic3RhdCIsInNpemVCeXRlcyIsInNpemUiLCJ1cGxvYWRVcmwiLCJmZXRjaFVwbG9hZFVybCIsImRvd25sb2FkZXIiLCJvayIsImVycm9yQm9keSIsIkJsb2IiLCJjdXJyZW50Qm9keU9iamVjdCIsInBhcnNlZEJvZHkiLCJkZWVwTWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2UiLCJzb3VyY2VWYWx1ZSIsInRhcmdldFZhbHVlIiwibWVyZ2VkQm9keSIsIk1DUF9MQUJFTCIsImhhc01jcFRvb2xVc2FnZUZyb21NY3BUb1Rvb2wiLCJoYXNNY3BUb29sVXNhZ2UiLCJpc01jcENhbGxhYmxlVG9vbCIsInNldE1jcFVzYWdlSGVhZGVyIiwiZXhpc3RpbmdIZWFkZXIiLCJ0cmltU3RhcnQiLCJvYmplY3QiLCJNY3BDYWxsYWJsZVRvb2wiLCJsaXN0QWxsVG9vbHMiLCJtY3BDbGllbnQiLCJtYXhUb29scyIsImxpc3RBbGxUb29sc18xIiwiY3Vyc29yIiwibnVtVG9vbHMiLCJ0IiwibGlzdFRvb2xzIiwibmV4dEN1cnNvciIsIm1jcENsaWVudHMiLCJmdW5jdGlvbk5hbWVUb01jcENsaWVudCIsImluaXRpYWxpemUiLCJmdW5jdGlvbk1hcCIsImNhbGxUb29sIiwiZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cyIsInJlcXVlc3RPcHRpb25zIiwiY2FsbFRvb2xSZXNwb25zZSIsImlzRXJyb3IiLCJpc01jcENsaWVudCIsIm1jcFRvVG9vbCIsIm1heWJlQ29uZmlnIiwiaGFuZGxlV2ViU29ja2V0TWVzc2FnZSQxIiwib25tZXNzYWdlIiwiZXZlbnQiLCJzZXJ2ZXJNZXNzYWdlIiwiTGl2ZU11c2ljIiwid2ViU29ja2V0RmFjdG9yeSIsImNvbm5lY3QiLCJ3ZWJzb2NrZXRCYXNlVXJsIiwibWFwVG9IZWFkZXJzJDEiLCJvbm9wZW5SZXNvbHZlIiwib25vcGVuUHJvbWlzZSIsImNhbGxiYWNrcyIsIm9ub3BlbkF3YWl0ZWRDYWxsYmFjayIsIndlYnNvY2tldENhbGxiYWNrcyIsIm9ub3BlbiIsIm9uZXJyb3IiLCJvbmNsb3NlIiwiY29ubiIsImhlYWRlcnNUb01hcCQxIiwic2V0dXAiLCJjbGllbnRNZXNzYWdlIiwic2VuZCIsIkxpdmVNdXNpY1Nlc3Npb24iLCJzZXRXZWlnaHRlZFByb21wdHMiLCJ3ZWlnaHRlZFByb21wdHMiLCJzZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzIiwiY2xpZW50Q29udGVudCIsInNldE11c2ljR2VuZXJhdGlvbkNvbmZpZyIsIm11c2ljR2VuZXJhdGlvbkNvbmZpZyIsInNldENvbmZpZ1BhcmFtZXRlcnMiLCJzZW5kUGxheWJhY2tDb250cm9sIiwicGxheWJhY2tDb250cm9sIiwicGxheSIsIlBMQVkiLCJwYXVzZSIsIlBBVVNFIiwic3RvcCIsIlNUT1AiLCJyZXNldENvbnRleHQiLCJSRVNFVF9DT05URVhUIiwiY2xvc2UiLCJoZWFkZXJNYXAiLCJmb3JFYWNoIiwiRlVOQ1RJT05fUkVTUE9OU0VfUkVRVUlSRVNfSUQiLCJoYW5kbGVXZWJTb2NrZXRNZXNzYWdlIiwianNvbkRhdGEiLCJBcnJheUJ1ZmZlciIsIkxpdmUiLCJtdXNpYyIsImNsaWVudEhlYWRlcnMiLCJtYXBUb0hlYWRlcnMiLCJoZWFkZXJzVG9NYXAiLCJyZXNwb25zZU1vZGFsaXRpZXMiLCJBVURJTyIsImdlbmVyYXRpb25Db25maWciLCJpbnB1dFRvb2xzIiwiY29udmVydGVkVG9vbHMiLCJpc0NhbGxhYmxlVG9vbCIsImNhbGxhYmxlVG9vbCIsImxpdmVDb25uZWN0UGFyYW1ldGVycyIsIlNlc3Npb24iLCJkZWZhdWx0TGl2ZVNlbmRDbGllbnRDb250ZW50UGFyYW1lcnRlcnMiLCJ0dXJuQ29tcGxldGUiLCJ0TGl2ZUNsaWVudENvbnRlbnQiLCJ0dXJucyIsInRMaXZlQ2xpZW50dFRvb2xSZXNwb25zZSIsInRvb2xSZXNwb25zZSIsInNlbmRDbGllbnRDb250ZW50Iiwic2VuZFJlYWx0aW1lSW5wdXQiLCJzZW5kVG9vbFJlc3BvbnNlIiwiREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTIiwic2hvdWxkRGlzYWJsZUFmYyIsImF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZyIsImRpc2FibGUiLCJjYWxsYWJsZVRvb2xzUHJlc2VudCIsIm1heENhbGxzIiwibWF4aW11bVJlbW90ZUNhbGxzIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaGFzQ2FsbGFibGVUb29scyIsInNvbWUiLCJoYXNOb25DYWxsYWJsZVRvb2xzIiwic2hvdWxkQXBwZW5kQWZjSGlzdG9yeSIsImlnbm9yZUNhbGxIaXN0b3J5IiwiTW9kZWxzIiwidHJhbnNmb3JtZWRQYXJhbXMiLCJwcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZSIsIm1heWJlTW92ZVRvUmVzcG9uc2VKc29uU2NoZW0iLCJnZW5lcmF0ZUNvbnRlbnRJbnRlcm5hbCIsImZ1bmN0aW9uUmVzcG9uc2VDb250ZW50IiwibWF4UmVtb3RlQ2FsbHMiLCJyZW1vdGVDYWxscyIsInJlc3BvbnNlQ29udGVudCIsImZ1bmN0aW9uUmVzcG9uc2VQYXJ0cyIsImdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsIiwicHJvY2Vzc0FmY1N0cmVhbSIsImdlbmVyYXRlSW1hZ2VzIiwiZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbCIsInBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyIsImdlbmVyYXRlZEltYWdlcyIsImdlbmVyYXRlZEltYWdlIiwic2FmZXR5QXR0cmlidXRlcyIsImNvbnRlbnRUeXBlIiwiZGVmYXVsdENvbmZpZyIsInF1ZXJ5QmFzZSIsImFjdHVhbENvbmZpZyIsImFjdHVhbFBhcmFtcyIsIlBBR0VEX0lURU1fTU9ERUxTIiwiZWRpdEltYWdlIiwicHJvbXB0IiwicmVmZXJlbmNlSW1hZ2VzIiwiaW1nIiwiZWRpdEltYWdlSW50ZXJuYWwiLCJ1cHNjYWxlSW1hZ2UiLCJhcGlDb25maWciLCJudW1iZXJPZkltYWdlcyIsIm1vZGUiLCJhcGlQYXJhbXMiLCJpbWFnZSIsInVwc2NhbGVGYWN0b3IiLCJ1cHNjYWxlSW1hZ2VJbnRlcm5hbCIsImdlbmVyYXRlVmlkZW9zIiwiZ2VuZXJhdGVWaWRlb3NJbnRlcm5hbCIsInJlc3BvbnNlU2NoZW1hIiwidHJhbnNmb3JtZWRUb29scyIsImFsbCIsIm5ld1BhcmFtcyIsIm5ld0hlYWRlcnMiLCJpbml0QWZjVG9vbHNNYXAiLCJhZmNUb29scyIsIk1hcCIsInRvb2xEZWNsYXJhdGlvbiIsImRlY2xhcmF0aW9uIiwid2VyZUZ1bmN0aW9uc0NhbGxlZCIsInJlbW90ZUNhbGxDb3VudCIsImFmY1Rvb2xzTWFwIiwibW9kZWxzIiwicmVzcG9uc2VDb250ZW50cyIsInJlc3BvbnNlXzEiLCJyZXNwb25zZV8xXzEiLCJyZXNwb25zZVBhcnRzIiwidHlwZWRSZXNwb25zZUNodW5rIiwibmV3Q29udGVudHMiLCJ1cGRhdGVkQ29udGVudHMiLCJlXzIiLCJhcGlSZXNwb25zZV8xIiwiYXBpUmVzcG9uc2VfMV8xIiwiZV8yXzEiLCJlXzMiLCJhcGlSZXNwb25zZV8yIiwiYXBpUmVzcG9uc2VfMl8xIiwiZV8zXzEiLCJlbWJlZENvbnRlbnQiLCJyZWNvbnRleHRJbWFnZSIsInNlZ21lbnRJbWFnZSIsImNvdW50VG9rZW5zIiwiY29tcHV0ZVRva2VucyIsImdldE9wZXJhdGlvblBhcmFtZXRlcnNUb01sZGV2IiwiZnJvbU9wZXJhdGlvbk5hbWUiLCJnZXRPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJmZXRjaFByZWRpY3RPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgiLCJmcm9tUmVzb3VyY2VOYW1lIiwiT3BlcmF0aW9ucyIsImdldFZpZGVvc09wZXJhdGlvbiIsInJhd09wZXJhdGlvbiIsImZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsIiwib3BlcmF0aW9uTmFtZSIsImdldFZpZGVvc09wZXJhdGlvbkludGVybmFsIiwicHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYiLCJ2b2ljZUNvbmZpZ1RvTWxkZXYiLCJzcGVha2VyVm9pY2VDb25maWdUb01sZGV2IiwibXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2Iiwic3BlZWNoQ29uZmlnVG9NbGRldiIsInZpZGVvTWV0YWRhdGFUb01sZGV2IiwiYmxvYlRvTWxkZXYiLCJmaWxlRGF0YVRvTWxkZXYiLCJwYXJ0VG9NbGRldiIsImNvbnRlbnRUb01sZGV2IiwiZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYiLCJpbnRlcnZhbFRvTWxkZXYiLCJnb29nbGVTZWFyY2hUb01sZGV2IiwiZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYiLCJnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2IiwidXJsQ29udGV4dFRvTWxkZXYiLCJ0b29sQ29tcHV0ZXJVc2VUb01sZGV2IiwidG9vbFRvTWxkZXYiLCJzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYiLCJhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2IiwiYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb25Ub01sZGV2IiwicmVhbHRpbWVJbnB1dENvbmZpZ1RvTWxkZXYiLCJzbGlkaW5nV2luZG93VG9NbGRldiIsImNvbnRleHRXaW5kb3dDb21wcmVzc2lvbkNvbmZpZ1RvTWxkZXYiLCJwcm9hY3Rpdml0eUNvbmZpZ1RvTWxkZXYiLCJsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYiLCJsaXZlQ29ubmVjdENvbnN0cmFpbnRzVG9NbGRldiIsImNyZWF0ZUF1dGhUb2tlbkNvbmZpZ1RvTWxkZXYiLCJmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUiLCJmcm9tVXNlcyIsImZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzIiwiZnJvbUxvY2tBZGRpdGlvbmFsRmllbGRzIiwiY3JlYXRlQXV0aFRva2VuUGFyYW1ldGVyc1RvTWxkZXYiLCJhdXRoVG9rZW5Gcm9tTWxkZXYiLCJnZXRGaWVsZE1hc2tzIiwiZmllbGRzIiwiZmllbGQiLCJrayIsImNvbnZlcnRCaWRpU2V0dXBUb1Rva2VuU2V0dXAiLCJzZXR1cEZvck1hc2tHZW5lcmF0aW9uIiwiYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUiLCJpbm5lclNldHVwIiwicHJlRXhpc3RpbmdGaWVsZE1hc2siLCJnZW5lcmF0ZWRNYXNrRnJvbUJpZGkiLCJsb2NrQWRkaXRpb25hbEZpZWxkcyIsImdlbmVyYXRpb25Db25maWdGaWVsZHMiLCJtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmciLCJmaW5hbE1hc2tQYXJ0cyIsIlRva2VucyIsInRyYW5zZm9ybWVkQm9keSIsIkdPT0dMRV9BUElfS0VZX0hFQURFUiIsIlJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSIsIk5vZGVBdXRoIiwidmVydGV4QXV0aE9wdGlvbnMiLCJidWlsZEdvb2dsZUF1dGhPcHRpb25zIiwiZ29vZ2xlQXV0aE9wdGlvbnMiLCJnb29nbGVBdXRoIiwiYWRkS2V5SGVhZGVyIiwiYWRkR29vZ2xlQXV0aEhlYWRlcnMiLCJhdXRoSGVhZGVycyIsImdldFJlcXVlc3RIZWFkZXJzIiwiYXV0aE9wdGlvbnMiLCJzY29wZXMiLCJOb2RlRG93bmxvYWRlciIsImRvd25sb2FkUGF0aCIsIndyaXRlciIsImZyb21XZWIiLCJwaXBlIiwiZW5jb2RpbmciLCJOb2RlV2ViU29ja2V0RmFjdG9yeSIsIk5vZGVXZWJTb2NrZXQiLCJ3cyIsIldlYlNvY2tldCIsImdldFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2IiwibGlzdFR1bmluZ0pvYnNDb25maWdUb01sZGV2IiwibGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9NbGRldiIsInR1bmluZ0V4YW1wbGVUb01sZGV2IiwiZnJvbVRleHRJbnB1dCIsImZyb21PdXRwdXQiLCJ0dW5pbmdEYXRhc2V0VG9NbGRldiIsImZyb21FeGFtcGxlcyIsImNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvTWxkZXYiLCJmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lIiwiZnJvbUVwb2NoQ291bnQiLCJmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllciIsImZyb21CYXRjaFNpemUiLCJmcm9tTGVhcm5pbmdSYXRlIiwiY3JlYXRlVHVuaW5nSm9iUGFyYW1ldGVyc1ByaXZhdGVUb01sZGV2IiwiZnJvbVByZVR1bmVkTW9kZWwiLCJmcm9tVHJhaW5pbmdEYXRhc2V0IiwiZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4IiwibGlzdFR1bmluZ0pvYnNDb25maWdUb1ZlcnRleCIsImxpc3RUdW5pbmdKb2JzUGFyYW1ldGVyc1RvVmVydGV4IiwidHVuaW5nRGF0YXNldFRvVmVydGV4IiwiZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSIsInR1bmluZ1ZhbGlkYXRpb25EYXRhc2V0VG9WZXJ0ZXgiLCJjcmVhdGVUdW5pbmdKb2JDb25maWdUb1ZlcnRleCIsImZyb21WYWxpZGF0aW9uRGF0YXNldCIsImZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkiLCJmcm9tUHJlVHVuZWRNb2RlbENoZWNrcG9pbnRJZCIsImZyb21BZGFwdGVyU2l6ZSIsImNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9WZXJ0ZXgiLCJ0dW5lZE1vZGVsRnJvbU1sZGV2IiwiZnJvbUVuZHBvaW50IiwidHVuaW5nSm9iRnJvbU1sZGV2IiwiZnJvbVR1bmVkTW9kZWwiLCJmcm9tQ3VzdG9tQmFzZU1vZGVsIiwiZnJvbUV4cGVyaW1lbnQiLCJmcm9tT3V0cHV0VXJpIiwiZnJvbVBpcGVsaW5lSm9iIiwiZnJvbVNlcnZpY2VBY2NvdW50IiwibGlzdFR1bmluZ0pvYnNSZXNwb25zZUZyb21NbGRldiIsImZyb21UdW5pbmdKb2JzIiwidHVuaW5nT3BlcmF0aW9uRnJvbU1sZGV2IiwidHVuZWRNb2RlbENoZWNrcG9pbnRGcm9tVmVydGV4IiwidHVuZWRNb2RlbEZyb21WZXJ0ZXgiLCJ0dW5pbmdKb2JGcm9tVmVydGV4IiwiZnJvbVN1cGVydmlzZWRUdW5pbmdTcGVjIiwiZnJvbVR1bmluZ0RhdGFTdGF0cyIsImZyb21FbmNyeXB0aW9uU3BlYyIsImZyb21QYXJ0bmVyTW9kZWxUdW5pbmdTcGVjIiwibGlzdFR1bmluZ0pvYnNSZXNwb25zZUZyb21WZXJ0ZXgiLCJUdW5pbmdzIiwiZ2V0SW50ZXJuYWwiLCJQQUdFRF9JVEVNX1RVTklOR19KT0JTIiwidHVuZSIsImJhc2VNb2RlbCIsInByZVR1bmVkTW9kZWwiLCJ0dW5lZE1vZGVsTmFtZSIsInBhcmFtc1ByaXZhdGUiLCJ0dW5lSW50ZXJuYWwiLCJ0dW5lTWxkZXZJbnRlcm5hbCIsInR1bmluZ0pvYiIsIkpPQl9TVEFURV9RVUVVRUQiLCJNQVhfQ0hVTktfU0laRSIsIk1BWF9SRVRSWV9DT1VOVCIsIklOSVRJQUxfUkVUUllfREVMQVlfTVMiLCJERUxBWV9NVUxUSVBMSUVSIiwiWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEIiwidXBsb2FkQmxvYiIsImZpbGVTaXplIiwib2Zmc2V0IiwidXBsb2FkQ29tbWFuZCIsImNodW5rU2l6ZSIsIm1pbiIsInJldHJ5Q291bnQiLCJjdXJyZW50RGVsYXlNcyIsInNsZWVwIiwicmVzcG9uc2VKc29uIiwiZ2V0QmxvYlN0YXQiLCJtcyIsInJlc29sdmVQcm9taXNlIiwiTm9kZVVwbG9hZGVyIiwib3JpZ2luYWxTdGF0IiwiaW5mZXJNaW1lVHlwZSIsInVwbG9hZEZpbGVGcm9tUGF0aCIsImZpbGVQYXRoIiwiZmlsZUV4dGVuc2lvbiIsImxhc3RJbmRleE9mIiwibWltZVR5cGVzIiwidG9Mb3dlckNhc2UiLCJmaWxlSGFuZGxlIiwib3BlbiIsIlVpbnQ4QXJyYXkiLCJieXRlc1JlYWQiLCJMQU5HVUFHRV9MQUJFTF9QUkVGSVgiLCJHb29nbGVHZW5BSSIsImdldEJvb2xlYW5FbnYiLCJlbnZBcGlLZXkiLCJnZXRBcGlLZXlGcm9tRW52IiwiZW52UHJvamVjdCIsImdldEVudiIsImVudkxvY2F0aW9uIiwiY3JlZGVudGlhbHMiLCJkZWJ1ZyIsInByb2Nlc3MiLCJ2ZXJzaW9uIiwibGl2ZSIsImJhdGNoZXMiLCJjaGF0cyIsImNhY2hlcyIsImZpbGVzIiwib3BlcmF0aW9ucyIsImF1dGhUb2tlbnMiLCJ0dW5pbmdzIiwiZW52Iiwic3RyaW5nVG9Cb29sZWFuIiwic3RyIiwiZW52R29vZ2xlQXBpS2V5IiwiZW52R2VtaW5pQXBpS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google/genai/dist/node/index.mjs\n");

/***/ })

};
;